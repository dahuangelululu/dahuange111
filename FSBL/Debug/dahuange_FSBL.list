
dahuange_FSBL.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34180400  34180400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006ea0  3418074c  3418074c  0000074c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  341875ec  341875ec  00008620  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  341875ec  341875ec  00008620  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  341875ec  341875ec  00008620  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  341875ec  341875ec  00008620  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  341875ec  341875ec  000075ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  341875f0  341875f0  000075f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         0000000c  341c0000  341875f4  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .noncacheable 00000004  341c000c  34187600  0000900c  2**0
                  ALLOC
 10 .gnu.sgstubs  00000020  34187600  34187600  00008600  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .bss          00000104  341c0010  341c0010  00009010  2**2
                  ALLOC
 12 ._user_heap_stack 00000a04  341c0114  341c0114  00009010  2**0
                  ALLOC
 13 .ARM.attributes 0000003a  00000000  00000000  00008620  2**0
                  CONTENTS, READONLY
 14 .debug_info   00015411  00000000  00000000  0000865a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 000023cc  00000000  00000000  0001da6b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00001680  00000000  00000000  0001fe38  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 000010ed  00000000  00000000  000214b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00052070  00000000  00000000  000225a5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00016f00  00000000  00000000  00074615  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    0020a840  00000000  00000000  0008b515  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  00295d55  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00005c88  00000000  00000000  00295d98  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 00000045  00000000  00000000  0029ba20  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

3418074c <__do_global_dtors_aux>:
3418074c:	b510      	push	{r4, lr}
3418074e:	4c05      	ldr	r4, [pc, #20]	@ (34180764 <__do_global_dtors_aux+0x18>)
34180750:	7823      	ldrb	r3, [r4, #0]
34180752:	b933      	cbnz	r3, 34180762 <__do_global_dtors_aux+0x16>
34180754:	4b04      	ldr	r3, [pc, #16]	@ (34180768 <__do_global_dtors_aux+0x1c>)
34180756:	b113      	cbz	r3, 3418075e <__do_global_dtors_aux+0x12>
34180758:	4804      	ldr	r0, [pc, #16]	@ (3418076c <__do_global_dtors_aux+0x20>)
3418075a:	f3af 8000 	nop.w
3418075e:	2301      	movs	r3, #1
34180760:	7023      	strb	r3, [r4, #0]
34180762:	bd10      	pop	{r4, pc}
34180764:	341c0010 	.word	0x341c0010
34180768:	00000000 	.word	0x00000000
3418076c:	341875d4 	.word	0x341875d4

34180770 <frame_dummy>:
34180770:	b508      	push	{r3, lr}
34180772:	4b03      	ldr	r3, [pc, #12]	@ (34180780 <frame_dummy+0x10>)
34180774:	b11b      	cbz	r3, 3418077e <frame_dummy+0xe>
34180776:	4903      	ldr	r1, [pc, #12]	@ (34180784 <frame_dummy+0x14>)
34180778:	4803      	ldr	r0, [pc, #12]	@ (34180788 <frame_dummy+0x18>)
3418077a:	f3af 8000 	nop.w
3418077e:	bd08      	pop	{r3, pc}
34180780:	00000000 	.word	0x00000000
34180784:	341c0014 	.word	0x341c0014
34180788:	341875d4 	.word	0x341875d4

3418078c <MX_EXTMEM_MANAGER_Init>:
/**
  * Init External memory manager
  * @retval None
  */
void MX_EXTMEM_MANAGER_Init(void)
{
3418078c:	b580      	push	{r7, lr}
3418078e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MX_EXTMEM_Init_PreTreatment */

  /* USER CODE END MX_EXTMEM_Init_PreTreatment */

  /* Initialization of the memory parameters */
  memset(extmem_list_config, 0x0, sizeof(extmem_list_config));
34180790:	2214      	movs	r2, #20
34180792:	2100      	movs	r1, #0
34180794:	4805      	ldr	r0, [pc, #20]	@ (341807ac <MX_EXTMEM_MANAGER_Init+0x20>)
34180796:	f006 fef1 	bl	3418757c <memset>

  /* EXTMEMORY_1 */
  extmem_list_config[0].MemType = EXTMEM_USER;
3418079a:	4b04      	ldr	r3, [pc, #16]	@ (341807ac <MX_EXTMEM_MANAGER_Init+0x20>)
3418079c:	2204      	movs	r2, #4
3418079e:	701a      	strb	r2, [r3, #0]

  EXTMEM_Init(EXTMEMORY_1, 0);
341807a0:	2100      	movs	r1, #0
341807a2:	2000      	movs	r0, #0
341807a4:	f006 fd88 	bl	341872b8 <EXTMEM_Init>

  /* USER CODE BEGIN MX_EXTMEM_Init_PostTreatment */

  /* USER CODE END MX_EXTMEM_Init_PostTreatment */
}
341807a8:	bf00      	nop
341807aa:	bd80      	pop	{r7, pc}
341807ac:	341c0100 	.word	0x341c0100

341807b0 <LL_AHB4_GRP1_EnableClock>:
  *         @arg @ref LL_AHB4_GRP1_PERIPH_PWR
  *         @arg @ref LL_AHB4_GRP1_PERIPH_CRC
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
341807b0:	b480      	push	{r7}
341807b2:	b085      	sub	sp, #20
341807b4:	af00      	add	r7, sp, #0
341807b6:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4ENSR, Periphs);
341807b8:	4a07      	ldr	r2, [pc, #28]	@ (341807d8 <LL_AHB4_GRP1_EnableClock+0x28>)
341807ba:	687b      	ldr	r3, [r7, #4]
341807bc:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4ENR);
341807c0:	4b05      	ldr	r3, [pc, #20]	@ (341807d8 <LL_AHB4_GRP1_EnableClock+0x28>)
341807c2:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
341807c6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341807c8:	68fb      	ldr	r3, [r7, #12]
}
341807ca:	bf00      	nop
341807cc:	3714      	adds	r7, #20
341807ce:	46bd      	mov	sp, r7
341807d0:	f85d 7b04 	ldr.w	r7, [sp], #4
341807d4:	4770      	bx	lr
341807d6:	bf00      	nop
341807d8:	56028000 	.word	0x56028000

341807dc <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Pinout Configuration
*/
void MX_GPIO_Init(void)
{
341807dc:	b580      	push	{r7, lr}
341807de:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOP_CLK_ENABLE();
341807e0:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
341807e4:	f7ff ffe4 	bl	341807b0 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOO_CLK_ENABLE();
341807e8:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
341807ec:	f7ff ffe0 	bl	341807b0 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPION_CLK_ENABLE();
341807f0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
341807f4:	f7ff ffdc 	bl	341807b0 <LL_AHB4_GRP1_EnableClock>

}
341807f8:	bf00      	nop
341807fa:	bd80      	pop	{r7, pc}

341807fc <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
341807fc:	b580      	push	{r7, lr}
341807fe:	b084      	sub	sp, #16
34180800:	af00      	add	r7, sp, #0
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34180802:	4b4b      	ldr	r3, [pc, #300]	@ (34180930 <main+0x134>)
34180804:	695b      	ldr	r3, [r3, #20]
34180806:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3418080a:	2b00      	cmp	r3, #0
3418080c:	d11b      	bne.n	34180846 <main+0x4a>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
3418080e:	f3bf 8f4f 	dsb	sy
}
34180812:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34180814:	f3bf 8f6f 	isb	sy
}
34180818:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
3418081a:	4b45      	ldr	r3, [pc, #276]	@ (34180930 <main+0x134>)
3418081c:	2200      	movs	r2, #0
3418081e:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
34180822:	f3bf 8f4f 	dsb	sy
}
34180826:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34180828:	f3bf 8f6f 	isb	sy
}
3418082c:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
3418082e:	4b40      	ldr	r3, [pc, #256]	@ (34180930 <main+0x134>)
34180830:	695b      	ldr	r3, [r3, #20]
34180832:	4a3f      	ldr	r2, [pc, #252]	@ (34180930 <main+0x134>)
34180834:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34180838:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
3418083a:	f3bf 8f4f 	dsb	sy
}
3418083e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34180840:	f3bf 8f6f 	isb	sy
}
34180844:	e000      	b.n	34180848 <main+0x4c>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34180846:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34180848:	4b39      	ldr	r3, [pc, #228]	@ (34180930 <main+0x134>)
3418084a:	695b      	ldr	r3, [r3, #20]
3418084c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34180850:	2b00      	cmp	r3, #0
34180852:	d138      	bne.n	341808c6 <main+0xca>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
34180854:	4b36      	ldr	r3, [pc, #216]	@ (34180930 <main+0x134>)
34180856:	2200      	movs	r2, #0
34180858:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
3418085c:	f3bf 8f4f 	dsb	sy
}
34180860:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
34180862:	4b33      	ldr	r3, [pc, #204]	@ (34180930 <main+0x134>)
34180864:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34180868:	60bb      	str	r3, [r7, #8]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
3418086a:	68bb      	ldr	r3, [r7, #8]
3418086c:	0b5b      	lsrs	r3, r3, #13
3418086e:	f3c3 030e 	ubfx	r3, r3, #0, #15
34180872:	607b      	str	r3, [r7, #4]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34180874:	68bb      	ldr	r3, [r7, #8]
34180876:	08db      	lsrs	r3, r3, #3
34180878:	f3c3 0309 	ubfx	r3, r3, #0, #10
3418087c:	603b      	str	r3, [r7, #0]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
3418087e:	687b      	ldr	r3, [r7, #4]
34180880:	015a      	lsls	r2, r3, #5
34180882:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
34180886:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
34180888:	683a      	ldr	r2, [r7, #0]
3418088a:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
3418088c:	4928      	ldr	r1, [pc, #160]	@ (34180930 <main+0x134>)
3418088e:	4313      	orrs	r3, r2
34180890:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
34180894:	683b      	ldr	r3, [r7, #0]
34180896:	1e5a      	subs	r2, r3, #1
34180898:	603a      	str	r2, [r7, #0]
3418089a:	2b00      	cmp	r3, #0
3418089c:	d1ef      	bne.n	3418087e <main+0x82>
    } while(sets-- != 0U);
3418089e:	687b      	ldr	r3, [r7, #4]
341808a0:	1e5a      	subs	r2, r3, #1
341808a2:	607a      	str	r2, [r7, #4]
341808a4:	2b00      	cmp	r3, #0
341808a6:	d1e5      	bne.n	34180874 <main+0x78>
  __ASM volatile ("dsb 0xF":::"memory");
341808a8:	f3bf 8f4f 	dsb	sy
}
341808ac:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
341808ae:	4b20      	ldr	r3, [pc, #128]	@ (34180930 <main+0x134>)
341808b0:	695b      	ldr	r3, [r3, #20]
341808b2:	4a1f      	ldr	r2, [pc, #124]	@ (34180930 <main+0x134>)
341808b4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
341808b8:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
341808ba:	f3bf 8f4f 	dsb	sy
}
341808be:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
341808c0:	f3bf 8f6f 	isb	sy
}
341808c4:	e000      	b.n	341808c8 <main+0xcc>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
341808c6:	bf00      	nop

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
341808c8:	f000 fe1b 	bl	34181502 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
341808cc:	f000 f836 	bl	3418093c <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
341808d0:	f7ff ff84 	bl	341807dc <MX_GPIO_Init>
  MX_XSPI1_Init();
341808d4:	f000 fd14 	bl	34181300 <MX_XSPI1_Init>
  MX_XSPI2_Init();
341808d8:	f000 fd8a 	bl	341813f0 <MX_XSPI2_Init>
  MX_EXTMEM_MANAGER_Init();
341808dc:	f7ff ff56 	bl	3418078c <MX_EXTMEM_MANAGER_Init>
  /* USER CODE BEGIN 2 */
  for (int i = 0; i < 4; i++)
341808e0:	2300      	movs	r3, #0
341808e2:	60fb      	str	r3, [r7, #12]
341808e4:	e00a      	b.n	341808fc <main+0x100>
  {
    HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_10);  // DS0 闪烁
341808e6:	f44f 6180 	mov.w	r1, #1024	@ 0x400
341808ea:	4812      	ldr	r0, [pc, #72]	@ (34180934 <main+0x138>)
341808ec:	f001 f958 	bl	34181ba0 <HAL_GPIO_TogglePin>
    HAL_Delay(80);
341808f0:	2050      	movs	r0, #80	@ 0x50
341808f2:	f000 fe71 	bl	341815d8 <HAL_Delay>
  for (int i = 0; i < 4; i++)
341808f6:	68fb      	ldr	r3, [r7, #12]
341808f8:	3301      	adds	r3, #1
341808fa:	60fb      	str	r3, [r7, #12]
341808fc:	68fb      	ldr	r3, [r7, #12]
341808fe:	2b03      	cmp	r3, #3
34180900:	ddf1      	ble.n	341808e6 <main+0xea>
  }

  /* USER CODE END 2 */

  /* Launch the application */
  if (BOOT_OK != BOOT_Application())
34180902:	f006 fbe5 	bl	341870d0 <BOOT_Application>
34180906:	4603      	mov	r3, r0
34180908:	2b00      	cmp	r3, #0
3418090a:	d00f      	beq.n	3418092c <main+0x130>
  {
	    // APP 启动失败：关 DS0，DS1 快闪报警
	    HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_RESET); // 关 DS0
3418090c:	2200      	movs	r2, #0
3418090e:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34180912:	4808      	ldr	r0, [pc, #32]	@ (34180934 <main+0x138>)
34180914:	f001 f92c 	bl	34181b70 <HAL_GPIO_WritePin>

	    while (1)
	    {
	      HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_10);  // DS1 快闪
34180918:	f44f 6180 	mov.w	r1, #1024	@ 0x400
3418091c:	4806      	ldr	r0, [pc, #24]	@ (34180938 <main+0x13c>)
3418091e:	f001 f93f 	bl	34181ba0 <HAL_GPIO_TogglePin>
	      HAL_Delay(100);
34180922:	2064      	movs	r0, #100	@ 0x64
34180924:	f000 fe58 	bl	341815d8 <HAL_Delay>
	      HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_10);  // DS1 快闪
34180928:	bf00      	nop
3418092a:	e7f5      	b.n	34180918 <main+0x11c>
	    }
  }
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
3418092c:	e7fe      	b.n	3418092c <main+0x130>
3418092e:	bf00      	nop
34180930:	e000ed00 	.word	0xe000ed00
34180934:	56021800 	.word	0x56021800
34180938:	56021000 	.word	0x56021000

3418093c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
3418093c:	b580      	push	{r7, lr}
3418093e:	b0b6      	sub	sp, #216	@ 0xd8
34180940:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
34180942:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34180946:	2298      	movs	r2, #152	@ 0x98
34180948:	2100      	movs	r1, #0
3418094a:	4618      	mov	r0, r3
3418094c:	f006 fe16 	bl	3418757c <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34180950:	463b      	mov	r3, r7
34180952:	2240      	movs	r2, #64	@ 0x40
34180954:	2100      	movs	r1, #0
34180956:	4618      	mov	r0, r3
34180958:	f006 fe10 	bl	3418757c <memset>

  /** Configure the System Power Supply
  */
  if (HAL_PWREx_ConfigSupply(PWR_SMPS_SUPPLY) != HAL_OK)
3418095c:	2004      	movs	r0, #4
3418095e:	f001 f939 	bl	34181bd4 <HAL_PWREx_ConfigSupply>
34180962:	4603      	mov	r3, r0
34180964:	2b00      	cmp	r3, #0
34180966:	d001      	beq.n	3418096c <SystemClock_Config+0x30>
  {
    Error_Handler();
34180968:	f000 f8c4 	bl	34180af4 <Error_Handler>
  }

  /* Enable HSI */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
3418096c:	2302      	movs	r3, #2
3418096e:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
34180970:	2308      	movs	r3, #8
34180972:	64fb      	str	r3, [r7, #76]	@ 0x4c
  RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1;
34180974:	2300      	movs	r3, #0
34180976:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
34180978:	2300      	movs	r3, #0
3418097a:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_NONE;
3418097c:	2300      	movs	r3, #0
3418097e:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_NONE;
34180980:	2300      	movs	r3, #0
34180982:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_NONE;
34180986:	2300      	movs	r3, #0
34180988:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_NONE;
3418098c:	2300      	movs	r3, #0
3418098e:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34180992:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34180996:	4618      	mov	r0, r3
34180998:	f001 fc22 	bl	341821e0 <HAL_RCC_OscConfig>
3418099c:	4603      	mov	r3, r0
3418099e:	2b00      	cmp	r3, #0
341809a0:	d001      	beq.n	341809a6 <SystemClock_Config+0x6a>
  {
    Error_Handler();
341809a2:	f000 f8a7 	bl	34180af4 <Error_Handler>
  }

  /** Get current CPU/System buses clocks configuration and if necessary switch
 to intermediate HSI clock to ensure target clock can be set
  */
  HAL_RCC_GetClockConfig(&RCC_ClkInitStruct);
341809a6:	463b      	mov	r3, r7
341809a8:	4618      	mov	r0, r3
341809aa:	f002 fa7d 	bl	34182ea8 <HAL_RCC_GetClockConfig>
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
341809ae:	687b      	ldr	r3, [r7, #4]
341809b0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
341809b4:	d003      	beq.n	341809be <SystemClock_Config+0x82>
     (RCC_ClkInitStruct.SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11))
341809b6:	68bb      	ldr	r3, [r7, #8]
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
341809b8:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
341809bc:	d10e      	bne.n	341809dc <SystemClock_Config+0xa0>
  {
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK);
341809be:	2303      	movs	r3, #3
341809c0:	603b      	str	r3, [r7, #0]
    RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_HSI;
341809c2:	2300      	movs	r3, #0
341809c4:	607b      	str	r3, [r7, #4]
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
341809c6:	2300      	movs	r3, #0
341809c8:	60bb      	str	r3, [r7, #8]
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
341809ca:	463b      	mov	r3, r7
341809cc:	4618      	mov	r0, r3
341809ce:	f001 ffe7 	bl	341829a0 <HAL_RCC_ClockConfig>
341809d2:	4603      	mov	r3, r0
341809d4:	2b00      	cmp	r3, #0
341809d6:	d001      	beq.n	341809dc <SystemClock_Config+0xa0>
    {
      /* Initialization Error */
      Error_Handler();
341809d8:	f000 f88c 	bl	34180af4 <Error_Handler>
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
341809dc:	2300      	movs	r3, #0
341809de:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
341809e0:	2302      	movs	r3, #2
341809e2:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
341809e4:	2300      	movs	r3, #0
341809e6:	66fb      	str	r3, [r7, #108]	@ 0x6c
  RCC_OscInitStruct.PLL1.PLLM = 2;
341809e8:	2302      	movs	r3, #2
341809ea:	673b      	str	r3, [r7, #112]	@ 0x70
  RCC_OscInitStruct.PLL1.PLLN = 25;
341809ec:	2319      	movs	r3, #25
341809ee:	67bb      	str	r3, [r7, #120]	@ 0x78
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
341809f0:	2300      	movs	r3, #0
341809f2:	677b      	str	r3, [r7, #116]	@ 0x74
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
341809f4:	2301      	movs	r3, #1
341809f6:	67fb      	str	r3, [r7, #124]	@ 0x7c
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
341809f8:	2301      	movs	r3, #1
341809fa:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_ON;
341809fe:	2302      	movs	r3, #2
34180a00:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
34180a04:	2300      	movs	r3, #0
34180a06:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
  RCC_OscInitStruct.PLL2.PLLM = 8;
34180a0a:	2308      	movs	r3, #8
34180a0c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  RCC_OscInitStruct.PLL2.PLLN = 125;
34180a10:	237d      	movs	r3, #125	@ 0x7d
34180a12:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
34180a16:	2300      	movs	r3, #0
34180a18:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  RCC_OscInitStruct.PLL2.PLLP1 = 1;
34180a1c:	2301      	movs	r3, #1
34180a1e:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
  RCC_OscInitStruct.PLL2.PLLP2 = 1;
34180a22:	2301      	movs	r3, #1
34180a24:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
34180a28:	2302      	movs	r3, #2
34180a2a:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL3.PLLSource = RCC_PLLSOURCE_HSI;
34180a2e:	2300      	movs	r3, #0
34180a30:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  RCC_OscInitStruct.PLL3.PLLM = 8;
34180a34:	2308      	movs	r3, #8
34180a36:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
  RCC_OscInitStruct.PLL3.PLLN = 200;
34180a3a:	23c8      	movs	r3, #200	@ 0xc8
34180a3c:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
  RCC_OscInitStruct.PLL3.PLLFractional = 0;
34180a40:	2300      	movs	r3, #0
34180a42:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
  RCC_OscInitStruct.PLL3.PLLP1 = 1;
34180a46:	2301      	movs	r3, #1
34180a48:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
  RCC_OscInitStruct.PLL3.PLLP2 = 2;
34180a4c:	2302      	movs	r3, #2
34180a4e:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_ON;
34180a52:	2302      	movs	r3, #2
34180a54:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  RCC_OscInitStruct.PLL4.PLLSource = RCC_PLLSOURCE_HSI;
34180a58:	2300      	movs	r3, #0
34180a5a:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
  RCC_OscInitStruct.PLL4.PLLM = 1;
34180a5e:	2301      	movs	r3, #1
34180a60:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
  RCC_OscInitStruct.PLL4.PLLN = 25;
34180a64:	2319      	movs	r3, #25
34180a66:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  RCC_OscInitStruct.PLL4.PLLFractional = 0;
34180a6a:	2300      	movs	r3, #0
34180a6c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
  RCC_OscInitStruct.PLL4.PLLP1 = 1;
34180a70:	2301      	movs	r3, #1
34180a72:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
  RCC_OscInitStruct.PLL4.PLLP2 = 1;
34180a76:	2301      	movs	r3, #1
34180a78:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34180a7c:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34180a80:	4618      	mov	r0, r3
34180a82:	f001 fbad 	bl	341821e0 <HAL_RCC_OscConfig>
34180a86:	4603      	mov	r3, r0
34180a88:	2b00      	cmp	r3, #0
34180a8a:	d001      	beq.n	34180a90 <SystemClock_Config+0x154>
  {
    Error_Handler();
34180a8c:	f000 f832 	bl	34180af4 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_CPUCLK|RCC_CLOCKTYPE_HCLK
34180a90:	237f      	movs	r3, #127	@ 0x7f
34180a92:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
                              |RCC_CLOCKTYPE_PCLK2|RCC_CLOCKTYPE_PCLK5
                              |RCC_CLOCKTYPE_PCLK4;
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34180a94:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34180a98:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
34180a9a:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34180a9e:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34180aa0:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
34180aa4:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
34180aa6:	2300      	movs	r3, #0
34180aa8:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
34180aaa:	2300      	movs	r3, #0
34180aac:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34180aae:	2300      	movs	r3, #0
34180ab0:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
34180ab2:	2300      	movs	r3, #0
34180ab4:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.IC1Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34180ab6:	2300      	movs	r3, #0
34180ab8:	623b      	str	r3, [r7, #32]
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 2;
34180aba:	2302      	movs	r3, #2
34180abc:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34180abe:	2300      	movs	r3, #0
34180ac0:	62bb      	str	r3, [r7, #40]	@ 0x28
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;
34180ac2:	2302      	movs	r3, #2
34180ac4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL2;
34180ac6:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
34180aca:	633b      	str	r3, [r7, #48]	@ 0x30
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 2;
34180acc:	2302      	movs	r3, #2
34180ace:	637b      	str	r3, [r7, #52]	@ 0x34
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL3;
34180ad0:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34180ad4:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 1;
34180ad6:	2301      	movs	r3, #1
34180ad8:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34180ada:	463b      	mov	r3, r7
34180adc:	4618      	mov	r0, r3
34180ade:	f001 ff5f 	bl	341829a0 <HAL_RCC_ClockConfig>
34180ae2:	4603      	mov	r3, r0
34180ae4:	2b00      	cmp	r3, #0
34180ae6:	d001      	beq.n	34180aec <SystemClock_Config+0x1b0>
  {
    Error_Handler();
34180ae8:	f000 f804 	bl	34180af4 <Error_Handler>
  }
}
34180aec:	bf00      	nop
34180aee:	37d8      	adds	r7, #216	@ 0xd8
34180af0:	46bd      	mov	sp, r7
34180af2:	bd80      	pop	{r7, pc}

34180af4 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
34180af4:	b480      	push	{r7}
34180af6:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
34180af8:	b672      	cpsid	i
}
34180afa:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
34180afc:	bf00      	nop
34180afe:	e7fd      	b.n	34180afc <Error_Handler+0x8>

34180b00 <LL_AHB4_GRP1_EnableClock>:
{
34180b00:	b480      	push	{r7}
34180b02:	b085      	sub	sp, #20
34180b04:	af00      	add	r7, sp, #0
34180b06:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34180b08:	4a07      	ldr	r2, [pc, #28]	@ (34180b28 <LL_AHB4_GRP1_EnableClock+0x28>)
34180b0a:	687b      	ldr	r3, [r7, #4]
34180b0c:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34180b10:	4b05      	ldr	r3, [pc, #20]	@ (34180b28 <LL_AHB4_GRP1_EnableClock+0x28>)
34180b12:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34180b16:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34180b18:	68fb      	ldr	r3, [r7, #12]
}
34180b1a:	bf00      	nop
34180b1c:	3714      	adds	r7, #20
34180b1e:	46bd      	mov	sp, r7
34180b20:	f85d 7b04 	ldr.w	r7, [sp], #4
34180b24:	4770      	bx	lr
34180b26:	bf00      	nop
34180b28:	56028000 	.word	0x56028000

34180b2c <LL_AHB5_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClock(uint32_t Periphs)
{
34180b2c:	b480      	push	{r7}
34180b2e:	b085      	sub	sp, #20
34180b30:	af00      	add	r7, sp, #0
34180b32:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34180b34:	4a07      	ldr	r2, [pc, #28]	@ (34180b54 <LL_AHB5_GRP1_EnableClock+0x28>)
34180b36:	687b      	ldr	r3, [r7, #4]
34180b38:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5ENR);
34180b3c:	4b05      	ldr	r3, [pc, #20]	@ (34180b54 <LL_AHB5_GRP1_EnableClock+0x28>)
34180b3e:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34180b42:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34180b44:	68fb      	ldr	r3, [r7, #12]
}
34180b46:	bf00      	nop
34180b48:	3714      	adds	r7, #20
34180b4a:	46bd      	mov	sp, r7
34180b4c:	f85d 7b04 	ldr.w	r7, [sp], #4
34180b50:	4770      	bx	lr
34180b52:	bf00      	nop
34180b54:	56028000 	.word	0x56028000

34180b58 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
34180b58:	b580      	push	{r7, lr}
34180b5a:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableVddIO2();
34180b5c:	f001 f8b4 	bl	34181cc8 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2,PWR_VDDIO_RANGE_1V8);
34180b60:	2101      	movs	r1, #1
34180b62:	2001      	movs	r0, #1
34180b64:	f001 f85e 	bl	34181c24 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO3();
34180b68:	f001 f8be 	bl	34181ce8 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3,PWR_VDDIO_RANGE_1V8);
34180b6c:	2101      	movs	r1, #1
34180b6e:	2002      	movs	r0, #2
34180b70:	f001 f858 	bl	34181c24 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO4();
34180b74:	f001 f8c8 	bl	34181d08 <HAL_PWREx_EnableVddIO4>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO4,PWR_VDDIO_RANGE_3V3);
34180b78:	2100      	movs	r1, #0
34180b7a:	2003      	movs	r0, #3
34180b7c:	f001 f852 	bl	34181c24 <HAL_PWREx_ConfigVddIORange>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
34180b80:	bf00      	nop
34180b82:	bd80      	pop	{r7, pc}

34180b84 <HAL_XSPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hxspi: XSPI handle pointer
* @retval None
*/
void HAL_XSPI_MspInit(XSPI_HandleTypeDef* hxspi)
{
34180b84:	b580      	push	{r7, lr}
34180b86:	b0ec      	sub	sp, #432	@ 0x1b0
34180b88:	af00      	add	r7, sp, #0
34180b8a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34180b8e:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34180b92:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34180b94:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34180b98:	2200      	movs	r2, #0
34180b9a:	601a      	str	r2, [r3, #0]
34180b9c:	605a      	str	r2, [r3, #4]
34180b9e:	609a      	str	r2, [r3, #8]
34180ba0:	60da      	str	r2, [r3, #12]
34180ba2:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34180ba4:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34180ba8:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34180bac:	4618      	mov	r0, r3
34180bae:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34180bb2:	461a      	mov	r2, r3
34180bb4:	2100      	movs	r1, #0
34180bb6:	f006 fce1 	bl	3418757c <memset>
  if(hxspi->Instance==XSPI1)
34180bba:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34180bbe:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34180bc2:	681b      	ldr	r3, [r3, #0]
34180bc4:	681b      	ldr	r3, [r3, #0]
34180bc6:	4a5a      	ldr	r2, [pc, #360]	@ (34180d30 <HAL_XSPI_MspInit+0x1ac>)
34180bc8:	4293      	cmp	r3, r2
34180bca:	d15d      	bne.n	34180c88 <HAL_XSPI_MspInit+0x104>

  /* USER CODE END XSPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI1;
34180bcc:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34180bd0:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34180bd4:	f04f 0200 	mov.w	r2, #0
34180bd8:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34180bdc:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34180be0:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34180be4:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34180be8:	4a52      	ldr	r2, [pc, #328]	@ (34180d34 <HAL_XSPI_MspInit+0x1b0>)
34180bea:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34180bee:	f107 0308 	add.w	r3, r7, #8
34180bf2:	4618      	mov	r0, r3
34180bf4:	f003 fa86 	bl	34184104 <HAL_RCCEx_PeriphCLKConfig>
34180bf8:	4603      	mov	r3, r0
34180bfa:	2b00      	cmp	r3, #0
34180bfc:	d001      	beq.n	34180c02 <HAL_XSPI_MspInit+0x7e>
    {
      Error_Handler();
34180bfe:	f7ff ff79 	bl	34180af4 <Error_Handler>
    }

    /* Peripheral clock enable */
    HAL_RCC_XSPIM_CLK_ENABLED++;
34180c02:	4b4d      	ldr	r3, [pc, #308]	@ (34180d38 <HAL_XSPI_MspInit+0x1b4>)
34180c04:	681b      	ldr	r3, [r3, #0]
34180c06:	3301      	adds	r3, #1
34180c08:	4a4b      	ldr	r2, [pc, #300]	@ (34180d38 <HAL_XSPI_MspInit+0x1b4>)
34180c0a:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
34180c0c:	4b4a      	ldr	r3, [pc, #296]	@ (34180d38 <HAL_XSPI_MspInit+0x1b4>)
34180c0e:	681b      	ldr	r3, [r3, #0]
34180c10:	2b01      	cmp	r3, #1
34180c12:	d103      	bne.n	34180c1c <HAL_XSPI_MspInit+0x98>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34180c14:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34180c18:	f7ff ff88 	bl	34180b2c <LL_AHB5_GRP1_EnableClock>
    }
    __HAL_RCC_XSPI1_CLK_ENABLE();
34180c1c:	2020      	movs	r0, #32
34180c1e:	f7ff ff85 	bl	34180b2c <LL_AHB5_GRP1_EnableClock>

    __HAL_RCC_GPIOP_CLK_ENABLE();
34180c22:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34180c26:	f7ff ff6b 	bl	34180b00 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOO_CLK_ENABLE();
34180c2a:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34180c2e:	f7ff ff67 	bl	34180b00 <LL_AHB4_GRP1_EnableClock>
    PO5     ------> XSPIM_P1_NCLK
    PO2     ------> XSPIM_P1_DQS0
    PO0     ------> XSPIM_P1_NCS1
    PO4     ------> XSPIM_P1_CLK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_0|GPIO_PIN_4
34180c32:	23ff      	movs	r3, #255	@ 0xff
34180c34:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |GPIO_PIN_1|GPIO_PIN_5|GPIO_PIN_3|GPIO_PIN_2;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34180c38:	2302      	movs	r3, #2
34180c3a:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34180c3e:	2300      	movs	r3, #0
34180c40:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34180c44:	2303      	movs	r3, #3
34180c46:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
34180c4a:	2309      	movs	r3, #9
34180c4c:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOP, &GPIO_InitStruct);
34180c50:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34180c54:	4619      	mov	r1, r3
34180c56:	4839      	ldr	r0, [pc, #228]	@ (34180d3c <HAL_XSPI_MspInit+0x1b8>)
34180c58:	f000 fdd8 	bl	3418180c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_2|GPIO_PIN_0|GPIO_PIN_4;
34180c5c:	2335      	movs	r3, #53	@ 0x35
34180c5e:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34180c62:	2302      	movs	r3, #2
34180c64:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34180c68:	2300      	movs	r3, #0
34180c6a:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34180c6e:	2303      	movs	r3, #3
34180c70:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
34180c74:	2309      	movs	r3, #9
34180c76:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
34180c7a:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34180c7e:	4619      	mov	r1, r3
34180c80:	482f      	ldr	r0, [pc, #188]	@ (34180d40 <HAL_XSPI_MspInit+0x1bc>)
34180c82:	f000 fdc3 	bl	3418180c <HAL_GPIO_Init>
  /* USER CODE BEGIN XSPI2_MspInit 1 */

  /* USER CODE END XSPI2_MspInit 1 */
  }

}
34180c86:	e04e      	b.n	34180d26 <HAL_XSPI_MspInit+0x1a2>
  else if(hxspi->Instance==XSPI2)
34180c88:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34180c8c:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34180c90:	681b      	ldr	r3, [r3, #0]
34180c92:	681b      	ldr	r3, [r3, #0]
34180c94:	4a2b      	ldr	r2, [pc, #172]	@ (34180d44 <HAL_XSPI_MspInit+0x1c0>)
34180c96:	4293      	cmp	r3, r2
34180c98:	d145      	bne.n	34180d26 <HAL_XSPI_MspInit+0x1a2>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI2;
34180c9a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34180c9e:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34180ca2:	f04f 0200 	mov.w	r2, #0
34180ca6:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
34180caa:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34180cae:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34180cb2:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34180cb6:	4a24      	ldr	r2, [pc, #144]	@ (34180d48 <HAL_XSPI_MspInit+0x1c4>)
34180cb8:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34180cbc:	f107 0308 	add.w	r3, r7, #8
34180cc0:	4618      	mov	r0, r3
34180cc2:	f003 fa1f 	bl	34184104 <HAL_RCCEx_PeriphCLKConfig>
34180cc6:	4603      	mov	r3, r0
34180cc8:	2b00      	cmp	r3, #0
34180cca:	d001      	beq.n	34180cd0 <HAL_XSPI_MspInit+0x14c>
      Error_Handler();
34180ccc:	f7ff ff12 	bl	34180af4 <Error_Handler>
    HAL_RCC_XSPIM_CLK_ENABLED++;
34180cd0:	4b19      	ldr	r3, [pc, #100]	@ (34180d38 <HAL_XSPI_MspInit+0x1b4>)
34180cd2:	681b      	ldr	r3, [r3, #0]
34180cd4:	3301      	adds	r3, #1
34180cd6:	4a18      	ldr	r2, [pc, #96]	@ (34180d38 <HAL_XSPI_MspInit+0x1b4>)
34180cd8:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
34180cda:	4b17      	ldr	r3, [pc, #92]	@ (34180d38 <HAL_XSPI_MspInit+0x1b4>)
34180cdc:	681b      	ldr	r3, [r3, #0]
34180cde:	2b01      	cmp	r3, #1
34180ce0:	d103      	bne.n	34180cea <HAL_XSPI_MspInit+0x166>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34180ce2:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34180ce6:	f7ff ff21 	bl	34180b2c <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_XSPI2_CLK_ENABLE();
34180cea:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34180cee:	f7ff ff1d 	bl	34180b2c <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_GPION_CLK_ENABLE();
34180cf2:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34180cf6:	f7ff ff03 	bl	34180b00 <LL_AHB4_GRP1_EnableClock>
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_0
34180cfa:	f640 737f 	movw	r3, #3967	@ 0xf7f
34180cfe:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34180d02:	2302      	movs	r3, #2
34180d04:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34180d08:	2300      	movs	r3, #0
34180d0a:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34180d0e:	2303      	movs	r3, #3
34180d10:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P2;
34180d14:	2309      	movs	r3, #9
34180d16:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPION, &GPIO_InitStruct);
34180d1a:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34180d1e:	4619      	mov	r1, r3
34180d20:	480a      	ldr	r0, [pc, #40]	@ (34180d4c <HAL_XSPI_MspInit+0x1c8>)
34180d22:	f000 fd73 	bl	3418180c <HAL_GPIO_Init>
}
34180d26:	bf00      	nop
34180d28:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
34180d2c:	46bd      	mov	sp, r7
34180d2e:	bd80      	pop	{r7, pc}
34180d30:	58025000 	.word	0x58025000
34180d34:	03000014 	.word	0x03000014
34180d38:	341c002c 	.word	0x341c002c
34180d3c:	56023c00 	.word	0x56023c00
34180d40:	56023800 	.word	0x56023800
34180d44:	5802a000 	.word	0x5802a000
34180d48:	03000414 	.word	0x03000414
34180d4c:	56023400 	.word	0x56023400

34180d50 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
34180d50:	b480      	push	{r7}
34180d52:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34180d54:	bf00      	nop
34180d56:	e7fd      	b.n	34180d54 <NMI_Handler+0x4>

34180d58 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
34180d58:	b480      	push	{r7}
34180d5a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
34180d5c:	bf00      	nop
34180d5e:	e7fd      	b.n	34180d5c <HardFault_Handler+0x4>

34180d60 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
34180d60:	b480      	push	{r7}
34180d62:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34180d64:	bf00      	nop
34180d66:	e7fd      	b.n	34180d64 <MemManage_Handler+0x4>

34180d68 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
34180d68:	b480      	push	{r7}
34180d6a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
34180d6c:	bf00      	nop
34180d6e:	e7fd      	b.n	34180d6c <BusFault_Handler+0x4>

34180d70 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
34180d70:	b480      	push	{r7}
34180d72:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34180d74:	bf00      	nop
34180d76:	e7fd      	b.n	34180d74 <UsageFault_Handler+0x4>

34180d78 <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
34180d78:	b480      	push	{r7}
34180d7a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
34180d7c:	bf00      	nop
34180d7e:	e7fd      	b.n	34180d7c <SecureFault_Handler+0x4>

34180d80 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
34180d80:	b480      	push	{r7}
34180d82:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
34180d84:	bf00      	nop
34180d86:	46bd      	mov	sp, r7
34180d88:	f85d 7b04 	ldr.w	r7, [sp], #4
34180d8c:	4770      	bx	lr

34180d8e <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
34180d8e:	b480      	push	{r7}
34180d90:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
34180d92:	bf00      	nop
34180d94:	46bd      	mov	sp, r7
34180d96:	f85d 7b04 	ldr.w	r7, [sp], #4
34180d9a:	4770      	bx	lr

34180d9c <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
34180d9c:	b480      	push	{r7}
34180d9e:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
34180da0:	bf00      	nop
34180da2:	46bd      	mov	sp, r7
34180da4:	f85d 7b04 	ldr.w	r7, [sp], #4
34180da8:	4770      	bx	lr

34180daa <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
34180daa:	b580      	push	{r7, lr}
34180dac:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
34180dae:	f000 fbf3 	bl	34181598 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
34180db2:	bf00      	nop
34180db4:	bd80      	pop	{r7, pc}
	...

34180db8 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
34180db8:	b480      	push	{r7}
34180dba:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34180dbc:	4b6a      	ldr	r3, [pc, #424]	@ (34180f68 <SystemInit+0x1b0>)
34180dbe:	4a6b      	ldr	r2, [pc, #428]	@ (34180f6c <SystemInit+0x1b4>)
34180dc0:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
34180dc2:	4b6b      	ldr	r3, [pc, #428]	@ (34180f70 <SystemInit+0x1b8>)
34180dc4:	2201      	movs	r2, #1
34180dc6:	f8c3 2a18 	str.w	r2, [r3, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34180dca:	4b69      	ldr	r3, [pc, #420]	@ (34180f70 <SystemInit+0x1b8>)
34180dcc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180dd0:	461a      	mov	r2, r3
34180dd2:	2301      	movs	r3, #1
34180dd4:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
  /* Deactivate RNG clock */
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34180dd8:	4b65      	ldr	r3, [pc, #404]	@ (34180f70 <SystemInit+0x1b8>)
34180dda:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180dde:	461a      	mov	r2, r3
34180de0:	2301      	movs	r3, #1
34180de2:	f8c2 3258 	str.w	r3, [r2, #600]	@ 0x258

  /* Clear SAU regions */
  SAU->RNR = 0;
34180de6:	4b63      	ldr	r3, [pc, #396]	@ (34180f74 <SystemInit+0x1bc>)
34180de8:	2200      	movs	r2, #0
34180dea:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180dec:	4b61      	ldr	r3, [pc, #388]	@ (34180f74 <SystemInit+0x1bc>)
34180dee:	2200      	movs	r2, #0
34180df0:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180df2:	4b60      	ldr	r3, [pc, #384]	@ (34180f74 <SystemInit+0x1bc>)
34180df4:	2200      	movs	r2, #0
34180df6:	611a      	str	r2, [r3, #16]
  SAU->RNR = 1;
34180df8:	4b5e      	ldr	r3, [pc, #376]	@ (34180f74 <SystemInit+0x1bc>)
34180dfa:	2201      	movs	r2, #1
34180dfc:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180dfe:	4b5d      	ldr	r3, [pc, #372]	@ (34180f74 <SystemInit+0x1bc>)
34180e00:	2200      	movs	r2, #0
34180e02:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180e04:	4b5b      	ldr	r3, [pc, #364]	@ (34180f74 <SystemInit+0x1bc>)
34180e06:	2200      	movs	r2, #0
34180e08:	611a      	str	r2, [r3, #16]
  SAU->RNR = 2;
34180e0a:	4b5a      	ldr	r3, [pc, #360]	@ (34180f74 <SystemInit+0x1bc>)
34180e0c:	2202      	movs	r2, #2
34180e0e:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180e10:	4b58      	ldr	r3, [pc, #352]	@ (34180f74 <SystemInit+0x1bc>)
34180e12:	2200      	movs	r2, #0
34180e14:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180e16:	4b57      	ldr	r3, [pc, #348]	@ (34180f74 <SystemInit+0x1bc>)
34180e18:	2200      	movs	r2, #0
34180e1a:	611a      	str	r2, [r3, #16]
  SAU->RNR = 3;
34180e1c:	4b55      	ldr	r3, [pc, #340]	@ (34180f74 <SystemInit+0x1bc>)
34180e1e:	2203      	movs	r2, #3
34180e20:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180e22:	4b54      	ldr	r3, [pc, #336]	@ (34180f74 <SystemInit+0x1bc>)
34180e24:	2200      	movs	r2, #0
34180e26:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180e28:	4b52      	ldr	r3, [pc, #328]	@ (34180f74 <SystemInit+0x1bc>)
34180e2a:	2200      	movs	r2, #0
34180e2c:	611a      	str	r2, [r3, #16]
  SAU->RNR = 4;
34180e2e:	4b51      	ldr	r3, [pc, #324]	@ (34180f74 <SystemInit+0x1bc>)
34180e30:	2204      	movs	r2, #4
34180e32:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180e34:	4b4f      	ldr	r3, [pc, #316]	@ (34180f74 <SystemInit+0x1bc>)
34180e36:	2200      	movs	r2, #0
34180e38:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180e3a:	4b4e      	ldr	r3, [pc, #312]	@ (34180f74 <SystemInit+0x1bc>)
34180e3c:	2200      	movs	r2, #0
34180e3e:	611a      	str	r2, [r3, #16]
  SAU->RNR = 5;
34180e40:	4b4c      	ldr	r3, [pc, #304]	@ (34180f74 <SystemInit+0x1bc>)
34180e42:	2205      	movs	r2, #5
34180e44:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180e46:	4b4b      	ldr	r3, [pc, #300]	@ (34180f74 <SystemInit+0x1bc>)
34180e48:	2200      	movs	r2, #0
34180e4a:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180e4c:	4b49      	ldr	r3, [pc, #292]	@ (34180f74 <SystemInit+0x1bc>)
34180e4e:	2200      	movs	r2, #0
34180e50:	611a      	str	r2, [r3, #16]
  SAU->RNR = 6;
34180e52:	4b48      	ldr	r3, [pc, #288]	@ (34180f74 <SystemInit+0x1bc>)
34180e54:	2206      	movs	r2, #6
34180e56:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180e58:	4b46      	ldr	r3, [pc, #280]	@ (34180f74 <SystemInit+0x1bc>)
34180e5a:	2200      	movs	r2, #0
34180e5c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180e5e:	4b45      	ldr	r3, [pc, #276]	@ (34180f74 <SystemInit+0x1bc>)
34180e60:	2200      	movs	r2, #0
34180e62:	611a      	str	r2, [r3, #16]
  SAU->RNR = 7;
34180e64:	4b43      	ldr	r3, [pc, #268]	@ (34180f74 <SystemInit+0x1bc>)
34180e66:	2207      	movs	r2, #7
34180e68:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180e6a:	4b42      	ldr	r3, [pc, #264]	@ (34180f74 <SystemInit+0x1bc>)
34180e6c:	2200      	movs	r2, #0
34180e6e:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180e70:	4b40      	ldr	r3, [pc, #256]	@ (34180f74 <SystemInit+0x1bc>)
34180e72:	2200      	movs	r2, #0
34180e74:	611a      	str	r2, [r3, #16]

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34180e76:	4b3e      	ldr	r3, [pc, #248]	@ (34180f70 <SystemInit+0x1b8>)
34180e78:	2201      	movs	r2, #1
34180e7a:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
34180e7e:	4b3c      	ldr	r3, [pc, #240]	@ (34180f70 <SystemInit+0x1b8>)
34180e80:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34180e84:	4b38      	ldr	r3, [pc, #224]	@ (34180f68 <SystemInit+0x1b0>)
34180e86:	4a3c      	ldr	r2, [pc, #240]	@ (34180f78 <SystemInit+0x1c0>)
34180e88:	689b      	ldr	r3, [r3, #8]
34180e8a:	6113      	str	r3, [r2, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
34180e8c:	4b3b      	ldr	r3, [pc, #236]	@ (34180f7c <SystemInit+0x1c4>)
34180e8e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34180e90:	4a3a      	ldr	r2, [pc, #232]	@ (34180f7c <SystemInit+0x1c4>)
34180e92:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34180e96:	63d3      	str	r3, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
34180e98:	4b38      	ldr	r3, [pc, #224]	@ (34180f7c <SystemInit+0x1c4>)
34180e9a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34180e9c:	4a37      	ldr	r2, [pc, #220]	@ (34180f7c <SystemInit+0x1c4>)
34180e9e:	f043 0310 	orr.w	r3, r3, #16
34180ea2:	63d3      	str	r3, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
34180ea4:	4b35      	ldr	r3, [pc, #212]	@ (34180f7c <SystemInit+0x1c4>)
34180ea6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
34180ea8:	4b31      	ldr	r3, [pc, #196]	@ (34180f70 <SystemInit+0x1b8>)
34180eaa:	f8d3 3274 	ldr.w	r3, [r3, #628]	@ 0x274
34180eae:	4a30      	ldr	r2, [pc, #192]	@ (34180f70 <SystemInit+0x1b8>)
34180eb0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34180eb4:	f8c2 3274 	str.w	r3, [r2, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
34180eb8:	4b2d      	ldr	r3, [pc, #180]	@ (34180f70 <SystemInit+0x1b8>)
34180eba:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34180ebe:	4a2c      	ldr	r2, [pc, #176]	@ (34180f70 <SystemInit+0x1b8>)
34180ec0:	f043 0310 	orr.w	r3, r3, #16
34180ec4:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  (void) RCC->APB4ENR2;
34180ec8:	4b29      	ldr	r3, [pc, #164]	@ (34180f70 <SystemInit+0x1b8>)
34180eca:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
34180ece:	4b28      	ldr	r3, [pc, #160]	@ (34180f70 <SystemInit+0x1b8>)
34180ed0:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34180ed4:	4a26      	ldr	r2, [pc, #152]	@ (34180f70 <SystemInit+0x1b8>)
34180ed6:	f023 0310 	bic.w	r3, r3, #16
34180eda:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
34180ede:	4b24      	ldr	r3, [pc, #144]	@ (34180f70 <SystemInit+0x1b8>)
34180ee0:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
34180ee4:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
34180ee8:	4b21      	ldr	r3, [pc, #132]	@ (34180f70 <SystemInit+0x1b8>)
34180eea:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180eee:	461a      	mov	r2, r3
34180ef0:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34180ef4:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220

  /* TIM2 reset */
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
34180ef8:	4b1d      	ldr	r3, [pc, #116]	@ (34180f70 <SystemInit+0x1b8>)
34180efa:	2201      	movs	r2, #1
34180efc:	f8c3 2a24 	str.w	r2, [r3, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
34180f00:	4b1b      	ldr	r3, [pc, #108]	@ (34180f70 <SystemInit+0x1b8>)
34180f02:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180f06:	461a      	mov	r2, r3
34180f08:	2301      	movs	r3, #1
34180f0a:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
34180f0e:	4b18      	ldr	r3, [pc, #96]	@ (34180f70 <SystemInit+0x1b8>)
34180f10:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180f14:	461a      	mov	r2, r3
34180f16:	2301      	movs	r3, #1
34180f18:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34180f1c:	4b14      	ldr	r3, [pc, #80]	@ (34180f70 <SystemInit+0x1b8>)
34180f1e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180f22:	461a      	mov	r2, r3
34180f24:	2340      	movs	r3, #64	@ 0x40
34180f26:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34180f2a:	4b13      	ldr	r3, [pc, #76]	@ (34180f78 <SystemInit+0x1c0>)
34180f2c:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34180f2e:	4b10      	ldr	r3, [pc, #64]	@ (34180f70 <SystemInit+0x1b8>)
34180f30:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180f34:	461a      	mov	r2, r3
34180f36:	2301      	movs	r3, #1
34180f38:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34180f3c:	4b0a      	ldr	r3, [pc, #40]	@ (34180f68 <SystemInit+0x1b0>)
34180f3e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34180f42:	4a09      	ldr	r2, [pc, #36]	@ (34180f68 <SystemInit+0x1b0>)
34180f44:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34180f48:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34180f4c:	4b0c      	ldr	r3, [pc, #48]	@ (34180f80 <SystemInit+0x1c8>)
34180f4e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34180f52:	4a0b      	ldr	r2, [pc, #44]	@ (34180f80 <SystemInit+0x1c8>)
34180f54:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34180f58:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34180f5c:	bf00      	nop
34180f5e:	46bd      	mov	sp, r7
34180f60:	f85d 7b04 	ldr.w	r7, [sp], #4
34180f64:	4770      	bx	lr
34180f66:	bf00      	nop
34180f68:	e000ed00 	.word	0xe000ed00
34180f6c:	34180400 	.word	0x34180400
34180f70:	56028000 	.word	0x56028000
34180f74:	e000edd0 	.word	0xe000edd0
34180f78:	56008000 	.word	0x56008000
34180f7c:	56024800 	.word	0x56024800
34180f80:	e002ed00 	.word	0xe002ed00

34180f84 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
34180f84:	b480      	push	{r7}
34180f86:	b08d      	sub	sp, #52	@ 0x34
34180f88:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
34180f8a:	2300      	movs	r3, #0
34180f8c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
34180f8e:	2300      	movs	r3, #0
34180f90:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
34180f92:	2300      	movs	r3, #0
34180f94:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
34180f96:	2300      	movs	r3, #0
34180f98:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
34180f9a:	2300      	movs	r3, #0
34180f9c:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
34180f9e:	2300      	movs	r3, #0
34180fa0:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34180fa2:	4b9b      	ldr	r3, [pc, #620]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
34180fa4:	6a1b      	ldr	r3, [r3, #32]
34180fa6:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
34180faa:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34180fae:	d029      	beq.n	34181004 <SystemCoreClockUpdate+0x80>
34180fb0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34180fb4:	f200 8180 	bhi.w	341812b8 <SystemCoreClockUpdate+0x334>
34180fb8:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34180fbc:	d01f      	beq.n	34180ffe <SystemCoreClockUpdate+0x7a>
34180fbe:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34180fc2:	f200 8179 	bhi.w	341812b8 <SystemCoreClockUpdate+0x334>
34180fc6:	2b00      	cmp	r3, #0
34180fc8:	d003      	beq.n	34180fd2 <SystemCoreClockUpdate+0x4e>
34180fca:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34180fce:	d00a      	beq.n	34180fe6 <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
34180fd0:	e172      	b.n	341812b8 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34180fd2:	4b8f      	ldr	r3, [pc, #572]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
34180fd4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34180fd6:	09db      	lsrs	r3, r3, #7
34180fd8:	f003 0303 	and.w	r3, r3, #3
34180fdc:	4a8d      	ldr	r2, [pc, #564]	@ (34181214 <SystemCoreClockUpdate+0x290>)
34180fde:	fa22 f303 	lsr.w	r3, r2, r3
34180fe2:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34180fe4:	e169      	b.n	341812ba <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34180fe6:	4b8a      	ldr	r3, [pc, #552]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
34180fe8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34180fea:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34180fee:	2b00      	cmp	r3, #0
34180ff0:	d102      	bne.n	34180ff8 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
34180ff2:	4b89      	ldr	r3, [pc, #548]	@ (34181218 <SystemCoreClockUpdate+0x294>)
34180ff4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34180ff6:	e160      	b.n	341812ba <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
34180ff8:	4b88      	ldr	r3, [pc, #544]	@ (3418121c <SystemCoreClockUpdate+0x298>)
34180ffa:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34180ffc:	e15d      	b.n	341812ba <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
34180ffe:	4b88      	ldr	r3, [pc, #544]	@ (34181220 <SystemCoreClockUpdate+0x29c>)
34181000:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34181002:	e15a      	b.n	341812ba <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34181004:	4b82      	ldr	r3, [pc, #520]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
34181006:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418100a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
3418100e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181012:	d066      	beq.n	341810e2 <SystemCoreClockUpdate+0x15e>
34181014:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181018:	f200 8091 	bhi.w	3418113e <SystemCoreClockUpdate+0x1ba>
3418101c:	2b00      	cmp	r3, #0
3418101e:	d003      	beq.n	34181028 <SystemCoreClockUpdate+0xa4>
34181020:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34181024:	d02f      	beq.n	34181086 <SystemCoreClockUpdate+0x102>
34181026:	e08a      	b.n	3418113e <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34181028:	4b79      	ldr	r3, [pc, #484]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
3418102a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418102e:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34181030:	68fb      	ldr	r3, [r7, #12]
34181032:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34181036:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
34181038:	68fb      	ldr	r3, [r7, #12]
3418103a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418103e:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34181040:	693b      	ldr	r3, [r7, #16]
34181042:	2b00      	cmp	r3, #0
34181044:	f040 80a9 	bne.w	3418119a <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
34181048:	68fb      	ldr	r3, [r7, #12]
3418104a:	0d1b      	lsrs	r3, r3, #20
3418104c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34181050:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34181052:	68fb      	ldr	r3, [r7, #12]
34181054:	0a1b      	lsrs	r3, r3, #8
34181056:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418105a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
3418105c:	4b6c      	ldr	r3, [pc, #432]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
3418105e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34181062:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34181066:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34181068:	4b69      	ldr	r3, [pc, #420]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
3418106a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418106e:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
34181070:	68fb      	ldr	r3, [r7, #12]
34181072:	0edb      	lsrs	r3, r3, #27
34181074:	f003 0307 	and.w	r3, r3, #7
34181078:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
3418107a:	68fb      	ldr	r3, [r7, #12]
3418107c:	0e1b      	lsrs	r3, r3, #24
3418107e:	f003 0307 	and.w	r3, r3, #7
34181082:	61bb      	str	r3, [r7, #24]
      break;
34181084:	e089      	b.n	3418119a <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34181086:	4b62      	ldr	r3, [pc, #392]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
34181088:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418108c:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
3418108e:	68fb      	ldr	r3, [r7, #12]
34181090:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34181094:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
34181096:	68fb      	ldr	r3, [r7, #12]
34181098:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418109c:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
3418109e:	693b      	ldr	r3, [r7, #16]
341810a0:	2b00      	cmp	r3, #0
341810a2:	d17c      	bne.n	3418119e <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
341810a4:	68fb      	ldr	r3, [r7, #12]
341810a6:	0d1b      	lsrs	r3, r3, #20
341810a8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
341810ac:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
341810ae:	68fb      	ldr	r3, [r7, #12]
341810b0:	0a1b      	lsrs	r3, r3, #8
341810b2:	f3c3 030b 	ubfx	r3, r3, #0, #12
341810b6:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
341810b8:	4b55      	ldr	r3, [pc, #340]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
341810ba:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341810be:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
341810c2:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
341810c4:	4b52      	ldr	r3, [pc, #328]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
341810c6:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
341810ca:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
341810cc:	68fb      	ldr	r3, [r7, #12]
341810ce:	0edb      	lsrs	r3, r3, #27
341810d0:	f003 0307 	and.w	r3, r3, #7
341810d4:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
341810d6:	68fb      	ldr	r3, [r7, #12]
341810d8:	0e1b      	lsrs	r3, r3, #24
341810da:	f003 0307 	and.w	r3, r3, #7
341810de:	61bb      	str	r3, [r7, #24]
      break;
341810e0:	e05d      	b.n	3418119e <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
341810e2:	4b4b      	ldr	r3, [pc, #300]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
341810e4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
341810e8:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
341810ea:	68fb      	ldr	r3, [r7, #12]
341810ec:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
341810f0:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
341810f2:	68fb      	ldr	r3, [r7, #12]
341810f4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
341810f8:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
341810fa:	693b      	ldr	r3, [r7, #16]
341810fc:	2b00      	cmp	r3, #0
341810fe:	d150      	bne.n	341811a2 <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34181100:	68fb      	ldr	r3, [r7, #12]
34181102:	0d1b      	lsrs	r3, r3, #20
34181104:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34181108:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
3418110a:	68fb      	ldr	r3, [r7, #12]
3418110c:	0a1b      	lsrs	r3, r3, #8
3418110e:	f3c3 030b 	ubfx	r3, r3, #0, #12
34181112:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34181114:	4b3e      	ldr	r3, [pc, #248]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
34181116:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3418111a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418111e:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34181120:	4b3b      	ldr	r3, [pc, #236]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
34181122:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34181126:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34181128:	68fb      	ldr	r3, [r7, #12]
3418112a:	0edb      	lsrs	r3, r3, #27
3418112c:	f003 0307 	and.w	r3, r3, #7
34181130:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
34181132:	68fb      	ldr	r3, [r7, #12]
34181134:	0e1b      	lsrs	r3, r3, #24
34181136:	f003 0307 	and.w	r3, r3, #7
3418113a:	61bb      	str	r3, [r7, #24]
      break;
3418113c:	e031      	b.n	341811a2 <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
3418113e:	4b34      	ldr	r3, [pc, #208]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
34181140:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34181144:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34181146:	68fb      	ldr	r3, [r7, #12]
34181148:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
3418114c:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
3418114e:	68fb      	ldr	r3, [r7, #12]
34181150:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34181154:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34181156:	693b      	ldr	r3, [r7, #16]
34181158:	2b00      	cmp	r3, #0
3418115a:	d124      	bne.n	341811a6 <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
3418115c:	68fb      	ldr	r3, [r7, #12]
3418115e:	0d1b      	lsrs	r3, r3, #20
34181160:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34181164:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34181166:	68fb      	ldr	r3, [r7, #12]
34181168:	0a1b      	lsrs	r3, r3, #8
3418116a:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418116e:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34181170:	4b27      	ldr	r3, [pc, #156]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
34181172:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34181176:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418117a:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
3418117c:	4b24      	ldr	r3, [pc, #144]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
3418117e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34181182:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34181184:	68fb      	ldr	r3, [r7, #12]
34181186:	0edb      	lsrs	r3, r3, #27
34181188:	f003 0307 	and.w	r3, r3, #7
3418118c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
3418118e:	68fb      	ldr	r3, [r7, #12]
34181190:	0e1b      	lsrs	r3, r3, #24
34181192:	f003 0307 	and.w	r3, r3, #7
34181196:	61bb      	str	r3, [r7, #24]
      break;
34181198:	e005      	b.n	341811a6 <SystemCoreClockUpdate+0x222>
      break;
3418119a:	bf00      	nop
3418119c:	e004      	b.n	341811a8 <SystemCoreClockUpdate+0x224>
      break;
3418119e:	bf00      	nop
341811a0:	e002      	b.n	341811a8 <SystemCoreClockUpdate+0x224>
      break;
341811a2:	bf00      	nop
341811a4:	e000      	b.n	341811a8 <SystemCoreClockUpdate+0x224>
      break;
341811a6:	bf00      	nop
    switch (pllsource)
341811a8:	697b      	ldr	r3, [r7, #20]
341811aa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341811ae:	d02c      	beq.n	3418120a <SystemCoreClockUpdate+0x286>
341811b0:	697b      	ldr	r3, [r7, #20]
341811b2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341811b6:	d839      	bhi.n	3418122c <SystemCoreClockUpdate+0x2a8>
341811b8:	697b      	ldr	r3, [r7, #20]
341811ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341811be:	d021      	beq.n	34181204 <SystemCoreClockUpdate+0x280>
341811c0:	697b      	ldr	r3, [r7, #20]
341811c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341811c6:	d831      	bhi.n	3418122c <SystemCoreClockUpdate+0x2a8>
341811c8:	697b      	ldr	r3, [r7, #20]
341811ca:	2b00      	cmp	r3, #0
341811cc:	d004      	beq.n	341811d8 <SystemCoreClockUpdate+0x254>
341811ce:	697b      	ldr	r3, [r7, #20]
341811d0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341811d4:	d00a      	beq.n	341811ec <SystemCoreClockUpdate+0x268>
      break;
341811d6:	e029      	b.n	3418122c <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
341811d8:	4b0d      	ldr	r3, [pc, #52]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
341811da:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341811dc:	09db      	lsrs	r3, r3, #7
341811de:	f003 0303 	and.w	r3, r3, #3
341811e2:	4a0c      	ldr	r2, [pc, #48]	@ (34181214 <SystemCoreClockUpdate+0x290>)
341811e4:	fa22 f303 	lsr.w	r3, r2, r3
341811e8:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
341811ea:	e020      	b.n	3418122e <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
341811ec:	4b08      	ldr	r3, [pc, #32]	@ (34181210 <SystemCoreClockUpdate+0x28c>)
341811ee:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341811f0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341811f4:	2b00      	cmp	r3, #0
341811f6:	d102      	bne.n	341811fe <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
341811f8:	4b07      	ldr	r3, [pc, #28]	@ (34181218 <SystemCoreClockUpdate+0x294>)
341811fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
341811fc:	e017      	b.n	3418122e <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
341811fe:	4b07      	ldr	r3, [pc, #28]	@ (3418121c <SystemCoreClockUpdate+0x298>)
34181200:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34181202:	e014      	b.n	3418122e <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34181204:	4b06      	ldr	r3, [pc, #24]	@ (34181220 <SystemCoreClockUpdate+0x29c>)
34181206:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34181208:	e011      	b.n	3418122e <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
3418120a:	4b06      	ldr	r3, [pc, #24]	@ (34181224 <SystemCoreClockUpdate+0x2a0>)
3418120c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3418120e:	e00e      	b.n	3418122e <SystemCoreClockUpdate+0x2aa>
34181210:	56028000 	.word	0x56028000
34181214:	03d09000 	.word	0x03d09000
34181218:	003d0900 	.word	0x003d0900
3418121c:	00f42400 	.word	0x00f42400
34181220:	02dc6c00 	.word	0x02dc6c00
34181224:	00bb8000 	.word	0x00bb8000
34181228:	4b800000 	.word	0x4b800000
      break;
3418122c:	bf00      	nop
    if (pllbypass == 0U)
3418122e:	693b      	ldr	r3, [r7, #16]
34181230:	2b00      	cmp	r3, #0
34181232:	d134      	bne.n	3418129e <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34181234:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34181236:	ee07 3a90 	vmov	s15, r3
3418123a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3418123e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34181240:	ee07 3a90 	vmov	s15, r3
34181244:	eef8 6a67 	vcvt.f32.u32	s13, s15
34181248:	6a3b      	ldr	r3, [r7, #32]
3418124a:	ee07 3a90 	vmov	s15, r3
3418124e:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34181252:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34181228 <SystemCoreClockUpdate+0x2a4>
34181256:	eec6 7a25 	vdiv.f32	s15, s12, s11
3418125a:	ee76 7aa7 	vadd.f32	s15, s13, s15
3418125e:	ee67 6a27 	vmul.f32	s13, s14, s15
34181262:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34181264:	ee07 3a90 	vmov	s15, r3
34181268:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3418126c:	eec6 7a87 	vdiv.f32	s15, s13, s14
34181270:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34181274:	69fb      	ldr	r3, [r7, #28]
34181276:	ee07 3a90 	vmov	s15, r3
3418127a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3418127e:	69bb      	ldr	r3, [r7, #24]
34181280:	ee07 3a90 	vmov	s15, r3
34181284:	eef8 7a67 	vcvt.f32.u32	s15, s15
34181288:	ee27 7a27 	vmul.f32	s14, s14, s15
3418128c:	edd7 6a02 	vldr	s13, [r7, #8]
34181290:	eec6 7a87 	vdiv.f32	s15, s13, s14
34181294:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34181298:	ee17 3a90 	vmov	r3, s15
3418129c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
3418129e:	4b0b      	ldr	r3, [pc, #44]	@ (341812cc <SystemCoreClockUpdate+0x348>)
341812a0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341812a4:	0c1b      	lsrs	r3, r3, #16
341812a6:	b2db      	uxtb	r3, r3
341812a8:	3301      	adds	r3, #1
341812aa:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
341812ac:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
341812ae:	687b      	ldr	r3, [r7, #4]
341812b0:	fbb2 f3f3 	udiv	r3, r2, r3
341812b4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
341812b6:	e000      	b.n	341812ba <SystemCoreClockUpdate+0x336>
    break;
341812b8:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
341812ba:	4a05      	ldr	r2, [pc, #20]	@ (341812d0 <SystemCoreClockUpdate+0x34c>)
341812bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341812be:	6013      	str	r3, [r2, #0]
}
341812c0:	bf00      	nop
341812c2:	3734      	adds	r7, #52	@ 0x34
341812c4:	46bd      	mov	sp, r7
341812c6:	f85d 7b04 	ldr.w	r7, [sp], #4
341812ca:	4770      	bx	lr
341812cc:	56028000 	.word	0x56028000
341812d0:	341c0000 	.word	0x341c0000

341812d4 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
341812d4:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
341812d8:	b588      	push	{r3, r7, lr}
341812da:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
341812dc:	f7ff fe52 	bl	34180f84 <SystemCoreClockUpdate>

  return SystemCoreClock;
341812e0:	4b06      	ldr	r3, [pc, #24]	@ (341812fc <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
341812e2:	681b      	ldr	r3, [r3, #0]
}
341812e4:	4618      	mov	r0, r3
341812e6:	46bd      	mov	sp, r7
341812e8:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
341812ec:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
341812f0:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
341812f4:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
341812f8:	4774      	bxns	lr
341812fa:	bf00      	nop
341812fc:	341c0000 	.word	0x341c0000

34181300 <MX_XSPI1_Init>:
XSPI_HandleTypeDef hxspi1;
XSPI_HandleTypeDef hxspi2;

/* XSPI1 init function */
void MX_XSPI1_Init(void)
{
34181300:	b580      	push	{r7, lr}
34181302:	b088      	sub	sp, #32
34181304:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI1_Init 0 */

  /* USER CODE END XSPI1_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34181306:	f107 0314 	add.w	r3, r7, #20
3418130a:	2200      	movs	r2, #0
3418130c:	601a      	str	r2, [r3, #0]
3418130e:	605a      	str	r2, [r3, #4]
34181310:	609a      	str	r2, [r3, #8]
  XSPI_HyperbusCfgTypeDef sHyperBusCfg = {0};
34181312:	1d3b      	adds	r3, r7, #4
34181314:	2200      	movs	r2, #0
34181316:	601a      	str	r2, [r3, #0]
34181318:	605a      	str	r2, [r3, #4]
3418131a:	609a      	str	r2, [r3, #8]
3418131c:	60da      	str	r2, [r3, #12]

  /* USER CODE BEGIN XSPI1_Init 1 */

  /* USER CODE END XSPI1_Init 1 */
  hxspi1.Instance = XSPI1;
3418131e:	4b32      	ldr	r3, [pc, #200]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181320:	4a32      	ldr	r2, [pc, #200]	@ (341813ec <MX_XSPI1_Init+0xec>)
34181322:	601a      	str	r2, [r3, #0]
  hxspi1.Init.FifoThresholdByte = 4;
34181324:	4b30      	ldr	r3, [pc, #192]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181326:	2204      	movs	r2, #4
34181328:	605a      	str	r2, [r3, #4]
  hxspi1.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
3418132a:	4b2f      	ldr	r3, [pc, #188]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
3418132c:	2200      	movs	r2, #0
3418132e:	609a      	str	r2, [r3, #8]
  hxspi1.Init.MemoryType = HAL_XSPI_MEMTYPE_HYPERBUS;
34181330:	4b2d      	ldr	r3, [pc, #180]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181332:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34181336:	60da      	str	r2, [r3, #12]
  hxspi1.Init.MemorySize = HAL_XSPI_SIZE_256MB;
34181338:	4b2b      	ldr	r3, [pc, #172]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
3418133a:	2218      	movs	r2, #24
3418133c:	611a      	str	r2, [r3, #16]
  hxspi1.Init.ChipSelectHighTimeCycle = 2;
3418133e:	4b2a      	ldr	r3, [pc, #168]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181340:	2202      	movs	r2, #2
34181342:	615a      	str	r2, [r3, #20]
  hxspi1.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
34181344:	4b28      	ldr	r3, [pc, #160]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181346:	2200      	movs	r2, #0
34181348:	619a      	str	r2, [r3, #24]
  hxspi1.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
3418134a:	4b27      	ldr	r3, [pc, #156]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
3418134c:	2200      	movs	r2, #0
3418134e:	61da      	str	r2, [r3, #28]
  hxspi1.Init.WrapSize = HAL_XSPI_WRAP_32_BYTES;
34181350:	4b25      	ldr	r3, [pc, #148]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181352:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
34181356:	621a      	str	r2, [r3, #32]
  hxspi1.Init.ClockPrescaler = 1 - 1;
34181358:	4b23      	ldr	r3, [pc, #140]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
3418135a:	2200      	movs	r2, #0
3418135c:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi1.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
3418135e:	4b22      	ldr	r3, [pc, #136]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181360:	2200      	movs	r2, #0
34181362:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi1.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34181364:	4b20      	ldr	r3, [pc, #128]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181366:	2200      	movs	r2, #0
34181368:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi1.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
3418136a:	4b1f      	ldr	r3, [pc, #124]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
3418136c:	2200      	movs	r2, #0
3418136e:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi1.Init.MaxTran = 0;
34181370:	4b1d      	ldr	r3, [pc, #116]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181372:	2200      	movs	r2, #0
34181374:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi1.Init.Refresh = 0;
34181376:	4b1c      	ldr	r3, [pc, #112]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181378:	2200      	movs	r2, #0
3418137a:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi1.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
3418137c:	4b1a      	ldr	r3, [pc, #104]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
3418137e:	2200      	movs	r2, #0
34181380:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi1) != HAL_OK)
34181382:	4819      	ldr	r0, [pc, #100]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
34181384:	f005 fb7c 	bl	34186a80 <HAL_XSPI_Init>
34181388:	4603      	mov	r3, r0
3418138a:	2b00      	cmp	r3, #0
3418138c:	d001      	beq.n	34181392 <MX_XSPI1_Init+0x92>
  {
    Error_Handler();
3418138e:	f7ff fbb1 	bl	34180af4 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34181392:	2310      	movs	r3, #16
34181394:	617b      	str	r3, [r7, #20]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_1;
34181396:	2300      	movs	r3, #0
34181398:	61bb      	str	r3, [r7, #24]
  sXspiManagerCfg.Req2AckTime = 1;
3418139a:	2301      	movs	r3, #1
3418139c:	61fb      	str	r3, [r7, #28]
  if (HAL_XSPIM_Config(&hxspi1, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3418139e:	f107 0314 	add.w	r3, r7, #20
341813a2:	f241 3288 	movw	r2, #5000	@ 0x1388
341813a6:	4619      	mov	r1, r3
341813a8:	480f      	ldr	r0, [pc, #60]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
341813aa:	f005 fccb 	bl	34186d44 <HAL_XSPIM_Config>
341813ae:	4603      	mov	r3, r0
341813b0:	2b00      	cmp	r3, #0
341813b2:	d001      	beq.n	341813b8 <MX_XSPI1_Init+0xb8>
  {
    Error_Handler();
341813b4:	f7ff fb9e 	bl	34180af4 <Error_Handler>
  }
  sHyperBusCfg.RWRecoveryTimeCycle = 7;
341813b8:	2307      	movs	r3, #7
341813ba:	607b      	str	r3, [r7, #4]
  sHyperBusCfg.AccessTimeCycle = 7;
341813bc:	2307      	movs	r3, #7
341813be:	60bb      	str	r3, [r7, #8]
  sHyperBusCfg.WriteZeroLatency = HAL_XSPI_LATENCY_ON_WRITE;
341813c0:	2300      	movs	r3, #0
341813c2:	60fb      	str	r3, [r7, #12]
  sHyperBusCfg.LatencyMode = HAL_XSPI_FIXED_LATENCY;
341813c4:	2301      	movs	r3, #1
341813c6:	613b      	str	r3, [r7, #16]
  if (HAL_XSPI_HyperbusCfg(&hxspi1, &sHyperBusCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341813c8:	1d3b      	adds	r3, r7, #4
341813ca:	f241 3288 	movw	r2, #5000	@ 0x1388
341813ce:	4619      	mov	r1, r3
341813d0:	4805      	ldr	r0, [pc, #20]	@ (341813e8 <MX_XSPI1_Init+0xe8>)
341813d2:	f005 fc65 	bl	34186ca0 <HAL_XSPI_HyperbusCfg>
341813d6:	4603      	mov	r3, r0
341813d8:	2b00      	cmp	r3, #0
341813da:	d001      	beq.n	341813e0 <MX_XSPI1_Init+0xe0>
  {
    Error_Handler();
341813dc:	f7ff fb8a 	bl	34180af4 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI1_Init 2 */

  /* USER CODE END XSPI1_Init 2 */

}
341813e0:	bf00      	nop
341813e2:	3720      	adds	r7, #32
341813e4:	46bd      	mov	sp, r7
341813e6:	bd80      	pop	{r7, pc}
341813e8:	341c0030 	.word	0x341c0030
341813ec:	58025000 	.word	0x58025000

341813f0 <MX_XSPI2_Init>:
/* XSPI2 init function */
void MX_XSPI2_Init(void)
{
341813f0:	b580      	push	{r7, lr}
341813f2:	b084      	sub	sp, #16
341813f4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI2_Init 0 */

  /* USER CODE END XSPI2_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
341813f6:	1d3b      	adds	r3, r7, #4
341813f8:	2200      	movs	r2, #0
341813fa:	601a      	str	r2, [r3, #0]
341813fc:	605a      	str	r2, [r3, #4]
341813fe:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN XSPI2_Init 1 */

  /* USER CODE END XSPI2_Init 1 */
  hxspi2.Instance = XSPI2;
34181400:	4b26      	ldr	r3, [pc, #152]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181402:	4a27      	ldr	r2, [pc, #156]	@ (341814a0 <MX_XSPI2_Init+0xb0>)
34181404:	601a      	str	r2, [r3, #0]
  hxspi2.Init.FifoThresholdByte = 4;
34181406:	4b25      	ldr	r3, [pc, #148]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181408:	2204      	movs	r2, #4
3418140a:	605a      	str	r2, [r3, #4]
  hxspi2.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
3418140c:	4b23      	ldr	r3, [pc, #140]	@ (3418149c <MX_XSPI2_Init+0xac>)
3418140e:	2200      	movs	r2, #0
34181410:	609a      	str	r2, [r3, #8]
  hxspi2.Init.MemoryType = HAL_XSPI_MEMTYPE_MICRON;
34181412:	4b22      	ldr	r3, [pc, #136]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181414:	2200      	movs	r2, #0
34181416:	60da      	str	r2, [r3, #12]
  hxspi2.Init.MemorySize = HAL_XSPI_SIZE_256MB;
34181418:	4b20      	ldr	r3, [pc, #128]	@ (3418149c <MX_XSPI2_Init+0xac>)
3418141a:	2218      	movs	r2, #24
3418141c:	611a      	str	r2, [r3, #16]
  hxspi2.Init.ChipSelectHighTimeCycle = 1;
3418141e:	4b1f      	ldr	r3, [pc, #124]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181420:	2201      	movs	r2, #1
34181422:	615a      	str	r2, [r3, #20]
  hxspi2.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
34181424:	4b1d      	ldr	r3, [pc, #116]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181426:	2200      	movs	r2, #0
34181428:	619a      	str	r2, [r3, #24]
  hxspi2.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
3418142a:	4b1c      	ldr	r3, [pc, #112]	@ (3418149c <MX_XSPI2_Init+0xac>)
3418142c:	2200      	movs	r2, #0
3418142e:	61da      	str	r2, [r3, #28]
  hxspi2.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
34181430:	4b1a      	ldr	r3, [pc, #104]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181432:	2200      	movs	r2, #0
34181434:	621a      	str	r2, [r3, #32]
  hxspi2.Init.ClockPrescaler = 0;
34181436:	4b19      	ldr	r3, [pc, #100]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181438:	2200      	movs	r2, #0
3418143a:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi2.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
3418143c:	4b17      	ldr	r3, [pc, #92]	@ (3418149c <MX_XSPI2_Init+0xac>)
3418143e:	2200      	movs	r2, #0
34181440:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi2.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34181442:	4b16      	ldr	r3, [pc, #88]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181444:	2200      	movs	r2, #0
34181446:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi2.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
34181448:	4b14      	ldr	r3, [pc, #80]	@ (3418149c <MX_XSPI2_Init+0xac>)
3418144a:	2200      	movs	r2, #0
3418144c:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi2.Init.MaxTran = 0;
3418144e:	4b13      	ldr	r3, [pc, #76]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181450:	2200      	movs	r2, #0
34181452:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi2.Init.Refresh = 0;
34181454:	4b11      	ldr	r3, [pc, #68]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181456:	2200      	movs	r2, #0
34181458:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi2.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
3418145a:	4b10      	ldr	r3, [pc, #64]	@ (3418149c <MX_XSPI2_Init+0xac>)
3418145c:	2200      	movs	r2, #0
3418145e:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi2) != HAL_OK)
34181460:	480e      	ldr	r0, [pc, #56]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181462:	f005 fb0d 	bl	34186a80 <HAL_XSPI_Init>
34181466:	4603      	mov	r3, r0
34181468:	2b00      	cmp	r3, #0
3418146a:	d001      	beq.n	34181470 <MX_XSPI2_Init+0x80>
  {
    Error_Handler();
3418146c:	f7ff fb42 	bl	34180af4 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34181470:	2310      	movs	r3, #16
34181472:	607b      	str	r3, [r7, #4]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_2;
34181474:	2301      	movs	r3, #1
34181476:	60bb      	str	r3, [r7, #8]
  sXspiManagerCfg.Req2AckTime = 1;
34181478:	2301      	movs	r3, #1
3418147a:	60fb      	str	r3, [r7, #12]
  if (HAL_XSPIM_Config(&hxspi2, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3418147c:	1d3b      	adds	r3, r7, #4
3418147e:	f241 3288 	movw	r2, #5000	@ 0x1388
34181482:	4619      	mov	r1, r3
34181484:	4805      	ldr	r0, [pc, #20]	@ (3418149c <MX_XSPI2_Init+0xac>)
34181486:	f005 fc5d 	bl	34186d44 <HAL_XSPIM_Config>
3418148a:	4603      	mov	r3, r0
3418148c:	2b00      	cmp	r3, #0
3418148e:	d001      	beq.n	34181494 <MX_XSPI2_Init+0xa4>
  {
    Error_Handler();
34181490:	f7ff fb30 	bl	34180af4 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI2_Init 2 */

  /* USER CODE END XSPI2_Init 2 */

}
34181494:	bf00      	nop
34181496:	3710      	adds	r7, #16
34181498:	46bd      	mov	sp, r7
3418149a:	bd80      	pop	{r7, pc}
3418149c:	341c0094 	.word	0x341c0094
341814a0:	5802a000 	.word	0x5802a000

341814a4 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
341814a4:	480f      	ldr	r0, [pc, #60]	@ (341814e4 <LoopForever+0x4>)
  msr   MSPLIM, r0
341814a6:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
341814aa:	480f      	ldr	r0, [pc, #60]	@ (341814e8 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
341814ac:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
341814ae:	f7ff fc83 	bl	34180db8 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
341814b2:	480e      	ldr	r0, [pc, #56]	@ (341814ec <LoopForever+0xc>)
  ldr r1, =_edata
341814b4:	490e      	ldr	r1, [pc, #56]	@ (341814f0 <LoopForever+0x10>)
  ldr r2, =_sidata
341814b6:	4a0f      	ldr	r2, [pc, #60]	@ (341814f4 <LoopForever+0x14>)
  movs r3, #0
341814b8:	2300      	movs	r3, #0
  b LoopCopyDataInit
341814ba:	e002      	b.n	341814c2 <LoopCopyDataInit>

341814bc <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
341814bc:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
341814be:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
341814c0:	3304      	adds	r3, #4

341814c2 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
341814c2:	18c4      	adds	r4, r0, r3
  cmp r4, r1
341814c4:	428c      	cmp	r4, r1
  bcc CopyDataInit
341814c6:	d3f9      	bcc.n	341814bc <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
341814c8:	4a0b      	ldr	r2, [pc, #44]	@ (341814f8 <LoopForever+0x18>)
  ldr r4, =_ebss
341814ca:	4c0c      	ldr	r4, [pc, #48]	@ (341814fc <LoopForever+0x1c>)
  movs r3, #0
341814cc:	2300      	movs	r3, #0
  b LoopFillZerobss
341814ce:	e001      	b.n	341814d4 <LoopFillZerobss>

341814d0 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
341814d0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
341814d2:	3204      	adds	r2, #4

341814d4 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
341814d4:	42a2      	cmp	r2, r4
  bcc FillZerobss
341814d6:	d3fb      	bcc.n	341814d0 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
341814d8:	f006 f858 	bl	3418758c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
341814dc:	f7ff f98e 	bl	341807fc <main>

341814e0 <LoopForever>:

LoopForever:
  b LoopForever
341814e0:	e7fe      	b.n	341814e0 <LoopForever>
341814e2:	0000      	.short	0x0000
  ldr   r0, =_sstack
341814e4:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
341814e8:	34200000 	.word	0x34200000
  ldr r0, =_sdata
341814ec:	341c0000 	.word	0x341c0000
  ldr r1, =_edata
341814f0:	341c000c 	.word	0x341c000c
  ldr r2, =_sidata
341814f4:	341875f4 	.word	0x341875f4
  ldr r2, =_sbss
341814f8:	341c0010 	.word	0x341c0010
  ldr r4, =_ebss
341814fc:	341c0114 	.word	0x341c0114

34181500 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34181500:	e7fe      	b.n	34181500 <ADC1_2_IRQHandler>

34181502 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
34181502:	b580      	push	{r7, lr}
34181504:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34181506:	2003      	movs	r0, #3
34181508:	f000 f94c 	bl	341817a4 <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
3418150c:	f7ff fd3a 	bl	34180f84 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34181510:	200f      	movs	r0, #15
34181512:	f000 f80b 	bl	3418152c <HAL_InitTick>
34181516:	4603      	mov	r3, r0
34181518:	2b00      	cmp	r3, #0
3418151a:	d001      	beq.n	34181520 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
3418151c:	2301      	movs	r3, #1
3418151e:	e002      	b.n	34181526 <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
34181520:	f7ff fb1a 	bl	34180b58 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
34181524:	2300      	movs	r3, #0
}
34181526:	4618      	mov	r0, r3
34181528:	bd80      	pop	{r7, pc}
	...

3418152c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
3418152c:	b580      	push	{r7, lr}
3418152e:	b082      	sub	sp, #8
34181530:	af00      	add	r7, sp, #0
34181532:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
34181534:	4b15      	ldr	r3, [pc, #84]	@ (3418158c <HAL_InitTick+0x60>)
34181536:	781b      	ldrb	r3, [r3, #0]
34181538:	2b00      	cmp	r3, #0
3418153a:	d101      	bne.n	34181540 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
3418153c:	2301      	movs	r3, #1
3418153e:	e021      	b.n	34181584 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34181540:	4b13      	ldr	r3, [pc, #76]	@ (34181590 <HAL_InitTick+0x64>)
34181542:	681a      	ldr	r2, [r3, #0]
34181544:	4b11      	ldr	r3, [pc, #68]	@ (3418158c <HAL_InitTick+0x60>)
34181546:	781b      	ldrb	r3, [r3, #0]
34181548:	4619      	mov	r1, r3
3418154a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
3418154e:	fbb3 f3f1 	udiv	r3, r3, r1
34181552:	fbb2 f3f3 	udiv	r3, r2, r3
34181556:	4618      	mov	r0, r3
34181558:	f000 f94c 	bl	341817f4 <HAL_SYSTICK_Config>
3418155c:	4603      	mov	r3, r0
3418155e:	2b00      	cmp	r3, #0
34181560:	d001      	beq.n	34181566 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
34181562:	2301      	movs	r3, #1
34181564:	e00e      	b.n	34181584 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34181566:	687b      	ldr	r3, [r7, #4]
34181568:	2b0f      	cmp	r3, #15
3418156a:	d80a      	bhi.n	34181582 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
3418156c:	2200      	movs	r2, #0
3418156e:	6879      	ldr	r1, [r7, #4]
34181570:	f04f 30ff 	mov.w	r0, #4294967295
34181574:	f000 f921 	bl	341817ba <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
34181578:	4a06      	ldr	r2, [pc, #24]	@ (34181594 <HAL_InitTick+0x68>)
3418157a:	687b      	ldr	r3, [r7, #4]
3418157c:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
3418157e:	2300      	movs	r3, #0
34181580:	e000      	b.n	34181584 <HAL_InitTick+0x58>
    return HAL_ERROR;
34181582:	2301      	movs	r3, #1
}
34181584:	4618      	mov	r0, r3
34181586:	3708      	adds	r7, #8
34181588:	46bd      	mov	sp, r7
3418158a:	bd80      	pop	{r7, pc}
3418158c:	341c0008 	.word	0x341c0008
34181590:	341c0000 	.word	0x341c0000
34181594:	341c0004 	.word	0x341c0004

34181598 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
34181598:	b480      	push	{r7}
3418159a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
3418159c:	4b06      	ldr	r3, [pc, #24]	@ (341815b8 <HAL_IncTick+0x20>)
3418159e:	781b      	ldrb	r3, [r3, #0]
341815a0:	461a      	mov	r2, r3
341815a2:	4b06      	ldr	r3, [pc, #24]	@ (341815bc <HAL_IncTick+0x24>)
341815a4:	681b      	ldr	r3, [r3, #0]
341815a6:	4413      	add	r3, r2
341815a8:	4a04      	ldr	r2, [pc, #16]	@ (341815bc <HAL_IncTick+0x24>)
341815aa:	6013      	str	r3, [r2, #0]
}
341815ac:	bf00      	nop
341815ae:	46bd      	mov	sp, r7
341815b0:	f85d 7b04 	ldr.w	r7, [sp], #4
341815b4:	4770      	bx	lr
341815b6:	bf00      	nop
341815b8:	341c0008 	.word	0x341c0008
341815bc:	341c00f8 	.word	0x341c00f8

341815c0 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
341815c0:	b480      	push	{r7}
341815c2:	af00      	add	r7, sp, #0
  return uwTick;
341815c4:	4b03      	ldr	r3, [pc, #12]	@ (341815d4 <HAL_GetTick+0x14>)
341815c6:	681b      	ldr	r3, [r3, #0]
}
341815c8:	4618      	mov	r0, r3
341815ca:	46bd      	mov	sp, r7
341815cc:	f85d 7b04 	ldr.w	r7, [sp], #4
341815d0:	4770      	bx	lr
341815d2:	bf00      	nop
341815d4:	341c00f8 	.word	0x341c00f8

341815d8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
341815d8:	b580      	push	{r7, lr}
341815da:	b084      	sub	sp, #16
341815dc:	af00      	add	r7, sp, #0
341815de:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
341815e0:	f7ff ffee 	bl	341815c0 <HAL_GetTick>
341815e4:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
341815e6:	687b      	ldr	r3, [r7, #4]
341815e8:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
341815ea:	68fb      	ldr	r3, [r7, #12]
341815ec:	f1b3 3fff 	cmp.w	r3, #4294967295
341815f0:	d005      	beq.n	341815fe <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
341815f2:	4b0a      	ldr	r3, [pc, #40]	@ (3418161c <HAL_Delay+0x44>)
341815f4:	781b      	ldrb	r3, [r3, #0]
341815f6:	461a      	mov	r2, r3
341815f8:	68fb      	ldr	r3, [r7, #12]
341815fa:	4413      	add	r3, r2
341815fc:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
341815fe:	bf00      	nop
34181600:	f7ff ffde 	bl	341815c0 <HAL_GetTick>
34181604:	4602      	mov	r2, r0
34181606:	68bb      	ldr	r3, [r7, #8]
34181608:	1ad3      	subs	r3, r2, r3
3418160a:	68fa      	ldr	r2, [r7, #12]
3418160c:	429a      	cmp	r2, r3
3418160e:	d8f7      	bhi.n	34181600 <HAL_Delay+0x28>
  {
  }
}
34181610:	bf00      	nop
34181612:	bf00      	nop
34181614:	3710      	adds	r7, #16
34181616:	46bd      	mov	sp, r7
34181618:	bd80      	pop	{r7, pc}
3418161a:	bf00      	nop
3418161c:	341c0008 	.word	0x341c0008

34181620 <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
34181620:	b480      	push	{r7}
34181622:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
34181624:	4b05      	ldr	r3, [pc, #20]	@ (3418163c <HAL_SuspendTick+0x1c>)
34181626:	681b      	ldr	r3, [r3, #0]
34181628:	4a04      	ldr	r2, [pc, #16]	@ (3418163c <HAL_SuspendTick+0x1c>)
3418162a:	f023 0302 	bic.w	r3, r3, #2
3418162e:	6013      	str	r3, [r2, #0]
}
34181630:	bf00      	nop
34181632:	46bd      	mov	sp, r7
34181634:	f85d 7b04 	ldr.w	r7, [sp], #4
34181638:	4770      	bx	lr
3418163a:	bf00      	nop
3418163c:	e000e010 	.word	0xe000e010

34181640 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34181640:	b480      	push	{r7}
34181642:	b085      	sub	sp, #20
34181644:	af00      	add	r7, sp, #0
34181646:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34181648:	687b      	ldr	r3, [r7, #4]
3418164a:	f003 0307 	and.w	r3, r3, #7
3418164e:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34181650:	4b0c      	ldr	r3, [pc, #48]	@ (34181684 <__NVIC_SetPriorityGrouping+0x44>)
34181652:	68db      	ldr	r3, [r3, #12]
34181654:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34181656:	68ba      	ldr	r2, [r7, #8]
34181658:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
3418165c:	4013      	ands	r3, r2
3418165e:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34181660:	68fb      	ldr	r3, [r7, #12]
34181662:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34181664:	68bb      	ldr	r3, [r7, #8]
34181666:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34181668:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
3418166c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34181670:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
34181672:	4a04      	ldr	r2, [pc, #16]	@ (34181684 <__NVIC_SetPriorityGrouping+0x44>)
34181674:	68bb      	ldr	r3, [r7, #8]
34181676:	60d3      	str	r3, [r2, #12]
}
34181678:	bf00      	nop
3418167a:	3714      	adds	r7, #20
3418167c:	46bd      	mov	sp, r7
3418167e:	f85d 7b04 	ldr.w	r7, [sp], #4
34181682:	4770      	bx	lr
34181684:	e000ed00 	.word	0xe000ed00

34181688 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
34181688:	b480      	push	{r7}
3418168a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
3418168c:	4b04      	ldr	r3, [pc, #16]	@ (341816a0 <__NVIC_GetPriorityGrouping+0x18>)
3418168e:	68db      	ldr	r3, [r3, #12]
34181690:	0a1b      	lsrs	r3, r3, #8
34181692:	f003 0307 	and.w	r3, r3, #7
}
34181696:	4618      	mov	r0, r3
34181698:	46bd      	mov	sp, r7
3418169a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418169e:	4770      	bx	lr
341816a0:	e000ed00 	.word	0xe000ed00

341816a4 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
341816a4:	b480      	push	{r7}
341816a6:	b083      	sub	sp, #12
341816a8:	af00      	add	r7, sp, #0
341816aa:	4603      	mov	r3, r0
341816ac:	6039      	str	r1, [r7, #0]
341816ae:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
341816b0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341816b4:	2b00      	cmp	r3, #0
341816b6:	db0a      	blt.n	341816ce <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
341816b8:	683b      	ldr	r3, [r7, #0]
341816ba:	b2da      	uxtb	r2, r3
341816bc:	490c      	ldr	r1, [pc, #48]	@ (341816f0 <__NVIC_SetPriority+0x4c>)
341816be:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341816c2:	0112      	lsls	r2, r2, #4
341816c4:	b2d2      	uxtb	r2, r2
341816c6:	440b      	add	r3, r1
341816c8:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
341816cc:	e00a      	b.n	341816e4 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
341816ce:	683b      	ldr	r3, [r7, #0]
341816d0:	b2da      	uxtb	r2, r3
341816d2:	4908      	ldr	r1, [pc, #32]	@ (341816f4 <__NVIC_SetPriority+0x50>)
341816d4:	88fb      	ldrh	r3, [r7, #6]
341816d6:	f003 030f 	and.w	r3, r3, #15
341816da:	3b04      	subs	r3, #4
341816dc:	0112      	lsls	r2, r2, #4
341816de:	b2d2      	uxtb	r2, r2
341816e0:	440b      	add	r3, r1
341816e2:	761a      	strb	r2, [r3, #24]
}
341816e4:	bf00      	nop
341816e6:	370c      	adds	r7, #12
341816e8:	46bd      	mov	sp, r7
341816ea:	f85d 7b04 	ldr.w	r7, [sp], #4
341816ee:	4770      	bx	lr
341816f0:	e000e100 	.word	0xe000e100
341816f4:	e000ed00 	.word	0xe000ed00

341816f8 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
341816f8:	b480      	push	{r7}
341816fa:	b089      	sub	sp, #36	@ 0x24
341816fc:	af00      	add	r7, sp, #0
341816fe:	60f8      	str	r0, [r7, #12]
34181700:	60b9      	str	r1, [r7, #8]
34181702:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
34181704:	68fb      	ldr	r3, [r7, #12]
34181706:	f003 0307 	and.w	r3, r3, #7
3418170a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
3418170c:	69fb      	ldr	r3, [r7, #28]
3418170e:	f1c3 0307 	rsb	r3, r3, #7
34181712:	2b04      	cmp	r3, #4
34181714:	bf28      	it	cs
34181716:	2304      	movcs	r3, #4
34181718:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
3418171a:	69fb      	ldr	r3, [r7, #28]
3418171c:	3304      	adds	r3, #4
3418171e:	2b06      	cmp	r3, #6
34181720:	d902      	bls.n	34181728 <NVIC_EncodePriority+0x30>
34181722:	69fb      	ldr	r3, [r7, #28]
34181724:	3b03      	subs	r3, #3
34181726:	e000      	b.n	3418172a <NVIC_EncodePriority+0x32>
34181728:	2300      	movs	r3, #0
3418172a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
3418172c:	f04f 32ff 	mov.w	r2, #4294967295
34181730:	69bb      	ldr	r3, [r7, #24]
34181732:	fa02 f303 	lsl.w	r3, r2, r3
34181736:	43da      	mvns	r2, r3
34181738:	68bb      	ldr	r3, [r7, #8]
3418173a:	401a      	ands	r2, r3
3418173c:	697b      	ldr	r3, [r7, #20]
3418173e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34181740:	f04f 31ff 	mov.w	r1, #4294967295
34181744:	697b      	ldr	r3, [r7, #20]
34181746:	fa01 f303 	lsl.w	r3, r1, r3
3418174a:	43d9      	mvns	r1, r3
3418174c:	687b      	ldr	r3, [r7, #4]
3418174e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34181750:	4313      	orrs	r3, r2
         );
}
34181752:	4618      	mov	r0, r3
34181754:	3724      	adds	r7, #36	@ 0x24
34181756:	46bd      	mov	sp, r7
34181758:	f85d 7b04 	ldr.w	r7, [sp], #4
3418175c:	4770      	bx	lr
	...

34181760 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
34181760:	b580      	push	{r7, lr}
34181762:	b082      	sub	sp, #8
34181764:	af00      	add	r7, sp, #0
34181766:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
34181768:	687b      	ldr	r3, [r7, #4]
3418176a:	3b01      	subs	r3, #1
3418176c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34181770:	d301      	bcc.n	34181776 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
34181772:	2301      	movs	r3, #1
34181774:	e00f      	b.n	34181796 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34181776:	4a0a      	ldr	r2, [pc, #40]	@ (341817a0 <SysTick_Config+0x40>)
34181778:	687b      	ldr	r3, [r7, #4]
3418177a:	3b01      	subs	r3, #1
3418177c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
3418177e:	210f      	movs	r1, #15
34181780:	f04f 30ff 	mov.w	r0, #4294967295
34181784:	f7ff ff8e 	bl	341816a4 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34181788:	4b05      	ldr	r3, [pc, #20]	@ (341817a0 <SysTick_Config+0x40>)
3418178a:	2200      	movs	r2, #0
3418178c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
3418178e:	4b04      	ldr	r3, [pc, #16]	@ (341817a0 <SysTick_Config+0x40>)
34181790:	2207      	movs	r2, #7
34181792:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34181794:	2300      	movs	r3, #0
}
34181796:	4618      	mov	r0, r3
34181798:	3708      	adds	r7, #8
3418179a:	46bd      	mov	sp, r7
3418179c:	bd80      	pop	{r7, pc}
3418179e:	bf00      	nop
341817a0:	e000e010 	.word	0xe000e010

341817a4 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
341817a4:	b580      	push	{r7, lr}
341817a6:	b082      	sub	sp, #8
341817a8:	af00      	add	r7, sp, #0
341817aa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
341817ac:	6878      	ldr	r0, [r7, #4]
341817ae:	f7ff ff47 	bl	34181640 <__NVIC_SetPriorityGrouping>
}
341817b2:	bf00      	nop
341817b4:	3708      	adds	r7, #8
341817b6:	46bd      	mov	sp, r7
341817b8:	bd80      	pop	{r7, pc}

341817ba <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
341817ba:	b580      	push	{r7, lr}
341817bc:	b086      	sub	sp, #24
341817be:	af00      	add	r7, sp, #0
341817c0:	4603      	mov	r3, r0
341817c2:	60b9      	str	r1, [r7, #8]
341817c4:	607a      	str	r2, [r7, #4]
341817c6:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
341817c8:	f7ff ff5e 	bl	34181688 <__NVIC_GetPriorityGrouping>
341817cc:	4603      	mov	r3, r0
341817ce:	f003 0307 	and.w	r3, r3, #7
341817d2:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
341817d4:	687a      	ldr	r2, [r7, #4]
341817d6:	68b9      	ldr	r1, [r7, #8]
341817d8:	6978      	ldr	r0, [r7, #20]
341817da:	f7ff ff8d 	bl	341816f8 <NVIC_EncodePriority>
341817de:	4602      	mov	r2, r0
341817e0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
341817e4:	4611      	mov	r1, r2
341817e6:	4618      	mov	r0, r3
341817e8:	f7ff ff5c 	bl	341816a4 <__NVIC_SetPriority>
}
341817ec:	bf00      	nop
341817ee:	3718      	adds	r7, #24
341817f0:	46bd      	mov	sp, r7
341817f2:	bd80      	pop	{r7, pc}

341817f4 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
341817f4:	b580      	push	{r7, lr}
341817f6:	b082      	sub	sp, #8
341817f8:	af00      	add	r7, sp, #0
341817fa:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
341817fc:	6878      	ldr	r0, [r7, #4]
341817fe:	f7ff ffaf 	bl	34181760 <SysTick_Config>
34181802:	4603      	mov	r3, r0
}
34181804:	4618      	mov	r0, r3
34181806:	3708      	adds	r7, #8
34181808:	46bd      	mov	sp, r7
3418180a:	bd80      	pop	{r7, pc}

3418180c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
3418180c:	b480      	push	{r7}
3418180e:	b087      	sub	sp, #28
34181810:	af00      	add	r7, sp, #0
34181812:	6078      	str	r0, [r7, #4]
34181814:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
34181816:	2300      	movs	r3, #0
34181818:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
3418181a:	e180      	b.n	34181b1e <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
3418181c:	683b      	ldr	r3, [r7, #0]
3418181e:	681a      	ldr	r2, [r3, #0]
34181820:	2101      	movs	r1, #1
34181822:	697b      	ldr	r3, [r7, #20]
34181824:	fa01 f303 	lsl.w	r3, r1, r3
34181828:	4013      	ands	r3, r2
3418182a:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
3418182c:	68fb      	ldr	r3, [r7, #12]
3418182e:	2b00      	cmp	r3, #0
34181830:	f000 8172 	beq.w	34181b18 <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34181834:	683b      	ldr	r3, [r7, #0]
34181836:	685b      	ldr	r3, [r3, #4]
34181838:	f003 0303 	and.w	r3, r3, #3
3418183c:	2b01      	cmp	r3, #1
3418183e:	d005      	beq.n	3418184c <HAL_GPIO_Init+0x40>
34181840:	683b      	ldr	r3, [r7, #0]
34181842:	685b      	ldr	r3, [r3, #4]
34181844:	f003 0303 	and.w	r3, r3, #3
34181848:	2b02      	cmp	r3, #2
3418184a:	d130      	bne.n	341818ae <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
3418184c:	687b      	ldr	r3, [r7, #4]
3418184e:	689b      	ldr	r3, [r3, #8]
34181850:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34181852:	697b      	ldr	r3, [r7, #20]
34181854:	005b      	lsls	r3, r3, #1
34181856:	2203      	movs	r2, #3
34181858:	fa02 f303 	lsl.w	r3, r2, r3
3418185c:	43db      	mvns	r3, r3
3418185e:	693a      	ldr	r2, [r7, #16]
34181860:	4013      	ands	r3, r2
34181862:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34181864:	683b      	ldr	r3, [r7, #0]
34181866:	68da      	ldr	r2, [r3, #12]
34181868:	697b      	ldr	r3, [r7, #20]
3418186a:	005b      	lsls	r3, r3, #1
3418186c:	fa02 f303 	lsl.w	r3, r2, r3
34181870:	693a      	ldr	r2, [r7, #16]
34181872:	4313      	orrs	r3, r2
34181874:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
34181876:	687b      	ldr	r3, [r7, #4]
34181878:	693a      	ldr	r2, [r7, #16]
3418187a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
3418187c:	687b      	ldr	r3, [r7, #4]
3418187e:	685b      	ldr	r3, [r3, #4]
34181880:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34181882:	2201      	movs	r2, #1
34181884:	697b      	ldr	r3, [r7, #20]
34181886:	fa02 f303 	lsl.w	r3, r2, r3
3418188a:	43db      	mvns	r3, r3
3418188c:	693a      	ldr	r2, [r7, #16]
3418188e:	4013      	ands	r3, r2
34181890:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34181892:	683b      	ldr	r3, [r7, #0]
34181894:	685b      	ldr	r3, [r3, #4]
34181896:	091b      	lsrs	r3, r3, #4
34181898:	f003 0201 	and.w	r2, r3, #1
3418189c:	697b      	ldr	r3, [r7, #20]
3418189e:	fa02 f303 	lsl.w	r3, r2, r3
341818a2:	693a      	ldr	r2, [r7, #16]
341818a4:	4313      	orrs	r3, r2
341818a6:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
341818a8:	687b      	ldr	r3, [r7, #4]
341818aa:	693a      	ldr	r2, [r7, #16]
341818ac:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
341818ae:	683b      	ldr	r3, [r7, #0]
341818b0:	685b      	ldr	r3, [r3, #4]
341818b2:	f003 0303 	and.w	r3, r3, #3
341818b6:	2b03      	cmp	r3, #3
341818b8:	d109      	bne.n	341818ce <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
341818ba:	683b      	ldr	r3, [r7, #0]
341818bc:	685b      	ldr	r3, [r3, #4]
341818be:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
341818c2:	2b03      	cmp	r3, #3
341818c4:	d11b      	bne.n	341818fe <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
341818c6:	683b      	ldr	r3, [r7, #0]
341818c8:	689b      	ldr	r3, [r3, #8]
341818ca:	2b01      	cmp	r3, #1
341818cc:	d017      	beq.n	341818fe <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
341818ce:	687b      	ldr	r3, [r7, #4]
341818d0:	68db      	ldr	r3, [r3, #12]
341818d2:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
341818d4:	697b      	ldr	r3, [r7, #20]
341818d6:	005b      	lsls	r3, r3, #1
341818d8:	2203      	movs	r2, #3
341818da:	fa02 f303 	lsl.w	r3, r2, r3
341818de:	43db      	mvns	r3, r3
341818e0:	693a      	ldr	r2, [r7, #16]
341818e2:	4013      	ands	r3, r2
341818e4:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
341818e6:	683b      	ldr	r3, [r7, #0]
341818e8:	689a      	ldr	r2, [r3, #8]
341818ea:	697b      	ldr	r3, [r7, #20]
341818ec:	005b      	lsls	r3, r3, #1
341818ee:	fa02 f303 	lsl.w	r3, r2, r3
341818f2:	693a      	ldr	r2, [r7, #16]
341818f4:	4313      	orrs	r3, r2
341818f6:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
341818f8:	687b      	ldr	r3, [r7, #4]
341818fa:	693a      	ldr	r2, [r7, #16]
341818fc:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
341818fe:	683b      	ldr	r3, [r7, #0]
34181900:	685b      	ldr	r3, [r3, #4]
34181902:	f003 0303 	and.w	r3, r3, #3
34181906:	2b02      	cmp	r3, #2
34181908:	d123      	bne.n	34181952 <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
3418190a:	697b      	ldr	r3, [r7, #20]
3418190c:	08da      	lsrs	r2, r3, #3
3418190e:	687b      	ldr	r3, [r7, #4]
34181910:	3208      	adds	r2, #8
34181912:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34181916:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34181918:	697b      	ldr	r3, [r7, #20]
3418191a:	f003 0307 	and.w	r3, r3, #7
3418191e:	009b      	lsls	r3, r3, #2
34181920:	220f      	movs	r2, #15
34181922:	fa02 f303 	lsl.w	r3, r2, r3
34181926:	43db      	mvns	r3, r3
34181928:	693a      	ldr	r2, [r7, #16]
3418192a:	4013      	ands	r3, r2
3418192c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
3418192e:	683b      	ldr	r3, [r7, #0]
34181930:	691a      	ldr	r2, [r3, #16]
34181932:	697b      	ldr	r3, [r7, #20]
34181934:	f003 0307 	and.w	r3, r3, #7
34181938:	009b      	lsls	r3, r3, #2
3418193a:	fa02 f303 	lsl.w	r3, r2, r3
3418193e:	693a      	ldr	r2, [r7, #16]
34181940:	4313      	orrs	r3, r2
34181942:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
34181944:	697b      	ldr	r3, [r7, #20]
34181946:	08da      	lsrs	r2, r3, #3
34181948:	687b      	ldr	r3, [r7, #4]
3418194a:	3208      	adds	r2, #8
3418194c:	6939      	ldr	r1, [r7, #16]
3418194e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
34181952:	687b      	ldr	r3, [r7, #4]
34181954:	681b      	ldr	r3, [r3, #0]
34181956:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34181958:	697b      	ldr	r3, [r7, #20]
3418195a:	005b      	lsls	r3, r3, #1
3418195c:	2203      	movs	r2, #3
3418195e:	fa02 f303 	lsl.w	r3, r2, r3
34181962:	43db      	mvns	r3, r3
34181964:	693a      	ldr	r2, [r7, #16]
34181966:	4013      	ands	r3, r2
34181968:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
3418196a:	683b      	ldr	r3, [r7, #0]
3418196c:	685b      	ldr	r3, [r3, #4]
3418196e:	f003 0203 	and.w	r2, r3, #3
34181972:	697b      	ldr	r3, [r7, #20]
34181974:	005b      	lsls	r3, r3, #1
34181976:	fa02 f303 	lsl.w	r3, r2, r3
3418197a:	693a      	ldr	r2, [r7, #16]
3418197c:	4313      	orrs	r3, r2
3418197e:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
34181980:	687b      	ldr	r3, [r7, #4]
34181982:	693a      	ldr	r2, [r7, #16]
34181984:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34181986:	683b      	ldr	r3, [r7, #0]
34181988:	685b      	ldr	r3, [r3, #4]
3418198a:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
3418198e:	2b00      	cmp	r3, #0
34181990:	f000 80c2 	beq.w	34181b18 <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
34181994:	4a69      	ldr	r2, [pc, #420]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181996:	697b      	ldr	r3, [r7, #20]
34181998:	089b      	lsrs	r3, r3, #2
3418199a:	3318      	adds	r3, #24
3418199c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341819a0:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
341819a2:	697b      	ldr	r3, [r7, #20]
341819a4:	f003 0303 	and.w	r3, r3, #3
341819a8:	00db      	lsls	r3, r3, #3
341819aa:	220f      	movs	r2, #15
341819ac:	fa02 f303 	lsl.w	r3, r2, r3
341819b0:	43db      	mvns	r3, r3
341819b2:	693a      	ldr	r2, [r7, #16]
341819b4:	4013      	ands	r3, r2
341819b6:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
341819b8:	687b      	ldr	r3, [r7, #4]
341819ba:	4a61      	ldr	r2, [pc, #388]	@ (34181b40 <HAL_GPIO_Init+0x334>)
341819bc:	4293      	cmp	r3, r2
341819be:	d043      	beq.n	34181a48 <HAL_GPIO_Init+0x23c>
341819c0:	687b      	ldr	r3, [r7, #4]
341819c2:	4a60      	ldr	r2, [pc, #384]	@ (34181b44 <HAL_GPIO_Init+0x338>)
341819c4:	4293      	cmp	r3, r2
341819c6:	d03d      	beq.n	34181a44 <HAL_GPIO_Init+0x238>
341819c8:	687b      	ldr	r3, [r7, #4]
341819ca:	4a5f      	ldr	r2, [pc, #380]	@ (34181b48 <HAL_GPIO_Init+0x33c>)
341819cc:	4293      	cmp	r3, r2
341819ce:	d037      	beq.n	34181a40 <HAL_GPIO_Init+0x234>
341819d0:	687b      	ldr	r3, [r7, #4]
341819d2:	4a5e      	ldr	r2, [pc, #376]	@ (34181b4c <HAL_GPIO_Init+0x340>)
341819d4:	4293      	cmp	r3, r2
341819d6:	d031      	beq.n	34181a3c <HAL_GPIO_Init+0x230>
341819d8:	687b      	ldr	r3, [r7, #4]
341819da:	4a5d      	ldr	r2, [pc, #372]	@ (34181b50 <HAL_GPIO_Init+0x344>)
341819dc:	4293      	cmp	r3, r2
341819de:	d02b      	beq.n	34181a38 <HAL_GPIO_Init+0x22c>
341819e0:	687b      	ldr	r3, [r7, #4]
341819e2:	4a5c      	ldr	r2, [pc, #368]	@ (34181b54 <HAL_GPIO_Init+0x348>)
341819e4:	4293      	cmp	r3, r2
341819e6:	d025      	beq.n	34181a34 <HAL_GPIO_Init+0x228>
341819e8:	687b      	ldr	r3, [r7, #4]
341819ea:	4a5b      	ldr	r2, [pc, #364]	@ (34181b58 <HAL_GPIO_Init+0x34c>)
341819ec:	4293      	cmp	r3, r2
341819ee:	d01f      	beq.n	34181a30 <HAL_GPIO_Init+0x224>
341819f0:	687b      	ldr	r3, [r7, #4]
341819f2:	4a5a      	ldr	r2, [pc, #360]	@ (34181b5c <HAL_GPIO_Init+0x350>)
341819f4:	4293      	cmp	r3, r2
341819f6:	d019      	beq.n	34181a2c <HAL_GPIO_Init+0x220>
341819f8:	687b      	ldr	r3, [r7, #4]
341819fa:	4a59      	ldr	r2, [pc, #356]	@ (34181b60 <HAL_GPIO_Init+0x354>)
341819fc:	4293      	cmp	r3, r2
341819fe:	d013      	beq.n	34181a28 <HAL_GPIO_Init+0x21c>
34181a00:	687b      	ldr	r3, [r7, #4]
34181a02:	4a58      	ldr	r2, [pc, #352]	@ (34181b64 <HAL_GPIO_Init+0x358>)
34181a04:	4293      	cmp	r3, r2
34181a06:	d00d      	beq.n	34181a24 <HAL_GPIO_Init+0x218>
34181a08:	687b      	ldr	r3, [r7, #4]
34181a0a:	4a57      	ldr	r2, [pc, #348]	@ (34181b68 <HAL_GPIO_Init+0x35c>)
34181a0c:	4293      	cmp	r3, r2
34181a0e:	d007      	beq.n	34181a20 <HAL_GPIO_Init+0x214>
34181a10:	687b      	ldr	r3, [r7, #4]
34181a12:	4a56      	ldr	r2, [pc, #344]	@ (34181b6c <HAL_GPIO_Init+0x360>)
34181a14:	4293      	cmp	r3, r2
34181a16:	d101      	bne.n	34181a1c <HAL_GPIO_Init+0x210>
34181a18:	230b      	movs	r3, #11
34181a1a:	e016      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a1c:	2310      	movs	r3, #16
34181a1e:	e014      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a20:	230a      	movs	r3, #10
34181a22:	e012      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a24:	2309      	movs	r3, #9
34181a26:	e010      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a28:	2308      	movs	r3, #8
34181a2a:	e00e      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a2c:	2307      	movs	r3, #7
34181a2e:	e00c      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a30:	2306      	movs	r3, #6
34181a32:	e00a      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a34:	2305      	movs	r3, #5
34181a36:	e008      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a38:	2304      	movs	r3, #4
34181a3a:	e006      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a3c:	2303      	movs	r3, #3
34181a3e:	e004      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a40:	2302      	movs	r3, #2
34181a42:	e002      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a44:	2301      	movs	r3, #1
34181a46:	e000      	b.n	34181a4a <HAL_GPIO_Init+0x23e>
34181a48:	2300      	movs	r3, #0
34181a4a:	697a      	ldr	r2, [r7, #20]
34181a4c:	f002 0203 	and.w	r2, r2, #3
34181a50:	00d2      	lsls	r2, r2, #3
34181a52:	4093      	lsls	r3, r2
34181a54:	693a      	ldr	r2, [r7, #16]
34181a56:	4313      	orrs	r3, r2
34181a58:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
34181a5a:	4938      	ldr	r1, [pc, #224]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181a5c:	697b      	ldr	r3, [r7, #20]
34181a5e:	089b      	lsrs	r3, r3, #2
34181a60:	3318      	adds	r3, #24
34181a62:	693a      	ldr	r2, [r7, #16]
34181a64:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
34181a68:	4b34      	ldr	r3, [pc, #208]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181a6a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34181a6e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34181a70:	68fb      	ldr	r3, [r7, #12]
34181a72:	43db      	mvns	r3, r3
34181a74:	693a      	ldr	r2, [r7, #16]
34181a76:	4013      	ands	r3, r2
34181a78:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
34181a7a:	683b      	ldr	r3, [r7, #0]
34181a7c:	685b      	ldr	r3, [r3, #4]
34181a7e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34181a82:	2b00      	cmp	r3, #0
34181a84:	d003      	beq.n	34181a8e <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
34181a86:	693a      	ldr	r2, [r7, #16]
34181a88:	68fb      	ldr	r3, [r7, #12]
34181a8a:	4313      	orrs	r3, r2
34181a8c:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
34181a8e:	4a2b      	ldr	r2, [pc, #172]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181a90:	693b      	ldr	r3, [r7, #16]
34181a92:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
34181a96:	4b29      	ldr	r3, [pc, #164]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181a98:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34181a9c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34181a9e:	68fb      	ldr	r3, [r7, #12]
34181aa0:	43db      	mvns	r3, r3
34181aa2:	693a      	ldr	r2, [r7, #16]
34181aa4:	4013      	ands	r3, r2
34181aa6:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
34181aa8:	683b      	ldr	r3, [r7, #0]
34181aaa:	685b      	ldr	r3, [r3, #4]
34181aac:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34181ab0:	2b00      	cmp	r3, #0
34181ab2:	d003      	beq.n	34181abc <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
34181ab4:	693a      	ldr	r2, [r7, #16]
34181ab6:	68fb      	ldr	r3, [r7, #12]
34181ab8:	4313      	orrs	r3, r2
34181aba:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
34181abc:	4a1f      	ldr	r2, [pc, #124]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181abe:	693b      	ldr	r3, [r7, #16]
34181ac0:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
34181ac4:	4b1d      	ldr	r3, [pc, #116]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181ac6:	681b      	ldr	r3, [r3, #0]
34181ac8:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34181aca:	68fb      	ldr	r3, [r7, #12]
34181acc:	43db      	mvns	r3, r3
34181ace:	693a      	ldr	r2, [r7, #16]
34181ad0:	4013      	ands	r3, r2
34181ad2:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
34181ad4:	683b      	ldr	r3, [r7, #0]
34181ad6:	685b      	ldr	r3, [r3, #4]
34181ad8:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34181adc:	2b00      	cmp	r3, #0
34181ade:	d003      	beq.n	34181ae8 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
34181ae0:	693a      	ldr	r2, [r7, #16]
34181ae2:	68fb      	ldr	r3, [r7, #12]
34181ae4:	4313      	orrs	r3, r2
34181ae6:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
34181ae8:	4a14      	ldr	r2, [pc, #80]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181aea:	693b      	ldr	r3, [r7, #16]
34181aec:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
34181aee:	4b13      	ldr	r3, [pc, #76]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181af0:	685b      	ldr	r3, [r3, #4]
34181af2:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34181af4:	68fb      	ldr	r3, [r7, #12]
34181af6:	43db      	mvns	r3, r3
34181af8:	693a      	ldr	r2, [r7, #16]
34181afa:	4013      	ands	r3, r2
34181afc:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
34181afe:	683b      	ldr	r3, [r7, #0]
34181b00:	685b      	ldr	r3, [r3, #4]
34181b02:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34181b06:	2b00      	cmp	r3, #0
34181b08:	d003      	beq.n	34181b12 <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
34181b0a:	693a      	ldr	r2, [r7, #16]
34181b0c:	68fb      	ldr	r3, [r7, #12]
34181b0e:	4313      	orrs	r3, r2
34181b10:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
34181b12:	4a0a      	ldr	r2, [pc, #40]	@ (34181b3c <HAL_GPIO_Init+0x330>)
34181b14:	693b      	ldr	r3, [r7, #16]
34181b16:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
34181b18:	697b      	ldr	r3, [r7, #20]
34181b1a:	3301      	adds	r3, #1
34181b1c:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34181b1e:	683b      	ldr	r3, [r7, #0]
34181b20:	681a      	ldr	r2, [r3, #0]
34181b22:	697b      	ldr	r3, [r7, #20]
34181b24:	fa22 f303 	lsr.w	r3, r2, r3
34181b28:	2b00      	cmp	r3, #0
34181b2a:	f47f ae77 	bne.w	3418181c <HAL_GPIO_Init+0x10>
  }
}
34181b2e:	bf00      	nop
34181b30:	bf00      	nop
34181b32:	371c      	adds	r7, #28
34181b34:	46bd      	mov	sp, r7
34181b36:	f85d 7b04 	ldr.w	r7, [sp], #4
34181b3a:	4770      	bx	lr
34181b3c:	56025000 	.word	0x56025000
34181b40:	56020000 	.word	0x56020000
34181b44:	56020400 	.word	0x56020400
34181b48:	56020800 	.word	0x56020800
34181b4c:	56020c00 	.word	0x56020c00
34181b50:	56021000 	.word	0x56021000
34181b54:	56021400 	.word	0x56021400
34181b58:	56021800 	.word	0x56021800
34181b5c:	56021c00 	.word	0x56021c00
34181b60:	56023400 	.word	0x56023400
34181b64:	56023800 	.word	0x56023800
34181b68:	56023c00 	.word	0x56023c00
34181b6c:	56024000 	.word	0x56024000

34181b70 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34181b70:	b480      	push	{r7}
34181b72:	b083      	sub	sp, #12
34181b74:	af00      	add	r7, sp, #0
34181b76:	6078      	str	r0, [r7, #4]
34181b78:	460b      	mov	r3, r1
34181b7a:	807b      	strh	r3, [r7, #2]
34181b7c:	4613      	mov	r3, r2
34181b7e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
34181b80:	787b      	ldrb	r3, [r7, #1]
34181b82:	2b00      	cmp	r3, #0
34181b84:	d003      	beq.n	34181b8e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34181b86:	887a      	ldrh	r2, [r7, #2]
34181b88:	687b      	ldr	r3, [r7, #4]
34181b8a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34181b8c:	e002      	b.n	34181b94 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34181b8e:	887a      	ldrh	r2, [r7, #2]
34181b90:	687b      	ldr	r3, [r7, #4]
34181b92:	629a      	str	r2, [r3, #40]	@ 0x28
}
34181b94:	bf00      	nop
34181b96:	370c      	adds	r7, #12
34181b98:	46bd      	mov	sp, r7
34181b9a:	f85d 7b04 	ldr.w	r7, [sp], #4
34181b9e:	4770      	bx	lr

34181ba0 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
34181ba0:	b480      	push	{r7}
34181ba2:	b085      	sub	sp, #20
34181ba4:	af00      	add	r7, sp, #0
34181ba6:	6078      	str	r0, [r7, #4]
34181ba8:	460b      	mov	r3, r1
34181baa:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
34181bac:	687b      	ldr	r3, [r7, #4]
34181bae:	695b      	ldr	r3, [r3, #20]
34181bb0:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
34181bb2:	887a      	ldrh	r2, [r7, #2]
34181bb4:	68fb      	ldr	r3, [r7, #12]
34181bb6:	4013      	ands	r3, r2
34181bb8:	041a      	lsls	r2, r3, #16
34181bba:	68fb      	ldr	r3, [r7, #12]
34181bbc:	43d9      	mvns	r1, r3
34181bbe:	887b      	ldrh	r3, [r7, #2]
34181bc0:	400b      	ands	r3, r1
34181bc2:	431a      	orrs	r2, r3
34181bc4:	687b      	ldr	r3, [r7, #4]
34181bc6:	619a      	str	r2, [r3, #24]
}
34181bc8:	bf00      	nop
34181bca:	3714      	adds	r7, #20
34181bcc:	46bd      	mov	sp, r7
34181bce:	f85d 7b04 	ldr.w	r7, [sp], #4
34181bd2:	4770      	bx	lr

34181bd4 <HAL_PWREx_ConfigSupply>:
  * @note: The power supply configuration is not reset by wakeup from Standby mode and
  *        application reset, but only reset by VDD POR.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
34181bd4:	b580      	push	{r7, lr}
34181bd6:	b084      	sub	sp, #16
34181bd8:	af00      	add	r7, sp, #0
34181bda:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set the power supply configuration */
  MODIFY_REG(PWR->CR1, PWR_SUPPLY_CONFIG_MASK, SupplySource);
34181bdc:	4b10      	ldr	r3, [pc, #64]	@ (34181c20 <HAL_PWREx_ConfigSupply+0x4c>)
34181bde:	681b      	ldr	r3, [r3, #0]
34181be0:	f023 0204 	bic.w	r2, r3, #4
34181be4:	490e      	ldr	r1, [pc, #56]	@ (34181c20 <HAL_PWREx_ConfigSupply+0x4c>)
34181be6:	687b      	ldr	r3, [r7, #4]
34181be8:	4313      	orrs	r3, r2
34181bea:	600b      	str	r3, [r1, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
34181bec:	f7ff fce8 	bl	341815c0 <HAL_GetTick>
34181bf0:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
34181bf2:	e009      	b.n	34181c08 <HAL_PWREx_ConfigSupply+0x34>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
34181bf4:	f7ff fce4 	bl	341815c0 <HAL_GetTick>
34181bf8:	4602      	mov	r2, r0
34181bfa:	68fb      	ldr	r3, [r7, #12]
34181bfc:	1ad3      	subs	r3, r2, r3
34181bfe:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
34181c02:	d901      	bls.n	34181c08 <HAL_PWREx_ConfigSupply+0x34>
    {
      return HAL_ERROR;
34181c04:	2301      	movs	r3, #1
34181c06:	e006      	b.n	34181c16 <HAL_PWREx_ConfigSupply+0x42>
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
34181c08:	4b05      	ldr	r3, [pc, #20]	@ (34181c20 <HAL_PWREx_ConfigSupply+0x4c>)
34181c0a:	6a1b      	ldr	r3, [r3, #32]
34181c0c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34181c10:	2b00      	cmp	r3, #0
34181c12:	d0ef      	beq.n	34181bf4 <HAL_PWREx_ConfigSupply+0x20>
    }
  }

  return HAL_OK;
34181c14:	2300      	movs	r3, #0
}
34181c16:	4618      	mov	r0, r3
34181c18:	3710      	adds	r7, #16
34181c1a:	46bd      	mov	sp, r7
34181c1c:	bd80      	pop	{r7, pc}
34181c1e:	bf00      	nop
34181c20:	56024800 	.word	0x56024800

34181c24 <HAL_PWREx_ConfigVddIORange>:
  * @note   Setting this configuration while VDDIOx is in 3v3 range
  *         damages the device.
  * @retval None.
  */
void HAL_PWREx_ConfigVddIORange(uint32_t VddIOPort, uint32_t VoltageRange)
{
34181c24:	b480      	push	{r7}
34181c26:	b083      	sub	sp, #12
34181c28:	af00      	add	r7, sp, #0
34181c2a:	6078      	str	r0, [r7, #4]
34181c2c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));

  switch (VddIOPort)
34181c2e:	687b      	ldr	r3, [r7, #4]
34181c30:	2b04      	cmp	r3, #4
34181c32:	d83f      	bhi.n	34181cb4 <HAL_PWREx_ConfigVddIORange+0x90>
34181c34:	a201      	add	r2, pc, #4	@ (adr r2, 34181c3c <HAL_PWREx_ConfigVddIORange+0x18>)
34181c36:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34181c3a:	bf00      	nop
34181c3c:	34181c51 	.word	0x34181c51
34181c40:	34181c65 	.word	0x34181c65
34181c44:	34181c79 	.word	0x34181c79
34181c48:	34181c8d 	.word	0x34181c8d
34181c4c:	34181ca1 	.word	0x34181ca1
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
34181c50:	4b1c      	ldr	r3, [pc, #112]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181c52:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34181c54:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34181c58:	683b      	ldr	r3, [r7, #0]
34181c5a:	061b      	lsls	r3, r3, #24
34181c5c:	4919      	ldr	r1, [pc, #100]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181c5e:	4313      	orrs	r3, r2
34181c60:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
34181c62:	e028      	b.n	34181cb6 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
34181c64:	4b17      	ldr	r3, [pc, #92]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181c66:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34181c68:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
34181c6c:	683b      	ldr	r3, [r7, #0]
34181c6e:	065b      	lsls	r3, r3, #25
34181c70:	4914      	ldr	r1, [pc, #80]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181c72:	4313      	orrs	r3, r2
34181c74:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
34181c76:	e01e      	b.n	34181cb6 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
34181c78:	4b12      	ldr	r3, [pc, #72]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181c7a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34181c7c:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
34181c80:	683b      	ldr	r3, [r7, #0]
34181c82:	069b      	lsls	r3, r3, #26
34181c84:	490f      	ldr	r1, [pc, #60]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181c86:	4313      	orrs	r3, r2
34181c88:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
34181c8a:	e014      	b.n	34181cb6 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO4:
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
34181c8c:	4b0d      	ldr	r3, [pc, #52]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181c8e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34181c90:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34181c94:	683b      	ldr	r3, [r7, #0]
34181c96:	061b      	lsls	r3, r3, #24
34181c98:	490a      	ldr	r1, [pc, #40]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181c9a:	4313      	orrs	r3, r2
34181c9c:	634b      	str	r3, [r1, #52]	@ 0x34
      break;
34181c9e:	e00a      	b.n	34181cb6 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO5:
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
34181ca0:	4b08      	ldr	r3, [pc, #32]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181ca2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34181ca4:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34181ca8:	683b      	ldr	r3, [r7, #0]
34181caa:	061b      	lsls	r3, r3, #24
34181cac:	4905      	ldr	r1, [pc, #20]	@ (34181cc4 <HAL_PWREx_ConfigVddIORange+0xa0>)
34181cae:	4313      	orrs	r3, r2
34181cb0:	638b      	str	r3, [r1, #56]	@ 0x38
      break;
34181cb2:	e000      	b.n	34181cb6 <HAL_PWREx_ConfigVddIORange+0x92>

    default:
      break;
34181cb4:	bf00      	nop
  }
}
34181cb6:	bf00      	nop
34181cb8:	370c      	adds	r7, #12
34181cba:	46bd      	mov	sp, r7
34181cbc:	f85d 7b04 	ldr.w	r7, [sp], #4
34181cc0:	4770      	bx	lr
34181cc2:	bf00      	nop
34181cc4:	56024800 	.word	0x56024800

34181cc8 <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
34181cc8:	b480      	push	{r7}
34181cca:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34181ccc:	4b05      	ldr	r3, [pc, #20]	@ (34181ce4 <HAL_PWREx_EnableVddIO2+0x1c>)
34181cce:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34181cd0:	4a04      	ldr	r2, [pc, #16]	@ (34181ce4 <HAL_PWREx_EnableVddIO2+0x1c>)
34181cd2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34181cd6:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34181cd8:	bf00      	nop
34181cda:	46bd      	mov	sp, r7
34181cdc:	f85d 7b04 	ldr.w	r7, [sp], #4
34181ce0:	4770      	bx	lr
34181ce2:	bf00      	nop
34181ce4:	56024800 	.word	0x56024800

34181ce8 <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
34181ce8:	b480      	push	{r7}
34181cea:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34181cec:	4b05      	ldr	r3, [pc, #20]	@ (34181d04 <HAL_PWREx_EnableVddIO3+0x1c>)
34181cee:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34181cf0:	4a04      	ldr	r2, [pc, #16]	@ (34181d04 <HAL_PWREx_EnableVddIO3+0x1c>)
34181cf2:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
34181cf6:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34181cf8:	bf00      	nop
34181cfa:	46bd      	mov	sp, r7
34181cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
34181d00:	4770      	bx	lr
34181d02:	bf00      	nop
34181d04:	56024800 	.word	0x56024800

34181d08 <HAL_PWREx_EnableVddIO4>:
  * @brief  Enable VDDIO4 supply valid.
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
34181d08:	b480      	push	{r7}
34181d0a:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
34181d0c:	4b05      	ldr	r3, [pc, #20]	@ (34181d24 <HAL_PWREx_EnableVddIO4+0x1c>)
34181d0e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34181d10:	4a04      	ldr	r2, [pc, #16]	@ (34181d24 <HAL_PWREx_EnableVddIO4+0x1c>)
34181d12:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34181d16:	6353      	str	r3, [r2, #52]	@ 0x34
}
34181d18:	bf00      	nop
34181d1a:	46bd      	mov	sp, r7
34181d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181d20:	4770      	bx	lr
34181d22:	bf00      	nop
34181d24:	56024800 	.word	0x56024800

34181d28 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll SR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
34181d28:	b480      	push	{r7}
34181d2a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34181d2c:	4b06      	ldr	r3, [pc, #24]	@ (34181d48 <LL_RCC_HSE_IsReady+0x20>)
34181d2e:	685b      	ldr	r3, [r3, #4]
34181d30:	f003 0310 	and.w	r3, r3, #16
34181d34:	2b00      	cmp	r3, #0
34181d36:	d001      	beq.n	34181d3c <LL_RCC_HSE_IsReady+0x14>
34181d38:	2301      	movs	r3, #1
34181d3a:	e000      	b.n	34181d3e <LL_RCC_HSE_IsReady+0x16>
34181d3c:	2300      	movs	r3, #0
}
34181d3e:	4618      	mov	r0, r3
34181d40:	46bd      	mov	sp, r7
34181d42:	f85d 7b04 	ldr.w	r7, [sp], #4
34181d46:	4770      	bx	lr
34181d48:	56028000 	.word	0x56028000

34181d4c <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI oscillator
  * @rmtoll CSR          HSIONS        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
34181d4c:	b480      	push	{r7}
34181d4e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
34181d50:	4b04      	ldr	r3, [pc, #16]	@ (34181d64 <LL_RCC_HSI_Enable+0x18>)
34181d52:	2208      	movs	r2, #8
34181d54:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34181d58:	bf00      	nop
34181d5a:	46bd      	mov	sp, r7
34181d5c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181d60:	4770      	bx	lr
34181d62:	bf00      	nop
34181d64:	56028000 	.word	0x56028000

34181d68 <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI oscillator
  * @rmtoll CCR          HSIONC        LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
34181d68:	b480      	push	{r7}
34181d6a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
34181d6c:	4b05      	ldr	r3, [pc, #20]	@ (34181d84 <LL_RCC_HSI_Disable+0x1c>)
34181d6e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181d72:	461a      	mov	r2, r3
34181d74:	2308      	movs	r3, #8
34181d76:	6013      	str	r3, [r2, #0]
}
34181d78:	bf00      	nop
34181d7a:	46bd      	mov	sp, r7
34181d7c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181d80:	4770      	bx	lr
34181d82:	bf00      	nop
34181d84:	56028000 	.word	0x56028000

34181d88 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll SR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
34181d88:	b480      	push	{r7}
34181d8a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
34181d8c:	4b06      	ldr	r3, [pc, #24]	@ (34181da8 <LL_RCC_HSI_IsReady+0x20>)
34181d8e:	685b      	ldr	r3, [r3, #4]
34181d90:	f003 0308 	and.w	r3, r3, #8
34181d94:	2b00      	cmp	r3, #0
34181d96:	d001      	beq.n	34181d9c <LL_RCC_HSI_IsReady+0x14>
34181d98:	2301      	movs	r3, #1
34181d9a:	e000      	b.n	34181d9e <LL_RCC_HSI_IsReady+0x16>
34181d9c:	2300      	movs	r3, #0
}
34181d9e:	4618      	mov	r0, r3
34181da0:	46bd      	mov	sp, r7
34181da2:	f85d 7b04 	ldr.w	r7, [sp], #4
34181da6:	4770      	bx	lr
34181da8:	56028000 	.word	0x56028000

34181dac <LL_RCC_HSI_SetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_HSI_SetDivider(uint32_t Divider)
{
34181dac:	b480      	push	{r7}
34181dae:	b083      	sub	sp, #12
34181db0:	af00      	add	r7, sp, #0
34181db2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
34181db4:	4b06      	ldr	r3, [pc, #24]	@ (34181dd0 <LL_RCC_HSI_SetDivider+0x24>)
34181db6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34181db8:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
34181dbc:	4904      	ldr	r1, [pc, #16]	@ (34181dd0 <LL_RCC_HSI_SetDivider+0x24>)
34181dbe:	687b      	ldr	r3, [r7, #4]
34181dc0:	4313      	orrs	r3, r2
34181dc2:	648b      	str	r3, [r1, #72]	@ 0x48
}
34181dc4:	bf00      	nop
34181dc6:	370c      	adds	r7, #12
34181dc8:	46bd      	mov	sp, r7
34181dca:	f85d 7b04 	ldr.w	r7, [sp], #4
34181dce:	4770      	bx	lr
34181dd0:	56028000 	.word	0x56028000

34181dd4 <LL_RCC_HSI_GetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_2
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_GetDivider(void)
{
34181dd4:	b480      	push	{r7}
34181dd6:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34181dd8:	4b04      	ldr	r3, [pc, #16]	@ (34181dec <LL_RCC_HSI_GetDivider+0x18>)
34181dda:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34181ddc:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
34181de0:	4618      	mov	r0, r3
34181de2:	46bd      	mov	sp, r7
34181de4:	f85d 7b04 	ldr.w	r7, [sp], #4
34181de8:	4770      	bx	lr
34181dea:	bf00      	nop
34181dec:	56028000 	.word	0x56028000

34181df0 <LL_RCC_HSI_SetCalibTrimming>:
  * @rmtoll HSICFGR      HSITRIM       LL_RCC_HSI_SetCalibTrimming
  * @param  Value This parameter can be a value between 0 and 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
34181df0:	b480      	push	{r7}
34181df2:	b083      	sub	sp, #12
34181df4:	af00      	add	r7, sp, #0
34181df6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
34181df8:	4b07      	ldr	r3, [pc, #28]	@ (34181e18 <LL_RCC_HSI_SetCalibTrimming+0x28>)
34181dfa:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34181dfc:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
34181e00:	687b      	ldr	r3, [r7, #4]
34181e02:	041b      	lsls	r3, r3, #16
34181e04:	4904      	ldr	r1, [pc, #16]	@ (34181e18 <LL_RCC_HSI_SetCalibTrimming+0x28>)
34181e06:	4313      	orrs	r3, r2
34181e08:	648b      	str	r3, [r1, #72]	@ 0x48
}
34181e0a:	bf00      	nop
34181e0c:	370c      	adds	r7, #12
34181e0e:	46bd      	mov	sp, r7
34181e10:	f85d 7b04 	ldr.w	r7, [sp], #4
34181e14:	4770      	bx	lr
34181e16:	bf00      	nop
34181e18:	56028000 	.word	0x56028000

34181e1c <LL_RCC_MSI_Enable>:
  * @brief  Enable MSI oscillator
  * @rmtoll CSR          MSIONS        LL_RCC_MSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Enable(void)
{
34181e1c:	b480      	push	{r7}
34181e1e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
34181e20:	4b04      	ldr	r3, [pc, #16]	@ (34181e34 <LL_RCC_MSI_Enable+0x18>)
34181e22:	2204      	movs	r2, #4
34181e24:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34181e28:	bf00      	nop
34181e2a:	46bd      	mov	sp, r7
34181e2c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181e30:	4770      	bx	lr
34181e32:	bf00      	nop
34181e34:	56028000 	.word	0x56028000

34181e38 <LL_RCC_MSI_Disable>:
  * @brief  Disable MSI oscillator
  * @rmtoll CCR          MSIONC        LL_RCC_MSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Disable(void)
{
34181e38:	b480      	push	{r7}
34181e3a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
34181e3c:	4b05      	ldr	r3, [pc, #20]	@ (34181e54 <LL_RCC_MSI_Disable+0x1c>)
34181e3e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181e42:	461a      	mov	r2, r3
34181e44:	2304      	movs	r3, #4
34181e46:	6013      	str	r3, [r2, #0]
}
34181e48:	bf00      	nop
34181e4a:	46bd      	mov	sp, r7
34181e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181e50:	4770      	bx	lr
34181e52:	bf00      	nop
34181e54:	56028000 	.word	0x56028000

34181e58 <LL_RCC_MSI_IsReady>:
  * @brief  Check if MSI clock is ready
  * @rmtoll SR           MSIRDY        LL_RCC_MSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsReady(void)
{
34181e58:	b480      	push	{r7}
34181e5a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34181e5c:	4b06      	ldr	r3, [pc, #24]	@ (34181e78 <LL_RCC_MSI_IsReady+0x20>)
34181e5e:	685b      	ldr	r3, [r3, #4]
34181e60:	f003 0304 	and.w	r3, r3, #4
34181e64:	2b00      	cmp	r3, #0
34181e66:	d001      	beq.n	34181e6c <LL_RCC_MSI_IsReady+0x14>
34181e68:	2301      	movs	r3, #1
34181e6a:	e000      	b.n	34181e6e <LL_RCC_MSI_IsReady+0x16>
34181e6c:	2300      	movs	r3, #0
}
34181e6e:	4618      	mov	r0, r3
34181e70:	46bd      	mov	sp, r7
34181e72:	f85d 7b04 	ldr.w	r7, [sp], #4
34181e76:	4770      	bx	lr
34181e78:	56028000 	.word	0x56028000

34181e7c <LL_RCC_MSI_SetFrequency>:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_MSI_SetFrequency(uint32_t Value)
{
34181e7c:	b480      	push	{r7}
34181e7e:	b083      	sub	sp, #12
34181e80:	af00      	add	r7, sp, #0
34181e82:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
34181e84:	4b06      	ldr	r3, [pc, #24]	@ (34181ea0 <LL_RCC_MSI_SetFrequency+0x24>)
34181e86:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34181e88:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34181e8c:	4904      	ldr	r1, [pc, #16]	@ (34181ea0 <LL_RCC_MSI_SetFrequency+0x24>)
34181e8e:	687b      	ldr	r3, [r7, #4]
34181e90:	4313      	orrs	r3, r2
34181e92:	644b      	str	r3, [r1, #68]	@ 0x44
}
34181e94:	bf00      	nop
34181e96:	370c      	adds	r7, #12
34181e98:	46bd      	mov	sp, r7
34181e9a:	f85d 7b04 	ldr.w	r7, [sp], #4
34181e9e:	4770      	bx	lr
34181ea0:	56028000 	.word	0x56028000

34181ea4 <LL_RCC_MSI_SetCalibTrimming>:
  * @rmtoll MSICFGR      MSITRIM       LL_RCC_MSI_SetCalibTrimming
  * @param  Value can be a value between 0 and 31
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
{
34181ea4:	b480      	push	{r7}
34181ea6:	b083      	sub	sp, #12
34181ea8:	af00      	add	r7, sp, #0
34181eaa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
34181eac:	4b07      	ldr	r3, [pc, #28]	@ (34181ecc <LL_RCC_MSI_SetCalibTrimming+0x28>)
34181eae:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34181eb0:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
34181eb4:	687b      	ldr	r3, [r7, #4]
34181eb6:	041b      	lsls	r3, r3, #16
34181eb8:	4904      	ldr	r1, [pc, #16]	@ (34181ecc <LL_RCC_MSI_SetCalibTrimming+0x28>)
34181eba:	4313      	orrs	r3, r2
34181ebc:	644b      	str	r3, [r1, #68]	@ 0x44
}
34181ebe:	bf00      	nop
34181ec0:	370c      	adds	r7, #12
34181ec2:	46bd      	mov	sp, r7
34181ec4:	f85d 7b04 	ldr.w	r7, [sp], #4
34181ec8:	4770      	bx	lr
34181eca:	bf00      	nop
34181ecc:	56028000 	.word	0x56028000

34181ed0 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll SR           LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
34181ed0:	b480      	push	{r7}
34181ed2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
34181ed4:	4b06      	ldr	r3, [pc, #24]	@ (34181ef0 <LL_RCC_LSE_IsReady+0x20>)
34181ed6:	685b      	ldr	r3, [r3, #4]
34181ed8:	f003 0302 	and.w	r3, r3, #2
34181edc:	2b00      	cmp	r3, #0
34181ede:	d001      	beq.n	34181ee4 <LL_RCC_LSE_IsReady+0x14>
34181ee0:	2301      	movs	r3, #1
34181ee2:	e000      	b.n	34181ee6 <LL_RCC_LSE_IsReady+0x16>
34181ee4:	2300      	movs	r3, #0
}
34181ee6:	4618      	mov	r0, r3
34181ee8:	46bd      	mov	sp, r7
34181eea:	f85d 7b04 	ldr.w	r7, [sp], #4
34181eee:	4770      	bx	lr
34181ef0:	56028000 	.word	0x56028000

34181ef4 <LL_RCC_LSI_Enable>:
  * @brief  Enable LSI Oscillator
  * @rmtoll CSR          LSIONS        LL_RCC_LSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Enable(void)
{
34181ef4:	b480      	push	{r7}
34181ef6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
34181ef8:	4b04      	ldr	r3, [pc, #16]	@ (34181f0c <LL_RCC_LSI_Enable+0x18>)
34181efa:	2201      	movs	r2, #1
34181efc:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34181f00:	bf00      	nop
34181f02:	46bd      	mov	sp, r7
34181f04:	f85d 7b04 	ldr.w	r7, [sp], #4
34181f08:	4770      	bx	lr
34181f0a:	bf00      	nop
34181f0c:	56028000 	.word	0x56028000

34181f10 <LL_RCC_LSI_Disable>:
  * @brief  Disable LSI Oscillator
  * @rmtoll CCR          LSIONC        LL_RCC_LSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Disable(void)
{
34181f10:	b480      	push	{r7}
34181f12:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
34181f14:	4b05      	ldr	r3, [pc, #20]	@ (34181f2c <LL_RCC_LSI_Disable+0x1c>)
34181f16:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181f1a:	461a      	mov	r2, r3
34181f1c:	2301      	movs	r3, #1
34181f1e:	6013      	str	r3, [r2, #0]
}
34181f20:	bf00      	nop
34181f22:	46bd      	mov	sp, r7
34181f24:	f85d 7b04 	ldr.w	r7, [sp], #4
34181f28:	4770      	bx	lr
34181f2a:	bf00      	nop
34181f2c:	56028000 	.word	0x56028000

34181f30 <LL_RCC_LSI_IsReady>:
  * @brief  Check if LSI is Ready
  * @rmtoll SR           LSIRDY        LL_RCC_LSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
{
34181f30:	b480      	push	{r7}
34181f32:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34181f34:	4b04      	ldr	r3, [pc, #16]	@ (34181f48 <LL_RCC_LSI_IsReady+0x18>)
34181f36:	685b      	ldr	r3, [r3, #4]
34181f38:	f003 0301 	and.w	r3, r3, #1
}
34181f3c:	4618      	mov	r0, r3
34181f3e:	46bd      	mov	sp, r7
34181f40:	f85d 7b04 	ldr.w	r7, [sp], #4
34181f44:	4770      	bx	lr
34181f46:	bf00      	nop
34181f48:	56028000 	.word	0x56028000

34181f4c <LL_RCC_GetCpuClkSource>:
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_IC1
  */
__STATIC_INLINE uint32_t LL_RCC_GetCpuClkSource(void)
{
34181f4c:	b480      	push	{r7}
34181f4e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34181f50:	4b04      	ldr	r3, [pc, #16]	@ (34181f64 <LL_RCC_GetCpuClkSource+0x18>)
34181f52:	6a1b      	ldr	r3, [r3, #32]
34181f54:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
34181f58:	4618      	mov	r0, r3
34181f5a:	46bd      	mov	sp, r7
34181f5c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181f60:	4770      	bx	lr
34181f62:	bf00      	nop
34181f64:	56028000 	.word	0x56028000

34181f68 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
34181f68:	b480      	push	{r7}
34181f6a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
34181f6c:	4b04      	ldr	r3, [pc, #16]	@ (34181f80 <LL_RCC_GetSysClkSource+0x18>)
34181f6e:	6a1b      	ldr	r3, [r3, #32]
34181f70:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34181f74:	4618      	mov	r0, r3
34181f76:	46bd      	mov	sp, r7
34181f78:	f85d 7b04 	ldr.w	r7, [sp], #4
34181f7c:	4770      	bx	lr
34181f7e:	bf00      	nop
34181f80:	56028000 	.word	0x56028000

34181f84 <LL_RCC_PLL1_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetSource(void)
{
34181f84:	b480      	push	{r7}
34181f86:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34181f88:	4b04      	ldr	r3, [pc, #16]	@ (34181f9c <LL_RCC_PLL1_GetSource+0x18>)
34181f8a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34181f8e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34181f92:	4618      	mov	r0, r3
34181f94:	46bd      	mov	sp, r7
34181f96:	f85d 7b04 	ldr.w	r7, [sp], #4
34181f9a:	4770      	bx	lr
34181f9c:	56028000 	.word	0x56028000

34181fa0 <LL_RCC_PLL1_IsReady>:
  * @brief  Check if PLL1 Ready
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
34181fa0:	b480      	push	{r7}
34181fa2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
34181fa4:	4b07      	ldr	r3, [pc, #28]	@ (34181fc4 <LL_RCC_PLL1_IsReady+0x24>)
34181fa6:	685b      	ldr	r3, [r3, #4]
34181fa8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34181fac:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34181fb0:	d101      	bne.n	34181fb6 <LL_RCC_PLL1_IsReady+0x16>
34181fb2:	2301      	movs	r3, #1
34181fb4:	e000      	b.n	34181fb8 <LL_RCC_PLL1_IsReady+0x18>
34181fb6:	2300      	movs	r3, #0
}
34181fb8:	4618      	mov	r0, r3
34181fba:	46bd      	mov	sp, r7
34181fbc:	f85d 7b04 	ldr.w	r7, [sp], #4
34181fc0:	4770      	bx	lr
34181fc2:	bf00      	nop
34181fc4:	56028000 	.word	0x56028000

34181fc8 <LL_RCC_PLL1_IsEnabledBypass>:
  * @brief  Check if PLL1 bypass is enabled
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
34181fc8:	b480      	push	{r7}
34181fca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34181fcc:	4b07      	ldr	r3, [pc, #28]	@ (34181fec <LL_RCC_PLL1_IsEnabledBypass+0x24>)
34181fce:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34181fd2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34181fd6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34181fda:	d101      	bne.n	34181fe0 <LL_RCC_PLL1_IsEnabledBypass+0x18>
34181fdc:	2301      	movs	r3, #1
34181fde:	e000      	b.n	34181fe2 <LL_RCC_PLL1_IsEnabledBypass+0x1a>
34181fe0:	2300      	movs	r3, #0
}
34181fe2:	4618      	mov	r0, r3
34181fe4:	46bd      	mov	sp, r7
34181fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
34181fea:	4770      	bx	lr
34181fec:	56028000 	.word	0x56028000

34181ff0 <LL_RCC_PLL2_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetSource(void)
{
34181ff0:	b480      	push	{r7}
34181ff2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34181ff4:	4b04      	ldr	r3, [pc, #16]	@ (34182008 <LL_RCC_PLL2_GetSource+0x18>)
34181ff6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34181ffa:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34181ffe:	4618      	mov	r0, r3
34182000:	46bd      	mov	sp, r7
34182002:	f85d 7b04 	ldr.w	r7, [sp], #4
34182006:	4770      	bx	lr
34182008:	56028000 	.word	0x56028000

3418200c <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll SR           PLL2RDY         LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
3418200c:	b480      	push	{r7}
3418200e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34182010:	4b07      	ldr	r3, [pc, #28]	@ (34182030 <LL_RCC_PLL2_IsReady+0x24>)
34182012:	685b      	ldr	r3, [r3, #4]
34182014:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34182018:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418201c:	d101      	bne.n	34182022 <LL_RCC_PLL2_IsReady+0x16>
3418201e:	2301      	movs	r3, #1
34182020:	e000      	b.n	34182024 <LL_RCC_PLL2_IsReady+0x18>
34182022:	2300      	movs	r3, #0
}
34182024:	4618      	mov	r0, r3
34182026:	46bd      	mov	sp, r7
34182028:	f85d 7b04 	ldr.w	r7, [sp], #4
3418202c:	4770      	bx	lr
3418202e:	bf00      	nop
34182030:	56028000 	.word	0x56028000

34182034 <LL_RCC_PLL2_IsEnabledBypass>:
  * @brief  Check if PLL2 bypass is enabled
  * @rmtoll PLL2CFGR1    PLL2BYP         LL_RCC_PLL2_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsEnabledBypass(void)
{
34182034:	b480      	push	{r7}
34182036:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34182038:	4b07      	ldr	r3, [pc, #28]	@ (34182058 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3418203a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418203e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34182042:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34182046:	d101      	bne.n	3418204c <LL_RCC_PLL2_IsEnabledBypass+0x18>
34182048:	2301      	movs	r3, #1
3418204a:	e000      	b.n	3418204e <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3418204c:	2300      	movs	r3, #0
}
3418204e:	4618      	mov	r0, r3
34182050:	46bd      	mov	sp, r7
34182052:	f85d 7b04 	ldr.w	r7, [sp], #4
34182056:	4770      	bx	lr
34182058:	56028000 	.word	0x56028000

3418205c <LL_RCC_PLL3_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetSource(void)
{
3418205c:	b480      	push	{r7}
3418205e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34182060:	4b04      	ldr	r3, [pc, #16]	@ (34182074 <LL_RCC_PLL3_GetSource+0x18>)
34182062:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34182066:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418206a:	4618      	mov	r0, r3
3418206c:	46bd      	mov	sp, r7
3418206e:	f85d 7b04 	ldr.w	r7, [sp], #4
34182072:	4770      	bx	lr
34182074:	56028000 	.word	0x56028000

34182078 <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll SR           PLL3RDY         LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
34182078:	b480      	push	{r7}
3418207a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3418207c:	4b07      	ldr	r3, [pc, #28]	@ (3418209c <LL_RCC_PLL3_IsReady+0x24>)
3418207e:	685b      	ldr	r3, [r3, #4]
34182080:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34182084:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34182088:	d101      	bne.n	3418208e <LL_RCC_PLL3_IsReady+0x16>
3418208a:	2301      	movs	r3, #1
3418208c:	e000      	b.n	34182090 <LL_RCC_PLL3_IsReady+0x18>
3418208e:	2300      	movs	r3, #0
}
34182090:	4618      	mov	r0, r3
34182092:	46bd      	mov	sp, r7
34182094:	f85d 7b04 	ldr.w	r7, [sp], #4
34182098:	4770      	bx	lr
3418209a:	bf00      	nop
3418209c:	56028000 	.word	0x56028000

341820a0 <LL_RCC_PLL3_IsEnabledBypass>:
  * @brief  Check if PLL3 bypass is enabled
  * @rmtoll PLL3CFGR1    PLL3BYP         LL_RCC_PLL3_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsEnabledBypass(void)
{
341820a0:	b480      	push	{r7}
341820a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
341820a4:	4b07      	ldr	r3, [pc, #28]	@ (341820c4 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
341820a6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
341820aa:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
341820ae:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341820b2:	d101      	bne.n	341820b8 <LL_RCC_PLL3_IsEnabledBypass+0x18>
341820b4:	2301      	movs	r3, #1
341820b6:	e000      	b.n	341820ba <LL_RCC_PLL3_IsEnabledBypass+0x1a>
341820b8:	2300      	movs	r3, #0
}
341820ba:	4618      	mov	r0, r3
341820bc:	46bd      	mov	sp, r7
341820be:	f85d 7b04 	ldr.w	r7, [sp], #4
341820c2:	4770      	bx	lr
341820c4:	56028000 	.word	0x56028000

341820c8 <LL_RCC_PLL4_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_GetSource(void)
{
341820c8:	b480      	push	{r7}
341820ca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
341820cc:	4b04      	ldr	r3, [pc, #16]	@ (341820e0 <LL_RCC_PLL4_GetSource+0x18>)
341820ce:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
341820d2:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
341820d6:	4618      	mov	r0, r3
341820d8:	46bd      	mov	sp, r7
341820da:	f85d 7b04 	ldr.w	r7, [sp], #4
341820de:	4770      	bx	lr
341820e0:	56028000 	.word	0x56028000

341820e4 <LL_RCC_PLL4_IsReady>:
  * @brief  Check if PLL4 Ready
  * @rmtoll SR           PLL4RDY         LL_RCC_PLL4_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsReady(void)
{
341820e4:	b480      	push	{r7}
341820e6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
341820e8:	4b07      	ldr	r3, [pc, #28]	@ (34182108 <LL_RCC_PLL4_IsReady+0x24>)
341820ea:	685b      	ldr	r3, [r3, #4]
341820ec:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341820f0:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
341820f4:	d101      	bne.n	341820fa <LL_RCC_PLL4_IsReady+0x16>
341820f6:	2301      	movs	r3, #1
341820f8:	e000      	b.n	341820fc <LL_RCC_PLL4_IsReady+0x18>
341820fa:	2300      	movs	r3, #0
}
341820fc:	4618      	mov	r0, r3
341820fe:	46bd      	mov	sp, r7
34182100:	f85d 7b04 	ldr.w	r7, [sp], #4
34182104:	4770      	bx	lr
34182106:	bf00      	nop
34182108:	56028000 	.word	0x56028000

3418210c <LL_RCC_PLL4_IsEnabledBypass>:
  * @brief  Check if PLL4 bypass is enabled
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
3418210c:	b480      	push	{r7}
3418210e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34182110:	4b07      	ldr	r3, [pc, #28]	@ (34182130 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
34182112:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34182116:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418211a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418211e:	d101      	bne.n	34182124 <LL_RCC_PLL4_IsEnabledBypass+0x18>
34182120:	2301      	movs	r3, #1
34182122:	e000      	b.n	34182126 <LL_RCC_PLL4_IsEnabledBypass+0x1a>
34182124:	2300      	movs	r3, #0
}
34182126:	4618      	mov	r0, r3
34182128:	46bd      	mov	sp, r7
3418212a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418212e:	4770      	bx	lr
34182130:	56028000 	.word	0x56028000

34182134 <LL_RCC_IC1_Enable>:
  * @brief  Enable IC1
  * @rmtoll DIVENSR      IC1ENS        LL_RCC_IC1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC1_Enable(void)
{
34182134:	b480      	push	{r7}
34182136:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
34182138:	4b04      	ldr	r3, [pc, #16]	@ (3418214c <LL_RCC_IC1_Enable+0x18>)
3418213a:	2201      	movs	r2, #1
3418213c:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34182140:	bf00      	nop
34182142:	46bd      	mov	sp, r7
34182144:	f85d 7b04 	ldr.w	r7, [sp], #4
34182148:	4770      	bx	lr
3418214a:	bf00      	nop
3418214c:	56028000 	.word	0x56028000

34182150 <LL_RCC_IC1_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
34182150:	b480      	push	{r7}
34182152:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34182154:	4b04      	ldr	r3, [pc, #16]	@ (34182168 <LL_RCC_IC1_GetSource+0x18>)
34182156:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418215a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418215e:	4618      	mov	r0, r3
34182160:	46bd      	mov	sp, r7
34182162:	f85d 7b04 	ldr.w	r7, [sp], #4
34182166:	4770      	bx	lr
34182168:	56028000 	.word	0x56028000

3418216c <LL_RCC_IC1_GetDivider>:
  * @brief  Get IC1 divider
  * @rmtoll IC1CFGR      IC1INT        LL_RCC_IC1_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetDivider(void)
{
3418216c:	b480      	push	{r7}
3418216e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34182170:	4b05      	ldr	r3, [pc, #20]	@ (34182188 <LL_RCC_IC1_GetDivider+0x1c>)
34182172:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34182176:	0c1b      	lsrs	r3, r3, #16
34182178:	b2db      	uxtb	r3, r3
3418217a:	3301      	adds	r3, #1
}
3418217c:	4618      	mov	r0, r3
3418217e:	46bd      	mov	sp, r7
34182180:	f85d 7b04 	ldr.w	r7, [sp], #4
34182184:	4770      	bx	lr
34182186:	bf00      	nop
34182188:	56028000 	.word	0x56028000

3418218c <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
3418218c:	b480      	push	{r7}
3418218e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34182190:	4b04      	ldr	r3, [pc, #16]	@ (341821a4 <LL_RCC_IC2_GetSource+0x18>)
34182192:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34182196:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418219a:	4618      	mov	r0, r3
3418219c:	46bd      	mov	sp, r7
3418219e:	f85d 7b04 	ldr.w	r7, [sp], #4
341821a2:	4770      	bx	lr
341821a4:	56028000 	.word	0x56028000

341821a8 <LL_RCC_IC6_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
341821a8:	b480      	push	{r7}
341821aa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
341821ac:	4b04      	ldr	r3, [pc, #16]	@ (341821c0 <LL_RCC_IC6_GetSource+0x18>)
341821ae:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
341821b2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
341821b6:	4618      	mov	r0, r3
341821b8:	46bd      	mov	sp, r7
341821ba:	f85d 7b04 	ldr.w	r7, [sp], #4
341821be:	4770      	bx	lr
341821c0:	56028000 	.word	0x56028000

341821c4 <LL_RCC_IC11_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
341821c4:	b480      	push	{r7}
341821c6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
341821c8:	4b04      	ldr	r3, [pc, #16]	@ (341821dc <LL_RCC_IC11_GetSource+0x18>)
341821ca:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
341821ce:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
341821d2:	4618      	mov	r0, r3
341821d4:	46bd      	mov	sp, r7
341821d6:	f85d 7b04 	ldr.w	r7, [sp], #4
341821da:	4770      	bx	lr
341821dc:	56028000 	.word	0x56028000

341821e0 <HAL_RCC_OscConfig>:
  * @note   This function activates HSE but does not wait for the startup time defined in the datasheet.
  *         This must be ensured by the application when the HSE is selected as PLL source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
341821e0:	b580      	push	{r7, lr}
341821e2:	b0a2      	sub	sp, #136	@ 0x88
341821e4:	af00      	add	r7, sp, #0
341821e6:	6078      	str	r0, [r7, #4]
  uint32_t pll3src;
  uint32_t pll4src;
  uint32_t rccsr;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
341821e8:	687b      	ldr	r3, [r7, #4]
341821ea:	2b00      	cmp	r3, #0
341821ec:	d101      	bne.n	341821f2 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
341821ee:	2301      	movs	r3, #1
341821f0:	e3d1      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  cpuclksrc = LL_RCC_GetCpuClkSource();
341821f2:	f7ff feab 	bl	34181f4c <LL_RCC_GetCpuClkSource>
341821f6:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  sysclksrc = LL_RCC_GetSysClkSource();
341821fa:	f7ff feb5 	bl	34181f68 <LL_RCC_GetSysClkSource>
341821fe:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  pll1src = LL_RCC_PLL1_GetSource();
34182202:	f7ff febf 	bl	34181f84 <LL_RCC_PLL1_GetSource>
34182206:	67f8      	str	r0, [r7, #124]	@ 0x7c
  pll2src = LL_RCC_PLL2_GetSource();
34182208:	f7ff fef2 	bl	34181ff0 <LL_RCC_PLL2_GetSource>
3418220c:	67b8      	str	r0, [r7, #120]	@ 0x78
  pll3src = LL_RCC_PLL3_GetSource();
3418220e:	f7ff ff25 	bl	3418205c <LL_RCC_PLL3_GetSource>
34182212:	6778      	str	r0, [r7, #116]	@ 0x74
  pll4src = LL_RCC_PLL4_GetSource();
34182214:	f7ff ff58 	bl	341820c8 <LL_RCC_PLL4_GetSource>
34182218:	6738      	str	r0, [r7, #112]	@ 0x70
  rccsr = RCC->SR;
3418221a:	4b91      	ldr	r3, [pc, #580]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
3418221c:	685b      	ldr	r3, [r3, #4]
3418221e:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
34182220:	687b      	ldr	r3, [r7, #4]
34182222:	681b      	ldr	r3, [r3, #0]
34182224:	f003 0301 	and.w	r3, r3, #1
34182228:	2b00      	cmp	r3, #0
3418222a:	f000 80a8 	beq.w	3418237e <HAL_RCC_OscConfig+0x19e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
3418222e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34182232:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34182236:	d028      	beq.n	3418228a <HAL_RCC_OscConfig+0xaa>
34182238:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418223c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34182240:	d023      	beq.n	3418228a <HAL_RCC_OscConfig+0xaa>
34182242:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34182244:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34182248:	d104      	bne.n	34182254 <HAL_RCC_OscConfig+0x74>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418224a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418224c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34182250:	2b00      	cmp	r3, #0
34182252:	d11a      	bne.n	3418228a <HAL_RCC_OscConfig+0xaa>
34182254:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34182256:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418225a:	d104      	bne.n	34182266 <HAL_RCC_OscConfig+0x86>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418225c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418225e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34182262:	2b00      	cmp	r3, #0
34182264:	d111      	bne.n	3418228a <HAL_RCC_OscConfig+0xaa>
34182266:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34182268:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418226c:	d104      	bne.n	34182278 <HAL_RCC_OscConfig+0x98>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418226e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34182270:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34182274:	2b00      	cmp	r3, #0
34182276:	d108      	bne.n	3418228a <HAL_RCC_OscConfig+0xaa>
34182278:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418227a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418227e:	d10a      	bne.n	34182296 <HAL_RCC_OscConfig+0xb6>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34182280:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34182282:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34182286:	2b00      	cmp	r3, #0
34182288:	d005      	beq.n	34182296 <HAL_RCC_OscConfig+0xb6>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
3418228a:	687b      	ldr	r3, [r7, #4]
3418228c:	685b      	ldr	r3, [r3, #4]
3418228e:	2b00      	cmp	r3, #0
34182290:	d175      	bne.n	3418237e <HAL_RCC_OscConfig+0x19e>
      {
        return HAL_ERROR;
34182292:	2301      	movs	r3, #1
34182294:	e37f      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      /* HSE ON , nothing to do */
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
34182296:	687b      	ldr	r3, [r7, #4]
34182298:	685b      	ldr	r3, [r3, #4]
3418229a:	2b10      	cmp	r3, #16
3418229c:	d104      	bne.n	341822a8 <HAL_RCC_OscConfig+0xc8>
3418229e:	4b70      	ldr	r3, [pc, #448]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
341822a0:	2210      	movs	r2, #16
341822a2:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
341822a6:	e043      	b.n	34182330 <HAL_RCC_OscConfig+0x150>
341822a8:	687b      	ldr	r3, [r7, #4]
341822aa:	685b      	ldr	r3, [r3, #4]
341822ac:	2b00      	cmp	r3, #0
341822ae:	d10c      	bne.n	341822ca <HAL_RCC_OscConfig+0xea>
341822b0:	4b6b      	ldr	r3, [pc, #428]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
341822b2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341822b6:	461a      	mov	r2, r3
341822b8:	2310      	movs	r3, #16
341822ba:	6013      	str	r3, [r2, #0]
341822bc:	4b68      	ldr	r3, [pc, #416]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
341822be:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341822c0:	4a67      	ldr	r2, [pc, #412]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
341822c2:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
341822c6:	6553      	str	r3, [r2, #84]	@ 0x54
341822c8:	e032      	b.n	34182330 <HAL_RCC_OscConfig+0x150>
341822ca:	687b      	ldr	r3, [r7, #4]
341822cc:	685b      	ldr	r3, [r3, #4]
341822ce:	f248 0210 	movw	r2, #32784	@ 0x8010
341822d2:	4293      	cmp	r3, r2
341822d4:	d110      	bne.n	341822f8 <HAL_RCC_OscConfig+0x118>
341822d6:	4b62      	ldr	r3, [pc, #392]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
341822d8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341822da:	4a61      	ldr	r2, [pc, #388]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
341822dc:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
341822e0:	6553      	str	r3, [r2, #84]	@ 0x54
341822e2:	4b5f      	ldr	r3, [pc, #380]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
341822e4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341822e6:	4a5e      	ldr	r2, [pc, #376]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
341822e8:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
341822ec:	6553      	str	r3, [r2, #84]	@ 0x54
341822ee:	4b5c      	ldr	r3, [pc, #368]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
341822f0:	2210      	movs	r2, #16
341822f2:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
341822f6:	e01b      	b.n	34182330 <HAL_RCC_OscConfig+0x150>
341822f8:	687b      	ldr	r3, [r7, #4]
341822fa:	685b      	ldr	r3, [r3, #4]
341822fc:	4a59      	ldr	r2, [pc, #356]	@ (34182464 <HAL_RCC_OscConfig+0x284>)
341822fe:	4293      	cmp	r3, r2
34182300:	d10a      	bne.n	34182318 <HAL_RCC_OscConfig+0x138>
34182302:	4b57      	ldr	r3, [pc, #348]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
34182304:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34182306:	4a56      	ldr	r2, [pc, #344]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
34182308:	f443 33c0 	orr.w	r3, r3, #98304	@ 0x18000
3418230c:	6553      	str	r3, [r2, #84]	@ 0x54
3418230e:	4b54      	ldr	r3, [pc, #336]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
34182310:	2210      	movs	r2, #16
34182312:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34182316:	e00b      	b.n	34182330 <HAL_RCC_OscConfig+0x150>
34182318:	4b51      	ldr	r3, [pc, #324]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
3418231a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418231e:	461a      	mov	r2, r3
34182320:	2310      	movs	r3, #16
34182322:	6013      	str	r3, [r2, #0]
34182324:	4b4e      	ldr	r3, [pc, #312]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
34182326:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34182328:	4a4d      	ldr	r2, [pc, #308]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
3418232a:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3418232e:	6553      	str	r3, [r2, #84]	@ 0x54

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34182330:	f7ff f946 	bl	341815c0 <HAL_GetTick>
34182334:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
34182336:	687b      	ldr	r3, [r7, #4]
34182338:	685b      	ldr	r3, [r3, #4]
3418233a:	2b00      	cmp	r3, #0
3418233c:	d019      	beq.n	34182372 <HAL_RCC_OscConfig+0x192>
      {
        /* Wait till HSE is ready */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3418233e:	e008      	b.n	34182352 <HAL_RCC_OscConfig+0x172>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34182340:	f7ff f93e 	bl	341815c0 <HAL_GetTick>
34182344:	4602      	mov	r2, r0
34182346:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34182348:	1ad3      	subs	r3, r2, r3
3418234a:	2b64      	cmp	r3, #100	@ 0x64
3418234c:	d901      	bls.n	34182352 <HAL_RCC_OscConfig+0x172>
          {
            return HAL_TIMEOUT;
3418234e:	2303      	movs	r3, #3
34182350:	e321      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
34182352:	4b43      	ldr	r3, [pc, #268]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
34182354:	685b      	ldr	r3, [r3, #4]
34182356:	f003 0310 	and.w	r3, r3, #16
3418235a:	2b00      	cmp	r3, #0
3418235c:	d0f0      	beq.n	34182340 <HAL_RCC_OscConfig+0x160>
3418235e:	e00e      	b.n	3418237e <HAL_RCC_OscConfig+0x19e>
      else
      {
        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34182360:	f7ff f92e 	bl	341815c0 <HAL_GetTick>
34182364:	4602      	mov	r2, r0
34182366:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34182368:	1ad3      	subs	r3, r2, r3
3418236a:	2b64      	cmp	r3, #100	@ 0x64
3418236c:	d901      	bls.n	34182372 <HAL_RCC_OscConfig+0x192>
          {
            return HAL_TIMEOUT;
3418236e:	2303      	movs	r3, #3
34182370:	e311      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
34182372:	4b3b      	ldr	r3, [pc, #236]	@ (34182460 <HAL_RCC_OscConfig+0x280>)
34182374:	685b      	ldr	r3, [r3, #4]
34182376:	f003 0310 	and.w	r3, r3, #16
3418237a:	2b00      	cmp	r3, #0
3418237c:	d1f0      	bne.n	34182360 <HAL_RCC_OscConfig+0x180>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
3418237e:	687b      	ldr	r3, [r7, #4]
34182380:	681b      	ldr	r3, [r3, #0]
34182382:	f003 0302 	and.w	r3, r3, #2
34182386:	2b00      	cmp	r3, #0
34182388:	d073      	beq.n	34182472 <HAL_RCC_OscConfig+0x292>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));

    /* When the HSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
3418238a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418238e:	2b00      	cmp	r3, #0
34182390:	d023      	beq.n	341823da <HAL_RCC_OscConfig+0x1fa>
34182392:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34182396:	2b00      	cmp	r3, #0
34182398:	d01f      	beq.n	341823da <HAL_RCC_OscConfig+0x1fa>
3418239a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418239c:	2b00      	cmp	r3, #0
3418239e:	d104      	bne.n	341823aa <HAL_RCC_OscConfig+0x1ca>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
341823a0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341823a2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341823a6:	2b00      	cmp	r3, #0
341823a8:	d117      	bne.n	341823da <HAL_RCC_OscConfig+0x1fa>
341823aa:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
341823ac:	2b00      	cmp	r3, #0
341823ae:	d104      	bne.n	341823ba <HAL_RCC_OscConfig+0x1da>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
341823b0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341823b2:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341823b6:	2b00      	cmp	r3, #0
341823b8:	d10f      	bne.n	341823da <HAL_RCC_OscConfig+0x1fa>
341823ba:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
341823bc:	2b00      	cmp	r3, #0
341823be:	d104      	bne.n	341823ca <HAL_RCC_OscConfig+0x1ea>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
341823c0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341823c2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341823c6:	2b00      	cmp	r3, #0
341823c8:	d107      	bne.n	341823da <HAL_RCC_OscConfig+0x1fa>
341823ca:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
341823cc:	2b00      	cmp	r3, #0
341823ce:	d115      	bne.n	341823fc <HAL_RCC_OscConfig+0x21c>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
341823d0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341823d2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341823d6:	2b00      	cmp	r3, #0
341823d8:	d010      	beq.n	341823fc <HAL_RCC_OscConfig+0x21c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
341823da:	687b      	ldr	r3, [r7, #4]
341823dc:	68db      	ldr	r3, [r3, #12]
341823de:	2b00      	cmp	r3, #0
341823e0:	d101      	bne.n	341823e6 <HAL_RCC_OscConfig+0x206>
      {
        return HAL_ERROR;
341823e2:	2301      	movs	r3, #1
341823e4:	e2d7      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
341823e6:	687b      	ldr	r3, [r7, #4]
341823e8:	691b      	ldr	r3, [r3, #16]
341823ea:	4618      	mov	r0, r3
341823ec:	f7ff fcde 	bl	34181dac <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
341823f0:	687b      	ldr	r3, [r7, #4]
341823f2:	695b      	ldr	r3, [r3, #20]
341823f4:	4618      	mov	r0, r3
341823f6:	f7ff fcfb 	bl	34181df0 <LL_RCC_HSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
341823fa:	e03a      	b.n	34182472 <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
341823fc:	687b      	ldr	r3, [r7, #4]
341823fe:	68db      	ldr	r3, [r3, #12]
34182400:	2b00      	cmp	r3, #0
34182402:	d01e      	beq.n	34182442 <HAL_RCC_OscConfig+0x262>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
34182404:	f7ff fca2 	bl	34181d4c <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34182408:	f7ff f8da 	bl	341815c0 <HAL_GetTick>
3418240c:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
3418240e:	e008      	b.n	34182422 <HAL_RCC_OscConfig+0x242>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
34182410:	f7ff f8d6 	bl	341815c0 <HAL_GetTick>
34182414:	4602      	mov	r2, r0
34182416:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34182418:	1ad3      	subs	r3, r2, r3
3418241a:	2b01      	cmp	r3, #1
3418241c:	d901      	bls.n	34182422 <HAL_RCC_OscConfig+0x242>
          {
            return HAL_TIMEOUT;
3418241e:	2303      	movs	r3, #3
34182420:	e2b9      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_HSI_IsReady() == 0U)
34182422:	f7ff fcb1 	bl	34181d88 <LL_RCC_HSI_IsReady>
34182426:	4603      	mov	r3, r0
34182428:	2b00      	cmp	r3, #0
3418242a:	d0f1      	beq.n	34182410 <HAL_RCC_OscConfig+0x230>
          }
        }

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3418242c:	687b      	ldr	r3, [r7, #4]
3418242e:	691b      	ldr	r3, [r3, #16]
34182430:	4618      	mov	r0, r3
34182432:	f7ff fcbb 	bl	34181dac <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
34182436:	687b      	ldr	r3, [r7, #4]
34182438:	695b      	ldr	r3, [r3, #20]
3418243a:	4618      	mov	r0, r3
3418243c:	f7ff fcd8 	bl	34181df0 <LL_RCC_HSI_SetCalibTrimming>
34182440:	e017      	b.n	34182472 <HAL_RCC_OscConfig+0x292>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
34182442:	f7ff fc91 	bl	34181d68 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34182446:	f7ff f8bb 	bl	341815c0 <HAL_GetTick>
3418244a:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
3418244c:	e00c      	b.n	34182468 <HAL_RCC_OscConfig+0x288>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3418244e:	f7ff f8b7 	bl	341815c0 <HAL_GetTick>
34182452:	4602      	mov	r2, r0
34182454:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34182456:	1ad3      	subs	r3, r2, r3
34182458:	2b01      	cmp	r3, #1
3418245a:	d905      	bls.n	34182468 <HAL_RCC_OscConfig+0x288>
          {
            return HAL_TIMEOUT;
3418245c:	2303      	movs	r3, #3
3418245e:	e29a      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
34182460:	56028000 	.word	0x56028000
34182464:	00018010 	.word	0x00018010
        while (LL_RCC_HSI_IsReady() != 0U)
34182468:	f7ff fc8e 	bl	34181d88 <LL_RCC_HSI_IsReady>
3418246c:	4603      	mov	r3, r0
3418246e:	2b00      	cmp	r3, #0
34182470:	d1ed      	bne.n	3418244e <HAL_RCC_OscConfig+0x26e>
      }
    }
  }

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
34182472:	687b      	ldr	r3, [r7, #4]
34182474:	681b      	ldr	r3, [r3, #0]
34182476:	f003 0310 	and.w	r3, r3, #16
3418247a:	2b00      	cmp	r3, #0
3418247c:	d070      	beq.n	34182560 <HAL_RCC_OscConfig+0x380>
    /* Check the parameters */
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));

    /* When the MSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    /* but just to update the MSI calibration value */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
3418247e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34182482:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34182486:	d028      	beq.n	341824da <HAL_RCC_OscConfig+0x2fa>
34182488:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418248c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34182490:	d023      	beq.n	341824da <HAL_RCC_OscConfig+0x2fa>
34182492:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34182494:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34182498:	d104      	bne.n	341824a4 <HAL_RCC_OscConfig+0x2c4>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418249a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418249c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341824a0:	2b00      	cmp	r3, #0
341824a2:	d11a      	bne.n	341824da <HAL_RCC_OscConfig+0x2fa>
341824a4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
341824a6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341824aa:	d104      	bne.n	341824b6 <HAL_RCC_OscConfig+0x2d6>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
341824ac:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341824ae:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341824b2:	2b00      	cmp	r3, #0
341824b4:	d111      	bne.n	341824da <HAL_RCC_OscConfig+0x2fa>
341824b6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
341824b8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341824bc:	d104      	bne.n	341824c8 <HAL_RCC_OscConfig+0x2e8>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
341824be:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341824c0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341824c4:	2b00      	cmp	r3, #0
341824c6:	d108      	bne.n	341824da <HAL_RCC_OscConfig+0x2fa>
341824c8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
341824ca:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341824ce:	d110      	bne.n	341824f2 <HAL_RCC_OscConfig+0x312>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
341824d0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341824d2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341824d6:	2b00      	cmp	r3, #0
341824d8:	d00b      	beq.n	341824f2 <HAL_RCC_OscConfig+0x312>
    {
      /* When MSI is used as system clock it will not disabled */
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
341824da:	687b      	ldr	r3, [r7, #4]
341824dc:	69db      	ldr	r3, [r3, #28]
341824de:	2b00      	cmp	r3, #0
341824e0:	d101      	bne.n	341824e6 <HAL_RCC_OscConfig+0x306>
      {
        return HAL_ERROR;
341824e2:	2301      	movs	r3, #1
341824e4:	e257      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
341824e6:	687b      	ldr	r3, [r7, #4]
341824e8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341824ea:	4618      	mov	r0, r3
341824ec:	f7ff fcda 	bl	34181ea4 <LL_RCC_MSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
341824f0:	e036      	b.n	34182560 <HAL_RCC_OscConfig+0x380>
      }
    }
    else
    {
      /* Check the MSI State */
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
341824f2:	687b      	ldr	r3, [r7, #4]
341824f4:	69db      	ldr	r3, [r3, #28]
341824f6:	2b00      	cmp	r3, #0
341824f8:	d01e      	beq.n	34182538 <HAL_RCC_OscConfig+0x358>
        /* Check the parameters */
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Set the frequency */
        __HAL_RCC_MSI_FREQUENCY_CONFIG(pRCC_OscInitStruct->MSIFrequency);
341824fa:	687b      	ldr	r3, [r7, #4]
341824fc:	6a1b      	ldr	r3, [r3, #32]
341824fe:	4618      	mov	r0, r3
34182500:	f7ff fcbc 	bl	34181e7c <LL_RCC_MSI_SetFrequency>

        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
34182504:	f7ff fc8a 	bl	34181e1c <LL_RCC_MSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34182508:	f7ff f85a 	bl	341815c0 <HAL_GetTick>
3418250c:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
3418250e:	e008      	b.n	34182522 <HAL_RCC_OscConfig+0x342>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34182510:	f7ff f856 	bl	341815c0 <HAL_GetTick>
34182514:	4602      	mov	r2, r0
34182516:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34182518:	1ad3      	subs	r3, r2, r3
3418251a:	2b01      	cmp	r3, #1
3418251c:	d901      	bls.n	34182522 <HAL_RCC_OscConfig+0x342>
          {
            return HAL_TIMEOUT;
3418251e:	2303      	movs	r3, #3
34182520:	e239      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() == 0U)
34182522:	f7ff fc99 	bl	34181e58 <LL_RCC_MSI_IsReady>
34182526:	4603      	mov	r3, r0
34182528:	2b00      	cmp	r3, #0
3418252a:	d0f1      	beq.n	34182510 <HAL_RCC_OscConfig+0x330>
          }
        }

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3418252c:	687b      	ldr	r3, [r7, #4]
3418252e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182530:	4618      	mov	r0, r3
34182532:	f7ff fcb7 	bl	34181ea4 <LL_RCC_MSI_SetCalibTrimming>
34182536:	e013      	b.n	34182560 <HAL_RCC_OscConfig+0x380>
      }
      else
      {
        /* Ignore MSI frequency and calibration values in disable case */
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
34182538:	f7ff fc7e 	bl	34181e38 <LL_RCC_MSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418253c:	f7ff f840 	bl	341815c0 <HAL_GetTick>
34182540:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
34182542:	e008      	b.n	34182556 <HAL_RCC_OscConfig+0x376>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34182544:	f7ff f83c 	bl	341815c0 <HAL_GetTick>
34182548:	4602      	mov	r2, r0
3418254a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418254c:	1ad3      	subs	r3, r2, r3
3418254e:	2b01      	cmp	r3, #1
34182550:	d901      	bls.n	34182556 <HAL_RCC_OscConfig+0x376>
          {
            return HAL_TIMEOUT;
34182552:	2303      	movs	r3, #3
34182554:	e21f      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() != 0U)
34182556:	f7ff fc7f 	bl	34181e58 <LL_RCC_MSI_IsReady>
3418255a:	4603      	mov	r3, r0
3418255c:	2b00      	cmp	r3, #0
3418255e:	d1f1      	bne.n	34182544 <HAL_RCC_OscConfig+0x364>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
34182560:	687b      	ldr	r3, [r7, #4]
34182562:	681b      	ldr	r3, [r3, #0]
34182564:	f003 0308 	and.w	r3, r3, #8
34182568:	2b00      	cmp	r3, #0
3418256a:	d02c      	beq.n	341825c6 <HAL_RCC_OscConfig+0x3e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
3418256c:	687b      	ldr	r3, [r7, #4]
3418256e:	699b      	ldr	r3, [r3, #24]
34182570:	2b00      	cmp	r3, #0
34182572:	d014      	beq.n	3418259e <HAL_RCC_OscConfig+0x3be>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
34182574:	f7ff fcbe 	bl	34181ef4 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34182578:	f7ff f822 	bl	341815c0 <HAL_GetTick>
3418257c:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
3418257e:	e008      	b.n	34182592 <HAL_RCC_OscConfig+0x3b2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
34182580:	f7ff f81e 	bl	341815c0 <HAL_GetTick>
34182584:	4602      	mov	r2, r0
34182586:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34182588:	1ad3      	subs	r3, r2, r3
3418258a:	2b01      	cmp	r3, #1
3418258c:	d901      	bls.n	34182592 <HAL_RCC_OscConfig+0x3b2>
        {
          return HAL_TIMEOUT;
3418258e:	2303      	movs	r3, #3
34182590:	e201      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() == 0U)
34182592:	f7ff fccd 	bl	34181f30 <LL_RCC_LSI_IsReady>
34182596:	4603      	mov	r3, r0
34182598:	2b00      	cmp	r3, #0
3418259a:	d0f1      	beq.n	34182580 <HAL_RCC_OscConfig+0x3a0>
3418259c:	e013      	b.n	341825c6 <HAL_RCC_OscConfig+0x3e6>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
3418259e:	f7ff fcb7 	bl	34181f10 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
341825a2:	f7ff f80d 	bl	341815c0 <HAL_GetTick>
341825a6:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() != 0U)
341825a8:	e008      	b.n	341825bc <HAL_RCC_OscConfig+0x3dc>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
341825aa:	f7ff f809 	bl	341815c0 <HAL_GetTick>
341825ae:	4602      	mov	r2, r0
341825b0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341825b2:	1ad3      	subs	r3, r2, r3
341825b4:	2b01      	cmp	r3, #1
341825b6:	d901      	bls.n	341825bc <HAL_RCC_OscConfig+0x3dc>
        {
          return HAL_TIMEOUT;
341825b8:	2303      	movs	r3, #3
341825ba:	e1ec      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() != 0U)
341825bc:	f7ff fcb8 	bl	34181f30 <LL_RCC_LSI_IsReady>
341825c0:	4603      	mov	r3, r0
341825c2:	2b00      	cmp	r3, #0
341825c4:	d1f1      	bne.n	341825aa <HAL_RCC_OscConfig+0x3ca>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
341825c6:	687b      	ldr	r3, [r7, #4]
341825c8:	681b      	ldr	r3, [r3, #0]
341825ca:	f003 0304 	and.w	r3, r3, #4
341825ce:	2b00      	cmp	r3, #0
341825d0:	f000 808c 	beq.w	341826ec <HAL_RCC_OscConfig+0x50c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
341825d4:	687b      	ldr	r3, [r7, #4]
341825d6:	689b      	ldr	r3, [r3, #8]
341825d8:	2b02      	cmp	r3, #2
341825da:	d104      	bne.n	341825e6 <HAL_RCC_OscConfig+0x406>
341825dc:	4b96      	ldr	r3, [pc, #600]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
341825de:	2202      	movs	r2, #2
341825e0:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
341825e4:	e055      	b.n	34182692 <HAL_RCC_OscConfig+0x4b2>
341825e6:	687b      	ldr	r3, [r7, #4]
341825e8:	689b      	ldr	r3, [r3, #8]
341825ea:	2b00      	cmp	r3, #0
341825ec:	d112      	bne.n	34182614 <HAL_RCC_OscConfig+0x434>
341825ee:	4b92      	ldr	r3, [pc, #584]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
341825f0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341825f4:	461a      	mov	r2, r3
341825f6:	2302      	movs	r3, #2
341825f8:	6013      	str	r3, [r2, #0]
341825fa:	4b8f      	ldr	r3, [pc, #572]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
341825fc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341825fe:	4a8e      	ldr	r2, [pc, #568]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182600:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34182604:	6413      	str	r3, [r2, #64]	@ 0x40
34182606:	4b8c      	ldr	r3, [pc, #560]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182608:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418260a:	4a8b      	ldr	r2, [pc, #556]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
3418260c:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34182610:	6413      	str	r3, [r2, #64]	@ 0x40
34182612:	e03e      	b.n	34182692 <HAL_RCC_OscConfig+0x4b2>
34182614:	687b      	ldr	r3, [r7, #4]
34182616:	689b      	ldr	r3, [r3, #8]
34182618:	f248 0202 	movw	r2, #32770	@ 0x8002
3418261c:	4293      	cmp	r3, r2
3418261e:	d110      	bne.n	34182642 <HAL_RCC_OscConfig+0x462>
34182620:	4b85      	ldr	r3, [pc, #532]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182622:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34182624:	4a84      	ldr	r2, [pc, #528]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182626:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418262a:	6413      	str	r3, [r2, #64]	@ 0x40
3418262c:	4b82      	ldr	r3, [pc, #520]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
3418262e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34182630:	4a81      	ldr	r2, [pc, #516]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182632:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34182636:	6413      	str	r3, [r2, #64]	@ 0x40
34182638:	4b7f      	ldr	r3, [pc, #508]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
3418263a:	2202      	movs	r2, #2
3418263c:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34182640:	e027      	b.n	34182692 <HAL_RCC_OscConfig+0x4b2>
34182642:	687b      	ldr	r3, [r7, #4]
34182644:	689b      	ldr	r3, [r3, #8]
34182646:	4a7d      	ldr	r2, [pc, #500]	@ (3418283c <HAL_RCC_OscConfig+0x65c>)
34182648:	4293      	cmp	r3, r2
3418264a:	d110      	bne.n	3418266e <HAL_RCC_OscConfig+0x48e>
3418264c:	4b7a      	ldr	r3, [pc, #488]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
3418264e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34182650:	4a79      	ldr	r2, [pc, #484]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182652:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34182656:	6413      	str	r3, [r2, #64]	@ 0x40
34182658:	4b77      	ldr	r3, [pc, #476]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
3418265a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418265c:	4a76      	ldr	r2, [pc, #472]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
3418265e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34182662:	6413      	str	r3, [r2, #64]	@ 0x40
34182664:	4b74      	ldr	r3, [pc, #464]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182666:	2202      	movs	r2, #2
34182668:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418266c:	e011      	b.n	34182692 <HAL_RCC_OscConfig+0x4b2>
3418266e:	4b72      	ldr	r3, [pc, #456]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182670:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34182674:	461a      	mov	r2, r3
34182676:	2302      	movs	r3, #2
34182678:	6013      	str	r3, [r2, #0]
3418267a:	4b6f      	ldr	r3, [pc, #444]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
3418267c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418267e:	4a6e      	ldr	r2, [pc, #440]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182680:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34182684:	6413      	str	r3, [r2, #64]	@ 0x40
34182686:	4b6c      	ldr	r3, [pc, #432]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
34182688:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418268a:	4a6b      	ldr	r2, [pc, #428]	@ (34182838 <HAL_RCC_OscConfig+0x658>)
3418268c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34182690:	6413      	str	r3, [r2, #64]	@ 0x40
    /* Check the LSE State */
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
34182692:	687b      	ldr	r3, [r7, #4]
34182694:	689b      	ldr	r3, [r3, #8]
34182696:	2b00      	cmp	r3, #0
34182698:	d014      	beq.n	341826c4 <HAL_RCC_OscConfig+0x4e4>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418269a:	f7fe ff91 	bl	341815c0 <HAL_GetTick>
3418269e:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
341826a0:	e00a      	b.n	341826b8 <HAL_RCC_OscConfig+0x4d8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
341826a2:	f7fe ff8d 	bl	341815c0 <HAL_GetTick>
341826a6:	4602      	mov	r2, r0
341826a8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341826aa:	1ad3      	subs	r3, r2, r3
341826ac:	f241 3288 	movw	r2, #5000	@ 0x1388
341826b0:	4293      	cmp	r3, r2
341826b2:	d901      	bls.n	341826b8 <HAL_RCC_OscConfig+0x4d8>
        {
          return HAL_TIMEOUT;
341826b4:	2303      	movs	r3, #3
341826b6:	e16e      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() == 0U)
341826b8:	f7ff fc0a 	bl	34181ed0 <LL_RCC_LSE_IsReady>
341826bc:	4603      	mov	r3, r0
341826be:	2b00      	cmp	r3, #0
341826c0:	d0ef      	beq.n	341826a2 <HAL_RCC_OscConfig+0x4c2>
341826c2:	e013      	b.n	341826ec <HAL_RCC_OscConfig+0x50c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
341826c4:	f7fe ff7c 	bl	341815c0 <HAL_GetTick>
341826c8:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
341826ca:	e00a      	b.n	341826e2 <HAL_RCC_OscConfig+0x502>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
341826cc:	f7fe ff78 	bl	341815c0 <HAL_GetTick>
341826d0:	4602      	mov	r2, r0
341826d2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341826d4:	1ad3      	subs	r3, r2, r3
341826d6:	f241 3288 	movw	r2, #5000	@ 0x1388
341826da:	4293      	cmp	r3, r2
341826dc:	d901      	bls.n	341826e2 <HAL_RCC_OscConfig+0x502>
        {
          return HAL_TIMEOUT;
341826de:	2303      	movs	r3, #3
341826e0:	e159      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() != 0U)
341826e2:	f7ff fbf5 	bl	34181ed0 <LL_RCC_LSE_IsReady>
341826e6:	4603      	mov	r3, r0
341826e8:	2b00      	cmp	r3, #0
341826ea:	d1ef      	bne.n	341826cc <HAL_RCC_OscConfig+0x4ec>

  /*-------------------------------- PLL1 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));

  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
341826ec:	687b      	ldr	r3, [r7, #4]
341826ee:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
341826f0:	2b00      	cmp	r3, #0
341826f2:	d04c      	beq.n	3418278e <HAL_RCC_OscConfig+0x5ae>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
341826f4:	687b      	ldr	r3, [r7, #4]
341826f6:	3328      	adds	r3, #40	@ 0x28
341826f8:	4619      	mov	r1, r3
341826fa:	2000      	movs	r0, #0
341826fc:	f000 fda6 	bl	3418324c <RCC_PLL_IsNewConfig>
34182700:	6678      	str	r0, [r7, #100]	@ 0x64
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
34182702:	f7ff fc4d 	bl	34181fa0 <LL_RCC_PLL1_IsReady>
34182706:	6638      	str	r0, [r7, #96]	@ 0x60
    if (new_pll_config == 1U)
34182708:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3418270a:	2b01      	cmp	r3, #1
3418270c:	d130      	bne.n	34182770 <HAL_RCC_OscConfig+0x590>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418270e:	f7ff fd1f 	bl	34182150 <LL_RCC_IC1_GetSource>
34182712:	65f8      	str	r0, [r7, #92]	@ 0x5c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34182714:	f7ff fd3a 	bl	3418218c <LL_RCC_IC2_GetSource>
34182718:	65b8      	str	r0, [r7, #88]	@ 0x58
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418271a:	f7ff fd45 	bl	341821a8 <LL_RCC_IC6_GetSource>
3418271e:	6578      	str	r0, [r7, #84]	@ 0x54
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34182720:	f7ff fd50 	bl	341821c4 <LL_RCC_IC11_GetSource>
34182724:	6538      	str	r0, [r7, #80]	@ 0x50
      /* PLL1 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
34182726:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418272a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418272e:	d104      	bne.n	3418273a <HAL_RCC_OscConfig+0x55a>
34182730:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34182732:	2b00      	cmp	r3, #0
34182734:	d101      	bne.n	3418273a <HAL_RCC_OscConfig+0x55a>
      {
        return HAL_ERROR;
34182736:	2301      	movs	r3, #1
34182738:	e12d      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL1 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
3418273a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418273e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182742:	d10a      	bne.n	3418275a <HAL_RCC_OscConfig+0x57a>
34182744:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34182746:	2b00      	cmp	r3, #0
34182748:	d005      	beq.n	34182756 <HAL_RCC_OscConfig+0x576>
3418274a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3418274c:	2b00      	cmp	r3, #0
3418274e:	d002      	beq.n	34182756 <HAL_RCC_OscConfig+0x576>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
34182750:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34182752:	2b00      	cmp	r3, #0
34182754:	d101      	bne.n	3418275a <HAL_RCC_OscConfig+0x57a>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL1)))
      {
        return HAL_ERROR;
34182756:	2301      	movs	r3, #1
34182758:	e11d      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL1 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
3418275a:	687b      	ldr	r3, [r7, #4]
3418275c:	3328      	adds	r3, #40	@ 0x28
3418275e:	4619      	mov	r1, r3
34182760:	2000      	movs	r0, #0
34182762:	f000 fc17 	bl	34182f94 <RCC_PLL_Config>
34182766:	4603      	mov	r3, r0
34182768:	2b00      	cmp	r3, #0
3418276a:	d010      	beq.n	3418278e <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3418276c:	2301      	movs	r3, #1
3418276e:	e112      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
34182770:	687b      	ldr	r3, [r7, #4]
34182772:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34182774:	2b02      	cmp	r3, #2
34182776:	d10a      	bne.n	3418278e <HAL_RCC_OscConfig+0x5ae>
34182778:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3418277a:	2b00      	cmp	r3, #0
3418277c:	d107      	bne.n	3418278e <HAL_RCC_OscConfig+0x5ae>
    {
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
3418277e:	2000      	movs	r0, #0
34182780:	f000 fd38 	bl	341831f4 <RCC_PLL_Enable>
34182784:	4603      	mov	r3, r0
34182786:	2b00      	cmp	r3, #0
34182788:	d001      	beq.n	3418278e <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3418278a:	2301      	movs	r3, #1
3418278c:	e103      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL2 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));

  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
3418278e:	687b      	ldr	r3, [r7, #4]
34182790:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34182792:	2b00      	cmp	r3, #0
34182794:	d054      	beq.n	34182840 <HAL_RCC_OscConfig+0x660>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
34182796:	687b      	ldr	r3, [r7, #4]
34182798:	3344      	adds	r3, #68	@ 0x44
3418279a:	4619      	mov	r1, r3
3418279c:	2001      	movs	r0, #1
3418279e:	f000 fd55 	bl	3418324c <RCC_PLL_IsNewConfig>
341827a2:	64f8      	str	r0, [r7, #76]	@ 0x4c
    uint32_t pll2_ready = LL_RCC_PLL2_IsReady();
341827a4:	f7ff fc32 	bl	3418200c <LL_RCC_PLL2_IsReady>
341827a8:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (new_pll_config == 1U)
341827aa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341827ac:	2b01      	cmp	r3, #1
341827ae:	d134      	bne.n	3418281a <HAL_RCC_OscConfig+0x63a>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
341827b0:	f7ff fcce 	bl	34182150 <LL_RCC_IC1_GetSource>
341827b4:	6478      	str	r0, [r7, #68]	@ 0x44
      uint32_t ic2src = LL_RCC_IC2_GetSource();
341827b6:	f7ff fce9 	bl	3418218c <LL_RCC_IC2_GetSource>
341827ba:	6438      	str	r0, [r7, #64]	@ 0x40
      uint32_t ic6src = LL_RCC_IC6_GetSource();
341827bc:	f7ff fcf4 	bl	341821a8 <LL_RCC_IC6_GetSource>
341827c0:	63f8      	str	r0, [r7, #60]	@ 0x3c
      uint32_t ic11src = LL_RCC_IC11_GetSource();
341827c2:	f7ff fcff 	bl	341821c4 <LL_RCC_IC11_GetSource>
341827c6:	63b8      	str	r0, [r7, #56]	@ 0x38
      /* PLL2 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
341827c8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341827cc:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
341827d0:	d105      	bne.n	341827de <HAL_RCC_OscConfig+0x5fe>
341827d2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
341827d4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341827d8:	d101      	bne.n	341827de <HAL_RCC_OscConfig+0x5fe>
      {
        return HAL_ERROR;
341827da:	2301      	movs	r3, #1
341827dc:	e0db      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL2 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
341827de:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
341827e2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341827e6:	d10d      	bne.n	34182804 <HAL_RCC_OscConfig+0x624>
341827e8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341827ea:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341827ee:	d007      	beq.n	34182800 <HAL_RCC_OscConfig+0x620>
341827f0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341827f2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341827f6:	d003      	beq.n	34182800 <HAL_RCC_OscConfig+0x620>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
341827f8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341827fa:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341827fe:	d101      	bne.n	34182804 <HAL_RCC_OscConfig+0x624>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL2)))
      {
        return HAL_ERROR;
34182800:	2301      	movs	r3, #1
34182802:	e0c8      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL2 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
34182804:	687b      	ldr	r3, [r7, #4]
34182806:	3344      	adds	r3, #68	@ 0x44
34182808:	4619      	mov	r1, r3
3418280a:	2001      	movs	r0, #1
3418280c:	f000 fbc2 	bl	34182f94 <RCC_PLL_Config>
34182810:	4603      	mov	r3, r0
34182812:	2b00      	cmp	r3, #0
34182814:	d014      	beq.n	34182840 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
34182816:	2301      	movs	r3, #1
34182818:	e0bd      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
3418281a:	687b      	ldr	r3, [r7, #4]
3418281c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418281e:	2b02      	cmp	r3, #2
34182820:	d10e      	bne.n	34182840 <HAL_RCC_OscConfig+0x660>
34182822:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34182824:	2b00      	cmp	r3, #0
34182826:	d10b      	bne.n	34182840 <HAL_RCC_OscConfig+0x660>
    {
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
34182828:	2001      	movs	r0, #1
3418282a:	f000 fce3 	bl	341831f4 <RCC_PLL_Enable>
3418282e:	4603      	mov	r3, r0
34182830:	2b00      	cmp	r3, #0
34182832:	d005      	beq.n	34182840 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
34182834:	2301      	movs	r3, #1
34182836:	e0ae      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
34182838:	56028000 	.word	0x56028000
3418283c:	00018002 	.word	0x00018002

  /*-------------------------------- PLL3 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));

  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
34182840:	687b      	ldr	r3, [r7, #4]
34182842:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34182844:	2b00      	cmp	r3, #0
34182846:	d050      	beq.n	341828ea <HAL_RCC_OscConfig+0x70a>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
34182848:	687b      	ldr	r3, [r7, #4]
3418284a:	3360      	adds	r3, #96	@ 0x60
3418284c:	4619      	mov	r1, r3
3418284e:	2002      	movs	r0, #2
34182850:	f000 fcfc 	bl	3418324c <RCC_PLL_IsNewConfig>
34182854:	6378      	str	r0, [r7, #52]	@ 0x34
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
34182856:	f7ff fba3 	bl	34181fa0 <LL_RCC_PLL1_IsReady>
3418285a:	6338      	str	r0, [r7, #48]	@ 0x30
    if (new_pll_config == 1U)
3418285c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3418285e:	2b01      	cmp	r3, #1
34182860:	d134      	bne.n	341828cc <HAL_RCC_OscConfig+0x6ec>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
34182862:	f7ff fc75 	bl	34182150 <LL_RCC_IC1_GetSource>
34182866:	62f8      	str	r0, [r7, #44]	@ 0x2c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34182868:	f7ff fc90 	bl	3418218c <LL_RCC_IC2_GetSource>
3418286c:	62b8      	str	r0, [r7, #40]	@ 0x28
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418286e:	f7ff fc9b 	bl	341821a8 <LL_RCC_IC6_GetSource>
34182872:	6278      	str	r0, [r7, #36]	@ 0x24
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34182874:	f7ff fca6 	bl	341821c4 <LL_RCC_IC11_GetSource>
34182878:	6238      	str	r0, [r7, #32]
      /* PLL3 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
3418287a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418287e:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34182882:	d105      	bne.n	34182890 <HAL_RCC_OscConfig+0x6b0>
34182884:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34182886:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418288a:	d101      	bne.n	34182890 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
3418288c:	2301      	movs	r3, #1
3418288e:	e082      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
34182890:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34182894:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182898:	d10d      	bne.n	341828b6 <HAL_RCC_OscConfig+0x6d6>
3418289a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418289c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341828a0:	d007      	beq.n	341828b2 <HAL_RCC_OscConfig+0x6d2>
341828a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341828a4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341828a8:	d003      	beq.n	341828b2 <HAL_RCC_OscConfig+0x6d2>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
341828aa:	6a3b      	ldr	r3, [r7, #32]
341828ac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341828b0:	d101      	bne.n	341828b6 <HAL_RCC_OscConfig+0x6d6>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL3)))
      {
        return HAL_ERROR;
341828b2:	2301      	movs	r3, #1
341828b4:	e06f      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
341828b6:	687b      	ldr	r3, [r7, #4]
341828b8:	3360      	adds	r3, #96	@ 0x60
341828ba:	4619      	mov	r1, r3
341828bc:	2002      	movs	r0, #2
341828be:	f000 fb69 	bl	34182f94 <RCC_PLL_Config>
341828c2:	4603      	mov	r3, r0
341828c4:	2b00      	cmp	r3, #0
341828c6:	d010      	beq.n	341828ea <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
341828c8:	2301      	movs	r3, #1
341828ca:	e064      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
341828cc:	687b      	ldr	r3, [r7, #4]
341828ce:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
341828d0:	2b02      	cmp	r3, #2
341828d2:	d10a      	bne.n	341828ea <HAL_RCC_OscConfig+0x70a>
341828d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341828d6:	2b00      	cmp	r3, #0
341828d8:	d107      	bne.n	341828ea <HAL_RCC_OscConfig+0x70a>
    {
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
341828da:	2002      	movs	r0, #2
341828dc:	f000 fc8a 	bl	341831f4 <RCC_PLL_Enable>
341828e0:	4603      	mov	r3, r0
341828e2:	2b00      	cmp	r3, #0
341828e4:	d001      	beq.n	341828ea <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
341828e6:	2301      	movs	r3, #1
341828e8:	e055      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL4 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));

  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
341828ea:	687b      	ldr	r3, [r7, #4]
341828ec:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341828ee:	2b00      	cmp	r3, #0
341828f0:	d050      	beq.n	34182994 <HAL_RCC_OscConfig+0x7b4>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
341828f2:	687b      	ldr	r3, [r7, #4]
341828f4:	337c      	adds	r3, #124	@ 0x7c
341828f6:	4619      	mov	r1, r3
341828f8:	2003      	movs	r0, #3
341828fa:	f000 fca7 	bl	3418324c <RCC_PLL_IsNewConfig>
341828fe:	61f8      	str	r0, [r7, #28]
    uint32_t pll4_ready = LL_RCC_PLL4_IsReady();
34182900:	f7ff fbf0 	bl	341820e4 <LL_RCC_PLL4_IsReady>
34182904:	61b8      	str	r0, [r7, #24]

    if (new_pll_config == 1U)
34182906:	69fb      	ldr	r3, [r7, #28]
34182908:	2b01      	cmp	r3, #1
3418290a:	d134      	bne.n	34182976 <HAL_RCC_OscConfig+0x796>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418290c:	f7ff fc20 	bl	34182150 <LL_RCC_IC1_GetSource>
34182910:	6178      	str	r0, [r7, #20]
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34182912:	f7ff fc3b 	bl	3418218c <LL_RCC_IC2_GetSource>
34182916:	6138      	str	r0, [r7, #16]
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34182918:	f7ff fc46 	bl	341821a8 <LL_RCC_IC6_GetSource>
3418291c:	60f8      	str	r0, [r7, #12]
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418291e:	f7ff fc51 	bl	341821c4 <LL_RCC_IC11_GetSource>
34182922:	60b8      	str	r0, [r7, #8]
      /* PLL4 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
34182924:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34182928:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418292c:	d105      	bne.n	3418293a <HAL_RCC_OscConfig+0x75a>
3418292e:	697b      	ldr	r3, [r7, #20]
34182930:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182934:	d101      	bne.n	3418293a <HAL_RCC_OscConfig+0x75a>
      {
        return HAL_ERROR;
34182936:	2301      	movs	r3, #1
34182938:	e02d      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
3418293a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418293e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182942:	d10d      	bne.n	34182960 <HAL_RCC_OscConfig+0x780>
34182944:	693b      	ldr	r3, [r7, #16]
34182946:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418294a:	d007      	beq.n	3418295c <HAL_RCC_OscConfig+0x77c>
3418294c:	68fb      	ldr	r3, [r7, #12]
3418294e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182952:	d003      	beq.n	3418295c <HAL_RCC_OscConfig+0x77c>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
34182954:	68bb      	ldr	r3, [r7, #8]
34182956:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418295a:	d101      	bne.n	34182960 <HAL_RCC_OscConfig+0x780>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL4)))
      {
        return HAL_ERROR;
3418295c:	2301      	movs	r3, #1
3418295e:	e01a      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
34182960:	687b      	ldr	r3, [r7, #4]
34182962:	337c      	adds	r3, #124	@ 0x7c
34182964:	4619      	mov	r1, r3
34182966:	2003      	movs	r0, #3
34182968:	f000 fb14 	bl	34182f94 <RCC_PLL_Config>
3418296c:	4603      	mov	r3, r0
3418296e:	2b00      	cmp	r3, #0
34182970:	d010      	beq.n	34182994 <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
34182972:	2301      	movs	r3, #1
34182974:	e00f      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
34182976:	687b      	ldr	r3, [r7, #4]
34182978:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418297a:	2b02      	cmp	r3, #2
3418297c:	d10a      	bne.n	34182994 <HAL_RCC_OscConfig+0x7b4>
3418297e:	69bb      	ldr	r3, [r7, #24]
34182980:	2b00      	cmp	r3, #0
34182982:	d107      	bne.n	34182994 <HAL_RCC_OscConfig+0x7b4>
    {
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
34182984:	2003      	movs	r0, #3
34182986:	f000 fc35 	bl	341831f4 <RCC_PLL_Enable>
3418298a:	4603      	mov	r3, r0
3418298c:	2b00      	cmp	r3, #0
3418298e:	d001      	beq.n	34182994 <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
34182990:	2301      	movs	r3, #1
34182992:	e000      	b.n	34182996 <HAL_RCC_OscConfig+0x7b6>
    {
      /* Nothing to do */
    }
  }

  return HAL_OK;
34182994:	2300      	movs	r3, #0
}
34182996:	4618      	mov	r0, r3
34182998:	3788      	adds	r7, #136	@ 0x88
3418299a:	46bd      	mov	sp, r7
3418299c:	bd80      	pop	{r7, pc}
3418299e:	bf00      	nop

341829a0 <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
341829a0:	b580      	push	{r7, lr}
341829a2:	b084      	sub	sp, #16
341829a4:	af00      	add	r7, sp, #0
341829a6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
341829a8:	687b      	ldr	r3, [r7, #4]
341829aa:	2b00      	cmp	r3, #0
341829ac:	d101      	bne.n	341829b2 <HAL_RCC_ClockConfig+0x12>
  {
    return HAL_ERROR;
341829ae:	2301      	movs	r3, #1
341829b0:	e1f2      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));

  /* Increasing the BUS frequency divider ? */

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
341829b2:	687b      	ldr	r3, [r7, #4]
341829b4:	681b      	ldr	r3, [r3, #0]
341829b6:	f003 0308 	and.w	r3, r3, #8
341829ba:	2b00      	cmp	r3, #0
341829bc:	d010      	beq.n	341829e0 <HAL_RCC_ClockConfig+0x40>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
341829be:	687b      	ldr	r3, [r7, #4]
341829c0:	691a      	ldr	r2, [r3, #16]
341829c2:	4ba3      	ldr	r3, [pc, #652]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
341829c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341829c6:	f003 0307 	and.w	r3, r3, #7
341829ca:	429a      	cmp	r2, r3
341829cc:	d908      	bls.n	341829e0 <HAL_RCC_ClockConfig+0x40>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
341829ce:	4ba0      	ldr	r3, [pc, #640]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
341829d0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341829d2:	f023 0207 	bic.w	r2, r3, #7
341829d6:	687b      	ldr	r3, [r7, #4]
341829d8:	691b      	ldr	r3, [r3, #16]
341829da:	499d      	ldr	r1, [pc, #628]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
341829dc:	4313      	orrs	r3, r2
341829de:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
341829e0:	687b      	ldr	r3, [r7, #4]
341829e2:	681b      	ldr	r3, [r3, #0]
341829e4:	f003 0310 	and.w	r3, r3, #16
341829e8:	2b00      	cmp	r3, #0
341829ea:	d010      	beq.n	34182a0e <HAL_RCC_ClockConfig+0x6e>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
341829ec:	687b      	ldr	r3, [r7, #4]
341829ee:	695a      	ldr	r2, [r3, #20]
341829f0:	4b97      	ldr	r3, [pc, #604]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
341829f2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341829f4:	f003 0370 	and.w	r3, r3, #112	@ 0x70
341829f8:	429a      	cmp	r2, r3
341829fa:	d908      	bls.n	34182a0e <HAL_RCC_ClockConfig+0x6e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
341829fc:	4b94      	ldr	r3, [pc, #592]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
341829fe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182a00:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
34182a04:	687b      	ldr	r3, [r7, #4]
34182a06:	695b      	ldr	r3, [r3, #20]
34182a08:	4991      	ldr	r1, [pc, #580]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a0a:	4313      	orrs	r3, r2
34182a0c:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34182a0e:	687b      	ldr	r3, [r7, #4]
34182a10:	681b      	ldr	r3, [r3, #0]
34182a12:	f003 0320 	and.w	r3, r3, #32
34182a16:	2b00      	cmp	r3, #0
34182a18:	d010      	beq.n	34182a3c <HAL_RCC_ClockConfig+0x9c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34182a1a:	687b      	ldr	r3, [r7, #4]
34182a1c:	699a      	ldr	r2, [r3, #24]
34182a1e:	4b8c      	ldr	r3, [pc, #560]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a20:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182a22:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34182a26:	429a      	cmp	r2, r3
34182a28:	d908      	bls.n	34182a3c <HAL_RCC_ClockConfig+0x9c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
34182a2a:	4b89      	ldr	r3, [pc, #548]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a2c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182a2e:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
34182a32:	687b      	ldr	r3, [r7, #4]
34182a34:	699b      	ldr	r3, [r3, #24]
34182a36:	4986      	ldr	r1, [pc, #536]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a38:	4313      	orrs	r3, r2
34182a3a:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34182a3c:	687b      	ldr	r3, [r7, #4]
34182a3e:	681b      	ldr	r3, [r3, #0]
34182a40:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34182a44:	2b00      	cmp	r3, #0
34182a46:	d010      	beq.n	34182a6a <HAL_RCC_ClockConfig+0xca>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34182a48:	687b      	ldr	r3, [r7, #4]
34182a4a:	69da      	ldr	r2, [r3, #28]
34182a4c:	4b80      	ldr	r3, [pc, #512]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a4e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182a50:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34182a54:	429a      	cmp	r2, r3
34182a56:	d908      	bls.n	34182a6a <HAL_RCC_ClockConfig+0xca>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34182a58:	4b7d      	ldr	r3, [pc, #500]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a5a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182a5c:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34182a60:	687b      	ldr	r3, [r7, #4]
34182a62:	69db      	ldr	r3, [r3, #28]
34182a64:	497a      	ldr	r1, [pc, #488]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a66:	4313      	orrs	r3, r2
34182a68:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34182a6a:	687b      	ldr	r3, [r7, #4]
34182a6c:	681b      	ldr	r3, [r3, #0]
34182a6e:	f003 0304 	and.w	r3, r3, #4
34182a72:	2b00      	cmp	r3, #0
34182a74:	d010      	beq.n	34182a98 <HAL_RCC_ClockConfig+0xf8>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
34182a76:	687b      	ldr	r3, [r7, #4]
34182a78:	68da      	ldr	r2, [r3, #12]
34182a7a:	4b75      	ldr	r3, [pc, #468]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a7c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182a7e:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
34182a82:	429a      	cmp	r2, r3
34182a84:	d908      	bls.n	34182a98 <HAL_RCC_ClockConfig+0xf8>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
34182a86:	4b72      	ldr	r3, [pc, #456]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a88:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182a8a:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
34182a8e:	687b      	ldr	r3, [r7, #4]
34182a90:	68db      	ldr	r3, [r3, #12]
34182a92:	496f      	ldr	r1, [pc, #444]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182a94:	4313      	orrs	r3, r2
34182a96:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*------------------------- CPUCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
34182a98:	687b      	ldr	r3, [r7, #4]
34182a9a:	681b      	ldr	r3, [r3, #0]
34182a9c:	f003 0301 	and.w	r3, r3, #1
34182aa0:	2b00      	cmp	r3, #0
34182aa2:	d063      	beq.n	34182b6c <HAL_RCC_ClockConfig+0x1cc>
  {
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));

    /* HSE is selected as CPU Clock Source */
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
34182aa4:	687b      	ldr	r3, [r7, #4]
34182aa6:	685b      	ldr	r3, [r3, #4]
34182aa8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34182aac:	d106      	bne.n	34182abc <HAL_RCC_ClockConfig+0x11c>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
34182aae:	f7ff f93b 	bl	34181d28 <LL_RCC_HSE_IsReady>
34182ab2:	4603      	mov	r3, r0
34182ab4:	2b00      	cmp	r3, #0
34182ab6:	d134      	bne.n	34182b22 <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
34182ab8:	2301      	movs	r3, #1
34182aba:	e16d      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
34182abc:	687b      	ldr	r3, [r7, #4]
34182abe:	685b      	ldr	r3, [r3, #4]
34182ac0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34182ac4:	d11a      	bne.n	34182afc <HAL_RCC_ClockConfig+0x15c>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC1 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
34182ac6:	f7ff fb43 	bl	34182150 <LL_RCC_IC1_GetSource>
34182aca:	4602      	mov	r2, r0
34182acc:	687b      	ldr	r3, [r7, #4]
34182ace:	6a1b      	ldr	r3, [r3, #32]
34182ad0:	4619      	mov	r1, r3
34182ad2:	4610      	mov	r0, r2
34182ad4:	f000 fc6e 	bl	341833b4 <RCC_IC_CheckPLLSources>
34182ad8:	4603      	mov	r3, r0
34182ada:	2b01      	cmp	r3, #1
34182adc:	d001      	beq.n	34182ae2 <HAL_RCC_ClockConfig+0x142>
      {
        return HAL_ERROR;
34182ade:	2301      	movs	r3, #1
34182ae0:	e15a      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC1 source and divider */
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
34182ae2:	687b      	ldr	r3, [r7, #4]
34182ae4:	6a1a      	ldr	r2, [r3, #32]
34182ae6:	687b      	ldr	r3, [r7, #4]
34182ae8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182aea:	3b01      	subs	r3, #1
34182aec:	041b      	lsls	r3, r3, #16
34182aee:	4958      	ldr	r1, [pc, #352]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182af0:	4313      	orrs	r3, r2
34182af2:	f8c1 30c4 	str.w	r3, [r1, #196]	@ 0xc4
                ((pRCC_ClkInitStruct->IC1Selection.ClockDivider - 1U) << RCC_IC1CFGR_IC1INT_Pos));

      /* Enable IC1 */
      LL_RCC_IC1_Enable();
34182af6:	f7ff fb1d 	bl	34182134 <LL_RCC_IC1_Enable>
34182afa:	e012      	b.n	34182b22 <HAL_RCC_ClockConfig+0x182>
    }
    /* MSI is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
34182afc:	687b      	ldr	r3, [r7, #4]
34182afe:	685b      	ldr	r3, [r3, #4]
34182b00:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34182b04:	d106      	bne.n	34182b14 <HAL_RCC_ClockConfig+0x174>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
34182b06:	f7ff f9a7 	bl	34181e58 <LL_RCC_MSI_IsReady>
34182b0a:	4603      	mov	r3, r0
34182b0c:	2b00      	cmp	r3, #0
34182b0e:	d108      	bne.n	34182b22 <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
34182b10:	2301      	movs	r3, #1
34182b12:	e141      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
    }
    /* HSI is selected as CPU Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
34182b14:	f7ff f938 	bl	34181d88 <LL_RCC_HSI_IsReady>
34182b18:	4603      	mov	r3, r0
34182b1a:	2b00      	cmp	r3, #0
34182b1c:	d101      	bne.n	34182b22 <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
34182b1e:	2301      	movs	r3, #1
34182b20:	e13a      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the CPU clock */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
34182b22:	4b4b      	ldr	r3, [pc, #300]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182b24:	6a1b      	ldr	r3, [r3, #32]
34182b26:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
34182b2a:	687b      	ldr	r3, [r7, #4]
34182b2c:	685b      	ldr	r3, [r3, #4]
34182b2e:	4948      	ldr	r1, [pc, #288]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182b30:	4313      	orrs	r3, r2
34182b32:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34182b34:	f7fe fd44 	bl	341815c0 <HAL_GetTick>
34182b38:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
34182b3a:	e00a      	b.n	34182b52 <HAL_RCC_ClockConfig+0x1b2>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34182b3c:	f7fe fd40 	bl	341815c0 <HAL_GetTick>
34182b40:	4602      	mov	r2, r0
34182b42:	68fb      	ldr	r3, [r7, #12]
34182b44:	1ad3      	subs	r3, r2, r3
34182b46:	f241 3288 	movw	r2, #5000	@ 0x1388
34182b4a:	4293      	cmp	r3, r2
34182b4c:	d901      	bls.n	34182b52 <HAL_RCC_ClockConfig+0x1b2>
      {
        return HAL_TIMEOUT;
34182b4e:	2303      	movs	r3, #3
34182b50:	e122      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
34182b52:	f7ff f9fb 	bl	34181f4c <LL_RCC_GetCpuClkSource>
34182b56:	4602      	mov	r2, r0
34182b58:	687b      	ldr	r3, [r7, #4]
34182b5a:	685b      	ldr	r3, [r3, #4]
34182b5c:	011b      	lsls	r3, r3, #4
34182b5e:	429a      	cmp	r2, r3
34182b60:	d1ec      	bne.n	34182b3c <HAL_RCC_ClockConfig+0x19c>
      }
    }

    /* Update the SystemCoreClock global variable with CPU clock */
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
34182b62:	f000 f921 	bl	34182da8 <HAL_RCC_GetCpuClockFreq>
34182b66:	4603      	mov	r3, r0
34182b68:	4a3a      	ldr	r2, [pc, #232]	@ (34182c54 <HAL_RCC_ClockConfig+0x2b4>)
34182b6a:	6013      	str	r3, [r2, #0]

  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
34182b6c:	687b      	ldr	r3, [r7, #4]
34182b6e:	681b      	ldr	r3, [r3, #0]
34182b70:	f003 0302 	and.w	r3, r3, #2
34182b74:	2b00      	cmp	r3, #0
34182b76:	f000 8096 	beq.w	34182ca6 <HAL_RCC_ClockConfig+0x306>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System bus clock source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
34182b7a:	687b      	ldr	r3, [r7, #4]
34182b7c:	689b      	ldr	r3, [r3, #8]
34182b7e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34182b82:	d106      	bne.n	34182b92 <HAL_RCC_ClockConfig+0x1f2>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
34182b84:	f7ff f8d0 	bl	34181d28 <LL_RCC_HSE_IsReady>
34182b88:	4603      	mov	r3, r0
34182b8a:	2b00      	cmp	r3, #0
34182b8c:	d16b      	bne.n	34182c66 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
34182b8e:	2301      	movs	r3, #1
34182b90:	e102      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL output is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
34182b92:	687b      	ldr	r3, [r7, #4]
34182b94:	689b      	ldr	r3, [r3, #8]
34182b96:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34182b9a:	d14d      	bne.n	34182c38 <HAL_RCC_ClockConfig+0x298>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC2/IC6/IC11 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
34182b9c:	f7ff faf6 	bl	3418218c <LL_RCC_IC2_GetSource>
34182ba0:	4602      	mov	r2, r0
34182ba2:	687b      	ldr	r3, [r7, #4]
34182ba4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34182ba6:	4619      	mov	r1, r3
34182ba8:	4610      	mov	r0, r2
34182baa:	f000 fc03 	bl	341833b4 <RCC_IC_CheckPLLSources>
34182bae:	4603      	mov	r3, r0
34182bb0:	2b01      	cmp	r3, #1
34182bb2:	d001      	beq.n	34182bb8 <HAL_RCC_ClockConfig+0x218>
      {
        return HAL_ERROR;
34182bb4:	2301      	movs	r3, #1
34182bb6:	e0ef      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
34182bb8:	f7ff faf6 	bl	341821a8 <LL_RCC_IC6_GetSource>
34182bbc:	4602      	mov	r2, r0
34182bbe:	687b      	ldr	r3, [r7, #4]
34182bc0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34182bc2:	4619      	mov	r1, r3
34182bc4:	4610      	mov	r0, r2
34182bc6:	f000 fbf5 	bl	341833b4 <RCC_IC_CheckPLLSources>
34182bca:	4603      	mov	r3, r0
34182bcc:	2b01      	cmp	r3, #1
34182bce:	d001      	beq.n	34182bd4 <HAL_RCC_ClockConfig+0x234>
      {
        return HAL_ERROR;
34182bd0:	2301      	movs	r3, #1
34182bd2:	e0e1      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
34182bd4:	f7ff faf6 	bl	341821c4 <LL_RCC_IC11_GetSource>
34182bd8:	4602      	mov	r2, r0
34182bda:	687b      	ldr	r3, [r7, #4]
34182bdc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34182bde:	4619      	mov	r1, r3
34182be0:	4610      	mov	r0, r2
34182be2:	f000 fbe7 	bl	341833b4 <RCC_IC_CheckPLLSources>
34182be6:	4603      	mov	r3, r0
34182be8:	2b01      	cmp	r3, #1
34182bea:	d001      	beq.n	34182bf0 <HAL_RCC_ClockConfig+0x250>
      {
        return HAL_ERROR;
34182bec:	2301      	movs	r3, #1
34182bee:	e0d3      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC2, IC6 and IC11 sources and dividers */
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
34182bf0:	687b      	ldr	r3, [r7, #4]
34182bf2:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34182bf4:	687b      	ldr	r3, [r7, #4]
34182bf6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34182bf8:	3b01      	subs	r3, #1
34182bfa:	041b      	lsls	r3, r3, #16
34182bfc:	4914      	ldr	r1, [pc, #80]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182bfe:	4313      	orrs	r3, r2
34182c00:	f8c1 30c8 	str.w	r3, [r1, #200]	@ 0xc8
                ((pRCC_ClkInitStruct->IC2Selection.ClockDivider - 1U) << RCC_IC2CFGR_IC2INT_Pos));
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
34182c04:	687b      	ldr	r3, [r7, #4]
34182c06:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
34182c08:	687b      	ldr	r3, [r7, #4]
34182c0a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34182c0c:	3b01      	subs	r3, #1
34182c0e:	041b      	lsls	r3, r3, #16
34182c10:	490f      	ldr	r1, [pc, #60]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182c12:	4313      	orrs	r3, r2
34182c14:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
                ((pRCC_ClkInitStruct->IC6Selection.ClockDivider - 1U) << RCC_IC6CFGR_IC6INT_Pos));
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
34182c18:	687b      	ldr	r3, [r7, #4]
34182c1a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34182c1c:	687b      	ldr	r3, [r7, #4]
34182c1e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34182c20:	3b01      	subs	r3, #1
34182c22:	041b      	lsls	r3, r3, #16
34182c24:	490a      	ldr	r1, [pc, #40]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182c26:	4313      	orrs	r3, r2
34182c28:	f8c1 30ec 	str.w	r3, [r1, #236]	@ 0xec
                ((pRCC_ClkInitStruct->IC11Selection.ClockDivider - 1U) << RCC_IC11CFGR_IC11INT_Pos));

      /* Require to have IC2, IC6 and IC11 outputs enabled */
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
34182c2c:	4b08      	ldr	r3, [pc, #32]	@ (34182c50 <HAL_RCC_ClockConfig+0x2b0>)
34182c2e:	f240 4222 	movw	r2, #1058	@ 0x422
34182c32:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
34182c36:	e016      	b.n	34182c66 <HAL_RCC_ClockConfig+0x2c6>
    }
    /* HSI is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
34182c38:	687b      	ldr	r3, [r7, #4]
34182c3a:	689b      	ldr	r3, [r3, #8]
34182c3c:	2b00      	cmp	r3, #0
34182c3e:	d10b      	bne.n	34182c58 <HAL_RCC_ClockConfig+0x2b8>
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
34182c40:	f7ff f8a2 	bl	34181d88 <LL_RCC_HSI_IsReady>
34182c44:	4603      	mov	r3, r0
34182c46:	2b00      	cmp	r3, #0
34182c48:	d10d      	bne.n	34182c66 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
34182c4a:	2301      	movs	r3, #1
34182c4c:	e0a4      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
34182c4e:	bf00      	nop
34182c50:	56028000 	.word	0x56028000
34182c54:	341c0000 	.word	0x341c0000
    }
    /* MSI is selected as System bus clock source */
    else
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
34182c58:	f7ff f8fe 	bl	34181e58 <LL_RCC_MSI_IsReady>
34182c5c:	4603      	mov	r3, r0
34182c5e:	2b00      	cmp	r3, #0
34182c60:	d101      	bne.n	34182c66 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
34182c62:	2301      	movs	r3, #1
34182c64:	e098      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the system bus clocks */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
34182c66:	4b4e      	ldr	r3, [pc, #312]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182c68:	6a1b      	ldr	r3, [r3, #32]
34182c6a:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34182c6e:	687b      	ldr	r3, [r7, #4]
34182c70:	689b      	ldr	r3, [r3, #8]
34182c72:	494b      	ldr	r1, [pc, #300]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182c74:	4313      	orrs	r3, r2
34182c76:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34182c78:	f7fe fca2 	bl	341815c0 <HAL_GetTick>
34182c7c:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
34182c7e:	e00a      	b.n	34182c96 <HAL_RCC_ClockConfig+0x2f6>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34182c80:	f7fe fc9e 	bl	341815c0 <HAL_GetTick>
34182c84:	4602      	mov	r2, r0
34182c86:	68fb      	ldr	r3, [r7, #12]
34182c88:	1ad3      	subs	r3, r2, r3
34182c8a:	f241 3288 	movw	r2, #5000	@ 0x1388
34182c8e:	4293      	cmp	r3, r2
34182c90:	d901      	bls.n	34182c96 <HAL_RCC_ClockConfig+0x2f6>
      {
        return HAL_TIMEOUT;
34182c92:	2303      	movs	r3, #3
34182c94:	e080      	b.n	34182d98 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
34182c96:	f7ff f967 	bl	34181f68 <LL_RCC_GetSysClkSource>
34182c9a:	4602      	mov	r2, r0
34182c9c:	687b      	ldr	r3, [r7, #4]
34182c9e:	689b      	ldr	r3, [r3, #8]
34182ca0:	011b      	lsls	r3, r3, #4
34182ca2:	429a      	cmp	r2, r3
34182ca4:	d1ec      	bne.n	34182c80 <HAL_RCC_ClockConfig+0x2e0>
  }

  /* Decreasing the BUS frequency divider ? */

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34182ca6:	687b      	ldr	r3, [r7, #4]
34182ca8:	681b      	ldr	r3, [r3, #0]
34182caa:	f003 0304 	and.w	r3, r3, #4
34182cae:	2b00      	cmp	r3, #0
34182cb0:	d010      	beq.n	34182cd4 <HAL_RCC_ClockConfig+0x334>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
34182cb2:	687b      	ldr	r3, [r7, #4]
34182cb4:	68da      	ldr	r2, [r3, #12]
34182cb6:	4b3a      	ldr	r3, [pc, #232]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182cb8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182cba:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
34182cbe:	429a      	cmp	r2, r3
34182cc0:	d208      	bcs.n	34182cd4 <HAL_RCC_ClockConfig+0x334>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
34182cc2:	4b37      	ldr	r3, [pc, #220]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182cc4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182cc6:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
34182cca:	687b      	ldr	r3, [r7, #4]
34182ccc:	68db      	ldr	r3, [r3, #12]
34182cce:	4934      	ldr	r1, [pc, #208]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182cd0:	4313      	orrs	r3, r2
34182cd2:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
34182cd4:	687b      	ldr	r3, [r7, #4]
34182cd6:	681b      	ldr	r3, [r3, #0]
34182cd8:	f003 0308 	and.w	r3, r3, #8
34182cdc:	2b00      	cmp	r3, #0
34182cde:	d010      	beq.n	34182d02 <HAL_RCC_ClockConfig+0x362>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
34182ce0:	687b      	ldr	r3, [r7, #4]
34182ce2:	691a      	ldr	r2, [r3, #16]
34182ce4:	4b2e      	ldr	r3, [pc, #184]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182ce6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182ce8:	f003 0307 	and.w	r3, r3, #7
34182cec:	429a      	cmp	r2, r3
34182cee:	d208      	bcs.n	34182d02 <HAL_RCC_ClockConfig+0x362>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34182cf0:	4b2b      	ldr	r3, [pc, #172]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182cf2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182cf4:	f023 0207 	bic.w	r2, r3, #7
34182cf8:	687b      	ldr	r3, [r7, #4]
34182cfa:	691b      	ldr	r3, [r3, #16]
34182cfc:	4928      	ldr	r1, [pc, #160]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182cfe:	4313      	orrs	r3, r2
34182d00:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
34182d02:	687b      	ldr	r3, [r7, #4]
34182d04:	681b      	ldr	r3, [r3, #0]
34182d06:	f003 0310 	and.w	r3, r3, #16
34182d0a:	2b00      	cmp	r3, #0
34182d0c:	d010      	beq.n	34182d30 <HAL_RCC_ClockConfig+0x390>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34182d0e:	687b      	ldr	r3, [r7, #4]
34182d10:	695a      	ldr	r2, [r3, #20]
34182d12:	4b23      	ldr	r3, [pc, #140]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182d14:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182d16:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34182d1a:	429a      	cmp	r2, r3
34182d1c:	d208      	bcs.n	34182d30 <HAL_RCC_ClockConfig+0x390>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34182d1e:	4b20      	ldr	r3, [pc, #128]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182d20:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182d22:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
34182d26:	687b      	ldr	r3, [r7, #4]
34182d28:	695b      	ldr	r3, [r3, #20]
34182d2a:	491d      	ldr	r1, [pc, #116]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182d2c:	4313      	orrs	r3, r2
34182d2e:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34182d30:	687b      	ldr	r3, [r7, #4]
34182d32:	681b      	ldr	r3, [r3, #0]
34182d34:	f003 0320 	and.w	r3, r3, #32
34182d38:	2b00      	cmp	r3, #0
34182d3a:	d010      	beq.n	34182d5e <HAL_RCC_ClockConfig+0x3be>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34182d3c:	687b      	ldr	r3, [r7, #4]
34182d3e:	699a      	ldr	r2, [r3, #24]
34182d40:	4b17      	ldr	r3, [pc, #92]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182d42:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182d44:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34182d48:	429a      	cmp	r2, r3
34182d4a:	d208      	bcs.n	34182d5e <HAL_RCC_ClockConfig+0x3be>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
34182d4c:	4b14      	ldr	r3, [pc, #80]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182d4e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182d50:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
34182d54:	687b      	ldr	r3, [r7, #4]
34182d56:	699b      	ldr	r3, [r3, #24]
34182d58:	4911      	ldr	r1, [pc, #68]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182d5a:	4313      	orrs	r3, r2
34182d5c:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34182d5e:	687b      	ldr	r3, [r7, #4]
34182d60:	681b      	ldr	r3, [r3, #0]
34182d62:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34182d66:	2b00      	cmp	r3, #0
34182d68:	d010      	beq.n	34182d8c <HAL_RCC_ClockConfig+0x3ec>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34182d6a:	687b      	ldr	r3, [r7, #4]
34182d6c:	69da      	ldr	r2, [r3, #28]
34182d6e:	4b0c      	ldr	r3, [pc, #48]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182d70:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182d72:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34182d76:	429a      	cmp	r2, r3
34182d78:	d208      	bcs.n	34182d8c <HAL_RCC_ClockConfig+0x3ec>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34182d7a:	4b09      	ldr	r3, [pc, #36]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182d7c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182d7e:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34182d82:	687b      	ldr	r3, [r7, #4]
34182d84:	69db      	ldr	r3, [r3, #28]
34182d86:	4906      	ldr	r1, [pc, #24]	@ (34182da0 <HAL_RCC_ClockConfig+0x400>)
34182d88:	4313      	orrs	r3, r2
34182d8a:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
34182d8c:	4b05      	ldr	r3, [pc, #20]	@ (34182da4 <HAL_RCC_ClockConfig+0x404>)
34182d8e:	681b      	ldr	r3, [r3, #0]
34182d90:	4618      	mov	r0, r3
34182d92:	f7fe fbcb 	bl	3418152c <HAL_InitTick>
34182d96:	4603      	mov	r3, r0
}
34182d98:	4618      	mov	r0, r3
34182d9a:	3710      	adds	r7, #16
34182d9c:	46bd      	mov	sp, r7
34182d9e:	bd80      	pop	{r7, pc}
34182da0:	56028000 	.word	0x56028000
34182da4:	341c0004 	.word	0x341c0004

34182da8 <HAL_RCC_GetCpuClockFreq>:
  *         will be incorrect.
  *
  * @retval CPUCLK frequency
  */
uint32_t HAL_RCC_GetCpuClockFreq(void)
{
34182da8:	b580      	push	{r7, lr}
34182daa:	b082      	sub	sp, #8
34182dac:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
34182dae:	2300      	movs	r3, #0
34182db0:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetCpuClkSource())
34182db2:	f7ff f8cb 	bl	34181f4c <LL_RCC_GetCpuClkSource>
34182db6:	4603      	mov	r3, r0
34182db8:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34182dbc:	d026      	beq.n	34182e0c <HAL_RCC_GetCpuClockFreq+0x64>
34182dbe:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34182dc2:	d861      	bhi.n	34182e88 <HAL_RCC_GetCpuClockFreq+0xe0>
34182dc4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34182dc8:	d01d      	beq.n	34182e06 <HAL_RCC_GetCpuClockFreq+0x5e>
34182dca:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34182dce:	d85b      	bhi.n	34182e88 <HAL_RCC_GetCpuClockFreq+0xe0>
34182dd0:	2b00      	cmp	r3, #0
34182dd2:	d003      	beq.n	34182ddc <HAL_RCC_GetCpuClockFreq+0x34>
34182dd4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34182dd8:	d009      	beq.n	34182dee <HAL_RCC_GetCpuClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
34182dda:	e055      	b.n	34182e88 <HAL_RCC_GetCpuClockFreq+0xe0>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34182ddc:	f7fe fffa 	bl	34181dd4 <LL_RCC_HSI_GetDivider>
34182de0:	4603      	mov	r3, r0
34182de2:	09db      	lsrs	r3, r3, #7
34182de4:	4a2b      	ldr	r2, [pc, #172]	@ (34182e94 <HAL_RCC_GetCpuClockFreq+0xec>)
34182de6:	fa22 f303 	lsr.w	r3, r2, r3
34182dea:	607b      	str	r3, [r7, #4]
      break;
34182dec:	e04d      	b.n	34182e8a <HAL_RCC_GetCpuClockFreq+0xe2>
      frequency = RCC_GET_MSI_FREQUENCY();
34182dee:	4b2a      	ldr	r3, [pc, #168]	@ (34182e98 <HAL_RCC_GetCpuClockFreq+0xf0>)
34182df0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34182df2:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34182df6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34182dfa:	d101      	bne.n	34182e00 <HAL_RCC_GetCpuClockFreq+0x58>
34182dfc:	4b27      	ldr	r3, [pc, #156]	@ (34182e9c <HAL_RCC_GetCpuClockFreq+0xf4>)
34182dfe:	e000      	b.n	34182e02 <HAL_RCC_GetCpuClockFreq+0x5a>
34182e00:	4b27      	ldr	r3, [pc, #156]	@ (34182ea0 <HAL_RCC_GetCpuClockFreq+0xf8>)
34182e02:	607b      	str	r3, [r7, #4]
      break;
34182e04:	e041      	b.n	34182e8a <HAL_RCC_GetCpuClockFreq+0xe2>
      frequency = HSE_VALUE;
34182e06:	4b27      	ldr	r3, [pc, #156]	@ (34182ea4 <HAL_RCC_GetCpuClockFreq+0xfc>)
34182e08:	607b      	str	r3, [r7, #4]
      break;
34182e0a:	e03e      	b.n	34182e8a <HAL_RCC_GetCpuClockFreq+0xe2>
      ic_divider = LL_RCC_IC1_GetDivider();
34182e0c:	f7ff f9ae 	bl	3418216c <LL_RCC_IC1_GetDivider>
34182e10:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC1_GetSource())
34182e12:	f7ff f99d 	bl	34182150 <LL_RCC_IC1_GetSource>
34182e16:	4603      	mov	r3, r0
34182e18:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182e1c:	d029      	beq.n	34182e72 <HAL_RCC_GetCpuClockFreq+0xca>
34182e1e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182e22:	d82f      	bhi.n	34182e84 <HAL_RCC_GetCpuClockFreq+0xdc>
34182e24:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34182e28:	d01a      	beq.n	34182e60 <HAL_RCC_GetCpuClockFreq+0xb8>
34182e2a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34182e2e:	d829      	bhi.n	34182e84 <HAL_RCC_GetCpuClockFreq+0xdc>
34182e30:	2b00      	cmp	r3, #0
34182e32:	d003      	beq.n	34182e3c <HAL_RCC_GetCpuClockFreq+0x94>
34182e34:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34182e38:	d009      	beq.n	34182e4e <HAL_RCC_GetCpuClockFreq+0xa6>
          break;
34182e3a:	e023      	b.n	34182e84 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
34182e3c:	f003 fc46 	bl	341866cc <HAL_RCCEx_GetPLL1CLKFreq>
34182e40:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34182e42:	687a      	ldr	r2, [r7, #4]
34182e44:	683b      	ldr	r3, [r7, #0]
34182e46:	fbb2 f3f3 	udiv	r3, r2, r3
34182e4a:	607b      	str	r3, [r7, #4]
          break;
34182e4c:	e01b      	b.n	34182e86 <HAL_RCC_GetCpuClockFreq+0xde>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
34182e4e:	f003 fc83 	bl	34186758 <HAL_RCCEx_GetPLL2CLKFreq>
34182e52:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34182e54:	687a      	ldr	r2, [r7, #4]
34182e56:	683b      	ldr	r3, [r7, #0]
34182e58:	fbb2 f3f3 	udiv	r3, r2, r3
34182e5c:	607b      	str	r3, [r7, #4]
          break;
34182e5e:	e012      	b.n	34182e86 <HAL_RCC_GetCpuClockFreq+0xde>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
34182e60:	f003 fcc0 	bl	341867e4 <HAL_RCCEx_GetPLL3CLKFreq>
34182e64:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34182e66:	687a      	ldr	r2, [r7, #4]
34182e68:	683b      	ldr	r3, [r7, #0]
34182e6a:	fbb2 f3f3 	udiv	r3, r2, r3
34182e6e:	607b      	str	r3, [r7, #4]
          break;
34182e70:	e009      	b.n	34182e86 <HAL_RCC_GetCpuClockFreq+0xde>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
34182e72:	f003 fcfd 	bl	34186870 <HAL_RCCEx_GetPLL4CLKFreq>
34182e76:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34182e78:	687a      	ldr	r2, [r7, #4]
34182e7a:	683b      	ldr	r3, [r7, #0]
34182e7c:	fbb2 f3f3 	udiv	r3, r2, r3
34182e80:	607b      	str	r3, [r7, #4]
          break;
34182e82:	e000      	b.n	34182e86 <HAL_RCC_GetCpuClockFreq+0xde>
          break;
34182e84:	bf00      	nop
      break;
34182e86:	e000      	b.n	34182e8a <HAL_RCC_GetCpuClockFreq+0xe2>
      break;
34182e88:	bf00      	nop
  }

  return frequency;
34182e8a:	687b      	ldr	r3, [r7, #4]
}
34182e8c:	4618      	mov	r0, r3
34182e8e:	3708      	adds	r7, #8
34182e90:	46bd      	mov	sp, r7
34182e92:	bd80      	pop	{r7, pc}
34182e94:	03d09000 	.word	0x03d09000
34182e98:	56028000 	.word	0x56028000
34182e9c:	00f42400 	.word	0x00f42400
34182ea0:	003d0900 	.word	0x003d0900
34182ea4:	02dc6c00 	.word	0x02dc6c00

34182ea8 <HAL_RCC_GetClockConfig>:
  * @param  pRCC_ClkInitStruct  Pointer to an RCC_ClkInitTypeDef structure that
  *         will return the configuration.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
34182ea8:	b480      	push	{r7}
34182eaa:	b085      	sub	sp, #20
34182eac:	af00      	add	r7, sp, #0
34182eae:	6078      	str	r0, [r7, #4]
  uint32_t cfgr_value;

  /* Set all possible values for the Clock type parameter --------------------*/
  pRCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK | \
34182eb0:	687b      	ldr	r3, [r7, #4]
34182eb2:	227f      	movs	r2, #127	@ 0x7f
34182eb4:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_HCLK   | \
                                  RCC_CLOCKTYPE_PCLK1  | RCC_CLOCKTYPE_PCLK2 | \
                                  RCC_CLOCKTYPE_PCLK4  | RCC_CLOCKTYPE_PCLK5;

  /* Get the configuration register 1 value */
  cfgr_value = RCC->CFGR1;
34182eb6:	4b36      	ldr	r3, [pc, #216]	@ (34182f90 <HAL_RCC_GetClockConfig+0xe8>)
34182eb8:	6a1b      	ldr	r3, [r3, #32]
34182eba:	60fb      	str	r3, [r7, #12]

  /* Get the active CPU source -----------------------------------------------*/
  pRCC_ClkInitStruct->CPUCLKSource = (cfgr_value & RCC_CFGR1_CPUSWS) >> 4U;
34182ebc:	68fb      	ldr	r3, [r7, #12]
34182ebe:	091b      	lsrs	r3, r3, #4
34182ec0:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
34182ec4:	687b      	ldr	r3, [r7, #4]
34182ec6:	605a      	str	r2, [r3, #4]

  /* Get the active SYSCLK bus source ----------------------------------------*/
  pRCC_ClkInitStruct->SYSCLKSource = (cfgr_value & RCC_CFGR1_SYSSWS) >> 4U;
34182ec8:	68fb      	ldr	r3, [r7, #12]
34182eca:	091b      	lsrs	r3, r3, #4
34182ecc:	f003 7240 	and.w	r2, r3, #50331648	@ 0x3000000
34182ed0:	687b      	ldr	r3, [r7, #4]
34182ed2:	609a      	str	r2, [r3, #8]

  /* Get the configuration register 2 value */
  cfgr_value = RCC->CFGR2;
34182ed4:	4b2e      	ldr	r3, [pc, #184]	@ (34182f90 <HAL_RCC_GetClockConfig+0xe8>)
34182ed6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182ed8:	60fb      	str	r3, [r7, #12]

  /* Get the HCLK configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->AHBCLKDivider = (cfgr_value & RCC_CFGR2_HPRE);
34182eda:	68fb      	ldr	r3, [r7, #12]
34182edc:	f403 02e0 	and.w	r2, r3, #7340032	@ 0x700000
34182ee0:	687b      	ldr	r3, [r7, #4]
34182ee2:	60da      	str	r2, [r3, #12]

  /* Get the APB1 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB1CLKDivider = (cfgr_value & RCC_CFGR2_PPRE1);
34182ee4:	68fb      	ldr	r3, [r7, #12]
34182ee6:	f003 0207 	and.w	r2, r3, #7
34182eea:	687b      	ldr	r3, [r7, #4]
34182eec:	611a      	str	r2, [r3, #16]

  /* Get the APB2 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB2CLKDivider = (cfgr_value & RCC_CFGR2_PPRE2);
34182eee:	68fb      	ldr	r3, [r7, #12]
34182ef0:	f003 0270 	and.w	r2, r3, #112	@ 0x70
34182ef4:	687b      	ldr	r3, [r7, #4]
34182ef6:	615a      	str	r2, [r3, #20]

  /* Get the APB4 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB4CLKDivider = (cfgr_value & RCC_CFGR2_PPRE4);
34182ef8:	68fb      	ldr	r3, [r7, #12]
34182efa:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
34182efe:	687b      	ldr	r3, [r7, #4]
34182f00:	619a      	str	r2, [r3, #24]

  /* Get the APB5 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB5CLKDivider = (cfgr_value & RCC_CFGR2_PPRE5);
34182f02:	68fb      	ldr	r3, [r7, #12]
34182f04:	f403 22e0 	and.w	r2, r3, #458752	@ 0x70000
34182f08:	687b      	ldr	r3, [r7, #4]
34182f0a:	61da      	str	r2, [r3, #28]

  /* Get the IC1 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC1CFGR;
34182f0c:	4b20      	ldr	r3, [pc, #128]	@ (34182f90 <HAL_RCC_GetClockConfig+0xe8>)
34182f0e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34182f12:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC1Selection.ClockSelection = cfgr_value & RCC_IC1CFGR_IC1SEL;
34182f14:	68fb      	ldr	r3, [r7, #12]
34182f16:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
34182f1a:	687b      	ldr	r3, [r7, #4]
34182f1c:	621a      	str	r2, [r3, #32]
  pRCC_ClkInitStruct->IC1Selection.ClockDivider = ((cfgr_value & RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1U;
34182f1e:	68fb      	ldr	r3, [r7, #12]
34182f20:	0c1b      	lsrs	r3, r3, #16
34182f22:	b2db      	uxtb	r3, r3
34182f24:	1c5a      	adds	r2, r3, #1
34182f26:	687b      	ldr	r3, [r7, #4]
34182f28:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Get the IC2 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC2CFGR;
34182f2a:	4b19      	ldr	r3, [pc, #100]	@ (34182f90 <HAL_RCC_GetClockConfig+0xe8>)
34182f2c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34182f30:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC2Selection.ClockSelection = cfgr_value & RCC_IC2CFGR_IC2SEL;
34182f32:	68fb      	ldr	r3, [r7, #12]
34182f34:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
34182f38:	687b      	ldr	r3, [r7, #4]
34182f3a:	629a      	str	r2, [r3, #40]	@ 0x28
  pRCC_ClkInitStruct->IC2Selection.ClockDivider = ((cfgr_value & RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1U;
34182f3c:	68fb      	ldr	r3, [r7, #12]
34182f3e:	0c1b      	lsrs	r3, r3, #16
34182f40:	b2db      	uxtb	r3, r3
34182f42:	1c5a      	adds	r2, r3, #1
34182f44:	687b      	ldr	r3, [r7, #4]
34182f46:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Get the IC6 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC6CFGR;
34182f48:	4b11      	ldr	r3, [pc, #68]	@ (34182f90 <HAL_RCC_GetClockConfig+0xe8>)
34182f4a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34182f4e:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC6Selection.ClockSelection = cfgr_value & RCC_IC6CFGR_IC6SEL;
34182f50:	68fb      	ldr	r3, [r7, #12]
34182f52:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
34182f56:	687b      	ldr	r3, [r7, #4]
34182f58:	631a      	str	r2, [r3, #48]	@ 0x30
  pRCC_ClkInitStruct->IC6Selection.ClockDivider = ((cfgr_value & RCC_IC6CFGR_IC6INT) >> RCC_IC6CFGR_IC6INT_Pos) + 1U;
34182f5a:	68fb      	ldr	r3, [r7, #12]
34182f5c:	0c1b      	lsrs	r3, r3, #16
34182f5e:	b2db      	uxtb	r3, r3
34182f60:	1c5a      	adds	r2, r3, #1
34182f62:	687b      	ldr	r3, [r7, #4]
34182f64:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Get the IC11 configuration ----------------------------------------------*/
  cfgr_value = RCC->IC11CFGR;
34182f66:	4b0a      	ldr	r3, [pc, #40]	@ (34182f90 <HAL_RCC_GetClockConfig+0xe8>)
34182f68:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34182f6c:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC11Selection.ClockSelection = cfgr_value & RCC_IC11CFGR_IC11SEL;
34182f6e:	68fb      	ldr	r3, [r7, #12]
34182f70:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
34182f74:	687b      	ldr	r3, [r7, #4]
34182f76:	639a      	str	r2, [r3, #56]	@ 0x38
  pRCC_ClkInitStruct->IC11Selection.ClockDivider = ((cfgr_value & RCC_IC11CFGR_IC11INT) >> RCC_IC11CFGR_IC11INT_Pos) + 1U;
34182f78:	68fb      	ldr	r3, [r7, #12]
34182f7a:	0c1b      	lsrs	r3, r3, #16
34182f7c:	b2db      	uxtb	r3, r3
34182f7e:	1c5a      	adds	r2, r3, #1
34182f80:	687b      	ldr	r3, [r7, #4]
34182f82:	63da      	str	r2, [r3, #60]	@ 0x3c
}
34182f84:	bf00      	nop
34182f86:	3714      	adds	r7, #20
34182f88:	46bd      	mov	sp, r7
34182f8a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f8e:	4770      	bx	lr
34182f90:	56028000 	.word	0x56028000

34182f94 <RCC_PLL_Config>:
  * @note   PLL is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Config(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
34182f94:	b580      	push	{r7, lr}
34182f96:	b088      	sub	sp, #32
34182f98:	af00      	add	r7, sp, #0
34182f9a:	6078      	str	r0, [r7, #4]
34182f9c:	6039      	str	r1, [r7, #0]
  __IO uint32_t *p_rcc_pll_cfgr1_reg;
  __IO uint32_t *p_rcc_pll_cfgr2_reg;
  __IO uint32_t *p_rcc_pll_cfgr3_reg;
  HAL_StatusTypeDef ret = HAL_OK;
34182f9e:	2300      	movs	r3, #0
34182fa0:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart;

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34182fa2:	687b      	ldr	r3, [r7, #4]
34182fa4:	011a      	lsls	r2, r3, #4
34182fa6:	4b8e      	ldr	r3, [pc, #568]	@ (341831e0 <RCC_PLL_Config+0x24c>)
34182fa8:	4413      	add	r3, r2
34182faa:	61bb      	str	r3, [r7, #24]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
34182fac:	687b      	ldr	r3, [r7, #4]
34182fae:	011a      	lsls	r2, r3, #4
34182fb0:	4b8c      	ldr	r3, [pc, #560]	@ (341831e4 <RCC_PLL_Config+0x250>)
34182fb2:	4413      	add	r3, r2
34182fb4:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
34182fb6:	687b      	ldr	r3, [r7, #4]
34182fb8:	011a      	lsls	r2, r3, #4
34182fba:	4b8b      	ldr	r3, [pc, #556]	@ (341831e8 <RCC_PLL_Config+0x254>)
34182fbc:	4413      	add	r3, r2
34182fbe:	613b      	str	r3, [r7, #16]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */
  if (pPLLInit->PLLState == RCC_PLL_ON)
34182fc0:	683b      	ldr	r3, [r7, #0]
34182fc2:	681b      	ldr	r3, [r3, #0]
34182fc4:	2b02      	cmp	r3, #2
34182fc6:	f040 8091 	bne.w	341830ec <RCC_PLL_Config+0x158>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34182fca:	4a88      	ldr	r2, [pc, #544]	@ (341831ec <RCC_PLL_Config+0x258>)
34182fcc:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182fd0:	687b      	ldr	r3, [r7, #4]
34182fd2:	fa01 f303 	lsl.w	r3, r1, r3
34182fd6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34182fda:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34182fdc:	f7fe faf0 	bl	341815c0 <HAL_GetTick>
34182fe0:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34182fe2:	e008      	b.n	34182ff6 <RCC_PLL_Config+0x62>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34182fe4:	f7fe faec 	bl	341815c0 <HAL_GetTick>
34182fe8:	4602      	mov	r2, r0
34182fea:	68fb      	ldr	r3, [r7, #12]
34182fec:	1ad3      	subs	r3, r2, r3
34182fee:	2b01      	cmp	r3, #1
34182ff0:	d901      	bls.n	34182ff6 <RCC_PLL_Config+0x62>
      {
        return HAL_TIMEOUT;
34182ff2:	2303      	movs	r3, #3
34182ff4:	e0f0      	b.n	341831d8 <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34182ff6:	4b7d      	ldr	r3, [pc, #500]	@ (341831ec <RCC_PLL_Config+0x258>)
34182ff8:	685a      	ldr	r2, [r3, #4]
34182ffa:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182ffe:	687b      	ldr	r3, [r7, #4]
34183000:	fa01 f303 	lsl.w	r3, r1, r3
34183004:	401a      	ands	r2, r3
34183006:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418300a:	687b      	ldr	r3, [r7, #4]
3418300c:	fa01 f303 	lsl.w	r3, r1, r3
34183010:	429a      	cmp	r2, r3
34183012:	d0e7      	beq.n	34182fe4 <RCC_PLL_Config+0x50>
      }
    }

    /* Ensure PLLxMODSSDIS='1' */
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
34183014:	693b      	ldr	r3, [r7, #16]
34183016:	681b      	ldr	r3, [r3, #0]
34183018:	f043 0204 	orr.w	r2, r3, #4
3418301c:	693b      	ldr	r3, [r7, #16]
3418301e:	601a      	str	r2, [r3, #0]

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
34183020:	69bb      	ldr	r3, [r7, #24]
34183022:	681b      	ldr	r3, [r3, #0]
34183024:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
34183028:	69bb      	ldr	r3, [r7, #24]
3418302a:	601a      	str	r2, [r3, #0]

    /* Configure the PLLx clock source, multiplication and division factors. */
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
3418302c:	69bb      	ldr	r3, [r7, #24]
3418302e:	681a      	ldr	r2, [r3, #0]
34183030:	4b6f      	ldr	r3, [pc, #444]	@ (341831f0 <RCC_PLL_Config+0x25c>)
34183032:	4013      	ands	r3, r2
34183034:	683a      	ldr	r2, [r7, #0]
34183036:	6851      	ldr	r1, [r2, #4]
34183038:	683a      	ldr	r2, [r7, #0]
3418303a:	6892      	ldr	r2, [r2, #8]
3418303c:	0512      	lsls	r2, r2, #20
3418303e:	4311      	orrs	r1, r2
34183040:	683a      	ldr	r2, [r7, #0]
34183042:	6912      	ldr	r2, [r2, #16]
34183044:	0212      	lsls	r2, r2, #8
34183046:	430a      	orrs	r2, r1
34183048:	431a      	orrs	r2, r3
3418304a:	69bb      	ldr	r3, [r7, #24]
3418304c:	601a      	str	r2, [r3, #0]
               (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
                | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)));
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
3418304e:	693b      	ldr	r3, [r7, #16]
34183050:	681b      	ldr	r3, [r3, #0]
34183052:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
34183056:	683b      	ldr	r3, [r7, #0]
34183058:	695b      	ldr	r3, [r3, #20]
3418305a:	06d9      	lsls	r1, r3, #27
3418305c:	683b      	ldr	r3, [r7, #0]
3418305e:	699b      	ldr	r3, [r3, #24]
34183060:	061b      	lsls	r3, r3, #24
34183062:	430b      	orrs	r3, r1
34183064:	431a      	orrs	r2, r3
34183066:	693b      	ldr	r3, [r7, #16]
34183068:	601a      	str	r2, [r3, #0]
               ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)));

    /* Configure PLLx DIVNFRAC */
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
3418306a:	697b      	ldr	r3, [r7, #20]
3418306c:	681b      	ldr	r3, [r3, #0]
3418306e:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
34183072:	683b      	ldr	r3, [r7, #0]
34183074:	68db      	ldr	r3, [r3, #12]
34183076:	431a      	orrs	r2, r3
34183078:	697b      	ldr	r3, [r7, #20]
3418307a:	601a      	str	r2, [r3, #0]
               pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);

    /* Clear PLLxMODDSEN (Also clear in Fractional Mode to ensure the latch of updated FRAC value when set again) */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
3418307c:	693b      	ldr	r3, [r7, #16]
3418307e:	681b      	ldr	r3, [r3, #0]
34183080:	f023 0208 	bic.w	r2, r3, #8
34183084:	693b      	ldr	r3, [r7, #16]
34183086:	601a      	str	r2, [r3, #0]

    /* Fractional Mode specificities Management */
    if (pPLLInit->PLLFractional != 0U)
34183088:	683b      	ldr	r3, [r7, #0]
3418308a:	68db      	ldr	r3, [r3, #12]
3418308c:	2b00      	cmp	r3, #0
3418308e:	d005      	beq.n	3418309c <RCC_PLL_Config+0x108>
    {
      /* Set PLLxMODDSEN and DACEN */
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
34183090:	693b      	ldr	r3, [r7, #16]
34183092:	681b      	ldr	r3, [r3, #0]
34183094:	f043 020a 	orr.w	r2, r3, #10
34183098:	693b      	ldr	r3, [r7, #16]
3418309a:	601a      	str	r2, [r3, #0]
    }

    /* Ensure PLLxMODSSRST='1' and Enable PLLx post divider output */
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
3418309c:	693b      	ldr	r3, [r7, #16]
3418309e:	681b      	ldr	r3, [r3, #0]
341830a0:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
341830a4:	f043 0301 	orr.w	r3, r3, #1
341830a8:	693a      	ldr	r2, [r7, #16]
341830aa:	6013      	str	r3, [r2, #0]

    /* Enable the PLLx */
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
341830ac:	4a4f      	ldr	r2, [pc, #316]	@ (341831ec <RCC_PLL_Config+0x258>)
341830ae:	f44f 7180 	mov.w	r1, #256	@ 0x100
341830b2:	687b      	ldr	r3, [r7, #4]
341830b4:	fa01 f303 	lsl.w	r3, r1, r3
341830b8:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
341830bc:	f7fe fa80 	bl	341815c0 <HAL_GetTick>
341830c0:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is ready */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
341830c2:	e008      	b.n	341830d6 <RCC_PLL_Config+0x142>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
341830c4:	f7fe fa7c 	bl	341815c0 <HAL_GetTick>
341830c8:	4602      	mov	r2, r0
341830ca:	68fb      	ldr	r3, [r7, #12]
341830cc:	1ad3      	subs	r3, r2, r3
341830ce:	2b01      	cmp	r3, #1
341830d0:	d901      	bls.n	341830d6 <RCC_PLL_Config+0x142>
      {
        return HAL_TIMEOUT;
341830d2:	2303      	movs	r3, #3
341830d4:	e080      	b.n	341831d8 <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
341830d6:	4b45      	ldr	r3, [pc, #276]	@ (341831ec <RCC_PLL_Config+0x258>)
341830d8:	685a      	ldr	r2, [r3, #4]
341830da:	f44f 7180 	mov.w	r1, #256	@ 0x100
341830de:	687b      	ldr	r3, [r7, #4]
341830e0:	fa01 f303 	lsl.w	r3, r1, r3
341830e4:	4013      	ands	r3, r2
341830e6:	2b00      	cmp	r3, #0
341830e8:	d0ec      	beq.n	341830c4 <RCC_PLL_Config+0x130>
341830ea:	e074      	b.n	341831d6 <RCC_PLL_Config+0x242>
      }
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
341830ec:	683b      	ldr	r3, [r7, #0]
341830ee:	681b      	ldr	r3, [r3, #0]
341830f0:	2b03      	cmp	r3, #3
341830f2:	d13b      	bne.n	3418316c <RCC_PLL_Config+0x1d8>
  {
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));

    /* Check selected source is ready */
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
341830f4:	683b      	ldr	r3, [r7, #0]
341830f6:	685b      	ldr	r3, [r3, #4]
341830f8:	4618      	mov	r0, r3
341830fa:	f000 f921 	bl	34183340 <RCC_PLL_Source_IsReady>
341830fe:	4603      	mov	r3, r0
34183100:	2b01      	cmp	r3, #1
34183102:	d130      	bne.n	34183166 <RCC_PLL_Config+0x1d2>
    {
      /* Ensure PLLx is disabled */
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34183104:	4a39      	ldr	r2, [pc, #228]	@ (341831ec <RCC_PLL_Config+0x258>)
34183106:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418310a:	687b      	ldr	r3, [r7, #4]
3418310c:	fa01 f303 	lsl.w	r3, r1, r3
34183110:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34183114:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34183116:	f7fe fa53 	bl	341815c0 <HAL_GetTick>
3418311a:	60f8      	str	r0, [r7, #12]

      /* Wait till PLLx is disabled */
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418311c:	e008      	b.n	34183130 <RCC_PLL_Config+0x19c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418311e:	f7fe fa4f 	bl	341815c0 <HAL_GetTick>
34183122:	4602      	mov	r2, r0
34183124:	68fb      	ldr	r3, [r7, #12]
34183126:	1ad3      	subs	r3, r2, r3
34183128:	2b01      	cmp	r3, #1
3418312a:	d901      	bls.n	34183130 <RCC_PLL_Config+0x19c>
        {
          return HAL_TIMEOUT;
3418312c:	2303      	movs	r3, #3
3418312e:	e053      	b.n	341831d8 <RCC_PLL_Config+0x244>
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34183130:	4b2e      	ldr	r3, [pc, #184]	@ (341831ec <RCC_PLL_Config+0x258>)
34183132:	685a      	ldr	r2, [r3, #4]
34183134:	f44f 7180 	mov.w	r1, #256	@ 0x100
34183138:	687b      	ldr	r3, [r7, #4]
3418313a:	fa01 f303 	lsl.w	r3, r1, r3
3418313e:	401a      	ands	r2, r3
34183140:	f44f 7180 	mov.w	r1, #256	@ 0x100
34183144:	687b      	ldr	r3, [r7, #4]
34183146:	fa01 f303 	lsl.w	r3, r1, r3
3418314a:	429a      	cmp	r2, r3
3418314c:	d0e7      	beq.n	3418311e <RCC_PLL_Config+0x18a>
        }
      }

      /* Set bypass mode with selected source */
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
3418314e:	69bb      	ldr	r3, [r7, #24]
34183150:	681b      	ldr	r3, [r3, #0]
34183152:	f023 42f0 	bic.w	r2, r3, #2013265920	@ 0x78000000
34183156:	683b      	ldr	r3, [r7, #0]
34183158:	685b      	ldr	r3, [r3, #4]
3418315a:	4313      	orrs	r3, r2
3418315c:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
34183160:	69bb      	ldr	r3, [r7, #24]
34183162:	601a      	str	r2, [r3, #0]
34183164:	e037      	b.n	341831d6 <RCC_PLL_Config+0x242>
                 (RCC_PLL1CFGR1_PLL1BYP | pPLLInit->PLLSource));
    }
    else
    {
      ret = HAL_ERROR;
34183166:	2301      	movs	r3, #1
34183168:	77fb      	strb	r3, [r7, #31]
3418316a:	e034      	b.n	341831d6 <RCC_PLL_Config+0x242>
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
3418316c:	683b      	ldr	r3, [r7, #0]
3418316e:	681b      	ldr	r3, [r3, #0]
34183170:	2b01      	cmp	r3, #1
34183172:	d130      	bne.n	341831d6 <RCC_PLL_Config+0x242>
  {
    /* Disable PLLx post divider output */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
34183174:	693b      	ldr	r3, [r7, #16]
34183176:	681b      	ldr	r3, [r3, #0]
34183178:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
3418317c:	693b      	ldr	r3, [r7, #16]
3418317e:	601a      	str	r2, [r3, #0]

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34183180:	4a1a      	ldr	r2, [pc, #104]	@ (341831ec <RCC_PLL_Config+0x258>)
34183182:	f44f 7180 	mov.w	r1, #256	@ 0x100
34183186:	687b      	ldr	r3, [r7, #4]
34183188:	fa01 f303 	lsl.w	r3, r1, r3
3418318c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34183190:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34183192:	f7fe fa15 	bl	341815c0 <HAL_GetTick>
34183196:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34183198:	e008      	b.n	341831ac <RCC_PLL_Config+0x218>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418319a:	f7fe fa11 	bl	341815c0 <HAL_GetTick>
3418319e:	4602      	mov	r2, r0
341831a0:	68fb      	ldr	r3, [r7, #12]
341831a2:	1ad3      	subs	r3, r2, r3
341831a4:	2b01      	cmp	r3, #1
341831a6:	d901      	bls.n	341831ac <RCC_PLL_Config+0x218>
      {
        return HAL_TIMEOUT;
341831a8:	2303      	movs	r3, #3
341831aa:	e015      	b.n	341831d8 <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
341831ac:	4b0f      	ldr	r3, [pc, #60]	@ (341831ec <RCC_PLL_Config+0x258>)
341831ae:	685a      	ldr	r2, [r3, #4]
341831b0:	f44f 7180 	mov.w	r1, #256	@ 0x100
341831b4:	687b      	ldr	r3, [r7, #4]
341831b6:	fa01 f303 	lsl.w	r3, r1, r3
341831ba:	401a      	ands	r2, r3
341831bc:	f44f 7180 	mov.w	r1, #256	@ 0x100
341831c0:	687b      	ldr	r3, [r7, #4]
341831c2:	fa01 f303 	lsl.w	r3, r1, r3
341831c6:	429a      	cmp	r2, r3
341831c8:	d0e7      	beq.n	3418319a <RCC_PLL_Config+0x206>
      }
    }

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
341831ca:	69bb      	ldr	r3, [r7, #24]
341831cc:	681b      	ldr	r3, [r3, #0]
341831ce:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
341831d2:	69bb      	ldr	r3, [r7, #24]
341831d4:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }

  return ret;
341831d6:	7ffb      	ldrb	r3, [r7, #31]
}
341831d8:	4618      	mov	r0, r3
341831da:	3720      	adds	r7, #32
341831dc:	46bd      	mov	sp, r7
341831de:	bd80      	pop	{r7, pc}
341831e0:	56028080 	.word	0x56028080
341831e4:	56028084 	.word	0x56028084
341831e8:	56028088 	.word	0x56028088
341831ec:	56028000 	.word	0x56028000
341831f0:	8c0000ff 	.word	0x8c0000ff

341831f4 <RCC_PLL_Enable>:
  * @param  PLLnumber PLL number to enable
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Enable(uint32_t PLLnumber)
{
341831f4:	b580      	push	{r7, lr}
341831f6:	b084      	sub	sp, #16
341831f8:	af00      	add	r7, sp, #0
341831fa:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
341831fc:	2300      	movs	r3, #0
341831fe:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Enable the PLLx */
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
34183200:	4a11      	ldr	r2, [pc, #68]	@ (34183248 <RCC_PLL_Enable+0x54>)
34183202:	f44f 7180 	mov.w	r1, #256	@ 0x100
34183206:	687b      	ldr	r3, [r7, #4]
34183208:	fa01 f303 	lsl.w	r3, r1, r3
3418320c:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
34183210:	f7fe f9d6 	bl	341815c0 <HAL_GetTick>
34183214:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLx is ready */
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
34183216:	e008      	b.n	3418322a <RCC_PLL_Enable+0x36>
  {
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34183218:	f7fe f9d2 	bl	341815c0 <HAL_GetTick>
3418321c:	4602      	mov	r2, r0
3418321e:	68bb      	ldr	r3, [r7, #8]
34183220:	1ad3      	subs	r3, r2, r3
34183222:	2b01      	cmp	r3, #1
34183224:	d901      	bls.n	3418322a <RCC_PLL_Enable+0x36>
    {
      return HAL_TIMEOUT;
34183226:	2303      	movs	r3, #3
34183228:	e00a      	b.n	34183240 <RCC_PLL_Enable+0x4c>
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418322a:	4b07      	ldr	r3, [pc, #28]	@ (34183248 <RCC_PLL_Enable+0x54>)
3418322c:	685a      	ldr	r2, [r3, #4]
3418322e:	f44f 7180 	mov.w	r1, #256	@ 0x100
34183232:	687b      	ldr	r3, [r7, #4]
34183234:	fa01 f303 	lsl.w	r3, r1, r3
34183238:	4013      	ands	r3, r2
3418323a:	2b00      	cmp	r3, #0
3418323c:	d0ec      	beq.n	34183218 <RCC_PLL_Enable+0x24>
    }
  }

  return ret;
3418323e:	7bfb      	ldrb	r3, [r7, #15]
}
34183240:	4618      	mov	r0, r3
34183242:	3710      	adds	r7, #16
34183244:	46bd      	mov	sp, r7
34183246:	bd80      	pop	{r7, pc}
34183248:	56028000 	.word	0x56028000

3418324c <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3418324c:	b480      	push	{r7}
3418324e:	b089      	sub	sp, #36	@ 0x24
34183250:	af00      	add	r7, sp, #0
34183252:	6078      	str	r0, [r7, #4]
34183254:	6039      	str	r1, [r7, #0]
  __IO const uint32_t *p_rcc_pll_cfgr1_reg, *p_rcc_pll_cfgr2_reg, *p_rcc_pll_cfgr3_reg;
  uint32_t ret = 0U;
34183256:	2300      	movs	r3, #0
34183258:	61fb      	str	r3, [r7, #28]

  /* No assert since done in calling function */

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3418325a:	687b      	ldr	r3, [r7, #4]
3418325c:	011a      	lsls	r2, r3, #4
3418325e:	4b34      	ldr	r3, [pc, #208]	@ (34183330 <RCC_PLL_IsNewConfig+0xe4>)
34183260:	4413      	add	r3, r2
34183262:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
34183264:	687b      	ldr	r3, [r7, #4]
34183266:	011a      	lsls	r2, r3, #4
34183268:	4b32      	ldr	r3, [pc, #200]	@ (34183334 <RCC_PLL_IsNewConfig+0xe8>)
3418326a:	4413      	add	r3, r2
3418326c:	613b      	str	r3, [r7, #16]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3418326e:	687b      	ldr	r3, [r7, #4]
34183270:	011a      	lsls	r2, r3, #4
34183272:	4b31      	ldr	r3, [pc, #196]	@ (34183338 <RCC_PLL_IsNewConfig+0xec>)
34183274:	4413      	add	r3, r2
34183276:	60fb      	str	r3, [r7, #12]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
34183278:	697b      	ldr	r3, [r7, #20]
3418327a:	681b      	ldr	r3, [r3, #0]
3418327c:	f023 430c 	bic.w	r3, r3, #2348810240	@ 0x8c000000
34183280:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
34183284:	683a      	ldr	r2, [r7, #0]
34183286:	6851      	ldr	r1, [r2, #4]
34183288:	683a      	ldr	r2, [r7, #0]
3418328a:	6892      	ldr	r2, [r2, #8]
3418328c:	0512      	lsls	r2, r2, #20
3418328e:	4311      	orrs	r1, r2
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
34183290:	683a      	ldr	r2, [r7, #0]
34183292:	6912      	ldr	r2, [r2, #16]
34183294:	0212      	lsls	r2, r2, #8
34183296:	430a      	orrs	r2, r1
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
34183298:	4293      	cmp	r3, r2
3418329a:	d002      	beq.n	341832a2 <RCC_PLL_IsNewConfig+0x56>
  {
    ret = 1U; /* New PLL configuration */
3418329c:	2301      	movs	r3, #1
3418329e:	61fb      	str	r3, [r7, #28]
341832a0:	e03e      	b.n	34183320 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
341832a2:	693b      	ldr	r3, [r7, #16]
341832a4:	681b      	ldr	r3, [r3, #0]
341832a6:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
341832aa:	683b      	ldr	r3, [r7, #0]
341832ac:	68db      	ldr	r3, [r3, #12]
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
341832ae:	429a      	cmp	r2, r3
341832b0:	d002      	beq.n	341832b8 <RCC_PLL_IsNewConfig+0x6c>
  {
    ret = 1U; /* New PLL configuration */
341832b2:	2301      	movs	r3, #1
341832b4:	61fb      	str	r3, [r7, #28]
341832b6:	e033      	b.n	34183320 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
341832b8:	68fb      	ldr	r3, [r7, #12]
341832ba:	681b      	ldr	r3, [r3, #0]
341832bc:	f003 527c 	and.w	r2, r3, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
341832c0:	683b      	ldr	r3, [r7, #0]
341832c2:	695b      	ldr	r3, [r3, #20]
341832c4:	06d9      	lsls	r1, r3, #27
341832c6:	683b      	ldr	r3, [r7, #0]
341832c8:	699b      	ldr	r3, [r3, #24]
341832ca:	061b      	lsls	r3, r3, #24
341832cc:	430b      	orrs	r3, r1
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
341832ce:	429a      	cmp	r2, r3
341832d0:	d002      	beq.n	341832d8 <RCC_PLL_IsNewConfig+0x8c>
  {
    ret = 1U; /* New PLL configuration */
341832d2:	2301      	movs	r3, #1
341832d4:	61fb      	str	r3, [r7, #28]
341832d6:	e023      	b.n	34183320 <RCC_PLL_IsNewConfig+0xd4>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
341832d8:	4b18      	ldr	r3, [pc, #96]	@ (3418333c <RCC_PLL_IsNewConfig+0xf0>)
341832da:	685a      	ldr	r2, [r3, #4]
341832dc:	f44f 7180 	mov.w	r1, #256	@ 0x100
341832e0:	687b      	ldr	r3, [r7, #4]
341832e2:	fa01 f303 	lsl.w	r3, r1, r3
341832e6:	401a      	ands	r2, r3
341832e8:	f44f 7180 	mov.w	r1, #256	@ 0x100
341832ec:	687b      	ldr	r3, [r7, #4]
341832ee:	fa01 f303 	lsl.w	r3, r1, r3
341832f2:	429a      	cmp	r2, r3
341832f4:	d102      	bne.n	341832fc <RCC_PLL_IsNewConfig+0xb0>
    {
      pllState = RCC_PLL_ON;
341832f6:	2302      	movs	r3, #2
341832f8:	61bb      	str	r3, [r7, #24]
341832fa:	e00a      	b.n	34183312 <RCC_PLL_IsNewConfig+0xc6>
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
341832fc:	697b      	ldr	r3, [r7, #20]
341832fe:	681b      	ldr	r3, [r3, #0]
34183300:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34183304:	2b00      	cmp	r3, #0
34183306:	d002      	beq.n	3418330e <RCC_PLL_IsNewConfig+0xc2>
      {
        pllState = RCC_PLL_BYPASS;
34183308:	2303      	movs	r3, #3
3418330a:	61bb      	str	r3, [r7, #24]
3418330c:	e001      	b.n	34183312 <RCC_PLL_IsNewConfig+0xc6>
      }
      else
      {
        pllState = RCC_PLL_OFF;
3418330e:	2301      	movs	r3, #1
34183310:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
34183312:	683b      	ldr	r3, [r7, #0]
34183314:	681b      	ldr	r3, [r3, #0]
34183316:	69ba      	ldr	r2, [r7, #24]
34183318:	429a      	cmp	r2, r3
3418331a:	d001      	beq.n	34183320 <RCC_PLL_IsNewConfig+0xd4>
    {
      ret = 1U; /* New PLL configuration */
3418331c:	2301      	movs	r3, #1
3418331e:	61fb      	str	r3, [r7, #28]
    }
  }

  return ret;
34183320:	69fb      	ldr	r3, [r7, #28]
}
34183322:	4618      	mov	r0, r3
34183324:	3724      	adds	r7, #36	@ 0x24
34183326:	46bd      	mov	sp, r7
34183328:	f85d 7b04 	ldr.w	r7, [sp], #4
3418332c:	4770      	bx	lr
3418332e:	bf00      	nop
34183330:	56028080 	.word	0x56028080
34183334:	56028084 	.word	0x56028084
34183338:	56028088 	.word	0x56028088
3418333c:	56028000 	.word	0x56028000

34183340 <RCC_PLL_Source_IsReady>:
  * @brief  Check whether the PLL source is ready
  * @param  PLLSource PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_Source_IsReady(uint32_t PLLSource)
{
34183340:	b580      	push	{r7, lr}
34183342:	b084      	sub	sp, #16
34183344:	af00      	add	r7, sp, #0
34183346:	6078      	str	r0, [r7, #4]
  uint32_t ret = 1U;
34183348:	2301      	movs	r3, #1
3418334a:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  switch (PLLSource)
3418334c:	687b      	ldr	r3, [r7, #4]
3418334e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34183352:	d01b      	beq.n	3418338c <RCC_PLL_Source_IsReady+0x4c>
34183354:	687b      	ldr	r3, [r7, #4]
34183356:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418335a:	d81f      	bhi.n	3418339c <RCC_PLL_Source_IsReady+0x5c>
3418335c:	687b      	ldr	r3, [r7, #4]
3418335e:	2b00      	cmp	r3, #0
34183360:	d004      	beq.n	3418336c <RCC_PLL_Source_IsReady+0x2c>
34183362:	687b      	ldr	r3, [r7, #4]
34183364:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34183368:	d008      	beq.n	3418337c <RCC_PLL_Source_IsReady+0x3c>
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_PIN:
    default:
      break;
3418336a:	e017      	b.n	3418339c <RCC_PLL_Source_IsReady+0x5c>
      if (LL_RCC_HSI_IsReady() == 0U)
3418336c:	f7fe fd0c 	bl	34181d88 <LL_RCC_HSI_IsReady>
34183370:	4603      	mov	r3, r0
34183372:	2b00      	cmp	r3, #0
34183374:	d114      	bne.n	341833a0 <RCC_PLL_Source_IsReady+0x60>
        ret = 0U;
34183376:	2300      	movs	r3, #0
34183378:	60fb      	str	r3, [r7, #12]
      break;
3418337a:	e011      	b.n	341833a0 <RCC_PLL_Source_IsReady+0x60>
      if (LL_RCC_MSI_IsReady() == 0U)
3418337c:	f7fe fd6c 	bl	34181e58 <LL_RCC_MSI_IsReady>
34183380:	4603      	mov	r3, r0
34183382:	2b00      	cmp	r3, #0
34183384:	d10e      	bne.n	341833a4 <RCC_PLL_Source_IsReady+0x64>
        ret = 0U;
34183386:	2300      	movs	r3, #0
34183388:	60fb      	str	r3, [r7, #12]
      break;
3418338a:	e00b      	b.n	341833a4 <RCC_PLL_Source_IsReady+0x64>
      if (LL_RCC_HSE_IsReady() == 0U)
3418338c:	f7fe fccc 	bl	34181d28 <LL_RCC_HSE_IsReady>
34183390:	4603      	mov	r3, r0
34183392:	2b00      	cmp	r3, #0
34183394:	d108      	bne.n	341833a8 <RCC_PLL_Source_IsReady+0x68>
        ret = 0U;
34183396:	2300      	movs	r3, #0
34183398:	60fb      	str	r3, [r7, #12]
      break;
3418339a:	e005      	b.n	341833a8 <RCC_PLL_Source_IsReady+0x68>
      break;
3418339c:	bf00      	nop
3418339e:	e004      	b.n	341833aa <RCC_PLL_Source_IsReady+0x6a>
      break;
341833a0:	bf00      	nop
341833a2:	e002      	b.n	341833aa <RCC_PLL_Source_IsReady+0x6a>
      break;
341833a4:	bf00      	nop
341833a6:	e000      	b.n	341833aa <RCC_PLL_Source_IsReady+0x6a>
      break;
341833a8:	bf00      	nop
  }

  return ret;
341833aa:	68fb      	ldr	r3, [r7, #12]
}
341833ac:	4618      	mov	r0, r3
341833ae:	3710      	adds	r7, #16
341833b0:	46bd      	mov	sp, r7
341833b2:	bd80      	pop	{r7, pc}

341833b4 <RCC_IC_CheckPLLSources>:
  * @param  PLLSource1 First PLL source
  * @param  PLLSource2 Second PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_IC_CheckPLLSources(uint32_t PLLSource1, uint32_t PLLSource2)
{
341833b4:	b580      	push	{r7, lr}
341833b6:	b084      	sub	sp, #16
341833b8:	af00      	add	r7, sp, #0
341833ba:	6078      	str	r0, [r7, #4]
341833bc:	6039      	str	r1, [r7, #0]
  uint32_t ret = 1U;
341833be:	2301      	movs	r3, #1
341833c0:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
341833c2:	687b      	ldr	r3, [r7, #4]
341833c4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341833c8:	d03a      	beq.n	34183440 <RCC_IC_CheckPLLSources+0x8c>
341833ca:	687b      	ldr	r3, [r7, #4]
341833cc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341833d0:	d843      	bhi.n	3418345a <RCC_IC_CheckPLLSources+0xa6>
341833d2:	687b      	ldr	r3, [r7, #4]
341833d4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341833d8:	d025      	beq.n	34183426 <RCC_IC_CheckPLLSources+0x72>
341833da:	687b      	ldr	r3, [r7, #4]
341833dc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341833e0:	d83b      	bhi.n	3418345a <RCC_IC_CheckPLLSources+0xa6>
341833e2:	687b      	ldr	r3, [r7, #4]
341833e4:	2b00      	cmp	r3, #0
341833e6:	d004      	beq.n	341833f2 <RCC_IC_CheckPLLSources+0x3e>
341833e8:	687b      	ldr	r3, [r7, #4]
341833ea:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341833ee:	d00d      	beq.n	3418340c <RCC_IC_CheckPLLSources+0x58>
341833f0:	e033      	b.n	3418345a <RCC_IC_CheckPLLSources+0xa6>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
341833f2:	f7fe fdd5 	bl	34181fa0 <LL_RCC_PLL1_IsReady>
341833f6:	4603      	mov	r3, r0
341833f8:	2b00      	cmp	r3, #0
341833fa:	d131      	bne.n	34183460 <RCC_IC_CheckPLLSources+0xac>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
341833fc:	f7fe fde4 	bl	34181fc8 <LL_RCC_PLL1_IsEnabledBypass>
34183400:	4603      	mov	r3, r0
34183402:	2b00      	cmp	r3, #0
34183404:	d12c      	bne.n	34183460 <RCC_IC_CheckPLLSources+0xac>
        {
          ret = 0U;
34183406:	2300      	movs	r3, #0
34183408:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418340a:	e029      	b.n	34183460 <RCC_IC_CheckPLLSources+0xac>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3418340c:	f7fe fdfe 	bl	3418200c <LL_RCC_PLL2_IsReady>
34183410:	4603      	mov	r3, r0
34183412:	2b00      	cmp	r3, #0
34183414:	d126      	bne.n	34183464 <RCC_IC_CheckPLLSources+0xb0>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
34183416:	f7fe fe0d 	bl	34182034 <LL_RCC_PLL2_IsEnabledBypass>
3418341a:	4603      	mov	r3, r0
3418341c:	2b00      	cmp	r3, #0
3418341e:	d121      	bne.n	34183464 <RCC_IC_CheckPLLSources+0xb0>
        {
          ret = 0U;
34183420:	2300      	movs	r3, #0
34183422:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34183424:	e01e      	b.n	34183464 <RCC_IC_CheckPLLSources+0xb0>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
34183426:	f7fe fe27 	bl	34182078 <LL_RCC_PLL3_IsReady>
3418342a:	4603      	mov	r3, r0
3418342c:	2b00      	cmp	r3, #0
3418342e:	d11b      	bne.n	34183468 <RCC_IC_CheckPLLSources+0xb4>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
34183430:	f7fe fe36 	bl	341820a0 <LL_RCC_PLL3_IsEnabledBypass>
34183434:	4603      	mov	r3, r0
34183436:	2b00      	cmp	r3, #0
34183438:	d116      	bne.n	34183468 <RCC_IC_CheckPLLSources+0xb4>
        {
          ret = 0U;
3418343a:	2300      	movs	r3, #0
3418343c:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418343e:	e013      	b.n	34183468 <RCC_IC_CheckPLLSources+0xb4>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
34183440:	f7fe fe50 	bl	341820e4 <LL_RCC_PLL4_IsReady>
34183444:	4603      	mov	r3, r0
34183446:	2b00      	cmp	r3, #0
34183448:	d110      	bne.n	3418346c <RCC_IC_CheckPLLSources+0xb8>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3418344a:	f7fe fe5f 	bl	3418210c <LL_RCC_PLL4_IsEnabledBypass>
3418344e:	4603      	mov	r3, r0
34183450:	2b00      	cmp	r3, #0
34183452:	d10b      	bne.n	3418346c <RCC_IC_CheckPLLSources+0xb8>
        {
          ret = 0U;
34183454:	2300      	movs	r3, #0
34183456:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34183458:	e008      	b.n	3418346c <RCC_IC_CheckPLLSources+0xb8>
    default:
      /* Unexpected */
      ret = 0U;
3418345a:	2300      	movs	r3, #0
3418345c:	60fb      	str	r3, [r7, #12]
      break;
3418345e:	e006      	b.n	3418346e <RCC_IC_CheckPLLSources+0xba>
      break;
34183460:	bf00      	nop
34183462:	e004      	b.n	3418346e <RCC_IC_CheckPLLSources+0xba>
      break;
34183464:	bf00      	nop
34183466:	e002      	b.n	3418346e <RCC_IC_CheckPLLSources+0xba>
      break;
34183468:	bf00      	nop
3418346a:	e000      	b.n	3418346e <RCC_IC_CheckPLLSources+0xba>
      break;
3418346c:	bf00      	nop
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
3418346e:	683b      	ldr	r3, [r7, #0]
34183470:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34183474:	d03a      	beq.n	341834ec <RCC_IC_CheckPLLSources+0x138>
34183476:	683b      	ldr	r3, [r7, #0]
34183478:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418347c:	d843      	bhi.n	34183506 <RCC_IC_CheckPLLSources+0x152>
3418347e:	683b      	ldr	r3, [r7, #0]
34183480:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34183484:	d025      	beq.n	341834d2 <RCC_IC_CheckPLLSources+0x11e>
34183486:	683b      	ldr	r3, [r7, #0]
34183488:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418348c:	d83b      	bhi.n	34183506 <RCC_IC_CheckPLLSources+0x152>
3418348e:	683b      	ldr	r3, [r7, #0]
34183490:	2b00      	cmp	r3, #0
34183492:	d004      	beq.n	3418349e <RCC_IC_CheckPLLSources+0xea>
34183494:	683b      	ldr	r3, [r7, #0]
34183496:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418349a:	d00d      	beq.n	341834b8 <RCC_IC_CheckPLLSources+0x104>
3418349c:	e033      	b.n	34183506 <RCC_IC_CheckPLLSources+0x152>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3418349e:	f7fe fd7f 	bl	34181fa0 <LL_RCC_PLL1_IsReady>
341834a2:	4603      	mov	r3, r0
341834a4:	2b00      	cmp	r3, #0
341834a6:	d131      	bne.n	3418350c <RCC_IC_CheckPLLSources+0x158>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
341834a8:	f7fe fd8e 	bl	34181fc8 <LL_RCC_PLL1_IsEnabledBypass>
341834ac:	4603      	mov	r3, r0
341834ae:	2b00      	cmp	r3, #0
341834b0:	d12c      	bne.n	3418350c <RCC_IC_CheckPLLSources+0x158>
        {
          ret = 0U;
341834b2:	2300      	movs	r3, #0
341834b4:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
341834b6:	e029      	b.n	3418350c <RCC_IC_CheckPLLSources+0x158>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
341834b8:	f7fe fda8 	bl	3418200c <LL_RCC_PLL2_IsReady>
341834bc:	4603      	mov	r3, r0
341834be:	2b00      	cmp	r3, #0
341834c0:	d126      	bne.n	34183510 <RCC_IC_CheckPLLSources+0x15c>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
341834c2:	f7fe fdb7 	bl	34182034 <LL_RCC_PLL2_IsEnabledBypass>
341834c6:	4603      	mov	r3, r0
341834c8:	2b00      	cmp	r3, #0
341834ca:	d121      	bne.n	34183510 <RCC_IC_CheckPLLSources+0x15c>
        {
          ret = 0U;
341834cc:	2300      	movs	r3, #0
341834ce:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
341834d0:	e01e      	b.n	34183510 <RCC_IC_CheckPLLSources+0x15c>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
341834d2:	f7fe fdd1 	bl	34182078 <LL_RCC_PLL3_IsReady>
341834d6:	4603      	mov	r3, r0
341834d8:	2b00      	cmp	r3, #0
341834da:	d11b      	bne.n	34183514 <RCC_IC_CheckPLLSources+0x160>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
341834dc:	f7fe fde0 	bl	341820a0 <LL_RCC_PLL3_IsEnabledBypass>
341834e0:	4603      	mov	r3, r0
341834e2:	2b00      	cmp	r3, #0
341834e4:	d116      	bne.n	34183514 <RCC_IC_CheckPLLSources+0x160>
        {
          ret = 0U;
341834e6:	2300      	movs	r3, #0
341834e8:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
341834ea:	e013      	b.n	34183514 <RCC_IC_CheckPLLSources+0x160>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
341834ec:	f7fe fdfa 	bl	341820e4 <LL_RCC_PLL4_IsReady>
341834f0:	4603      	mov	r3, r0
341834f2:	2b00      	cmp	r3, #0
341834f4:	d110      	bne.n	34183518 <RCC_IC_CheckPLLSources+0x164>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
341834f6:	f7fe fe09 	bl	3418210c <LL_RCC_PLL4_IsEnabledBypass>
341834fa:	4603      	mov	r3, r0
341834fc:	2b00      	cmp	r3, #0
341834fe:	d10b      	bne.n	34183518 <RCC_IC_CheckPLLSources+0x164>
        {
          ret = 0U;
34183500:	2300      	movs	r3, #0
34183502:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34183504:	e008      	b.n	34183518 <RCC_IC_CheckPLLSources+0x164>
    default:
      /* Unexpected */
      ret = 0U;
34183506:	2300      	movs	r3, #0
34183508:	60fb      	str	r3, [r7, #12]
      break;
3418350a:	e006      	b.n	3418351a <RCC_IC_CheckPLLSources+0x166>
      break;
3418350c:	bf00      	nop
3418350e:	e004      	b.n	3418351a <RCC_IC_CheckPLLSources+0x166>
      break;
34183510:	bf00      	nop
34183512:	e002      	b.n	3418351a <RCC_IC_CheckPLLSources+0x166>
      break;
34183514:	bf00      	nop
34183516:	e000      	b.n	3418351a <RCC_IC_CheckPLLSources+0x166>
      break;
34183518:	bf00      	nop
  }

  return ret;
3418351a:	68fb      	ldr	r3, [r7, #12]
}
3418351c:	4618      	mov	r0, r3
3418351e:	3710      	adds	r7, #16
34183520:	46bd      	mov	sp, r7
34183522:	bd80      	pop	{r7, pc}

34183524 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
{
34183524:	b480      	push	{r7}
34183526:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
34183528:	4b05      	ldr	r3, [pc, #20]	@ (34183540 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3418352a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418352c:	4a04      	ldr	r2, [pc, #16]	@ (34183540 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3418352e:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34183532:	6553      	str	r3, [r2, #84]	@ 0x54
}
34183534:	bf00      	nop
34183536:	46bd      	mov	sp, r7
34183538:	f85d 7b04 	ldr.w	r7, [sp], #4
3418353c:	4770      	bx	lr
3418353e:	bf00      	nop
34183540:	56028000 	.word	0x56028000

34183544 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
{
34183544:	b480      	push	{r7}
34183546:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
34183548:	4b05      	ldr	r3, [pc, #20]	@ (34183560 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3418354a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418354c:	4a04      	ldr	r2, [pc, #16]	@ (34183560 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3418354e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34183552:	6553      	str	r3, [r2, #84]	@ 0x54
}
34183554:	bf00      	nop
34183556:	46bd      	mov	sp, r7
34183558:	f85d 7b04 	ldr.w	r7, [sp], #4
3418355c:	4770      	bx	lr
3418355e:	bf00      	nop
34183560:	56028000 	.word	0x56028000

34183564 <LL_RCC_HSE_IsReady>:
{
34183564:	b480      	push	{r7}
34183566:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34183568:	4b06      	ldr	r3, [pc, #24]	@ (34183584 <LL_RCC_HSE_IsReady+0x20>)
3418356a:	685b      	ldr	r3, [r3, #4]
3418356c:	f003 0310 	and.w	r3, r3, #16
34183570:	2b00      	cmp	r3, #0
34183572:	d001      	beq.n	34183578 <LL_RCC_HSE_IsReady+0x14>
34183574:	2301      	movs	r3, #1
34183576:	e000      	b.n	3418357a <LL_RCC_HSE_IsReady+0x16>
34183578:	2300      	movs	r3, #0
}
3418357a:	4618      	mov	r0, r3
3418357c:	46bd      	mov	sp, r7
3418357e:	f85d 7b04 	ldr.w	r7, [sp], #4
34183582:	4770      	bx	lr
34183584:	56028000 	.word	0x56028000

34183588 <LL_RCC_HSI_IsReady>:
{
34183588:	b480      	push	{r7}
3418358a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3418358c:	4b06      	ldr	r3, [pc, #24]	@ (341835a8 <LL_RCC_HSI_IsReady+0x20>)
3418358e:	685b      	ldr	r3, [r3, #4]
34183590:	f003 0308 	and.w	r3, r3, #8
34183594:	2b00      	cmp	r3, #0
34183596:	d001      	beq.n	3418359c <LL_RCC_HSI_IsReady+0x14>
34183598:	2301      	movs	r3, #1
3418359a:	e000      	b.n	3418359e <LL_RCC_HSI_IsReady+0x16>
3418359c:	2300      	movs	r3, #0
}
3418359e:	4618      	mov	r0, r3
341835a0:	46bd      	mov	sp, r7
341835a2:	f85d 7b04 	ldr.w	r7, [sp], #4
341835a6:	4770      	bx	lr
341835a8:	56028000 	.word	0x56028000

341835ac <LL_RCC_HSI_GetDivider>:
{
341835ac:	b480      	push	{r7}
341835ae:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
341835b0:	4b04      	ldr	r3, [pc, #16]	@ (341835c4 <LL_RCC_HSI_GetDivider+0x18>)
341835b2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341835b4:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
341835b8:	4618      	mov	r0, r3
341835ba:	46bd      	mov	sp, r7
341835bc:	f85d 7b04 	ldr.w	r7, [sp], #4
341835c0:	4770      	bx	lr
341835c2:	bf00      	nop
341835c4:	56028000 	.word	0x56028000

341835c8 <LL_RCC_MSI_IsReady>:
{
341835c8:	b480      	push	{r7}
341835ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
341835cc:	4b06      	ldr	r3, [pc, #24]	@ (341835e8 <LL_RCC_MSI_IsReady+0x20>)
341835ce:	685b      	ldr	r3, [r3, #4]
341835d0:	f003 0304 	and.w	r3, r3, #4
341835d4:	2b00      	cmp	r3, #0
341835d6:	d001      	beq.n	341835dc <LL_RCC_MSI_IsReady+0x14>
341835d8:	2301      	movs	r3, #1
341835da:	e000      	b.n	341835de <LL_RCC_MSI_IsReady+0x16>
341835dc:	2300      	movs	r3, #0
}
341835de:	4618      	mov	r0, r3
341835e0:	46bd      	mov	sp, r7
341835e2:	f85d 7b04 	ldr.w	r7, [sp], #4
341835e6:	4770      	bx	lr
341835e8:	56028000 	.word	0x56028000

341835ec <LL_RCC_MSI_GetFrequency>:
{
341835ec:	b480      	push	{r7}
341835ee:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
341835f0:	4b04      	ldr	r3, [pc, #16]	@ (34183604 <LL_RCC_MSI_GetFrequency+0x18>)
341835f2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341835f4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
341835f8:	4618      	mov	r0, r3
341835fa:	46bd      	mov	sp, r7
341835fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34183600:	4770      	bx	lr
34183602:	bf00      	nop
34183604:	56028000 	.word	0x56028000

34183608 <LL_RCC_LSE_IsReady>:
{
34183608:	b480      	push	{r7}
3418360a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3418360c:	4b06      	ldr	r3, [pc, #24]	@ (34183628 <LL_RCC_LSE_IsReady+0x20>)
3418360e:	685b      	ldr	r3, [r3, #4]
34183610:	f003 0302 	and.w	r3, r3, #2
34183614:	2b00      	cmp	r3, #0
34183616:	d001      	beq.n	3418361c <LL_RCC_LSE_IsReady+0x14>
34183618:	2301      	movs	r3, #1
3418361a:	e000      	b.n	3418361e <LL_RCC_LSE_IsReady+0x16>
3418361c:	2300      	movs	r3, #0
}
3418361e:	4618      	mov	r0, r3
34183620:	46bd      	mov	sp, r7
34183622:	f85d 7b04 	ldr.w	r7, [sp], #4
34183626:	4770      	bx	lr
34183628:	56028000 	.word	0x56028000

3418362c <LL_RCC_SetClockSource>:
{
3418362c:	b480      	push	{r7}
3418362e:	b085      	sub	sp, #20
34183630:	af00      	add	r7, sp, #0
34183632:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
34183634:	687b      	ldr	r3, [r7, #4]
34183636:	b2da      	uxtb	r2, r3
34183638:	4b10      	ldr	r3, [pc, #64]	@ (3418367c <LL_RCC_SetClockSource+0x50>)
3418363a:	4413      	add	r3, r2
3418363c:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
3418363e:	68fb      	ldr	r3, [r7, #12]
34183640:	681a      	ldr	r2, [r3, #0]
34183642:	687b      	ldr	r3, [r7, #4]
34183644:	0e19      	lsrs	r1, r3, #24
34183646:	687b      	ldr	r3, [r7, #4]
34183648:	0a1b      	lsrs	r3, r3, #8
3418364a:	f003 031f 	and.w	r3, r3, #31
3418364e:	fa01 f303 	lsl.w	r3, r1, r3
34183652:	43db      	mvns	r3, r3
34183654:	401a      	ands	r2, r3
34183656:	687b      	ldr	r3, [r7, #4]
34183658:	0c1b      	lsrs	r3, r3, #16
3418365a:	b2d9      	uxtb	r1, r3
3418365c:	687b      	ldr	r3, [r7, #4]
3418365e:	0a1b      	lsrs	r3, r3, #8
34183660:	f003 031f 	and.w	r3, r3, #31
34183664:	fa01 f303 	lsl.w	r3, r1, r3
34183668:	431a      	orrs	r2, r3
3418366a:	68fb      	ldr	r3, [r7, #12]
3418366c:	601a      	str	r2, [r3, #0]
}
3418366e:	bf00      	nop
34183670:	3714      	adds	r7, #20
34183672:	46bd      	mov	sp, r7
34183674:	f85d 7b04 	ldr.w	r7, [sp], #4
34183678:	4770      	bx	lr
3418367a:	bf00      	nop
3418367c:	56028144 	.word	0x56028144

34183680 <LL_RCC_SetADFClockSource>:
{
34183680:	b480      	push	{r7}
34183682:	b083      	sub	sp, #12
34183684:	af00      	add	r7, sp, #0
34183686:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
34183688:	4b07      	ldr	r3, [pc, #28]	@ (341836a8 <LL_RCC_SetADFClockSource+0x28>)
3418368a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418368e:	f023 0207 	bic.w	r2, r3, #7
34183692:	4905      	ldr	r1, [pc, #20]	@ (341836a8 <LL_RCC_SetADFClockSource+0x28>)
34183694:	687b      	ldr	r3, [r7, #4]
34183696:	4313      	orrs	r3, r2
34183698:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
3418369c:	bf00      	nop
3418369e:	370c      	adds	r7, #12
341836a0:	46bd      	mov	sp, r7
341836a2:	f85d 7b04 	ldr.w	r7, [sp], #4
341836a6:	4770      	bx	lr
341836a8:	56028000 	.word	0x56028000

341836ac <LL_RCC_SetCLKPClockSource>:
{
341836ac:	b480      	push	{r7}
341836ae:	b083      	sub	sp, #12
341836b0:	af00      	add	r7, sp, #0
341836b2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
341836b4:	4b07      	ldr	r3, [pc, #28]	@ (341836d4 <LL_RCC_SetCLKPClockSource+0x28>)
341836b6:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
341836ba:	f023 0207 	bic.w	r2, r3, #7
341836be:	4905      	ldr	r1, [pc, #20]	@ (341836d4 <LL_RCC_SetCLKPClockSource+0x28>)
341836c0:	687b      	ldr	r3, [r7, #4]
341836c2:	4313      	orrs	r3, r2
341836c4:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
341836c8:	bf00      	nop
341836ca:	370c      	adds	r7, #12
341836cc:	46bd      	mov	sp, r7
341836ce:	f85d 7b04 	ldr.w	r7, [sp], #4
341836d2:	4770      	bx	lr
341836d4:	56028000 	.word	0x56028000

341836d8 <LL_RCC_SetDCMIPPClockSource>:
{
341836d8:	b480      	push	{r7}
341836da:	b083      	sub	sp, #12
341836dc:	af00      	add	r7, sp, #0
341836de:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
341836e0:	4b07      	ldr	r3, [pc, #28]	@ (34183700 <LL_RCC_SetDCMIPPClockSource+0x28>)
341836e2:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
341836e6:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
341836ea:	4905      	ldr	r1, [pc, #20]	@ (34183700 <LL_RCC_SetDCMIPPClockSource+0x28>)
341836ec:	687b      	ldr	r3, [r7, #4]
341836ee:	4313      	orrs	r3, r2
341836f0:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
341836f4:	bf00      	nop
341836f6:	370c      	adds	r7, #12
341836f8:	46bd      	mov	sp, r7
341836fa:	f85d 7b04 	ldr.w	r7, [sp], #4
341836fe:	4770      	bx	lr
34183700:	56028000 	.word	0x56028000

34183704 <LL_RCC_SetETHClockSource>:
{
34183704:	b480      	push	{r7}
34183706:	b083      	sub	sp, #12
34183708:	af00      	add	r7, sp, #0
3418370a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
3418370c:	4b07      	ldr	r3, [pc, #28]	@ (3418372c <LL_RCC_SetETHClockSource+0x28>)
3418370e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34183712:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
34183716:	4905      	ldr	r1, [pc, #20]	@ (3418372c <LL_RCC_SetETHClockSource+0x28>)
34183718:	687b      	ldr	r3, [r7, #4]
3418371a:	4313      	orrs	r3, r2
3418371c:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34183720:	bf00      	nop
34183722:	370c      	adds	r7, #12
34183724:	46bd      	mov	sp, r7
34183726:	f85d 7b04 	ldr.w	r7, [sp], #4
3418372a:	4770      	bx	lr
3418372c:	56028000 	.word	0x56028000

34183730 <LL_RCC_SetETHPHYInterface>:
{
34183730:	b480      	push	{r7}
34183732:	b083      	sub	sp, #12
34183734:	af00      	add	r7, sp, #0
34183736:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
34183738:	4b07      	ldr	r3, [pc, #28]	@ (34183758 <LL_RCC_SetETHPHYInterface+0x28>)
3418373a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418373e:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34183742:	4905      	ldr	r1, [pc, #20]	@ (34183758 <LL_RCC_SetETHPHYInterface+0x28>)
34183744:	687b      	ldr	r3, [r7, #4]
34183746:	4313      	orrs	r3, r2
34183748:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3418374c:	bf00      	nop
3418374e:	370c      	adds	r7, #12
34183750:	46bd      	mov	sp, r7
34183752:	f85d 7b04 	ldr.w	r7, [sp], #4
34183756:	4770      	bx	lr
34183758:	56028000 	.word	0x56028000

3418375c <LL_RCC_SetETHREFRXClockSource>:
{
3418375c:	b480      	push	{r7}
3418375e:	b083      	sub	sp, #12
34183760:	af00      	add	r7, sp, #0
34183762:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
34183764:	4b07      	ldr	r3, [pc, #28]	@ (34183784 <LL_RCC_SetETHREFRXClockSource+0x28>)
34183766:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418376a:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
3418376e:	4905      	ldr	r1, [pc, #20]	@ (34183784 <LL_RCC_SetETHREFRXClockSource+0x28>)
34183770:	687b      	ldr	r3, [r7, #4]
34183772:	4313      	orrs	r3, r2
34183774:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34183778:	bf00      	nop
3418377a:	370c      	adds	r7, #12
3418377c:	46bd      	mov	sp, r7
3418377e:	f85d 7b04 	ldr.w	r7, [sp], #4
34183782:	4770      	bx	lr
34183784:	56028000 	.word	0x56028000

34183788 <LL_RCC_SetETHREFTXClockSource>:
{
34183788:	b480      	push	{r7}
3418378a:	b083      	sub	sp, #12
3418378c:	af00      	add	r7, sp, #0
3418378e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
34183790:	4b07      	ldr	r3, [pc, #28]	@ (341837b0 <LL_RCC_SetETHREFTXClockSource+0x28>)
34183792:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34183796:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3418379a:	4905      	ldr	r1, [pc, #20]	@ (341837b0 <LL_RCC_SetETHREFTXClockSource+0x28>)
3418379c:	687b      	ldr	r3, [r7, #4]
3418379e:	4313      	orrs	r3, r2
341837a0:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
341837a4:	bf00      	nop
341837a6:	370c      	adds	r7, #12
341837a8:	46bd      	mov	sp, r7
341837aa:	f85d 7b04 	ldr.w	r7, [sp], #4
341837ae:	4770      	bx	lr
341837b0:	56028000 	.word	0x56028000

341837b4 <LL_RCC_SetFDCANClockSource>:
{
341837b4:	b480      	push	{r7}
341837b6:	b083      	sub	sp, #12
341837b8:	af00      	add	r7, sp, #0
341837ba:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
341837bc:	4b07      	ldr	r3, [pc, #28]	@ (341837dc <LL_RCC_SetFDCANClockSource+0x28>)
341837be:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
341837c2:	f023 0203 	bic.w	r2, r3, #3
341837c6:	4905      	ldr	r1, [pc, #20]	@ (341837dc <LL_RCC_SetFDCANClockSource+0x28>)
341837c8:	687b      	ldr	r3, [r7, #4]
341837ca:	4313      	orrs	r3, r2
341837cc:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
341837d0:	bf00      	nop
341837d2:	370c      	adds	r7, #12
341837d4:	46bd      	mov	sp, r7
341837d6:	f85d 7b04 	ldr.w	r7, [sp], #4
341837da:	4770      	bx	lr
341837dc:	56028000 	.word	0x56028000

341837e0 <LL_RCC_SetFMCClockSource>:
{
341837e0:	b480      	push	{r7}
341837e2:	b083      	sub	sp, #12
341837e4:	af00      	add	r7, sp, #0
341837e6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
341837e8:	4b07      	ldr	r3, [pc, #28]	@ (34183808 <LL_RCC_SetFMCClockSource+0x28>)
341837ea:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
341837ee:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
341837f2:	4905      	ldr	r1, [pc, #20]	@ (34183808 <LL_RCC_SetFMCClockSource+0x28>)
341837f4:	687b      	ldr	r3, [r7, #4]
341837f6:	4313      	orrs	r3, r2
341837f8:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
341837fc:	bf00      	nop
341837fe:	370c      	adds	r7, #12
34183800:	46bd      	mov	sp, r7
34183802:	f85d 7b04 	ldr.w	r7, [sp], #4
34183806:	4770      	bx	lr
34183808:	56028000 	.word	0x56028000

3418380c <LL_RCC_SetI2CClockSource>:
{
3418380c:	b580      	push	{r7, lr}
3418380e:	b082      	sub	sp, #8
34183810:	af00      	add	r7, sp, #0
34183812:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34183814:	6878      	ldr	r0, [r7, #4]
34183816:	f7ff ff09 	bl	3418362c <LL_RCC_SetClockSource>
}
3418381a:	bf00      	nop
3418381c:	3708      	adds	r7, #8
3418381e:	46bd      	mov	sp, r7
34183820:	bd80      	pop	{r7, pc}

34183822 <LL_RCC_SetI3CClockSource>:
{
34183822:	b580      	push	{r7, lr}
34183824:	b082      	sub	sp, #8
34183826:	af00      	add	r7, sp, #0
34183828:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418382a:	6878      	ldr	r0, [r7, #4]
3418382c:	f7ff fefe 	bl	3418362c <LL_RCC_SetClockSource>
}
34183830:	bf00      	nop
34183832:	3708      	adds	r7, #8
34183834:	46bd      	mov	sp, r7
34183836:	bd80      	pop	{r7, pc}

34183838 <LL_RCC_SetLPTIMClockSource>:
{
34183838:	b580      	push	{r7, lr}
3418383a:	b082      	sub	sp, #8
3418383c:	af00      	add	r7, sp, #0
3418383e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34183840:	6878      	ldr	r0, [r7, #4]
34183842:	f7ff fef3 	bl	3418362c <LL_RCC_SetClockSource>
}
34183846:	bf00      	nop
34183848:	3708      	adds	r7, #8
3418384a:	46bd      	mov	sp, r7
3418384c:	bd80      	pop	{r7, pc}
	...

34183850 <LL_RCC_SetLPUARTClockSource>:
{
34183850:	b480      	push	{r7}
34183852:	b083      	sub	sp, #12
34183854:	af00      	add	r7, sp, #0
34183856:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
34183858:	4b07      	ldr	r3, [pc, #28]	@ (34183878 <LL_RCC_SetLPUARTClockSource+0x28>)
3418385a:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3418385e:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
34183862:	4905      	ldr	r1, [pc, #20]	@ (34183878 <LL_RCC_SetLPUARTClockSource+0x28>)
34183864:	687b      	ldr	r3, [r7, #4]
34183866:	4313      	orrs	r3, r2
34183868:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
3418386c:	bf00      	nop
3418386e:	370c      	adds	r7, #12
34183870:	46bd      	mov	sp, r7
34183872:	f85d 7b04 	ldr.w	r7, [sp], #4
34183876:	4770      	bx	lr
34183878:	56028000 	.word	0x56028000

3418387c <LL_RCC_SetLTDCClockSource>:
{
3418387c:	b480      	push	{r7}
3418387e:	b083      	sub	sp, #12
34183880:	af00      	add	r7, sp, #0
34183882:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
34183884:	4b07      	ldr	r3, [pc, #28]	@ (341838a4 <LL_RCC_SetLTDCClockSource+0x28>)
34183886:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3418388a:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3418388e:	4905      	ldr	r1, [pc, #20]	@ (341838a4 <LL_RCC_SetLTDCClockSource+0x28>)
34183890:	687b      	ldr	r3, [r7, #4]
34183892:	4313      	orrs	r3, r2
34183894:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
34183898:	bf00      	nop
3418389a:	370c      	adds	r7, #12
3418389c:	46bd      	mov	sp, r7
3418389e:	f85d 7b04 	ldr.w	r7, [sp], #4
341838a2:	4770      	bx	lr
341838a4:	56028000 	.word	0x56028000

341838a8 <LL_RCC_SetMDFClockSource>:
{
341838a8:	b480      	push	{r7}
341838aa:	b083      	sub	sp, #12
341838ac:	af00      	add	r7, sp, #0
341838ae:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
341838b0:	4b07      	ldr	r3, [pc, #28]	@ (341838d0 <LL_RCC_SetMDFClockSource+0x28>)
341838b2:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
341838b6:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
341838ba:	4905      	ldr	r1, [pc, #20]	@ (341838d0 <LL_RCC_SetMDFClockSource+0x28>)
341838bc:	687b      	ldr	r3, [r7, #4]
341838be:	4313      	orrs	r3, r2
341838c0:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
341838c4:	bf00      	nop
341838c6:	370c      	adds	r7, #12
341838c8:	46bd      	mov	sp, r7
341838ca:	f85d 7b04 	ldr.w	r7, [sp], #4
341838ce:	4770      	bx	lr
341838d0:	56028000 	.word	0x56028000

341838d4 <LL_RCC_SetOTGPHYClockSource>:
{
341838d4:	b580      	push	{r7, lr}
341838d6:	b082      	sub	sp, #8
341838d8:	af00      	add	r7, sp, #0
341838da:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
341838dc:	6878      	ldr	r0, [r7, #4]
341838de:	f7ff fea5 	bl	3418362c <LL_RCC_SetClockSource>
}
341838e2:	bf00      	nop
341838e4:	3708      	adds	r7, #8
341838e6:	46bd      	mov	sp, r7
341838e8:	bd80      	pop	{r7, pc}

341838ea <LL_RCC_SetOTGPHYCKREFClockSource>:
{
341838ea:	b580      	push	{r7, lr}
341838ec:	b082      	sub	sp, #8
341838ee:	af00      	add	r7, sp, #0
341838f0:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
341838f2:	6878      	ldr	r0, [r7, #4]
341838f4:	f7ff fe9a 	bl	3418362c <LL_RCC_SetClockSource>
}
341838f8:	bf00      	nop
341838fa:	3708      	adds	r7, #8
341838fc:	46bd      	mov	sp, r7
341838fe:	bd80      	pop	{r7, pc}

34183900 <LL_RCC_SetPSSIClockSource>:
{
34183900:	b480      	push	{r7}
34183902:	b083      	sub	sp, #12
34183904:	af00      	add	r7, sp, #0
34183906:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
34183908:	4b07      	ldr	r3, [pc, #28]	@ (34183928 <LL_RCC_SetPSSIClockSource+0x28>)
3418390a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418390e:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34183912:	4905      	ldr	r1, [pc, #20]	@ (34183928 <LL_RCC_SetPSSIClockSource+0x28>)
34183914:	687b      	ldr	r3, [r7, #4]
34183916:	4313      	orrs	r3, r2
34183918:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3418391c:	bf00      	nop
3418391e:	370c      	adds	r7, #12
34183920:	46bd      	mov	sp, r7
34183922:	f85d 7b04 	ldr.w	r7, [sp], #4
34183926:	4770      	bx	lr
34183928:	56028000 	.word	0x56028000

3418392c <LL_RCC_SetSAIClockSource>:
{
3418392c:	b580      	push	{r7, lr}
3418392e:	b082      	sub	sp, #8
34183930:	af00      	add	r7, sp, #0
34183932:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34183934:	6878      	ldr	r0, [r7, #4]
34183936:	f7ff fe79 	bl	3418362c <LL_RCC_SetClockSource>
}
3418393a:	bf00      	nop
3418393c:	3708      	adds	r7, #8
3418393e:	46bd      	mov	sp, r7
34183940:	bd80      	pop	{r7, pc}

34183942 <LL_RCC_SetSDMMCClockSource>:
{
34183942:	b580      	push	{r7, lr}
34183944:	b082      	sub	sp, #8
34183946:	af00      	add	r7, sp, #0
34183948:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418394a:	6878      	ldr	r0, [r7, #4]
3418394c:	f7ff fe6e 	bl	3418362c <LL_RCC_SetClockSource>
}
34183950:	bf00      	nop
34183952:	3708      	adds	r7, #8
34183954:	46bd      	mov	sp, r7
34183956:	bd80      	pop	{r7, pc}

34183958 <LL_RCC_SetSPDIFRXClockSource>:
{
34183958:	b480      	push	{r7}
3418395a:	b083      	sub	sp, #12
3418395c:	af00      	add	r7, sp, #0
3418395e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
34183960:	4b07      	ldr	r3, [pc, #28]	@ (34183980 <LL_RCC_SetSPDIFRXClockSource+0x28>)
34183962:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34183966:	f023 0207 	bic.w	r2, r3, #7
3418396a:	4905      	ldr	r1, [pc, #20]	@ (34183980 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3418396c:	687b      	ldr	r3, [r7, #4]
3418396e:	4313      	orrs	r3, r2
34183970:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
34183974:	bf00      	nop
34183976:	370c      	adds	r7, #12
34183978:	46bd      	mov	sp, r7
3418397a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418397e:	4770      	bx	lr
34183980:	56028000 	.word	0x56028000

34183984 <LL_RCC_SetSPIClockSource>:
{
34183984:	b580      	push	{r7, lr}
34183986:	b082      	sub	sp, #8
34183988:	af00      	add	r7, sp, #0
3418398a:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418398c:	6878      	ldr	r0, [r7, #4]
3418398e:	f7ff fe4d 	bl	3418362c <LL_RCC_SetClockSource>
}
34183992:	bf00      	nop
34183994:	3708      	adds	r7, #8
34183996:	46bd      	mov	sp, r7
34183998:	bd80      	pop	{r7, pc}

3418399a <LL_RCC_SetUSARTClockSource>:
{
3418399a:	b580      	push	{r7, lr}
3418399c:	b082      	sub	sp, #8
3418399e:	af00      	add	r7, sp, #0
341839a0:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
341839a2:	6878      	ldr	r0, [r7, #4]
341839a4:	f7ff fe42 	bl	3418362c <LL_RCC_SetClockSource>
}
341839a8:	bf00      	nop
341839aa:	3708      	adds	r7, #8
341839ac:	46bd      	mov	sp, r7
341839ae:	bd80      	pop	{r7, pc}

341839b0 <LL_RCC_SetXSPIClockSource>:
{
341839b0:	b580      	push	{r7, lr}
341839b2:	b082      	sub	sp, #8
341839b4:	af00      	add	r7, sp, #0
341839b6:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
341839b8:	6878      	ldr	r0, [r7, #4]
341839ba:	f7ff fe37 	bl	3418362c <LL_RCC_SetClockSource>
}
341839be:	bf00      	nop
341839c0:	3708      	adds	r7, #8
341839c2:	46bd      	mov	sp, r7
341839c4:	bd80      	pop	{r7, pc}
	...

341839c8 <LL_RCC_SetRTCClockSource>:
{
341839c8:	b480      	push	{r7}
341839ca:	b083      	sub	sp, #12
341839cc:	af00      	add	r7, sp, #0
341839ce:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
341839d0:	4b07      	ldr	r3, [pc, #28]	@ (341839f0 <LL_RCC_SetRTCClockSource+0x28>)
341839d2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
341839d6:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
341839da:	4905      	ldr	r1, [pc, #20]	@ (341839f0 <LL_RCC_SetRTCClockSource+0x28>)
341839dc:	687b      	ldr	r3, [r7, #4]
341839de:	4313      	orrs	r3, r2
341839e0:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
341839e4:	bf00      	nop
341839e6:	370c      	adds	r7, #12
341839e8:	46bd      	mov	sp, r7
341839ea:	f85d 7b04 	ldr.w	r7, [sp], #4
341839ee:	4770      	bx	lr
341839f0:	56028000 	.word	0x56028000

341839f4 <LL_RCC_GetRTCClockSource>:
{
341839f4:	b480      	push	{r7}
341839f6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
341839f8:	4b04      	ldr	r3, [pc, #16]	@ (34183a0c <LL_RCC_GetRTCClockSource+0x18>)
341839fa:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
341839fe:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
34183a02:	4618      	mov	r0, r3
34183a04:	46bd      	mov	sp, r7
34183a06:	f85d 7b04 	ldr.w	r7, [sp], #4
34183a0a:	4770      	bx	lr
34183a0c:	56028000 	.word	0x56028000

34183a10 <LL_RCC_SetRTC_HSEPrescaler>:
{
34183a10:	b480      	push	{r7}
34183a12:	b083      	sub	sp, #12
34183a14:	af00      	add	r7, sp, #0
34183a16:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
34183a18:	4b07      	ldr	r3, [pc, #28]	@ (34183a38 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
34183a1a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34183a1e:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
34183a22:	4905      	ldr	r1, [pc, #20]	@ (34183a38 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
34183a24:	687b      	ldr	r3, [r7, #4]
34183a26:	4313      	orrs	r3, r2
34183a28:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34183a2c:	bf00      	nop
34183a2e:	370c      	adds	r7, #12
34183a30:	46bd      	mov	sp, r7
34183a32:	f85d 7b04 	ldr.w	r7, [sp], #4
34183a36:	4770      	bx	lr
34183a38:	56028000 	.word	0x56028000

34183a3c <LL_RCC_SetTIMPrescaler>:
{
34183a3c:	b480      	push	{r7}
34183a3e:	b083      	sub	sp, #12
34183a40:	af00      	add	r7, sp, #0
34183a42:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
34183a44:	4b07      	ldr	r3, [pc, #28]	@ (34183a64 <LL_RCC_SetTIMPrescaler+0x28>)
34183a46:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34183a48:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34183a4c:	687b      	ldr	r3, [r7, #4]
34183a4e:	061b      	lsls	r3, r3, #24
34183a50:	4904      	ldr	r1, [pc, #16]	@ (34183a64 <LL_RCC_SetTIMPrescaler+0x28>)
34183a52:	4313      	orrs	r3, r2
34183a54:	624b      	str	r3, [r1, #36]	@ 0x24
}
34183a56:	bf00      	nop
34183a58:	370c      	adds	r7, #12
34183a5a:	46bd      	mov	sp, r7
34183a5c:	f85d 7b04 	ldr.w	r7, [sp], #4
34183a60:	4770      	bx	lr
34183a62:	bf00      	nop
34183a64:	56028000 	.word	0x56028000

34183a68 <LL_RCC_PLL1_GetSource>:
{
34183a68:	b480      	push	{r7}
34183a6a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34183a6c:	4b04      	ldr	r3, [pc, #16]	@ (34183a80 <LL_RCC_PLL1_GetSource+0x18>)
34183a6e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34183a72:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34183a76:	4618      	mov	r0, r3
34183a78:	46bd      	mov	sp, r7
34183a7a:	f85d 7b04 	ldr.w	r7, [sp], #4
34183a7e:	4770      	bx	lr
34183a80:	56028000 	.word	0x56028000

34183a84 <LL_RCC_PLL1_IsReady>:
{
34183a84:	b480      	push	{r7}
34183a86:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
34183a88:	4b07      	ldr	r3, [pc, #28]	@ (34183aa8 <LL_RCC_PLL1_IsReady+0x24>)
34183a8a:	685b      	ldr	r3, [r3, #4]
34183a8c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34183a90:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34183a94:	d101      	bne.n	34183a9a <LL_RCC_PLL1_IsReady+0x16>
34183a96:	2301      	movs	r3, #1
34183a98:	e000      	b.n	34183a9c <LL_RCC_PLL1_IsReady+0x18>
34183a9a:	2300      	movs	r3, #0
}
34183a9c:	4618      	mov	r0, r3
34183a9e:	46bd      	mov	sp, r7
34183aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
34183aa4:	4770      	bx	lr
34183aa6:	bf00      	nop
34183aa8:	56028000 	.word	0x56028000

34183aac <LL_RCC_PLL1_IsEnabledBypass>:
{
34183aac:	b480      	push	{r7}
34183aae:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34183ab0:	4b07      	ldr	r3, [pc, #28]	@ (34183ad0 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
34183ab2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34183ab6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34183aba:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34183abe:	d101      	bne.n	34183ac4 <LL_RCC_PLL1_IsEnabledBypass+0x18>
34183ac0:	2301      	movs	r3, #1
34183ac2:	e000      	b.n	34183ac6 <LL_RCC_PLL1_IsEnabledBypass+0x1a>
34183ac4:	2300      	movs	r3, #0
}
34183ac6:	4618      	mov	r0, r3
34183ac8:	46bd      	mov	sp, r7
34183aca:	f85d 7b04 	ldr.w	r7, [sp], #4
34183ace:	4770      	bx	lr
34183ad0:	56028000 	.word	0x56028000

34183ad4 <LL_RCC_PLL1_GetN>:
{
34183ad4:	b480      	push	{r7}
34183ad6:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
34183ad8:	4b05      	ldr	r3, [pc, #20]	@ (34183af0 <LL_RCC_PLL1_GetN+0x1c>)
34183ada:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34183ade:	0a1b      	lsrs	r3, r3, #8
34183ae0:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34183ae4:	4618      	mov	r0, r3
34183ae6:	46bd      	mov	sp, r7
34183ae8:	f85d 7b04 	ldr.w	r7, [sp], #4
34183aec:	4770      	bx	lr
34183aee:	bf00      	nop
34183af0:	56028000 	.word	0x56028000

34183af4 <LL_RCC_PLL1_GetM>:
{
34183af4:	b480      	push	{r7}
34183af6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
34183af8:	4b05      	ldr	r3, [pc, #20]	@ (34183b10 <LL_RCC_PLL1_GetM+0x1c>)
34183afa:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34183afe:	0d1b      	lsrs	r3, r3, #20
34183b00:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34183b04:	4618      	mov	r0, r3
34183b06:	46bd      	mov	sp, r7
34183b08:	f85d 7b04 	ldr.w	r7, [sp], #4
34183b0c:	4770      	bx	lr
34183b0e:	bf00      	nop
34183b10:	56028000 	.word	0x56028000

34183b14 <LL_RCC_PLL1_GetP1>:
{
34183b14:	b480      	push	{r7}
34183b16:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
34183b18:	4b05      	ldr	r3, [pc, #20]	@ (34183b30 <LL_RCC_PLL1_GetP1+0x1c>)
34183b1a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34183b1e:	0edb      	lsrs	r3, r3, #27
34183b20:	f003 0307 	and.w	r3, r3, #7
}
34183b24:	4618      	mov	r0, r3
34183b26:	46bd      	mov	sp, r7
34183b28:	f85d 7b04 	ldr.w	r7, [sp], #4
34183b2c:	4770      	bx	lr
34183b2e:	bf00      	nop
34183b30:	56028000 	.word	0x56028000

34183b34 <LL_RCC_PLL1_GetP2>:
{
34183b34:	b480      	push	{r7}
34183b36:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
34183b38:	4b05      	ldr	r3, [pc, #20]	@ (34183b50 <LL_RCC_PLL1_GetP2+0x1c>)
34183b3a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34183b3e:	0e1b      	lsrs	r3, r3, #24
34183b40:	f003 0307 	and.w	r3, r3, #7
}
34183b44:	4618      	mov	r0, r3
34183b46:	46bd      	mov	sp, r7
34183b48:	f85d 7b04 	ldr.w	r7, [sp], #4
34183b4c:	4770      	bx	lr
34183b4e:	bf00      	nop
34183b50:	56028000 	.word	0x56028000

34183b54 <LL_RCC_PLL1P_IsEnabled>:
{
34183b54:	b480      	push	{r7}
34183b56:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
34183b58:	4b07      	ldr	r3, [pc, #28]	@ (34183b78 <LL_RCC_PLL1P_IsEnabled+0x24>)
34183b5a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34183b5e:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34183b62:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34183b66:	d101      	bne.n	34183b6c <LL_RCC_PLL1P_IsEnabled+0x18>
34183b68:	2301      	movs	r3, #1
34183b6a:	e000      	b.n	34183b6e <LL_RCC_PLL1P_IsEnabled+0x1a>
34183b6c:	2300      	movs	r3, #0
}
34183b6e:	4618      	mov	r0, r3
34183b70:	46bd      	mov	sp, r7
34183b72:	f85d 7b04 	ldr.w	r7, [sp], #4
34183b76:	4770      	bx	lr
34183b78:	56028000 	.word	0x56028000

34183b7c <LL_RCC_PLL1_GetFRACN>:
{
34183b7c:	b480      	push	{r7}
34183b7e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
34183b80:	4b04      	ldr	r3, [pc, #16]	@ (34183b94 <LL_RCC_PLL1_GetFRACN+0x18>)
34183b82:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34183b86:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34183b8a:	4618      	mov	r0, r3
34183b8c:	46bd      	mov	sp, r7
34183b8e:	f85d 7b04 	ldr.w	r7, [sp], #4
34183b92:	4770      	bx	lr
34183b94:	56028000 	.word	0x56028000

34183b98 <LL_RCC_PLL2_GetSource>:
{
34183b98:	b480      	push	{r7}
34183b9a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34183b9c:	4b04      	ldr	r3, [pc, #16]	@ (34183bb0 <LL_RCC_PLL2_GetSource+0x18>)
34183b9e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34183ba2:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34183ba6:	4618      	mov	r0, r3
34183ba8:	46bd      	mov	sp, r7
34183baa:	f85d 7b04 	ldr.w	r7, [sp], #4
34183bae:	4770      	bx	lr
34183bb0:	56028000 	.word	0x56028000

34183bb4 <LL_RCC_PLL2_IsReady>:
{
34183bb4:	b480      	push	{r7}
34183bb6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34183bb8:	4b07      	ldr	r3, [pc, #28]	@ (34183bd8 <LL_RCC_PLL2_IsReady+0x24>)
34183bba:	685b      	ldr	r3, [r3, #4]
34183bbc:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34183bc0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34183bc4:	d101      	bne.n	34183bca <LL_RCC_PLL2_IsReady+0x16>
34183bc6:	2301      	movs	r3, #1
34183bc8:	e000      	b.n	34183bcc <LL_RCC_PLL2_IsReady+0x18>
34183bca:	2300      	movs	r3, #0
}
34183bcc:	4618      	mov	r0, r3
34183bce:	46bd      	mov	sp, r7
34183bd0:	f85d 7b04 	ldr.w	r7, [sp], #4
34183bd4:	4770      	bx	lr
34183bd6:	bf00      	nop
34183bd8:	56028000 	.word	0x56028000

34183bdc <LL_RCC_PLL2_IsEnabledBypass>:
{
34183bdc:	b480      	push	{r7}
34183bde:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34183be0:	4b07      	ldr	r3, [pc, #28]	@ (34183c00 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
34183be2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34183be6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34183bea:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34183bee:	d101      	bne.n	34183bf4 <LL_RCC_PLL2_IsEnabledBypass+0x18>
34183bf0:	2301      	movs	r3, #1
34183bf2:	e000      	b.n	34183bf6 <LL_RCC_PLL2_IsEnabledBypass+0x1a>
34183bf4:	2300      	movs	r3, #0
}
34183bf6:	4618      	mov	r0, r3
34183bf8:	46bd      	mov	sp, r7
34183bfa:	f85d 7b04 	ldr.w	r7, [sp], #4
34183bfe:	4770      	bx	lr
34183c00:	56028000 	.word	0x56028000

34183c04 <LL_RCC_PLL2_GetN>:
{
34183c04:	b480      	push	{r7}
34183c06:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
34183c08:	4b05      	ldr	r3, [pc, #20]	@ (34183c20 <LL_RCC_PLL2_GetN+0x1c>)
34183c0a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34183c0e:	0a1b      	lsrs	r3, r3, #8
34183c10:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34183c14:	4618      	mov	r0, r3
34183c16:	46bd      	mov	sp, r7
34183c18:	f85d 7b04 	ldr.w	r7, [sp], #4
34183c1c:	4770      	bx	lr
34183c1e:	bf00      	nop
34183c20:	56028000 	.word	0x56028000

34183c24 <LL_RCC_PLL2_GetM>:
{
34183c24:	b480      	push	{r7}
34183c26:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
34183c28:	4b05      	ldr	r3, [pc, #20]	@ (34183c40 <LL_RCC_PLL2_GetM+0x1c>)
34183c2a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34183c2e:	0d1b      	lsrs	r3, r3, #20
34183c30:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34183c34:	4618      	mov	r0, r3
34183c36:	46bd      	mov	sp, r7
34183c38:	f85d 7b04 	ldr.w	r7, [sp], #4
34183c3c:	4770      	bx	lr
34183c3e:	bf00      	nop
34183c40:	56028000 	.word	0x56028000

34183c44 <LL_RCC_PLL2_GetP1>:
{
34183c44:	b480      	push	{r7}
34183c46:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
34183c48:	4b05      	ldr	r3, [pc, #20]	@ (34183c60 <LL_RCC_PLL2_GetP1+0x1c>)
34183c4a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34183c4e:	0edb      	lsrs	r3, r3, #27
34183c50:	f003 0307 	and.w	r3, r3, #7
}
34183c54:	4618      	mov	r0, r3
34183c56:	46bd      	mov	sp, r7
34183c58:	f85d 7b04 	ldr.w	r7, [sp], #4
34183c5c:	4770      	bx	lr
34183c5e:	bf00      	nop
34183c60:	56028000 	.word	0x56028000

34183c64 <LL_RCC_PLL2_GetP2>:
{
34183c64:	b480      	push	{r7}
34183c66:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
34183c68:	4b05      	ldr	r3, [pc, #20]	@ (34183c80 <LL_RCC_PLL2_GetP2+0x1c>)
34183c6a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34183c6e:	0e1b      	lsrs	r3, r3, #24
34183c70:	f003 0307 	and.w	r3, r3, #7
}
34183c74:	4618      	mov	r0, r3
34183c76:	46bd      	mov	sp, r7
34183c78:	f85d 7b04 	ldr.w	r7, [sp], #4
34183c7c:	4770      	bx	lr
34183c7e:	bf00      	nop
34183c80:	56028000 	.word	0x56028000

34183c84 <LL_RCC_PLL2P_IsEnabled>:
{
34183c84:	b480      	push	{r7}
34183c86:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
34183c88:	4b07      	ldr	r3, [pc, #28]	@ (34183ca8 <LL_RCC_PLL2P_IsEnabled+0x24>)
34183c8a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34183c8e:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34183c92:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34183c96:	d101      	bne.n	34183c9c <LL_RCC_PLL2P_IsEnabled+0x18>
34183c98:	2301      	movs	r3, #1
34183c9a:	e000      	b.n	34183c9e <LL_RCC_PLL2P_IsEnabled+0x1a>
34183c9c:	2300      	movs	r3, #0
}
34183c9e:	4618      	mov	r0, r3
34183ca0:	46bd      	mov	sp, r7
34183ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
34183ca6:	4770      	bx	lr
34183ca8:	56028000 	.word	0x56028000

34183cac <LL_RCC_PLL2_GetFRACN>:
{
34183cac:	b480      	push	{r7}
34183cae:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
34183cb0:	4b04      	ldr	r3, [pc, #16]	@ (34183cc4 <LL_RCC_PLL2_GetFRACN+0x18>)
34183cb2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34183cb6:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34183cba:	4618      	mov	r0, r3
34183cbc:	46bd      	mov	sp, r7
34183cbe:	f85d 7b04 	ldr.w	r7, [sp], #4
34183cc2:	4770      	bx	lr
34183cc4:	56028000 	.word	0x56028000

34183cc8 <LL_RCC_PLL3_GetSource>:
{
34183cc8:	b480      	push	{r7}
34183cca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34183ccc:	4b04      	ldr	r3, [pc, #16]	@ (34183ce0 <LL_RCC_PLL3_GetSource+0x18>)
34183cce:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34183cd2:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34183cd6:	4618      	mov	r0, r3
34183cd8:	46bd      	mov	sp, r7
34183cda:	f85d 7b04 	ldr.w	r7, [sp], #4
34183cde:	4770      	bx	lr
34183ce0:	56028000 	.word	0x56028000

34183ce4 <LL_RCC_PLL3_IsReady>:
{
34183ce4:	b480      	push	{r7}
34183ce6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
34183ce8:	4b07      	ldr	r3, [pc, #28]	@ (34183d08 <LL_RCC_PLL3_IsReady+0x24>)
34183cea:	685b      	ldr	r3, [r3, #4]
34183cec:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34183cf0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34183cf4:	d101      	bne.n	34183cfa <LL_RCC_PLL3_IsReady+0x16>
34183cf6:	2301      	movs	r3, #1
34183cf8:	e000      	b.n	34183cfc <LL_RCC_PLL3_IsReady+0x18>
34183cfa:	2300      	movs	r3, #0
}
34183cfc:	4618      	mov	r0, r3
34183cfe:	46bd      	mov	sp, r7
34183d00:	f85d 7b04 	ldr.w	r7, [sp], #4
34183d04:	4770      	bx	lr
34183d06:	bf00      	nop
34183d08:	56028000 	.word	0x56028000

34183d0c <LL_RCC_PLL3_IsEnabledBypass>:
{
34183d0c:	b480      	push	{r7}
34183d0e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34183d10:	4b07      	ldr	r3, [pc, #28]	@ (34183d30 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
34183d12:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34183d16:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34183d1a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34183d1e:	d101      	bne.n	34183d24 <LL_RCC_PLL3_IsEnabledBypass+0x18>
34183d20:	2301      	movs	r3, #1
34183d22:	e000      	b.n	34183d26 <LL_RCC_PLL3_IsEnabledBypass+0x1a>
34183d24:	2300      	movs	r3, #0
}
34183d26:	4618      	mov	r0, r3
34183d28:	46bd      	mov	sp, r7
34183d2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34183d2e:	4770      	bx	lr
34183d30:	56028000 	.word	0x56028000

34183d34 <LL_RCC_PLL3_GetN>:
{
34183d34:	b480      	push	{r7}
34183d36:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
34183d38:	4b05      	ldr	r3, [pc, #20]	@ (34183d50 <LL_RCC_PLL3_GetN+0x1c>)
34183d3a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34183d3e:	0a1b      	lsrs	r3, r3, #8
34183d40:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34183d44:	4618      	mov	r0, r3
34183d46:	46bd      	mov	sp, r7
34183d48:	f85d 7b04 	ldr.w	r7, [sp], #4
34183d4c:	4770      	bx	lr
34183d4e:	bf00      	nop
34183d50:	56028000 	.word	0x56028000

34183d54 <LL_RCC_PLL3_GetM>:
{
34183d54:	b480      	push	{r7}
34183d56:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
34183d58:	4b05      	ldr	r3, [pc, #20]	@ (34183d70 <LL_RCC_PLL3_GetM+0x1c>)
34183d5a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34183d5e:	0d1b      	lsrs	r3, r3, #20
34183d60:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34183d64:	4618      	mov	r0, r3
34183d66:	46bd      	mov	sp, r7
34183d68:	f85d 7b04 	ldr.w	r7, [sp], #4
34183d6c:	4770      	bx	lr
34183d6e:	bf00      	nop
34183d70:	56028000 	.word	0x56028000

34183d74 <LL_RCC_PLL3_GetP1>:
{
34183d74:	b480      	push	{r7}
34183d76:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
34183d78:	4b05      	ldr	r3, [pc, #20]	@ (34183d90 <LL_RCC_PLL3_GetP1+0x1c>)
34183d7a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34183d7e:	0edb      	lsrs	r3, r3, #27
34183d80:	f003 0307 	and.w	r3, r3, #7
}
34183d84:	4618      	mov	r0, r3
34183d86:	46bd      	mov	sp, r7
34183d88:	f85d 7b04 	ldr.w	r7, [sp], #4
34183d8c:	4770      	bx	lr
34183d8e:	bf00      	nop
34183d90:	56028000 	.word	0x56028000

34183d94 <LL_RCC_PLL3_GetP2>:
{
34183d94:	b480      	push	{r7}
34183d96:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
34183d98:	4b05      	ldr	r3, [pc, #20]	@ (34183db0 <LL_RCC_PLL3_GetP2+0x1c>)
34183d9a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34183d9e:	0e1b      	lsrs	r3, r3, #24
34183da0:	f003 0307 	and.w	r3, r3, #7
}
34183da4:	4618      	mov	r0, r3
34183da6:	46bd      	mov	sp, r7
34183da8:	f85d 7b04 	ldr.w	r7, [sp], #4
34183dac:	4770      	bx	lr
34183dae:	bf00      	nop
34183db0:	56028000 	.word	0x56028000

34183db4 <LL_RCC_PLL3P_IsEnabled>:
{
34183db4:	b480      	push	{r7}
34183db6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
34183db8:	4b07      	ldr	r3, [pc, #28]	@ (34183dd8 <LL_RCC_PLL3P_IsEnabled+0x24>)
34183dba:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34183dbe:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34183dc2:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34183dc6:	d101      	bne.n	34183dcc <LL_RCC_PLL3P_IsEnabled+0x18>
34183dc8:	2301      	movs	r3, #1
34183dca:	e000      	b.n	34183dce <LL_RCC_PLL3P_IsEnabled+0x1a>
34183dcc:	2300      	movs	r3, #0
}
34183dce:	4618      	mov	r0, r3
34183dd0:	46bd      	mov	sp, r7
34183dd2:	f85d 7b04 	ldr.w	r7, [sp], #4
34183dd6:	4770      	bx	lr
34183dd8:	56028000 	.word	0x56028000

34183ddc <LL_RCC_PLL3_GetFRACN>:
{
34183ddc:	b480      	push	{r7}
34183dde:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
34183de0:	4b04      	ldr	r3, [pc, #16]	@ (34183df4 <LL_RCC_PLL3_GetFRACN+0x18>)
34183de2:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34183de6:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34183dea:	4618      	mov	r0, r3
34183dec:	46bd      	mov	sp, r7
34183dee:	f85d 7b04 	ldr.w	r7, [sp], #4
34183df2:	4770      	bx	lr
34183df4:	56028000 	.word	0x56028000

34183df8 <LL_RCC_PLL4_GetSource>:
{
34183df8:	b480      	push	{r7}
34183dfa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34183dfc:	4b04      	ldr	r3, [pc, #16]	@ (34183e10 <LL_RCC_PLL4_GetSource+0x18>)
34183dfe:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34183e02:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34183e06:	4618      	mov	r0, r3
34183e08:	46bd      	mov	sp, r7
34183e0a:	f85d 7b04 	ldr.w	r7, [sp], #4
34183e0e:	4770      	bx	lr
34183e10:	56028000 	.word	0x56028000

34183e14 <LL_RCC_PLL4_IsReady>:
{
34183e14:	b480      	push	{r7}
34183e16:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34183e18:	4b07      	ldr	r3, [pc, #28]	@ (34183e38 <LL_RCC_PLL4_IsReady+0x24>)
34183e1a:	685b      	ldr	r3, [r3, #4]
34183e1c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34183e20:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34183e24:	d101      	bne.n	34183e2a <LL_RCC_PLL4_IsReady+0x16>
34183e26:	2301      	movs	r3, #1
34183e28:	e000      	b.n	34183e2c <LL_RCC_PLL4_IsReady+0x18>
34183e2a:	2300      	movs	r3, #0
}
34183e2c:	4618      	mov	r0, r3
34183e2e:	46bd      	mov	sp, r7
34183e30:	f85d 7b04 	ldr.w	r7, [sp], #4
34183e34:	4770      	bx	lr
34183e36:	bf00      	nop
34183e38:	56028000 	.word	0x56028000

34183e3c <LL_RCC_PLL4_IsEnabledBypass>:
{
34183e3c:	b480      	push	{r7}
34183e3e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34183e40:	4b07      	ldr	r3, [pc, #28]	@ (34183e60 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
34183e42:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34183e46:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34183e4a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34183e4e:	d101      	bne.n	34183e54 <LL_RCC_PLL4_IsEnabledBypass+0x18>
34183e50:	2301      	movs	r3, #1
34183e52:	e000      	b.n	34183e56 <LL_RCC_PLL4_IsEnabledBypass+0x1a>
34183e54:	2300      	movs	r3, #0
}
34183e56:	4618      	mov	r0, r3
34183e58:	46bd      	mov	sp, r7
34183e5a:	f85d 7b04 	ldr.w	r7, [sp], #4
34183e5e:	4770      	bx	lr
34183e60:	56028000 	.word	0x56028000

34183e64 <LL_RCC_PLL4_GetN>:
{
34183e64:	b480      	push	{r7}
34183e66:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
34183e68:	4b05      	ldr	r3, [pc, #20]	@ (34183e80 <LL_RCC_PLL4_GetN+0x1c>)
34183e6a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34183e6e:	0a1b      	lsrs	r3, r3, #8
34183e70:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34183e74:	4618      	mov	r0, r3
34183e76:	46bd      	mov	sp, r7
34183e78:	f85d 7b04 	ldr.w	r7, [sp], #4
34183e7c:	4770      	bx	lr
34183e7e:	bf00      	nop
34183e80:	56028000 	.word	0x56028000

34183e84 <LL_RCC_PLL4_GetM>:
{
34183e84:	b480      	push	{r7}
34183e86:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
34183e88:	4b05      	ldr	r3, [pc, #20]	@ (34183ea0 <LL_RCC_PLL4_GetM+0x1c>)
34183e8a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34183e8e:	0d1b      	lsrs	r3, r3, #20
34183e90:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34183e94:	4618      	mov	r0, r3
34183e96:	46bd      	mov	sp, r7
34183e98:	f85d 7b04 	ldr.w	r7, [sp], #4
34183e9c:	4770      	bx	lr
34183e9e:	bf00      	nop
34183ea0:	56028000 	.word	0x56028000

34183ea4 <LL_RCC_PLL4_GetP1>:
{
34183ea4:	b480      	push	{r7}
34183ea6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
34183ea8:	4b05      	ldr	r3, [pc, #20]	@ (34183ec0 <LL_RCC_PLL4_GetP1+0x1c>)
34183eaa:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34183eae:	0edb      	lsrs	r3, r3, #27
34183eb0:	f003 0307 	and.w	r3, r3, #7
}
34183eb4:	4618      	mov	r0, r3
34183eb6:	46bd      	mov	sp, r7
34183eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
34183ebc:	4770      	bx	lr
34183ebe:	bf00      	nop
34183ec0:	56028000 	.word	0x56028000

34183ec4 <LL_RCC_PLL4_GetP2>:
{
34183ec4:	b480      	push	{r7}
34183ec6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
34183ec8:	4b05      	ldr	r3, [pc, #20]	@ (34183ee0 <LL_RCC_PLL4_GetP2+0x1c>)
34183eca:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34183ece:	0e1b      	lsrs	r3, r3, #24
34183ed0:	f003 0307 	and.w	r3, r3, #7
}
34183ed4:	4618      	mov	r0, r3
34183ed6:	46bd      	mov	sp, r7
34183ed8:	f85d 7b04 	ldr.w	r7, [sp], #4
34183edc:	4770      	bx	lr
34183ede:	bf00      	nop
34183ee0:	56028000 	.word	0x56028000

34183ee4 <LL_RCC_PLL4P_IsEnabled>:
{
34183ee4:	b480      	push	{r7}
34183ee6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
34183ee8:	4b07      	ldr	r3, [pc, #28]	@ (34183f08 <LL_RCC_PLL4P_IsEnabled+0x24>)
34183eea:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34183eee:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34183ef2:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34183ef6:	d101      	bne.n	34183efc <LL_RCC_PLL4P_IsEnabled+0x18>
34183ef8:	2301      	movs	r3, #1
34183efa:	e000      	b.n	34183efe <LL_RCC_PLL4P_IsEnabled+0x1a>
34183efc:	2300      	movs	r3, #0
}
34183efe:	4618      	mov	r0, r3
34183f00:	46bd      	mov	sp, r7
34183f02:	f85d 7b04 	ldr.w	r7, [sp], #4
34183f06:	4770      	bx	lr
34183f08:	56028000 	.word	0x56028000

34183f0c <LL_RCC_PLL4_GetFRACN>:
{
34183f0c:	b480      	push	{r7}
34183f0e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
34183f10:	4b04      	ldr	r3, [pc, #16]	@ (34183f24 <LL_RCC_PLL4_GetFRACN+0x18>)
34183f12:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34183f16:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34183f1a:	4618      	mov	r0, r3
34183f1c:	46bd      	mov	sp, r7
34183f1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34183f22:	4770      	bx	lr
34183f24:	56028000 	.word	0x56028000

34183f28 <LL_RCC_IC3_Enable>:
{
34183f28:	b480      	push	{r7}
34183f2a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
34183f2c:	4b04      	ldr	r3, [pc, #16]	@ (34183f40 <LL_RCC_IC3_Enable+0x18>)
34183f2e:	2204      	movs	r2, #4
34183f30:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34183f34:	bf00      	nop
34183f36:	46bd      	mov	sp, r7
34183f38:	f85d 7b04 	ldr.w	r7, [sp], #4
34183f3c:	4770      	bx	lr
34183f3e:	bf00      	nop
34183f40:	56028000 	.word	0x56028000

34183f44 <LL_RCC_IC4_Enable>:
{
34183f44:	b480      	push	{r7}
34183f46:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
34183f48:	4b04      	ldr	r3, [pc, #16]	@ (34183f5c <LL_RCC_IC4_Enable+0x18>)
34183f4a:	2208      	movs	r2, #8
34183f4c:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34183f50:	bf00      	nop
34183f52:	46bd      	mov	sp, r7
34183f54:	f85d 7b04 	ldr.w	r7, [sp], #4
34183f58:	4770      	bx	lr
34183f5a:	bf00      	nop
34183f5c:	56028000 	.word	0x56028000

34183f60 <LL_RCC_IC5_Enable>:
{
34183f60:	b480      	push	{r7}
34183f62:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
34183f64:	4b04      	ldr	r3, [pc, #16]	@ (34183f78 <LL_RCC_IC5_Enable+0x18>)
34183f66:	2210      	movs	r2, #16
34183f68:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34183f6c:	bf00      	nop
34183f6e:	46bd      	mov	sp, r7
34183f70:	f85d 7b04 	ldr.w	r7, [sp], #4
34183f74:	4770      	bx	lr
34183f76:	bf00      	nop
34183f78:	56028000 	.word	0x56028000

34183f7c <LL_RCC_IC7_Enable>:
{
34183f7c:	b480      	push	{r7}
34183f7e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
34183f80:	4b04      	ldr	r3, [pc, #16]	@ (34183f94 <LL_RCC_IC7_Enable+0x18>)
34183f82:	2240      	movs	r2, #64	@ 0x40
34183f84:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34183f88:	bf00      	nop
34183f8a:	46bd      	mov	sp, r7
34183f8c:	f85d 7b04 	ldr.w	r7, [sp], #4
34183f90:	4770      	bx	lr
34183f92:	bf00      	nop
34183f94:	56028000 	.word	0x56028000

34183f98 <LL_RCC_IC8_Enable>:
{
34183f98:	b480      	push	{r7}
34183f9a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34183f9c:	4b04      	ldr	r3, [pc, #16]	@ (34183fb0 <LL_RCC_IC8_Enable+0x18>)
34183f9e:	2280      	movs	r2, #128	@ 0x80
34183fa0:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34183fa4:	bf00      	nop
34183fa6:	46bd      	mov	sp, r7
34183fa8:	f85d 7b04 	ldr.w	r7, [sp], #4
34183fac:	4770      	bx	lr
34183fae:	bf00      	nop
34183fb0:	56028000 	.word	0x56028000

34183fb4 <LL_RCC_IC9_Enable>:
{
34183fb4:	b480      	push	{r7}
34183fb6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34183fb8:	4b04      	ldr	r3, [pc, #16]	@ (34183fcc <LL_RCC_IC9_Enable+0x18>)
34183fba:	f44f 7280 	mov.w	r2, #256	@ 0x100
34183fbe:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34183fc2:	bf00      	nop
34183fc4:	46bd      	mov	sp, r7
34183fc6:	f85d 7b04 	ldr.w	r7, [sp], #4
34183fca:	4770      	bx	lr
34183fcc:	56028000 	.word	0x56028000

34183fd0 <LL_RCC_IC10_Enable>:
{
34183fd0:	b480      	push	{r7}
34183fd2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34183fd4:	4b04      	ldr	r3, [pc, #16]	@ (34183fe8 <LL_RCC_IC10_Enable+0x18>)
34183fd6:	f44f 7200 	mov.w	r2, #512	@ 0x200
34183fda:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34183fde:	bf00      	nop
34183fe0:	46bd      	mov	sp, r7
34183fe2:	f85d 7b04 	ldr.w	r7, [sp], #4
34183fe6:	4770      	bx	lr
34183fe8:	56028000 	.word	0x56028000

34183fec <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
34183fec:	b480      	push	{r7}
34183fee:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
34183ff0:	4b04      	ldr	r3, [pc, #16]	@ (34184004 <LL_RCC_IC12_Enable+0x18>)
34183ff2:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34183ff6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34183ffa:	bf00      	nop
34183ffc:	46bd      	mov	sp, r7
34183ffe:	f85d 7b04 	ldr.w	r7, [sp], #4
34184002:	4770      	bx	lr
34184004:	56028000 	.word	0x56028000

34184008 <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
34184008:	b480      	push	{r7}
3418400a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
3418400c:	4b04      	ldr	r3, [pc, #16]	@ (34184020 <LL_RCC_IC13_Enable+0x18>)
3418400e:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34184012:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34184016:	bf00      	nop
34184018:	46bd      	mov	sp, r7
3418401a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418401e:	4770      	bx	lr
34184020:	56028000 	.word	0x56028000

34184024 <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
34184024:	b480      	push	{r7}
34184026:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34184028:	4b04      	ldr	r3, [pc, #16]	@ (3418403c <LL_RCC_IC14_Enable+0x18>)
3418402a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
3418402e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34184032:	bf00      	nop
34184034:	46bd      	mov	sp, r7
34184036:	f85d 7b04 	ldr.w	r7, [sp], #4
3418403a:	4770      	bx	lr
3418403c:	56028000 	.word	0x56028000

34184040 <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
34184040:	b480      	push	{r7}
34184042:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34184044:	4b04      	ldr	r3, [pc, #16]	@ (34184058 <LL_RCC_IC15_Enable+0x18>)
34184046:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
3418404a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418404e:	bf00      	nop
34184050:	46bd      	mov	sp, r7
34184052:	f85d 7b04 	ldr.w	r7, [sp], #4
34184056:	4770      	bx	lr
34184058:	56028000 	.word	0x56028000

3418405c <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
3418405c:	b480      	push	{r7}
3418405e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
34184060:	4b04      	ldr	r3, [pc, #16]	@ (34184074 <LL_RCC_IC16_Enable+0x18>)
34184062:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34184066:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418406a:	bf00      	nop
3418406c:	46bd      	mov	sp, r7
3418406e:	f85d 7b04 	ldr.w	r7, [sp], #4
34184072:	4770      	bx	lr
34184074:	56028000 	.word	0x56028000

34184078 <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
34184078:	b480      	push	{r7}
3418407a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
3418407c:	4b04      	ldr	r3, [pc, #16]	@ (34184090 <LL_RCC_IC17_Enable+0x18>)
3418407e:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34184082:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34184086:	bf00      	nop
34184088:	46bd      	mov	sp, r7
3418408a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418408e:	4770      	bx	lr
34184090:	56028000 	.word	0x56028000

34184094 <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
34184094:	b480      	push	{r7}
34184096:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
34184098:	4b04      	ldr	r3, [pc, #16]	@ (341840ac <LL_RCC_IC18_Enable+0x18>)
3418409a:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
3418409e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341840a2:	bf00      	nop
341840a4:	46bd      	mov	sp, r7
341840a6:	f85d 7b04 	ldr.w	r7, [sp], #4
341840aa:	4770      	bx	lr
341840ac:	56028000 	.word	0x56028000

341840b0 <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
341840b0:	b480      	push	{r7}
341840b2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
341840b4:	4b04      	ldr	r3, [pc, #16]	@ (341840c8 <LL_RCC_IC19_Enable+0x18>)
341840b6:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
341840ba:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341840be:	bf00      	nop
341840c0:	46bd      	mov	sp, r7
341840c2:	f85d 7b04 	ldr.w	r7, [sp], #4
341840c6:	4770      	bx	lr
341840c8:	56028000 	.word	0x56028000

341840cc <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
341840cc:	b480      	push	{r7}
341840ce:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
341840d0:	4b04      	ldr	r3, [pc, #16]	@ (341840e4 <LL_RCC_IC20_Enable+0x18>)
341840d2:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
341840d6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341840da:	bf00      	nop
341840dc:	46bd      	mov	sp, r7
341840de:	f85d 7b04 	ldr.w	r7, [sp], #4
341840e2:	4770      	bx	lr
341840e4:	56028000 	.word	0x56028000

341840e8 <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
341840e8:	b480      	push	{r7}
341840ea:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
341840ec:	4b04      	ldr	r3, [pc, #16]	@ (34184100 <LL_RCC_CLKP_Enable+0x18>)
341840ee:	2240      	movs	r2, #64	@ 0x40
341840f0:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
341840f4:	bf00      	nop
341840f6:	46bd      	mov	sp, r7
341840f8:	f85d 7b04 	ldr.w	r7, [sp], #4
341840fc:	4770      	bx	lr
341840fe:	bf00      	nop
34184100:	56028000 	.word	0x56028000

34184104 <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
34184104:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
34184108:	b0f2      	sub	sp, #456	@ 0x1c8
3418410a:	af00      	add	r7, sp, #0
3418410c:	f8c7 01b4 	str.w	r0, [r7, #436]	@ 0x1b4
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
34184110:	2300      	movs	r3, #0
34184112:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
34184116:	2300      	movs	r3, #0
34184118:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3418411c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184120:	e9d3 2300 	ldrd	r2, r3, [r3]
34184124:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
34184128:	2500      	movs	r5, #0
3418412a:	ea54 0305 	orrs.w	r3, r4, r5
3418412e:	d06c      	beq.n	3418420a <HAL_RCCEx_PeriphCLKConfig+0x106>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
34184130:	f7ff fc60 	bl	341839f4 <LL_RCC_GetRTCClockSource>
34184134:	f8c7 01c0 	str.w	r0, [r7, #448]	@ 0x1c0

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
34184138:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
3418413c:	2b00      	cmp	r3, #0
3418413e:	d018      	beq.n	34184172 <HAL_RCCEx_PeriphCLKConfig+0x6e>
34184140:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184144:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34184148:	f403 7240 	and.w	r2, r3, #768	@ 0x300
3418414c:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
34184150:	4293      	cmp	r3, r2
34184152:	d00e      	beq.n	34184172 <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
34184154:	4bc3      	ldr	r3, [pc, #780]	@ (34184464 <HAL_RCCEx_PeriphCLKConfig+0x360>)
34184156:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34184158:	4ac2      	ldr	r2, [pc, #776]	@ (34184464 <HAL_RCCEx_PeriphCLKConfig+0x360>)
3418415a:	f043 0301 	orr.w	r3, r3, #1
3418415e:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
34184160:	4bc0      	ldr	r3, [pc, #768]	@ (34184464 <HAL_RCCEx_PeriphCLKConfig+0x360>)
34184162:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34184164:	f003 0301 	and.w	r3, r3, #1
34184168:	2b00      	cmp	r3, #0
3418416a:	d102      	bne.n	34184172 <HAL_RCCEx_PeriphCLKConfig+0x6e>
      {
        ret = HAL_ERROR;
3418416c:	2301      	movs	r3, #1
3418416e:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
34184172:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34184176:	2b00      	cmp	r3, #0
34184178:	d143      	bne.n	34184202 <HAL_RCCEx_PeriphCLKConfig+0xfe>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
3418417a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418417e:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34184182:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34184186:	d117      	bne.n	341841b8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34184188:	f7fd fa1a 	bl	341815c0 <HAL_GetTick>
3418418c:	f8c7 01bc 	str.w	r0, [r7, #444]	@ 0x1bc

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
34184190:	e00d      	b.n	341841ae <HAL_RCCEx_PeriphCLKConfig+0xaa>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34184192:	f7fd fa15 	bl	341815c0 <HAL_GetTick>
34184196:	4602      	mov	r2, r0
34184198:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
3418419c:	1ad2      	subs	r2, r2, r3
3418419e:	f241 3388 	movw	r3, #5000	@ 0x1388
341841a2:	429a      	cmp	r2, r3
341841a4:	d903      	bls.n	341841ae <HAL_RCCEx_PeriphCLKConfig+0xaa>
          {
            ret = HAL_TIMEOUT;
341841a6:	2303      	movs	r3, #3
341841a8:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
            break;
341841ac:	e004      	b.n	341841b8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
        while (LL_RCC_LSE_IsReady() == 0U)
341841ae:	f7ff fa2b 	bl	34183608 <LL_RCC_LSE_IsReady>
341841b2:	4603      	mov	r3, r0
341841b4:	2b00      	cmp	r3, #0
341841b6:	d0ec      	beq.n	34184192 <HAL_RCCEx_PeriphCLKConfig+0x8e>
          }
        }
      }

      if (ret == HAL_OK)
341841b8:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
341841bc:	2b00      	cmp	r3, #0
341841be:	d11b      	bne.n	341841f8 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
341841c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341841c4:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
341841c8:	f403 7340 	and.w	r3, r3, #768	@ 0x300
341841cc:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
341841d0:	d108      	bne.n	341841e4 <HAL_RCCEx_PeriphCLKConfig+0xe0>
341841d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341841d6:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
341841da:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
341841de:	4618      	mov	r0, r3
341841e0:	f7ff fc16 	bl	34183a10 <LL_RCC_SetRTC_HSEPrescaler>
341841e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341841e8:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
341841ec:	f403 7340 	and.w	r3, r3, #768	@ 0x300
341841f0:	4618      	mov	r0, r3
341841f2:	f7ff fbe9 	bl	341839c8 <LL_RCC_SetRTCClockSource>
341841f6:	e008      	b.n	3418420a <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
      else
      {
        /* set overall return value */
        status = ret;
341841f8:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
341841fc:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
34184200:	e003      	b.n	3418420a <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
34184202:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34184206:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3418420a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418420e:	e9d3 2300 	ldrd	r2, r3, [r3]
34184212:	f002 0804 	and.w	r8, r2, #4
34184216:	f04f 0900 	mov.w	r9, #0
3418421a:	ea58 0309 	orrs.w	r3, r8, r9
3418421e:	f000 809b 	beq.w	34184358 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
34184222:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184226:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418422a:	2b04      	cmp	r3, #4
3418422c:	d116      	bne.n	3418425c <HAL_RCCEx_PeriphCLKConfig+0x158>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418422e:	4b8e      	ldr	r3, [pc, #568]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34184230:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34184234:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184238:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418423c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184240:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34184242:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184246:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34184248:	3b01      	subs	r3, #1
3418424a:	041b      	lsls	r3, r3, #16
3418424c:	4313      	orrs	r3, r2
3418424e:	4a86      	ldr	r2, [pc, #536]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34184250:	430b      	orrs	r3, r1
34184252:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34184256:	f7ff fe83 	bl	34183f60 <LL_RCC_IC5_Enable>
3418425a:	e076      	b.n	3418434a <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
3418425c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184260:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34184264:	2b05      	cmp	r3, #5
34184266:	d116      	bne.n	34184296 <HAL_RCCEx_PeriphCLKConfig+0x192>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34184268:	4b7f      	ldr	r3, [pc, #508]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418426a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418426e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184272:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184276:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418427a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418427c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184280:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34184282:	3b01      	subs	r3, #1
34184284:	041b      	lsls	r3, r3, #16
34184286:	4313      	orrs	r3, r2
34184288:	4a77      	ldr	r2, [pc, #476]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418428a:	430b      	orrs	r3, r1
3418428c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34184290:	f7ff fe9e 	bl	34183fd0 <LL_RCC_IC10_Enable>
34184294:	e059      	b.n	3418434a <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
34184296:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418429a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418429e:	2b06      	cmp	r3, #6
341842a0:	d116      	bne.n	341842d0 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341842a2:	4b71      	ldr	r3, [pc, #452]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
341842a4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341842a8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341842ac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341842b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341842b4:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341842b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341842ba:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341842bc:	3b01      	subs	r3, #1
341842be:	041b      	lsls	r3, r3, #16
341842c0:	4313      	orrs	r3, r2
341842c2:	4a69      	ldr	r2, [pc, #420]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
341842c4:	430b      	orrs	r3, r1
341842c6:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341842ca:	f7ff feb9 	bl	34184040 <LL_RCC_IC15_Enable>
341842ce:	e03c      	b.n	3418434a <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
341842d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341842d4:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
341842d8:	2b03      	cmp	r3, #3
341842da:	d118      	bne.n	3418430e <HAL_RCCEx_PeriphCLKConfig+0x20a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
341842dc:	4b62      	ldr	r3, [pc, #392]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
341842de:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
341842e2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341842e6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341842ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341842ee:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
341842f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341842f6:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
341842fa:	3b01      	subs	r3, #1
341842fc:	041b      	lsls	r3, r3, #16
341842fe:	4313      	orrs	r3, r2
34184300:	4a59      	ldr	r2, [pc, #356]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34184302:	430b      	orrs	r3, r1
34184304:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34184308:	f7ff fed2 	bl	341840b0 <LL_RCC_IC19_Enable>
3418430c:	e01d      	b.n	3418434a <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
3418430e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184312:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34184316:	2b07      	cmp	r3, #7
34184318:	d117      	bne.n	3418434a <HAL_RCCEx_PeriphCLKConfig+0x246>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3418431a:	4b53      	ldr	r3, [pc, #332]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418431c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34184320:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184324:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184328:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418432c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34184330:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184334:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34184338:	3b01      	subs	r3, #1
3418433a:	041b      	lsls	r3, r3, #16
3418433c:	4313      	orrs	r3, r2
3418433e:	4a4a      	ldr	r2, [pc, #296]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34184340:	430b      	orrs	r3, r1
34184342:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
34184346:	f7ff fec1 	bl	341840cc <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
3418434a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418434e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34184352:	4618      	mov	r0, r3
34184354:	f7ff f9aa 	bl	341836ac <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
34184358:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418435c:	e9d3 2300 	ldrd	r2, r3, [r3]
34184360:	f04f 0a00 	mov.w	sl, #0
34184364:	f403 0b80 	and.w	fp, r3, #4194304	@ 0x400000
34184368:	ea5a 030b 	orrs.w	r3, sl, fp
3418436c:	d04b      	beq.n	34184406 <HAL_RCCEx_PeriphCLKConfig+0x302>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3418436e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184372:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
34184376:	4b3d      	ldr	r3, [pc, #244]	@ (3418446c <HAL_RCCEx_PeriphCLKConfig+0x368>)
34184378:	429a      	cmp	r2, r3
3418437a:	d116      	bne.n	341843aa <HAL_RCCEx_PeriphCLKConfig+0x2a6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418437c:	4b3a      	ldr	r3, [pc, #232]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418437e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34184382:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184386:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418438a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418438e:	699a      	ldr	r2, [r3, #24]
34184390:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184394:	69db      	ldr	r3, [r3, #28]
34184396:	3b01      	subs	r3, #1
34184398:	041b      	lsls	r3, r3, #16
3418439a:	4313      	orrs	r3, r2
3418439c:	4a32      	ldr	r2, [pc, #200]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418439e:	430b      	orrs	r3, r1
341843a0:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
341843a4:	f7ff fdc0 	bl	34183f28 <LL_RCC_IC3_Enable>
341843a8:	e026      	b.n	341843f8 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
341843aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341843ae:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
341843b2:	4b2f      	ldr	r3, [pc, #188]	@ (34184470 <HAL_RCCEx_PeriphCLKConfig+0x36c>)
341843b4:	429a      	cmp	r2, r3
341843b6:	d116      	bne.n	341843e6 <HAL_RCCEx_PeriphCLKConfig+0x2e2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
341843b8:	4b2b      	ldr	r3, [pc, #172]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
341843ba:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
341843be:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341843c2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341843c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341843ca:	6a1a      	ldr	r2, [r3, #32]
341843cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341843d0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341843d2:	3b01      	subs	r3, #1
341843d4:	041b      	lsls	r3, r3, #16
341843d6:	4313      	orrs	r3, r2
341843d8:	4a23      	ldr	r2, [pc, #140]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
341843da:	430b      	orrs	r3, r1
341843dc:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
341843e0:	f7ff fdb0 	bl	34183f44 <LL_RCC_IC4_Enable>
341843e4:	e008      	b.n	341843f8 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
341843e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341843ea:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
341843ee:	4b21      	ldr	r3, [pc, #132]	@ (34184474 <HAL_RCCEx_PeriphCLKConfig+0x370>)
341843f0:	429a      	cmp	r2, r3
341843f2:	d101      	bne.n	341843f8 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    {
      LL_RCC_CLKP_Enable();
341843f4:	f7ff fe78 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
341843f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341843fc:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34184400:	4618      	mov	r0, r3
34184402:	f7ff fad5 	bl	341839b0 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
34184406:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418440a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418440e:	2100      	movs	r1, #0
34184410:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
34184414:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34184418:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
3418441c:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
34184420:	4603      	mov	r3, r0
34184422:	460a      	mov	r2, r1
34184424:	4313      	orrs	r3, r2
34184426:	d057      	beq.n	341844d8 <HAL_RCCEx_PeriphCLKConfig+0x3d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
34184428:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418442c:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34184430:	4b11      	ldr	r3, [pc, #68]	@ (34184478 <HAL_RCCEx_PeriphCLKConfig+0x374>)
34184432:	429a      	cmp	r2, r3
34184434:	d122      	bne.n	3418447c <HAL_RCCEx_PeriphCLKConfig+0x378>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34184436:	4b0c      	ldr	r3, [pc, #48]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34184438:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418443c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184440:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184444:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184448:	699a      	ldr	r2, [r3, #24]
3418444a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418444e:	69db      	ldr	r3, [r3, #28]
34184450:	3b01      	subs	r3, #1
34184452:	041b      	lsls	r3, r3, #16
34184454:	4313      	orrs	r3, r2
34184456:	4a04      	ldr	r2, [pc, #16]	@ (34184468 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34184458:	430b      	orrs	r3, r1
3418445a:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418445e:	f7ff fd63 	bl	34183f28 <LL_RCC_IC3_Enable>
34184462:	e032      	b.n	341844ca <HAL_RCCEx_PeriphCLKConfig+0x3c6>
34184464:	56024800 	.word	0x56024800
34184468:	56028000 	.word	0x56028000
3418446c:	03020014 	.word	0x03020014
34184470:	03030014 	.word	0x03030014
34184474:	03010014 	.word	0x03010014
34184478:	03020414 	.word	0x03020414
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3418447c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184480:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34184484:	4bc5      	ldr	r3, [pc, #788]	@ (3418479c <HAL_RCCEx_PeriphCLKConfig+0x698>)
34184486:	429a      	cmp	r2, r3
34184488:	d116      	bne.n	341844b8 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418448a:	4bc5      	ldr	r3, [pc, #788]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418448c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34184490:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184494:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184498:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418449c:	6a1a      	ldr	r2, [r3, #32]
3418449e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341844a2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341844a4:	3b01      	subs	r3, #1
341844a6:	041b      	lsls	r3, r3, #16
341844a8:	4313      	orrs	r3, r2
341844aa:	4abd      	ldr	r2, [pc, #756]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341844ac:	430b      	orrs	r3, r1
341844ae:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
341844b2:	f7ff fd47 	bl	34183f44 <LL_RCC_IC4_Enable>
341844b6:	e008      	b.n	341844ca <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
341844b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341844bc:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
341844c0:	4bb8      	ldr	r3, [pc, #736]	@ (341847a4 <HAL_RCCEx_PeriphCLKConfig+0x6a0>)
341844c2:	429a      	cmp	r2, r3
341844c4:	d101      	bne.n	341844ca <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    {
      LL_RCC_CLKP_Enable();
341844c6:	f7ff fe0f 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
341844ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341844ce:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
341844d2:	4618      	mov	r0, r3
341844d4:	f7ff fa6c 	bl	341839b0 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
341844d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341844dc:	e9d3 2300 	ldrd	r2, r3, [r3]
341844e0:	2100      	movs	r1, #0
341844e2:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
341844e6:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
341844ea:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
341844ee:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
341844f2:	4603      	mov	r3, r0
341844f4:	460a      	mov	r2, r1
341844f6:	4313      	orrs	r3, r2
341844f8:	d04b      	beq.n	34184592 <HAL_RCCEx_PeriphCLKConfig+0x48e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
341844fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341844fe:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34184502:	4ba9      	ldr	r3, [pc, #676]	@ (341847a8 <HAL_RCCEx_PeriphCLKConfig+0x6a4>)
34184504:	429a      	cmp	r2, r3
34184506:	d116      	bne.n	34184536 <HAL_RCCEx_PeriphCLKConfig+0x432>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34184508:	4ba5      	ldr	r3, [pc, #660]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418450a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418450e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184512:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184516:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418451a:	699a      	ldr	r2, [r3, #24]
3418451c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184520:	69db      	ldr	r3, [r3, #28]
34184522:	3b01      	subs	r3, #1
34184524:	041b      	lsls	r3, r3, #16
34184526:	4313      	orrs	r3, r2
34184528:	4a9d      	ldr	r2, [pc, #628]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418452a:	430b      	orrs	r3, r1
3418452c:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34184530:	f7ff fcfa 	bl	34183f28 <LL_RCC_IC3_Enable>
34184534:	e026      	b.n	34184584 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
34184536:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418453a:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3418453e:	4b9b      	ldr	r3, [pc, #620]	@ (341847ac <HAL_RCCEx_PeriphCLKConfig+0x6a8>)
34184540:	429a      	cmp	r2, r3
34184542:	d116      	bne.n	34184572 <HAL_RCCEx_PeriphCLKConfig+0x46e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34184544:	4b96      	ldr	r3, [pc, #600]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34184546:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418454a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418454e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184552:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184556:	6a1a      	ldr	r2, [r3, #32]
34184558:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418455c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418455e:	3b01      	subs	r3, #1
34184560:	041b      	lsls	r3, r3, #16
34184562:	4313      	orrs	r3, r2
34184564:	4a8e      	ldr	r2, [pc, #568]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34184566:	430b      	orrs	r3, r1
34184568:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418456c:	f7ff fcea 	bl	34183f44 <LL_RCC_IC4_Enable>
34184570:	e008      	b.n	34184584 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
34184572:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184576:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3418457a:	4b8d      	ldr	r3, [pc, #564]	@ (341847b0 <HAL_RCCEx_PeriphCLKConfig+0x6ac>)
3418457c:	429a      	cmp	r2, r3
3418457e:	d101      	bne.n	34184584 <HAL_RCCEx_PeriphCLKConfig+0x480>
    {
      LL_RCC_CLKP_Enable();
34184580:	f7ff fdb2 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
34184584:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184588:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3418458c:	4618      	mov	r0, r3
3418458e:	f7ff fa0f 	bl	341839b0 <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
34184592:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184596:	e9d3 2300 	ldrd	r2, r3, [r3]
3418459a:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
3418459e:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
341845a2:	2300      	movs	r3, #0
341845a4:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
341845a8:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
341845ac:	4603      	mov	r3, r0
341845ae:	460a      	mov	r2, r1
341845b0:	4313      	orrs	r3, r2
341845b2:	d048      	beq.n	34184646 <HAL_RCCEx_PeriphCLKConfig+0x542>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
341845b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341845b8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
341845bc:	2b20      	cmp	r3, #32
341845be:	d116      	bne.n	341845ee <HAL_RCCEx_PeriphCLKConfig+0x4ea>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
341845c0:	4b77      	ldr	r3, [pc, #476]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341845c2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
341845c6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341845ca:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341845ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341845d2:	699a      	ldr	r2, [r3, #24]
341845d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341845d8:	69db      	ldr	r3, [r3, #28]
341845da:	3b01      	subs	r3, #1
341845dc:	041b      	lsls	r3, r3, #16
341845de:	4313      	orrs	r3, r2
341845e0:	4a6f      	ldr	r2, [pc, #444]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341845e2:	430b      	orrs	r3, r1
341845e4:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
341845e8:	f7ff fc9e 	bl	34183f28 <LL_RCC_IC3_Enable>
341845ec:	e024      	b.n	34184638 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
341845ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341845f2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
341845f6:	2b30      	cmp	r3, #48	@ 0x30
341845f8:	d116      	bne.n	34184628 <HAL_RCCEx_PeriphCLKConfig+0x524>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
341845fa:	4b69      	ldr	r3, [pc, #420]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341845fc:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34184600:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184604:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184608:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418460c:	6a1a      	ldr	r2, [r3, #32]
3418460e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184612:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184614:	3b01      	subs	r3, #1
34184616:	041b      	lsls	r3, r3, #16
34184618:	4313      	orrs	r3, r2
3418461a:	4a61      	ldr	r2, [pc, #388]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418461c:	430b      	orrs	r3, r1
3418461e:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34184622:	f7ff fc8f 	bl	34183f44 <LL_RCC_IC4_Enable>
34184626:	e007      	b.n	34184638 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
34184628:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418462c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34184630:	2b10      	cmp	r3, #16
34184632:	d101      	bne.n	34184638 <HAL_RCCEx_PeriphCLKConfig+0x534>
    {
      LL_RCC_CLKP_Enable();
34184634:	f7ff fd58 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
34184638:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418463c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34184640:	4618      	mov	r0, r3
34184642:	f7ff f8cd 	bl	341837e0 <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
34184646:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418464a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418464e:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
34184652:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
34184656:	2300      	movs	r3, #0
34184658:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
3418465c:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
34184660:	4603      	mov	r3, r0
34184662:	460a      	mov	r2, r1
34184664:	4313      	orrs	r3, r2
34184666:	d04b      	beq.n	34184700 <HAL_RCCEx_PeriphCLKConfig+0x5fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
34184668:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418466c:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34184670:	4b50      	ldr	r3, [pc, #320]	@ (341847b4 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
34184672:	429a      	cmp	r2, r3
34184674:	d116      	bne.n	341846a4 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34184676:	4b4a      	ldr	r3, [pc, #296]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34184678:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418467c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184680:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184684:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184688:	6a1a      	ldr	r2, [r3, #32]
3418468a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418468e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184690:	3b01      	subs	r3, #1
34184692:	041b      	lsls	r3, r3, #16
34184694:	4313      	orrs	r3, r2
34184696:	4a42      	ldr	r2, [pc, #264]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34184698:	430b      	orrs	r3, r1
3418469a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418469e:	f7ff fc51 	bl	34183f44 <LL_RCC_IC4_Enable>
341846a2:	e026      	b.n	341846f2 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
341846a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341846a8:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
341846ac:	4b42      	ldr	r3, [pc, #264]	@ (341847b8 <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
341846ae:	429a      	cmp	r2, r3
341846b0:	d116      	bne.n	341846e0 <HAL_RCCEx_PeriphCLKConfig+0x5dc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
341846b2:	4b3b      	ldr	r3, [pc, #236]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341846b4:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
341846b8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341846bc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341846c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341846c4:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
341846c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341846ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341846cc:	3b01      	subs	r3, #1
341846ce:	041b      	lsls	r3, r3, #16
341846d0:	4313      	orrs	r3, r2
341846d2:	4a33      	ldr	r2, [pc, #204]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341846d4:	430b      	orrs	r3, r1
341846d6:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
341846da:	f7ff fc41 	bl	34183f60 <LL_RCC_IC5_Enable>
341846de:	e008      	b.n	341846f2 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
341846e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341846e4:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
341846e8:	4b34      	ldr	r3, [pc, #208]	@ (341847bc <HAL_RCCEx_PeriphCLKConfig+0x6b8>)
341846ea:	429a      	cmp	r2, r3
341846ec:	d101      	bne.n	341846f2 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    {
      LL_RCC_CLKP_Enable();
341846ee:	f7ff fcfb 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
341846f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341846f6:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
341846fa:	4618      	mov	r0, r3
341846fc:	f7ff f921 	bl	34183942 <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
34184700:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184704:	e9d3 2300 	ldrd	r2, r3, [r3]
34184708:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
3418470c:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
34184710:	2300      	movs	r3, #0
34184712:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
34184716:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
3418471a:	4603      	mov	r3, r0
3418471c:	460a      	mov	r2, r1
3418471e:	4313      	orrs	r3, r2
34184720:	d062      	beq.n	341847e8 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
34184722:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184726:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3418472a:	4b25      	ldr	r3, [pc, #148]	@ (341847c0 <HAL_RCCEx_PeriphCLKConfig+0x6bc>)
3418472c:	429a      	cmp	r2, r3
3418472e:	d116      	bne.n	3418475e <HAL_RCCEx_PeriphCLKConfig+0x65a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34184730:	4b1b      	ldr	r3, [pc, #108]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34184732:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34184736:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418473a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418473e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184742:	6a1a      	ldr	r2, [r3, #32]
34184744:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184748:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418474a:	3b01      	subs	r3, #1
3418474c:	041b      	lsls	r3, r3, #16
3418474e:	4313      	orrs	r3, r2
34184750:	4a13      	ldr	r2, [pc, #76]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34184752:	430b      	orrs	r3, r1
34184754:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34184758:	f7ff fbf4 	bl	34183f44 <LL_RCC_IC4_Enable>
3418475c:	e03d      	b.n	341847da <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3418475e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184762:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34184766:	4b17      	ldr	r3, [pc, #92]	@ (341847c4 <HAL_RCCEx_PeriphCLKConfig+0x6c0>)
34184768:	429a      	cmp	r2, r3
3418476a:	d12d      	bne.n	341847c8 <HAL_RCCEx_PeriphCLKConfig+0x6c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418476c:	4b0c      	ldr	r3, [pc, #48]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418476e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34184772:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184776:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418477a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418477e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34184780:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184784:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34184786:	3b01      	subs	r3, #1
34184788:	041b      	lsls	r3, r3, #16
3418478a:	4313      	orrs	r3, r2
3418478c:	4a04      	ldr	r2, [pc, #16]	@ (341847a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418478e:	430b      	orrs	r3, r1
34184790:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34184794:	f7ff fbe4 	bl	34183f60 <LL_RCC_IC5_Enable>
34184798:	e01f      	b.n	341847da <HAL_RCCEx_PeriphCLKConfig+0x6d6>
3418479a:	bf00      	nop
3418479c:	03030414 	.word	0x03030414
341847a0:	56028000 	.word	0x56028000
341847a4:	03010414 	.word	0x03010414
341847a8:	03020814 	.word	0x03020814
341847ac:	03030814 	.word	0x03030814
341847b0:	03010814 	.word	0x03010814
341847b4:	0302001c 	.word	0x0302001c
341847b8:	0303001c 	.word	0x0303001c
341847bc:	0301001c 	.word	0x0301001c
341847c0:	0302041c 	.word	0x0302041c
341847c4:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
341847c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341847cc:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
341847d0:	4bb3      	ldr	r3, [pc, #716]	@ (34184aa0 <HAL_RCCEx_PeriphCLKConfig+0x99c>)
341847d2:	429a      	cmp	r2, r3
341847d4:	d101      	bne.n	341847da <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    {
      LL_RCC_CLKP_Enable();
341847d6:	f7ff fc87 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
341847da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341847de:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
341847e2:	4618      	mov	r0, r3
341847e4:	f7ff f8ad 	bl	34183942 <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
341847e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341847ec:	e9d3 2300 	ldrd	r2, r3, [r3]
341847f0:	f002 0301 	and.w	r3, r2, #1
341847f4:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
341847f8:	2300      	movs	r3, #0
341847fa:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
341847fe:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
34184802:	4603      	mov	r3, r0
34184804:	460a      	mov	r2, r1
34184806:	4313      	orrs	r3, r2
34184808:	d057      	beq.n	341848ba <HAL_RCCEx_PeriphCLKConfig+0x7b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
3418480a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418480e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34184812:	2b20      	cmp	r3, #32
34184814:	d116      	bne.n	34184844 <HAL_RCCEx_PeriphCLKConfig+0x740>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34184816:	4ba3      	ldr	r3, [pc, #652]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184818:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418481c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184820:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184824:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184828:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418482a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418482e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34184830:	3b01      	subs	r3, #1
34184832:	041b      	lsls	r3, r3, #16
34184834:	4313      	orrs	r3, r2
34184836:	4a9b      	ldr	r2, [pc, #620]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184838:	430b      	orrs	r3, r1
3418483a:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3418483e:	f7ff fb9d 	bl	34183f7c <LL_RCC_IC7_Enable>
34184842:	e024      	b.n	3418488e <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
34184844:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184848:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3418484c:	2b30      	cmp	r3, #48	@ 0x30
3418484e:	d116      	bne.n	3418487e <HAL_RCCEx_PeriphCLKConfig+0x77a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34184850:	4b94      	ldr	r3, [pc, #592]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184852:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34184856:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418485a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418485e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184862:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34184864:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184868:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418486a:	3b01      	subs	r3, #1
3418486c:	041b      	lsls	r3, r3, #16
3418486e:	4313      	orrs	r3, r2
34184870:	4a8c      	ldr	r2, [pc, #560]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184872:	430b      	orrs	r3, r1
34184874:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34184878:	f7ff fb8e 	bl	34183f98 <LL_RCC_IC8_Enable>
3418487c:	e007      	b.n	3418488e <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
3418487e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184882:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34184886:	2b10      	cmp	r3, #16
34184888:	d101      	bne.n	3418488e <HAL_RCCEx_PeriphCLKConfig+0x78a>
    {
      LL_RCC_CLKP_Enable();
3418488a:	f7ff fc2d 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
3418488e:	4b85      	ldr	r3, [pc, #532]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184890:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34184894:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
34184898:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
3418489c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341848a0:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
341848a4:	3b01      	subs	r3, #1
341848a6:	021a      	lsls	r2, r3, #8
341848a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341848ac:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
341848b0:	4313      	orrs	r3, r2
341848b2:	4a7c      	ldr	r2, [pc, #496]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341848b4:	430b      	orrs	r3, r1
341848b6:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
341848ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341848be:	e9d3 2300 	ldrd	r2, r3, [r3]
341848c2:	f002 0302 	and.w	r3, r2, #2
341848c6:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
341848ca:	2300      	movs	r3, #0
341848cc:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
341848d0:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
341848d4:	4603      	mov	r3, r0
341848d6:	460a      	mov	r2, r1
341848d8:	4313      	orrs	r3, r2
341848da:	d048      	beq.n	3418496e <HAL_RCCEx_PeriphCLKConfig+0x86a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
341848dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341848e0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341848e4:	2b02      	cmp	r3, #2
341848e6:	d116      	bne.n	34184916 <HAL_RCCEx_PeriphCLKConfig+0x812>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
341848e8:	4b6e      	ldr	r3, [pc, #440]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341848ea:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
341848ee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341848f2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341848f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341848fa:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
341848fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184900:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34184902:	3b01      	subs	r3, #1
34184904:	041b      	lsls	r3, r3, #16
34184906:	4313      	orrs	r3, r2
34184908:	4a66      	ldr	r2, [pc, #408]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418490a:	430b      	orrs	r3, r1
3418490c:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34184910:	f7ff fb34 	bl	34183f7c <LL_RCC_IC7_Enable>
34184914:	e024      	b.n	34184960 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
34184916:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418491a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418491e:	2b03      	cmp	r3, #3
34184920:	d116      	bne.n	34184950 <HAL_RCCEx_PeriphCLKConfig+0x84c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34184922:	4b60      	ldr	r3, [pc, #384]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184924:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34184928:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418492c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184930:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184934:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34184936:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418493a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418493c:	3b01      	subs	r3, #1
3418493e:	041b      	lsls	r3, r3, #16
34184940:	4313      	orrs	r3, r2
34184942:	4a58      	ldr	r2, [pc, #352]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184944:	430b      	orrs	r3, r1
34184946:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418494a:	f7ff fb25 	bl	34183f98 <LL_RCC_IC8_Enable>
3418494e:	e007      	b.n	34184960 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
34184950:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184954:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34184958:	2b01      	cmp	r3, #1
3418495a:	d101      	bne.n	34184960 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    {
      LL_RCC_CLKP_Enable();
3418495c:	f7ff fbc4 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
34184960:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184964:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34184968:	4618      	mov	r0, r3
3418496a:	f7fe fe89 	bl	34183680 <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
3418496e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184972:	e9d3 2300 	ldrd	r2, r3, [r3]
34184976:	f002 0308 	and.w	r3, r2, #8
3418497a:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
3418497e:	2300      	movs	r3, #0
34184980:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
34184984:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
34184988:	4603      	mov	r3, r0
3418498a:	460a      	mov	r2, r1
3418498c:	4313      	orrs	r3, r2
3418498e:	d017      	beq.n	341849c0 <HAL_RCCEx_PeriphCLKConfig+0x8bc>
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
34184990:	4b44      	ldr	r3, [pc, #272]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184992:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34184996:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418499a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418499e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341849a2:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
341849a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341849aa:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341849ae:	3b01      	subs	r3, #1
341849b0:	041b      	lsls	r3, r3, #16
341849b2:	4313      	orrs	r3, r2
341849b4:	4a3b      	ldr	r2, [pc, #236]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341849b6:	430b      	orrs	r3, r1
341849b8:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
341849bc:	f7ff fb6a 	bl	34184094 <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
341849c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341849c4:	e9d3 2300 	ldrd	r2, r3, [r3]
341849c8:	f002 0310 	and.w	r3, r2, #16
341849cc:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
341849d0:	2300      	movs	r3, #0
341849d2:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
341849d6:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
341849da:	4603      	mov	r3, r0
341849dc:	460a      	mov	r2, r1
341849de:	4313      	orrs	r3, r2
341849e0:	d02f      	beq.n	34184a42 <HAL_RCCEx_PeriphCLKConfig+0x93e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
341849e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341849e6:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
341849ea:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341849ee:	d118      	bne.n	34184a22 <HAL_RCCEx_PeriphCLKConfig+0x91e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
341849f0:	4b2c      	ldr	r3, [pc, #176]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341849f2:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
341849f6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341849fa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341849fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184a02:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34184a06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184a0a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34184a0e:	3b01      	subs	r3, #1
34184a10:	041b      	lsls	r3, r3, #16
34184a12:	4313      	orrs	r3, r2
34184a14:	4a23      	ldr	r2, [pc, #140]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184a16:	430b      	orrs	r3, r1
34184a18:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
34184a1c:	f7ff fb2c 	bl	34184078 <LL_RCC_IC17_Enable>
34184a20:	e008      	b.n	34184a34 <HAL_RCCEx_PeriphCLKConfig+0x930>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
34184a22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184a26:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34184a2a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34184a2e:	d101      	bne.n	34184a34 <HAL_RCCEx_PeriphCLKConfig+0x930>
    {
      LL_RCC_CLKP_Enable();
34184a30:	f7ff fb5a 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
34184a34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184a38:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34184a3c:	4618      	mov	r0, r3
34184a3e:	f7fe fe4b 	bl	341836d8 <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
34184a42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184a46:	e9d3 2300 	ldrd	r2, r3, [r3]
34184a4a:	f002 0320 	and.w	r3, r2, #32
34184a4e:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
34184a52:	2300      	movs	r3, #0
34184a54:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
34184a58:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
34184a5c:	4603      	mov	r3, r0
34184a5e:	460a      	mov	r2, r1
34184a60:	4313      	orrs	r3, r2
34184a62:	d031      	beq.n	34184ac8 <HAL_RCCEx_PeriphCLKConfig+0x9c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
34184a64:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184a68:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34184a6c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34184a70:	d11a      	bne.n	34184aa8 <HAL_RCCEx_PeriphCLKConfig+0x9a4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
34184a72:	4b0c      	ldr	r3, [pc, #48]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184a74:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34184a78:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184a7c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184a80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184a84:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
34184a86:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184a8a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34184a8c:	3b01      	subs	r3, #1
34184a8e:	041b      	lsls	r3, r3, #16
34184a90:	4313      	orrs	r3, r2
34184a92:	4a04      	ldr	r2, [pc, #16]	@ (34184aa4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34184a94:	430b      	orrs	r3, r1
34184a96:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
34184a9a:	f7ff faa7 	bl	34183fec <LL_RCC_IC12_Enable>
34184a9e:	e00c      	b.n	34184aba <HAL_RCCEx_PeriphCLKConfig+0x9b6>
34184aa0:	0301041c 	.word	0x0301041c
34184aa4:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
34184aa8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184aac:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34184ab0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34184ab4:	d101      	bne.n	34184aba <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    {
      LL_RCC_CLKP_Enable();
34184ab6:	f7ff fb17 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
34184aba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184abe:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34184ac2:	4618      	mov	r0, r3
34184ac4:	f7fe fe1e 	bl	34183704 <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
34184ac8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184acc:	e9d3 2300 	ldrd	r2, r3, [r3]
34184ad0:	f002 0340 	and.w	r3, r2, #64	@ 0x40
34184ad4:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
34184ad8:	2300      	movs	r3, #0
34184ada:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
34184ade:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
34184ae2:	4603      	mov	r3, r0
34184ae4:	460a      	mov	r2, r1
34184ae6:	4313      	orrs	r3, r2
34184ae8:	d006      	beq.n	34184af8 <HAL_RCCEx_PeriphCLKConfig+0x9f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
34184aea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184aee:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34184af2:	4618      	mov	r0, r3
34184af4:	f7fe fe1c 	bl	34183730 <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
34184af8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184afc:	e9d3 2300 	ldrd	r2, r3, [r3]
34184b00:	f002 0380 	and.w	r3, r2, #128	@ 0x80
34184b04:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34184b08:	2300      	movs	r3, #0
34184b0a:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
34184b0e:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
34184b12:	4603      	mov	r3, r0
34184b14:	460a      	mov	r2, r1
34184b16:	4313      	orrs	r3, r2
34184b18:	d006      	beq.n	34184b28 <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
34184b1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184b1e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34184b22:	4618      	mov	r0, r3
34184b24:	f7fe fe1a 	bl	3418375c <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
34184b28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184b2c:	e9d3 2300 	ldrd	r2, r3, [r3]
34184b30:	f402 7380 	and.w	r3, r2, #256	@ 0x100
34184b34:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
34184b38:	2300      	movs	r3, #0
34184b3a:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
34184b3e:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
34184b42:	4603      	mov	r3, r0
34184b44:	460a      	mov	r2, r1
34184b46:	4313      	orrs	r3, r2
34184b48:	d006      	beq.n	34184b58 <HAL_RCCEx_PeriphCLKConfig+0xa54>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
34184b4a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184b4e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34184b52:	4618      	mov	r0, r3
34184b54:	f7fe fe18 	bl	34183788 <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
34184b58:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184b5c:	e9d3 2300 	ldrd	r2, r3, [r3]
34184b60:	f402 7300 	and.w	r3, r2, #512	@ 0x200
34184b64:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
34184b68:	2300      	movs	r3, #0
34184b6a:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
34184b6e:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
34184b72:	4603      	mov	r3, r0
34184b74:	460a      	mov	r2, r1
34184b76:	4313      	orrs	r3, r2
34184b78:	d038      	beq.n	34184bec <HAL_RCCEx_PeriphCLKConfig+0xae8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
34184b7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184b7e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34184b82:	2b02      	cmp	r3, #2
34184b84:	d116      	bne.n	34184bb4 <HAL_RCCEx_PeriphCLKConfig+0xab0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
34184b86:	4bbc      	ldr	r3, [pc, #752]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184b88:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34184b8c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184b90:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184b94:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184b98:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
34184b9a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184b9e:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34184ba0:	3b01      	subs	r3, #1
34184ba2:	041b      	lsls	r3, r3, #16
34184ba4:	4313      	orrs	r3, r2
34184ba6:	4ab4      	ldr	r2, [pc, #720]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184ba8:	430b      	orrs	r3, r1
34184baa:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
34184bae:	f7ff fa2b 	bl	34184008 <LL_RCC_IC13_Enable>
34184bb2:	e007      	b.n	34184bc4 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
34184bb4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184bb8:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34184bbc:	2b01      	cmp	r3, #1
34184bbe:	d101      	bne.n	34184bc4 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    {
      LL_RCC_CLKP_Enable();
34184bc0:	f7ff fa92 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
34184bc4:	4bac      	ldr	r3, [pc, #688]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184bc6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34184bca:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
34184bce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184bd2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34184bd6:	3b01      	subs	r3, #1
34184bd8:	011a      	lsls	r2, r3, #4
34184bda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184bde:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34184be2:	4313      	orrs	r3, r2
34184be4:	4aa4      	ldr	r2, [pc, #656]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184be6:	430b      	orrs	r3, r1
34184be8:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
34184bec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184bf0:	e9d3 2300 	ldrd	r2, r3, [r3]
34184bf4:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
34184bf8:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
34184bfc:	2300      	movs	r3, #0
34184bfe:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
34184c02:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
34184c06:	4603      	mov	r3, r0
34184c08:	460a      	mov	r2, r1
34184c0a:	4313      	orrs	r3, r2
34184c0c:	d02d      	beq.n	34184c6a <HAL_RCCEx_PeriphCLKConfig+0xb66>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
34184c0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184c12:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34184c16:	2b02      	cmp	r3, #2
34184c18:	d118      	bne.n	34184c4c <HAL_RCCEx_PeriphCLKConfig+0xb48>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34184c1a:	4b97      	ldr	r3, [pc, #604]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184c1c:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34184c20:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184c24:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184c28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184c2c:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34184c30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184c34:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34184c38:	3b01      	subs	r3, #1
34184c3a:	041b      	lsls	r3, r3, #16
34184c3c:	4313      	orrs	r3, r2
34184c3e:	4a8e      	ldr	r2, [pc, #568]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184c40:	430b      	orrs	r3, r1
34184c42:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34184c46:	f7ff fa33 	bl	341840b0 <LL_RCC_IC19_Enable>
34184c4a:	e007      	b.n	34184c5c <HAL_RCCEx_PeriphCLKConfig+0xb58>
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
34184c4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184c50:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34184c54:	2b01      	cmp	r3, #1
34184c56:	d101      	bne.n	34184c5c <HAL_RCCEx_PeriphCLKConfig+0xb58>
    {
      LL_RCC_CLKP_Enable();
34184c58:	f7ff fa46 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
34184c5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184c60:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34184c64:	4618      	mov	r0, r3
34184c66:	f7fe fda5 	bl	341837b4 <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
34184c6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184c6e:	e9d3 2300 	ldrd	r2, r3, [r3]
34184c72:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
34184c76:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
34184c7a:	2300      	movs	r3, #0
34184c7c:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
34184c80:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
34184c84:	4603      	mov	r3, r0
34184c86:	460a      	mov	r2, r1
34184c88:	4313      	orrs	r3, r2
34184c8a:	d04b      	beq.n	34184d24 <HAL_RCCEx_PeriphCLKConfig+0xc20>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
34184c8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184c90:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34184c94:	4b79      	ldr	r3, [pc, #484]	@ (34184e7c <HAL_RCCEx_PeriphCLKConfig+0xd78>)
34184c96:	429a      	cmp	r2, r3
34184c98:	d116      	bne.n	34184cc8 <HAL_RCCEx_PeriphCLKConfig+0xbc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34184c9a:	4b77      	ldr	r3, [pc, #476]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184c9c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34184ca0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184ca4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184ca8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184cac:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34184cae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184cb2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34184cb4:	3b01      	subs	r3, #1
34184cb6:	041b      	lsls	r3, r3, #16
34184cb8:	4313      	orrs	r3, r2
34184cba:	4a6f      	ldr	r2, [pc, #444]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184cbc:	430b      	orrs	r3, r1
34184cbe:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34184cc2:	f7ff f985 	bl	34183fd0 <LL_RCC_IC10_Enable>
34184cc6:	e026      	b.n	34184d16 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
34184cc8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184ccc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34184cd0:	4b6b      	ldr	r3, [pc, #428]	@ (34184e80 <HAL_RCCEx_PeriphCLKConfig+0xd7c>)
34184cd2:	429a      	cmp	r2, r3
34184cd4:	d116      	bne.n	34184d04 <HAL_RCCEx_PeriphCLKConfig+0xc00>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34184cd6:	4b68      	ldr	r3, [pc, #416]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184cd8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34184cdc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184ce0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184ce4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184ce8:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34184cea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184cee:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34184cf0:	3b01      	subs	r3, #1
34184cf2:	041b      	lsls	r3, r3, #16
34184cf4:	4313      	orrs	r3, r2
34184cf6:	4a60      	ldr	r2, [pc, #384]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184cf8:	430b      	orrs	r3, r1
34184cfa:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34184cfe:	f7ff f99f 	bl	34184040 <LL_RCC_IC15_Enable>
34184d02:	e008      	b.n	34184d16 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
34184d04:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184d08:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34184d0c:	4b5d      	ldr	r3, [pc, #372]	@ (34184e84 <HAL_RCCEx_PeriphCLKConfig+0xd80>)
34184d0e:	429a      	cmp	r2, r3
34184d10:	d101      	bne.n	34184d16 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    {
      LL_RCC_CLKP_Enable();
34184d12:	f7ff f9e9 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
34184d16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184d1a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34184d1e:	4618      	mov	r0, r3
34184d20:	f7fe fd74 	bl	3418380c <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
34184d24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184d28:	e9d3 2300 	ldrd	r2, r3, [r3]
34184d2c:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
34184d30:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
34184d34:	2300      	movs	r3, #0
34184d36:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
34184d3a:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
34184d3e:	4603      	mov	r3, r0
34184d40:	460a      	mov	r2, r1
34184d42:	4313      	orrs	r3, r2
34184d44:	d04b      	beq.n	34184dde <HAL_RCCEx_PeriphCLKConfig+0xcda>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
34184d46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184d4a:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34184d4e:	4b4e      	ldr	r3, [pc, #312]	@ (34184e88 <HAL_RCCEx_PeriphCLKConfig+0xd84>)
34184d50:	429a      	cmp	r2, r3
34184d52:	d116      	bne.n	34184d82 <HAL_RCCEx_PeriphCLKConfig+0xc7e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34184d54:	4b48      	ldr	r3, [pc, #288]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184d56:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34184d5a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184d5e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184d62:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184d66:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34184d68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184d6c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34184d6e:	3b01      	subs	r3, #1
34184d70:	041b      	lsls	r3, r3, #16
34184d72:	4313      	orrs	r3, r2
34184d74:	4a40      	ldr	r2, [pc, #256]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184d76:	430b      	orrs	r3, r1
34184d78:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34184d7c:	f7ff f928 	bl	34183fd0 <LL_RCC_IC10_Enable>
34184d80:	e026      	b.n	34184dd0 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
34184d82:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184d86:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34184d8a:	4b40      	ldr	r3, [pc, #256]	@ (34184e8c <HAL_RCCEx_PeriphCLKConfig+0xd88>)
34184d8c:	429a      	cmp	r2, r3
34184d8e:	d116      	bne.n	34184dbe <HAL_RCCEx_PeriphCLKConfig+0xcba>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34184d90:	4b39      	ldr	r3, [pc, #228]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184d92:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34184d96:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184d9a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184d9e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184da2:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34184da4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184da8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34184daa:	3b01      	subs	r3, #1
34184dac:	041b      	lsls	r3, r3, #16
34184dae:	4313      	orrs	r3, r2
34184db0:	4a31      	ldr	r2, [pc, #196]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184db2:	430b      	orrs	r3, r1
34184db4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34184db8:	f7ff f942 	bl	34184040 <LL_RCC_IC15_Enable>
34184dbc:	e008      	b.n	34184dd0 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
34184dbe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184dc2:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34184dc6:	4b32      	ldr	r3, [pc, #200]	@ (34184e90 <HAL_RCCEx_PeriphCLKConfig+0xd8c>)
34184dc8:	429a      	cmp	r2, r3
34184dca:	d101      	bne.n	34184dd0 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    {
      LL_RCC_CLKP_Enable();
34184dcc:	f7ff f98c 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
34184dd0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184dd4:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34184dd8:	4618      	mov	r0, r3
34184dda:	f7fe fd17 	bl	3418380c <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
34184dde:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184de2:	e9d3 2300 	ldrd	r2, r3, [r3]
34184de6:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
34184dea:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
34184dee:	2300      	movs	r3, #0
34184df0:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
34184df4:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
34184df8:	4603      	mov	r3, r0
34184dfa:	460a      	mov	r2, r1
34184dfc:	4313      	orrs	r3, r2
34184dfe:	d05d      	beq.n	34184ebc <HAL_RCCEx_PeriphCLKConfig+0xdb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
34184e00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184e04:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34184e08:	4b22      	ldr	r3, [pc, #136]	@ (34184e94 <HAL_RCCEx_PeriphCLKConfig+0xd90>)
34184e0a:	429a      	cmp	r2, r3
34184e0c:	d116      	bne.n	34184e3c <HAL_RCCEx_PeriphCLKConfig+0xd38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34184e0e:	4b1a      	ldr	r3, [pc, #104]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184e10:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34184e14:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184e18:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184e1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184e20:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34184e22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184e26:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34184e28:	3b01      	subs	r3, #1
34184e2a:	041b      	lsls	r3, r3, #16
34184e2c:	4313      	orrs	r3, r2
34184e2e:	4a12      	ldr	r2, [pc, #72]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184e30:	430b      	orrs	r3, r1
34184e32:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34184e36:	f7ff f8cb 	bl	34183fd0 <LL_RCC_IC10_Enable>
34184e3a:	e038      	b.n	34184eae <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
34184e3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184e40:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34184e44:	4b14      	ldr	r3, [pc, #80]	@ (34184e98 <HAL_RCCEx_PeriphCLKConfig+0xd94>)
34184e46:	429a      	cmp	r2, r3
34184e48:	d128      	bne.n	34184e9c <HAL_RCCEx_PeriphCLKConfig+0xd98>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34184e4a:	4b0b      	ldr	r3, [pc, #44]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184e4c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34184e50:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184e54:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184e58:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184e5c:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34184e5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184e62:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34184e64:	3b01      	subs	r3, #1
34184e66:	041b      	lsls	r3, r3, #16
34184e68:	4313      	orrs	r3, r2
34184e6a:	4a03      	ldr	r2, [pc, #12]	@ (34184e78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34184e6c:	430b      	orrs	r3, r1
34184e6e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34184e72:	f7ff f8e5 	bl	34184040 <LL_RCC_IC15_Enable>
34184e76:	e01a      	b.n	34184eae <HAL_RCCEx_PeriphCLKConfig+0xdaa>
34184e78:	56028000 	.word	0x56028000
34184e7c:	0702000c 	.word	0x0702000c
34184e80:	0703000c 	.word	0x0703000c
34184e84:	0701000c 	.word	0x0701000c
34184e88:	0702040c 	.word	0x0702040c
34184e8c:	0703040c 	.word	0x0703040c
34184e90:	0701040c 	.word	0x0701040c
34184e94:	0702080c 	.word	0x0702080c
34184e98:	0703080c 	.word	0x0703080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
34184e9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184ea0:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34184ea4:	4bc8      	ldr	r3, [pc, #800]	@ (341851c8 <HAL_RCCEx_PeriphCLKConfig+0x10c4>)
34184ea6:	429a      	cmp	r2, r3
34184ea8:	d101      	bne.n	34184eae <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      LL_RCC_CLKP_Enable();
34184eaa:	f7ff f91d 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
34184eae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184eb2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34184eb6:	4618      	mov	r0, r3
34184eb8:	f7fe fca8 	bl	3418380c <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
34184ebc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184ec0:	e9d3 2300 	ldrd	r2, r3, [r3]
34184ec4:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
34184ec8:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
34184ecc:	2300      	movs	r3, #0
34184ece:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
34184ed2:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
34184ed6:	4603      	mov	r3, r0
34184ed8:	460a      	mov	r2, r1
34184eda:	4313      	orrs	r3, r2
34184edc:	d04b      	beq.n	34184f76 <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
34184ede:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184ee2:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34184ee6:	4bb9      	ldr	r3, [pc, #740]	@ (341851cc <HAL_RCCEx_PeriphCLKConfig+0x10c8>)
34184ee8:	429a      	cmp	r2, r3
34184eea:	d116      	bne.n	34184f1a <HAL_RCCEx_PeriphCLKConfig+0xe16>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34184eec:	4bb8      	ldr	r3, [pc, #736]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34184eee:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34184ef2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184ef6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184efa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184efe:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34184f00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184f04:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34184f06:	3b01      	subs	r3, #1
34184f08:	041b      	lsls	r3, r3, #16
34184f0a:	4313      	orrs	r3, r2
34184f0c:	4ab0      	ldr	r2, [pc, #704]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34184f0e:	430b      	orrs	r3, r1
34184f10:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34184f14:	f7ff f85c 	bl	34183fd0 <LL_RCC_IC10_Enable>
34184f18:	e026      	b.n	34184f68 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
34184f1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184f1e:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34184f22:	4bac      	ldr	r3, [pc, #688]	@ (341851d4 <HAL_RCCEx_PeriphCLKConfig+0x10d0>)
34184f24:	429a      	cmp	r2, r3
34184f26:	d116      	bne.n	34184f56 <HAL_RCCEx_PeriphCLKConfig+0xe52>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34184f28:	4ba9      	ldr	r3, [pc, #676]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34184f2a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34184f2e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184f32:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184f36:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184f3a:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34184f3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184f40:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34184f42:	3b01      	subs	r3, #1
34184f44:	041b      	lsls	r3, r3, #16
34184f46:	4313      	orrs	r3, r2
34184f48:	4aa1      	ldr	r2, [pc, #644]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34184f4a:	430b      	orrs	r3, r1
34184f4c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34184f50:	f7ff f876 	bl	34184040 <LL_RCC_IC15_Enable>
34184f54:	e008      	b.n	34184f68 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
34184f56:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184f5a:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34184f5e:	4b9e      	ldr	r3, [pc, #632]	@ (341851d8 <HAL_RCCEx_PeriphCLKConfig+0x10d4>)
34184f60:	429a      	cmp	r2, r3
34184f62:	d101      	bne.n	34184f68 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    {
      LL_RCC_CLKP_Enable();
34184f64:	f7ff f8c0 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
34184f68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184f6c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34184f70:	4618      	mov	r0, r3
34184f72:	f7fe fc4b 	bl	3418380c <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
34184f76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184f7a:	e9d3 2300 	ldrd	r2, r3, [r3]
34184f7e:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
34184f82:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
34184f86:	2300      	movs	r3, #0
34184f88:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
34184f8c:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
34184f90:	4603      	mov	r3, r0
34184f92:	460a      	mov	r2, r1
34184f94:	4313      	orrs	r3, r2
34184f96:	d04b      	beq.n	34185030 <HAL_RCCEx_PeriphCLKConfig+0xf2c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
34184f98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184f9c:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34184fa0:	4b8e      	ldr	r3, [pc, #568]	@ (341851dc <HAL_RCCEx_PeriphCLKConfig+0x10d8>)
34184fa2:	429a      	cmp	r2, r3
34184fa4:	d116      	bne.n	34184fd4 <HAL_RCCEx_PeriphCLKConfig+0xed0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34184fa6:	4b8a      	ldr	r3, [pc, #552]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34184fa8:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34184fac:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184fb0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184fb4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184fb8:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34184fba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184fbe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34184fc0:	3b01      	subs	r3, #1
34184fc2:	041b      	lsls	r3, r3, #16
34184fc4:	4313      	orrs	r3, r2
34184fc6:	4a82      	ldr	r2, [pc, #520]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34184fc8:	430b      	orrs	r3, r1
34184fca:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34184fce:	f7fe ffff 	bl	34183fd0 <LL_RCC_IC10_Enable>
34184fd2:	e026      	b.n	34185022 <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
34184fd4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184fd8:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34184fdc:	4b80      	ldr	r3, [pc, #512]	@ (341851e0 <HAL_RCCEx_PeriphCLKConfig+0x10dc>)
34184fde:	429a      	cmp	r2, r3
34184fe0:	d116      	bne.n	34185010 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34184fe2:	4b7b      	ldr	r3, [pc, #492]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34184fe4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34184fe8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34184fec:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34184ff0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184ff4:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34184ff6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34184ffa:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34184ffc:	3b01      	subs	r3, #1
34184ffe:	041b      	lsls	r3, r3, #16
34185000:	4313      	orrs	r3, r2
34185002:	4a73      	ldr	r2, [pc, #460]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34185004:	430b      	orrs	r3, r1
34185006:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418500a:	f7ff f819 	bl	34184040 <LL_RCC_IC15_Enable>
3418500e:	e008      	b.n	34185022 <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
34185010:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185014:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34185018:	4b72      	ldr	r3, [pc, #456]	@ (341851e4 <HAL_RCCEx_PeriphCLKConfig+0x10e0>)
3418501a:	429a      	cmp	r2, r3
3418501c:	d101      	bne.n	34185022 <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    {
      LL_RCC_CLKP_Enable();
3418501e:	f7ff f863 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
34185022:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185026:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418502a:	4618      	mov	r0, r3
3418502c:	f7fe fbf9 	bl	34183822 <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
34185030:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185034:	e9d3 2300 	ldrd	r2, r3, [r3]
34185038:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
3418503c:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
34185040:	2300      	movs	r3, #0
34185042:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
34185046:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
3418504a:	4603      	mov	r3, r0
3418504c:	460a      	mov	r2, r1
3418504e:	4313      	orrs	r3, r2
34185050:	d04b      	beq.n	341850ea <HAL_RCCEx_PeriphCLKConfig+0xfe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
34185052:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185056:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3418505a:	4b63      	ldr	r3, [pc, #396]	@ (341851e8 <HAL_RCCEx_PeriphCLKConfig+0x10e4>)
3418505c:	429a      	cmp	r2, r3
3418505e:	d116      	bne.n	3418508e <HAL_RCCEx_PeriphCLKConfig+0xf8a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34185060:	4b5b      	ldr	r3, [pc, #364]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34185062:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34185066:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418506a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418506e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185072:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34185074:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185078:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418507a:	3b01      	subs	r3, #1
3418507c:	041b      	lsls	r3, r3, #16
3418507e:	4313      	orrs	r3, r2
34185080:	4a53      	ldr	r2, [pc, #332]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34185082:	430b      	orrs	r3, r1
34185084:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34185088:	f7fe ffa2 	bl	34183fd0 <LL_RCC_IC10_Enable>
3418508c:	e026      	b.n	341850dc <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3418508e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185092:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34185096:	4b55      	ldr	r3, [pc, #340]	@ (341851ec <HAL_RCCEx_PeriphCLKConfig+0x10e8>)
34185098:	429a      	cmp	r2, r3
3418509a:	d116      	bne.n	341850ca <HAL_RCCEx_PeriphCLKConfig+0xfc6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418509c:	4b4c      	ldr	r3, [pc, #304]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418509e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341850a2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341850a6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341850aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341850ae:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341850b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341850b4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341850b6:	3b01      	subs	r3, #1
341850b8:	041b      	lsls	r3, r3, #16
341850ba:	4313      	orrs	r3, r2
341850bc:	4a44      	ldr	r2, [pc, #272]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341850be:	430b      	orrs	r3, r1
341850c0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341850c4:	f7fe ffbc 	bl	34184040 <LL_RCC_IC15_Enable>
341850c8:	e008      	b.n	341850dc <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
341850ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341850ce:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
341850d2:	4b47      	ldr	r3, [pc, #284]	@ (341851f0 <HAL_RCCEx_PeriphCLKConfig+0x10ec>)
341850d4:	429a      	cmp	r2, r3
341850d6:	d101      	bne.n	341850dc <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    {
      LL_RCC_CLKP_Enable();
341850d8:	f7ff f806 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
341850dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341850e0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341850e4:	4618      	mov	r0, r3
341850e6:	f7fe fb9c 	bl	34183822 <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
341850ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341850ee:	e9d3 2300 	ldrd	r2, r3, [r3]
341850f2:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
341850f6:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
341850fa:	2300      	movs	r3, #0
341850fc:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
34185100:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
34185104:	4603      	mov	r3, r0
34185106:	460a      	mov	r2, r1
34185108:	4313      	orrs	r3, r2
3418510a:	d02d      	beq.n	34185168 <HAL_RCCEx_PeriphCLKConfig+0x1064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
3418510c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185110:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34185114:	4b37      	ldr	r3, [pc, #220]	@ (341851f4 <HAL_RCCEx_PeriphCLKConfig+0x10f0>)
34185116:	429a      	cmp	r2, r3
34185118:	d116      	bne.n	34185148 <HAL_RCCEx_PeriphCLKConfig+0x1044>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418511a:	4b2d      	ldr	r3, [pc, #180]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418511c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34185120:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185124:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185128:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418512c:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418512e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185132:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34185134:	3b01      	subs	r3, #1
34185136:	041b      	lsls	r3, r3, #16
34185138:	4313      	orrs	r3, r2
3418513a:	4a25      	ldr	r2, [pc, #148]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418513c:	430b      	orrs	r3, r1
3418513e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34185142:	f7fe ff7d 	bl	34184040 <LL_RCC_IC15_Enable>
34185146:	e008      	b.n	3418515a <HAL_RCCEx_PeriphCLKConfig+0x1056>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
34185148:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418514c:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34185150:	4b29      	ldr	r3, [pc, #164]	@ (341851f8 <HAL_RCCEx_PeriphCLKConfig+0x10f4>)
34185152:	429a      	cmp	r2, r3
34185154:	d101      	bne.n	3418515a <HAL_RCCEx_PeriphCLKConfig+0x1056>
    {
      LL_RCC_CLKP_Enable();
34185156:	f7fe ffc7 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
3418515a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418515e:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34185162:	4618      	mov	r0, r3
34185164:	f7fe fb68 	bl	34183838 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
34185168:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418516c:	e9d3 2300 	ldrd	r2, r3, [r3]
34185170:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
34185174:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
34185178:	2300      	movs	r3, #0
3418517a:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
3418517e:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
34185182:	4603      	mov	r3, r0
34185184:	460a      	mov	r2, r1
34185186:	4313      	orrs	r3, r2
34185188:	d04a      	beq.n	34185220 <HAL_RCCEx_PeriphCLKConfig+0x111c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
3418518a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418518e:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34185192:	4b1a      	ldr	r3, [pc, #104]	@ (341851fc <HAL_RCCEx_PeriphCLKConfig+0x10f8>)
34185194:	429a      	cmp	r2, r3
34185196:	d133      	bne.n	34185200 <HAL_RCCEx_PeriphCLKConfig+0x10fc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34185198:	4b0d      	ldr	r3, [pc, #52]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418519a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418519e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341851a2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341851a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341851aa:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341851ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341851b0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341851b2:	3b01      	subs	r3, #1
341851b4:	041b      	lsls	r3, r3, #16
341851b6:	4313      	orrs	r3, r2
341851b8:	4a05      	ldr	r2, [pc, #20]	@ (341851d0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341851ba:	430b      	orrs	r3, r1
341851bc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341851c0:	f7fe ff3e 	bl	34184040 <LL_RCC_IC15_Enable>
341851c4:	e025      	b.n	34185212 <HAL_RCCEx_PeriphCLKConfig+0x110e>
341851c6:	bf00      	nop
341851c8:	0701080c 	.word	0x0701080c
341851cc:	07020c0c 	.word	0x07020c0c
341851d0:	56028000 	.word	0x56028000
341851d4:	07030c0c 	.word	0x07030c0c
341851d8:	07010c0c 	.word	0x07010c0c
341851dc:	0702100c 	.word	0x0702100c
341851e0:	0703100c 	.word	0x0703100c
341851e4:	0701100c 	.word	0x0701100c
341851e8:	0702140c 	.word	0x0702140c
341851ec:	0703140c 	.word	0x0703140c
341851f0:	0701140c 	.word	0x0701140c
341851f4:	0702082c 	.word	0x0702082c
341851f8:	0701082c 	.word	0x0701082c
341851fc:	07020c2c 	.word	0x07020c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
34185200:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185204:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34185208:	4bca      	ldr	r3, [pc, #808]	@ (34185534 <HAL_RCCEx_PeriphCLKConfig+0x1430>)
3418520a:	429a      	cmp	r2, r3
3418520c:	d101      	bne.n	34185212 <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      LL_RCC_CLKP_Enable();
3418520e:	f7fe ff6b 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
34185212:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185216:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3418521a:	4618      	mov	r0, r3
3418521c:	f7fe fb0c 	bl	34183838 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
34185220:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185224:	e9d3 2300 	ldrd	r2, r3, [r3]
34185228:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
3418522c:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
34185230:	2300      	movs	r3, #0
34185232:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
34185236:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
3418523a:	4603      	mov	r3, r0
3418523c:	460a      	mov	r2, r1
3418523e:	4313      	orrs	r3, r2
34185240:	d02d      	beq.n	3418529e <HAL_RCCEx_PeriphCLKConfig+0x119a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
34185242:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185246:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3418524a:	4bbb      	ldr	r3, [pc, #748]	@ (34185538 <HAL_RCCEx_PeriphCLKConfig+0x1434>)
3418524c:	429a      	cmp	r2, r3
3418524e:	d116      	bne.n	3418527e <HAL_RCCEx_PeriphCLKConfig+0x117a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34185250:	4bba      	ldr	r3, [pc, #744]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34185252:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34185256:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418525a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418525e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185262:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34185264:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185268:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418526a:	3b01      	subs	r3, #1
3418526c:	041b      	lsls	r3, r3, #16
3418526e:	4313      	orrs	r3, r2
34185270:	4ab2      	ldr	r2, [pc, #712]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34185272:	430b      	orrs	r3, r1
34185274:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34185278:	f7fe fee2 	bl	34184040 <LL_RCC_IC15_Enable>
3418527c:	e008      	b.n	34185290 <HAL_RCCEx_PeriphCLKConfig+0x118c>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
3418527e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185282:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34185286:	4bae      	ldr	r3, [pc, #696]	@ (34185540 <HAL_RCCEx_PeriphCLKConfig+0x143c>)
34185288:	429a      	cmp	r2, r3
3418528a:	d101      	bne.n	34185290 <HAL_RCCEx_PeriphCLKConfig+0x118c>
    {
      LL_RCC_CLKP_Enable();
3418528c:	f7fe ff2c 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
34185290:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185294:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34185298:	4618      	mov	r0, r3
3418529a:	f7fe facd 	bl	34183838 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
3418529e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341852a2:	e9d3 2300 	ldrd	r2, r3, [r3]
341852a6:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
341852aa:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
341852ae:	2300      	movs	r3, #0
341852b0:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
341852b4:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
341852b8:	4603      	mov	r3, r0
341852ba:	460a      	mov	r2, r1
341852bc:	4313      	orrs	r3, r2
341852be:	d02d      	beq.n	3418531c <HAL_RCCEx_PeriphCLKConfig+0x1218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
341852c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341852c4:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
341852c8:	4b9e      	ldr	r3, [pc, #632]	@ (34185544 <HAL_RCCEx_PeriphCLKConfig+0x1440>)
341852ca:	429a      	cmp	r2, r3
341852cc:	d116      	bne.n	341852fc <HAL_RCCEx_PeriphCLKConfig+0x11f8>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341852ce:	4b9b      	ldr	r3, [pc, #620]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341852d0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341852d4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341852d8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341852dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341852e0:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341852e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341852e6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341852e8:	3b01      	subs	r3, #1
341852ea:	041b      	lsls	r3, r3, #16
341852ec:	4313      	orrs	r3, r2
341852ee:	4a93      	ldr	r2, [pc, #588]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341852f0:	430b      	orrs	r3, r1
341852f2:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341852f6:	f7fe fea3 	bl	34184040 <LL_RCC_IC15_Enable>
341852fa:	e008      	b.n	3418530e <HAL_RCCEx_PeriphCLKConfig+0x120a>
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
341852fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185300:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34185304:	4b90      	ldr	r3, [pc, #576]	@ (34185548 <HAL_RCCEx_PeriphCLKConfig+0x1444>)
34185306:	429a      	cmp	r2, r3
34185308:	d101      	bne.n	3418530e <HAL_RCCEx_PeriphCLKConfig+0x120a>
    {
      LL_RCC_CLKP_Enable();
3418530a:	f7fe feed 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
3418530e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185312:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34185316:	4618      	mov	r0, r3
34185318:	f7fe fa8e 	bl	34183838 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
3418531c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185320:	e9d3 2300 	ldrd	r2, r3, [r3]
34185324:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
34185328:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
3418532c:	2300      	movs	r3, #0
3418532e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
34185332:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
34185336:	4603      	mov	r3, r0
34185338:	460a      	mov	r2, r1
3418533a:	4313      	orrs	r3, r2
3418533c:	d02d      	beq.n	3418539a <HAL_RCCEx_PeriphCLKConfig+0x1296>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
3418533e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185342:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34185346:	4b81      	ldr	r3, [pc, #516]	@ (3418554c <HAL_RCCEx_PeriphCLKConfig+0x1448>)
34185348:	429a      	cmp	r2, r3
3418534a:	d116      	bne.n	3418537a <HAL_RCCEx_PeriphCLKConfig+0x1276>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418534c:	4b7b      	ldr	r3, [pc, #492]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418534e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34185352:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185356:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418535a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418535e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34185360:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185364:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34185366:	3b01      	subs	r3, #1
34185368:	041b      	lsls	r3, r3, #16
3418536a:	4313      	orrs	r3, r2
3418536c:	4a73      	ldr	r2, [pc, #460]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418536e:	430b      	orrs	r3, r1
34185370:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34185374:	f7fe fe64 	bl	34184040 <LL_RCC_IC15_Enable>
34185378:	e008      	b.n	3418538c <HAL_RCCEx_PeriphCLKConfig+0x1288>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
3418537a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418537e:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34185382:	4b73      	ldr	r3, [pc, #460]	@ (34185550 <HAL_RCCEx_PeriphCLKConfig+0x144c>)
34185384:	429a      	cmp	r2, r3
34185386:	d101      	bne.n	3418538c <HAL_RCCEx_PeriphCLKConfig+0x1288>
    {
      LL_RCC_CLKP_Enable();
34185388:	f7fe feae 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
3418538c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185390:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34185394:	4618      	mov	r0, r3
34185396:	f7fe fa4f 	bl	34183838 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
3418539a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418539e:	e9d3 2300 	ldrd	r2, r3, [r3]
341853a2:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
341853a6:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
341853aa:	2300      	movs	r3, #0
341853ac:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
341853b0:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
341853b4:	4603      	mov	r3, r0
341853b6:	460a      	mov	r2, r1
341853b8:	4313      	orrs	r3, r2
341853ba:	d04b      	beq.n	34185454 <HAL_RCCEx_PeriphCLKConfig+0x1350>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
341853bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341853c0:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
341853c4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341853c8:	d116      	bne.n	341853f8 <HAL_RCCEx_PeriphCLKConfig+0x12f4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341853ca:	4b5c      	ldr	r3, [pc, #368]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341853cc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341853d0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341853d4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341853d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341853dc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341853de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341853e2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341853e4:	3b01      	subs	r3, #1
341853e6:	041b      	lsls	r3, r3, #16
341853e8:	4313      	orrs	r3, r2
341853ea:	4a54      	ldr	r2, [pc, #336]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341853ec:	430b      	orrs	r3, r1
341853ee:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341853f2:	f7fe fddf 	bl	34183fb4 <LL_RCC_IC9_Enable>
341853f6:	e026      	b.n	34185446 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
341853f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341853fc:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34185400:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34185404:	d116      	bne.n	34185434 <HAL_RCCEx_PeriphCLKConfig+0x1330>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34185406:	4b4d      	ldr	r3, [pc, #308]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34185408:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418540c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185410:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185414:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185418:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418541a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418541e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34185420:	3b01      	subs	r3, #1
34185422:	041b      	lsls	r3, r3, #16
34185424:	4313      	orrs	r3, r2
34185426:	4a45      	ldr	r2, [pc, #276]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34185428:	430b      	orrs	r3, r1
3418542a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3418542e:	f7fe fdf9 	bl	34184024 <LL_RCC_IC14_Enable>
34185432:	e008      	b.n	34185446 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
34185434:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185438:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3418543c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34185440:	d101      	bne.n	34185446 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    {
      LL_RCC_CLKP_Enable();
34185442:	f7fe fe51 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
34185446:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418544a:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3418544e:	4618      	mov	r0, r3
34185450:	f7fe f9fe 	bl	34183850 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
34185454:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185458:	e9d3 2300 	ldrd	r2, r3, [r3]
3418545c:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
34185460:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
34185464:	2300      	movs	r3, #0
34185466:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
3418546a:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
3418546e:	4603      	mov	r3, r0
34185470:	460a      	mov	r2, r1
34185472:	4313      	orrs	r3, r2
34185474:	d02f      	beq.n	341854d6 <HAL_RCCEx_PeriphCLKConfig+0x13d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
34185476:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418547a:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3418547e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34185482:	d118      	bne.n	341854b6 <HAL_RCCEx_PeriphCLKConfig+0x13b2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
34185484:	4b2d      	ldr	r3, [pc, #180]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34185486:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3418548a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418548e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185492:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185496:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3418549a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418549e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
341854a2:	3b01      	subs	r3, #1
341854a4:	041b      	lsls	r3, r3, #16
341854a6:	4313      	orrs	r3, r2
341854a8:	4a24      	ldr	r2, [pc, #144]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341854aa:	430b      	orrs	r3, r1
341854ac:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
341854b0:	f7fe fdd4 	bl	3418405c <LL_RCC_IC16_Enable>
341854b4:	e008      	b.n	341854c8 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
341854b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341854ba:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
341854be:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
341854c2:	d101      	bne.n	341854c8 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    {
      LL_RCC_CLKP_Enable();
341854c4:	f7fe fe10 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
341854c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341854cc:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
341854d0:	4618      	mov	r0, r3
341854d2:	f7fe f9d3 	bl	3418387c <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
341854d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341854da:	e9d3 2300 	ldrd	r2, r3, [r3]
341854de:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
341854e2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
341854e6:	2300      	movs	r3, #0
341854e8:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
341854ec:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
341854f0:	4603      	mov	r3, r0
341854f2:	460a      	mov	r2, r1
341854f4:	4313      	orrs	r3, r2
341854f6:	d05b      	beq.n	341855b0 <HAL_RCCEx_PeriphCLKConfig+0x14ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
341854f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341854fc:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34185500:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34185504:	d126      	bne.n	34185554 <HAL_RCCEx_PeriphCLKConfig+0x1450>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34185506:	4b0d      	ldr	r3, [pc, #52]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34185508:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418550c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185510:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185514:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185518:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418551a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418551e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34185520:	3b01      	subs	r3, #1
34185522:	041b      	lsls	r3, r3, #16
34185524:	4313      	orrs	r3, r2
34185526:	4a05      	ldr	r2, [pc, #20]	@ (3418553c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34185528:	430b      	orrs	r3, r1
3418552a:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3418552e:	f7fe fd25 	bl	34183f7c <LL_RCC_IC7_Enable>
34185532:	e036      	b.n	341855a2 <HAL_RCCEx_PeriphCLKConfig+0x149e>
34185534:	07010c2c 	.word	0x07010c2c
34185538:	0702102c 	.word	0x0702102c
3418553c:	56028000 	.word	0x56028000
34185540:	0701102c 	.word	0x0701102c
34185544:	0702142c 	.word	0x0702142c
34185548:	0701142c 	.word	0x0701142c
3418554c:	0702182c 	.word	0x0702182c
34185550:	0701182c 	.word	0x0701182c
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
34185554:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185558:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3418555c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34185560:	d116      	bne.n	34185590 <HAL_RCCEx_PeriphCLKConfig+0x148c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34185562:	4bb5      	ldr	r3, [pc, #724]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34185564:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34185568:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418556c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185570:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185574:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34185576:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418557a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418557c:	3b01      	subs	r3, #1
3418557e:	041b      	lsls	r3, r3, #16
34185580:	4313      	orrs	r3, r2
34185582:	4aad      	ldr	r2, [pc, #692]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34185584:	430b      	orrs	r3, r1
34185586:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418558a:	f7fe fd05 	bl	34183f98 <LL_RCC_IC8_Enable>
3418558e:	e008      	b.n	341855a2 <HAL_RCCEx_PeriphCLKConfig+0x149e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
34185590:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185594:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34185598:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3418559c:	d101      	bne.n	341855a2 <HAL_RCCEx_PeriphCLKConfig+0x149e>
    {
      LL_RCC_CLKP_Enable();
3418559e:	f7fe fda3 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
341855a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341855a6:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
341855aa:	4618      	mov	r0, r3
341855ac:	f7fe f97c 	bl	341838a8 <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
341855b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341855b4:	e9d3 2300 	ldrd	r2, r3, [r3]
341855b8:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
341855bc:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
341855c0:	2300      	movs	r3, #0
341855c2:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
341855c6:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
341855ca:	4603      	mov	r3, r0
341855cc:	460a      	mov	r2, r1
341855ce:	4313      	orrs	r3, r2
341855d0:	d02d      	beq.n	3418562e <HAL_RCCEx_PeriphCLKConfig+0x152a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
341855d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341855d6:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
341855da:	2b20      	cmp	r3, #32
341855dc:	d118      	bne.n	34185610 <HAL_RCCEx_PeriphCLKConfig+0x150c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
341855de:	4b96      	ldr	r3, [pc, #600]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341855e0:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
341855e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341855e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341855ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341855f0:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
341855f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341855f8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
341855fc:	3b01      	subs	r3, #1
341855fe:	041b      	lsls	r3, r3, #16
34185600:	4313      	orrs	r3, r2
34185602:	4a8d      	ldr	r2, [pc, #564]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34185604:	430b      	orrs	r3, r1
34185606:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3418560a:	f7fe fd5f 	bl	341840cc <LL_RCC_IC20_Enable>
3418560e:	e007      	b.n	34185620 <HAL_RCCEx_PeriphCLKConfig+0x151c>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
34185610:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185614:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34185618:	2b10      	cmp	r3, #16
3418561a:	d101      	bne.n	34185620 <HAL_RCCEx_PeriphCLKConfig+0x151c>
    {
      LL_RCC_CLKP_Enable();
3418561c:	f7fe fd64 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
34185620:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185624:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34185628:	4618      	mov	r0, r3
3418562a:	f7fe f969 	bl	34183900 <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
3418562e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185632:	e9d3 2300 	ldrd	r2, r3, [r3]
34185636:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
3418563a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3418563e:	2300      	movs	r3, #0
34185640:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
34185644:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
34185648:	4603      	mov	r3, r0
3418564a:	460a      	mov	r2, r1
3418564c:	4313      	orrs	r3, r2
3418564e:	d04b      	beq.n	341856e8 <HAL_RCCEx_PeriphCLKConfig+0x15e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
34185650:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185654:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34185658:	4b78      	ldr	r3, [pc, #480]	@ (3418583c <HAL_RCCEx_PeriphCLKConfig+0x1738>)
3418565a:	429a      	cmp	r2, r3
3418565c:	d116      	bne.n	3418568c <HAL_RCCEx_PeriphCLKConfig+0x1588>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418565e:	4b76      	ldr	r3, [pc, #472]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34185660:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34185664:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185668:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418566c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185670:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34185672:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185676:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34185678:	3b01      	subs	r3, #1
3418567a:	041b      	lsls	r3, r3, #16
3418567c:	4313      	orrs	r3, r2
3418567e:	4a6e      	ldr	r2, [pc, #440]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34185680:	430b      	orrs	r3, r1
34185682:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34185686:	f7fe fc79 	bl	34183f7c <LL_RCC_IC7_Enable>
3418568a:	e026      	b.n	341856da <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
3418568c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185690:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34185694:	4b6a      	ldr	r3, [pc, #424]	@ (34185840 <HAL_RCCEx_PeriphCLKConfig+0x173c>)
34185696:	429a      	cmp	r2, r3
34185698:	d116      	bne.n	341856c8 <HAL_RCCEx_PeriphCLKConfig+0x15c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418569a:	4b67      	ldr	r3, [pc, #412]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418569c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
341856a0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341856a4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341856a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341856ac:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
341856ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341856b2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341856b4:	3b01      	subs	r3, #1
341856b6:	041b      	lsls	r3, r3, #16
341856b8:	4313      	orrs	r3, r2
341856ba:	4a5f      	ldr	r2, [pc, #380]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341856bc:	430b      	orrs	r3, r1
341856be:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
341856c2:	f7fe fc69 	bl	34183f98 <LL_RCC_IC8_Enable>
341856c6:	e008      	b.n	341856da <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
341856c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341856cc:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
341856d0:	4b5c      	ldr	r3, [pc, #368]	@ (34185844 <HAL_RCCEx_PeriphCLKConfig+0x1740>)
341856d2:	429a      	cmp	r2, r3
341856d4:	d101      	bne.n	341856da <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    {
      LL_RCC_CLKP_Enable();
341856d6:	f7fe fd07 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
341856da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341856de:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
341856e2:	4618      	mov	r0, r3
341856e4:	f7fe f922 	bl	3418392c <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
341856e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341856ec:	e9d3 2300 	ldrd	r2, r3, [r3]
341856f0:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
341856f4:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
341856f8:	2300      	movs	r3, #0
341856fa:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
341856fe:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
34185702:	4603      	mov	r3, r0
34185704:	460a      	mov	r2, r1
34185706:	4313      	orrs	r3, r2
34185708:	d04b      	beq.n	341857a2 <HAL_RCCEx_PeriphCLKConfig+0x169e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
3418570a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418570e:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34185712:	4b4d      	ldr	r3, [pc, #308]	@ (34185848 <HAL_RCCEx_PeriphCLKConfig+0x1744>)
34185714:	429a      	cmp	r2, r3
34185716:	d116      	bne.n	34185746 <HAL_RCCEx_PeriphCLKConfig+0x1642>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34185718:	4b47      	ldr	r3, [pc, #284]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418571a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418571e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185722:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185726:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418572a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418572c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185730:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34185732:	3b01      	subs	r3, #1
34185734:	041b      	lsls	r3, r3, #16
34185736:	4313      	orrs	r3, r2
34185738:	4a3f      	ldr	r2, [pc, #252]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418573a:	430b      	orrs	r3, r1
3418573c:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34185740:	f7fe fc1c 	bl	34183f7c <LL_RCC_IC7_Enable>
34185744:	e026      	b.n	34185794 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
34185746:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418574a:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3418574e:	4b3f      	ldr	r3, [pc, #252]	@ (3418584c <HAL_RCCEx_PeriphCLKConfig+0x1748>)
34185750:	429a      	cmp	r2, r3
34185752:	d116      	bne.n	34185782 <HAL_RCCEx_PeriphCLKConfig+0x167e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34185754:	4b38      	ldr	r3, [pc, #224]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34185756:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418575a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418575e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185762:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185766:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34185768:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418576c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418576e:	3b01      	subs	r3, #1
34185770:	041b      	lsls	r3, r3, #16
34185772:	4313      	orrs	r3, r2
34185774:	4a30      	ldr	r2, [pc, #192]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34185776:	430b      	orrs	r3, r1
34185778:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418577c:	f7fe fc0c 	bl	34183f98 <LL_RCC_IC8_Enable>
34185780:	e008      	b.n	34185794 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
34185782:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185786:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3418578a:	4b31      	ldr	r3, [pc, #196]	@ (34185850 <HAL_RCCEx_PeriphCLKConfig+0x174c>)
3418578c:	429a      	cmp	r2, r3
3418578e:	d101      	bne.n	34185794 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    {
      LL_RCC_CLKP_Enable();
34185790:	f7fe fcaa 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
34185794:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185798:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
3418579c:	4618      	mov	r0, r3
3418579e:	f7fe f8c5 	bl	3418392c <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
341857a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341857a6:	e9d3 2300 	ldrd	r2, r3, [r3]
341857aa:	2100      	movs	r1, #0
341857ac:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
341857b0:	f003 0301 	and.w	r3, r3, #1
341857b4:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
341857b8:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
341857bc:	4603      	mov	r3, r0
341857be:	460a      	mov	r2, r1
341857c0:	4313      	orrs	r3, r2
341857c2:	d056      	beq.n	34185872 <HAL_RCCEx_PeriphCLKConfig+0x176e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
341857c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341857c8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
341857cc:	2b02      	cmp	r3, #2
341857ce:	d116      	bne.n	341857fe <HAL_RCCEx_PeriphCLKConfig+0x16fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
341857d0:	4b19      	ldr	r3, [pc, #100]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341857d2:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
341857d6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341857da:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341857de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341857e2:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
341857e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341857e8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
341857ea:	3b01      	subs	r3, #1
341857ec:	041b      	lsls	r3, r3, #16
341857ee:	4313      	orrs	r3, r2
341857f0:	4a11      	ldr	r2, [pc, #68]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341857f2:	430b      	orrs	r3, r1
341857f4:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
341857f8:	f7fe fbc0 	bl	34183f7c <LL_RCC_IC7_Enable>
341857fc:	e032      	b.n	34185864 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
341857fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185802:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34185806:	2b03      	cmp	r3, #3
34185808:	d124      	bne.n	34185854 <HAL_RCCEx_PeriphCLKConfig+0x1750>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418580a:	4b0b      	ldr	r3, [pc, #44]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418580c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34185810:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185814:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185818:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418581c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418581e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185822:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34185824:	3b01      	subs	r3, #1
34185826:	041b      	lsls	r3, r3, #16
34185828:	4313      	orrs	r3, r2
3418582a:	4a03      	ldr	r2, [pc, #12]	@ (34185838 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418582c:	430b      	orrs	r3, r1
3418582e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34185832:	f7fe fbb1 	bl	34183f98 <LL_RCC_IC8_Enable>
34185836:	e015      	b.n	34185864 <HAL_RCCEx_PeriphCLKConfig+0x1760>
34185838:	56028000 	.word	0x56028000
3418583c:	07021418 	.word	0x07021418
34185840:	07031418 	.word	0x07031418
34185844:	07011418 	.word	0x07011418
34185848:	07021818 	.word	0x07021818
3418584c:	07031818 	.word	0x07031818
34185850:	07011818 	.word	0x07011818
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
34185854:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185858:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418585c:	2b01      	cmp	r3, #1
3418585e:	d101      	bne.n	34185864 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    {
      LL_RCC_CLKP_Enable();
34185860:	f7fe fc42 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
34185864:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185868:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418586c:	4618      	mov	r0, r3
3418586e:	f7fe f873 	bl	34183958 <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
34185872:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185876:	e9d3 2300 	ldrd	r2, r3, [r3]
3418587a:	2100      	movs	r1, #0
3418587c:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
34185880:	f003 0302 	and.w	r3, r3, #2
34185884:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
34185888:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
3418588c:	4603      	mov	r3, r0
3418588e:	460a      	mov	r2, r1
34185890:	4313      	orrs	r3, r2
34185892:	d04b      	beq.n	3418592c <HAL_RCCEx_PeriphCLKConfig+0x1828>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
34185894:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185898:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3418589c:	4bc6      	ldr	r3, [pc, #792]	@ (34185bb8 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>)
3418589e:	429a      	cmp	r2, r3
341858a0:	d116      	bne.n	341858d0 <HAL_RCCEx_PeriphCLKConfig+0x17cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
341858a2:	4bc6      	ldr	r3, [pc, #792]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341858a4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
341858a8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341858ac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341858b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341858b4:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
341858b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341858ba:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341858bc:	3b01      	subs	r3, #1
341858be:	041b      	lsls	r3, r3, #16
341858c0:	4313      	orrs	r3, r2
341858c2:	4abe      	ldr	r2, [pc, #760]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341858c4:	430b      	orrs	r3, r1
341858c6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
341858ca:	f7fe fb65 	bl	34183f98 <LL_RCC_IC8_Enable>
341858ce:	e026      	b.n	3418591e <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
341858d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341858d4:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
341858d8:	4bb9      	ldr	r3, [pc, #740]	@ (34185bc0 <HAL_RCCEx_PeriphCLKConfig+0x1abc>)
341858da:	429a      	cmp	r2, r3
341858dc:	d116      	bne.n	3418590c <HAL_RCCEx_PeriphCLKConfig+0x1808>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341858de:	4bb7      	ldr	r3, [pc, #732]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341858e0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341858e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341858e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341858ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341858f0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341858f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341858f6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341858f8:	3b01      	subs	r3, #1
341858fa:	041b      	lsls	r3, r3, #16
341858fc:	4313      	orrs	r3, r2
341858fe:	4aaf      	ldr	r2, [pc, #700]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185900:	430b      	orrs	r3, r1
34185902:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34185906:	f7fe fb55 	bl	34183fb4 <LL_RCC_IC9_Enable>
3418590a:	e008      	b.n	3418591e <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
3418590c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185910:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34185914:	4bab      	ldr	r3, [pc, #684]	@ (34185bc4 <HAL_RCCEx_PeriphCLKConfig+0x1ac0>)
34185916:	429a      	cmp	r2, r3
34185918:	d101      	bne.n	3418591e <HAL_RCCEx_PeriphCLKConfig+0x181a>
    {
      LL_RCC_CLKP_Enable();
3418591a:	f7fe fbe5 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
3418591e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185922:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
34185926:	4618      	mov	r0, r3
34185928:	f7fe f82c 	bl	34183984 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
3418592c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185930:	e9d3 2300 	ldrd	r2, r3, [r3]
34185934:	2100      	movs	r1, #0
34185936:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
3418593a:	f003 0304 	and.w	r3, r3, #4
3418593e:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
34185942:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
34185946:	4603      	mov	r3, r0
34185948:	460a      	mov	r2, r1
3418594a:	4313      	orrs	r3, r2
3418594c:	d04b      	beq.n	341859e6 <HAL_RCCEx_PeriphCLKConfig+0x18e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
3418594e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185952:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34185956:	4b9c      	ldr	r3, [pc, #624]	@ (34185bc8 <HAL_RCCEx_PeriphCLKConfig+0x1ac4>)
34185958:	429a      	cmp	r2, r3
3418595a:	d116      	bne.n	3418598a <HAL_RCCEx_PeriphCLKConfig+0x1886>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418595c:	4b97      	ldr	r3, [pc, #604]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418595e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34185962:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185966:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418596a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418596e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34185970:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185974:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34185976:	3b01      	subs	r3, #1
34185978:	041b      	lsls	r3, r3, #16
3418597a:	4313      	orrs	r3, r2
3418597c:	4a8f      	ldr	r2, [pc, #572]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418597e:	430b      	orrs	r3, r1
34185980:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34185984:	f7fe fb08 	bl	34183f98 <LL_RCC_IC8_Enable>
34185988:	e026      	b.n	341859d8 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
3418598a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418598e:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34185992:	4b8e      	ldr	r3, [pc, #568]	@ (34185bcc <HAL_RCCEx_PeriphCLKConfig+0x1ac8>)
34185994:	429a      	cmp	r2, r3
34185996:	d116      	bne.n	341859c6 <HAL_RCCEx_PeriphCLKConfig+0x18c2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34185998:	4b88      	ldr	r3, [pc, #544]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418599a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418599e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341859a2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341859a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341859aa:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341859ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341859b0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341859b2:	3b01      	subs	r3, #1
341859b4:	041b      	lsls	r3, r3, #16
341859b6:	4313      	orrs	r3, r2
341859b8:	4a80      	ldr	r2, [pc, #512]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341859ba:	430b      	orrs	r3, r1
341859bc:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341859c0:	f7fe faf8 	bl	34183fb4 <LL_RCC_IC9_Enable>
341859c4:	e008      	b.n	341859d8 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
341859c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341859ca:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
341859ce:	4b80      	ldr	r3, [pc, #512]	@ (34185bd0 <HAL_RCCEx_PeriphCLKConfig+0x1acc>)
341859d0:	429a      	cmp	r2, r3
341859d2:	d101      	bne.n	341859d8 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    {
      LL_RCC_CLKP_Enable();
341859d4:	f7fe fb88 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
341859d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341859dc:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
341859e0:	4618      	mov	r0, r3
341859e2:	f7fd ffcf 	bl	34183984 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
341859e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341859ea:	e9d3 2300 	ldrd	r2, r3, [r3]
341859ee:	2100      	movs	r1, #0
341859f0:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
341859f4:	f003 0308 	and.w	r3, r3, #8
341859f8:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
341859fc:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
34185a00:	4603      	mov	r3, r0
34185a02:	460a      	mov	r2, r1
34185a04:	4313      	orrs	r3, r2
34185a06:	d04b      	beq.n	34185aa0 <HAL_RCCEx_PeriphCLKConfig+0x199c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
34185a08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185a0c:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34185a10:	4b70      	ldr	r3, [pc, #448]	@ (34185bd4 <HAL_RCCEx_PeriphCLKConfig+0x1ad0>)
34185a12:	429a      	cmp	r2, r3
34185a14:	d116      	bne.n	34185a44 <HAL_RCCEx_PeriphCLKConfig+0x1940>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34185a16:	4b69      	ldr	r3, [pc, #420]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185a18:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34185a1c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185a20:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185a24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185a28:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34185a2a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185a2e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34185a30:	3b01      	subs	r3, #1
34185a32:	041b      	lsls	r3, r3, #16
34185a34:	4313      	orrs	r3, r2
34185a36:	4a61      	ldr	r2, [pc, #388]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185a38:	430b      	orrs	r3, r1
34185a3a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34185a3e:	f7fe faab 	bl	34183f98 <LL_RCC_IC8_Enable>
34185a42:	e026      	b.n	34185a92 <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
34185a44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185a48:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34185a4c:	4b62      	ldr	r3, [pc, #392]	@ (34185bd8 <HAL_RCCEx_PeriphCLKConfig+0x1ad4>)
34185a4e:	429a      	cmp	r2, r3
34185a50:	d116      	bne.n	34185a80 <HAL_RCCEx_PeriphCLKConfig+0x197c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34185a52:	4b5a      	ldr	r3, [pc, #360]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185a54:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34185a58:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185a5c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185a60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185a64:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34185a66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185a6a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34185a6c:	3b01      	subs	r3, #1
34185a6e:	041b      	lsls	r3, r3, #16
34185a70:	4313      	orrs	r3, r2
34185a72:	4a52      	ldr	r2, [pc, #328]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185a74:	430b      	orrs	r3, r1
34185a76:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34185a7a:	f7fe fa9b 	bl	34183fb4 <LL_RCC_IC9_Enable>
34185a7e:	e008      	b.n	34185a92 <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
34185a80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185a84:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34185a88:	4b54      	ldr	r3, [pc, #336]	@ (34185bdc <HAL_RCCEx_PeriphCLKConfig+0x1ad8>)
34185a8a:	429a      	cmp	r2, r3
34185a8c:	d101      	bne.n	34185a92 <HAL_RCCEx_PeriphCLKConfig+0x198e>
    {
      LL_RCC_CLKP_Enable();
34185a8e:	f7fe fb2b 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
34185a92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185a96:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
34185a9a:	4618      	mov	r0, r3
34185a9c:	f7fd ff72 	bl	34183984 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
34185aa0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185aa4:	e9d3 2300 	ldrd	r2, r3, [r3]
34185aa8:	2100      	movs	r1, #0
34185aaa:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
34185aae:	f003 0310 	and.w	r3, r3, #16
34185ab2:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
34185ab6:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
34185aba:	4603      	mov	r3, r0
34185abc:	460a      	mov	r2, r1
34185abe:	4313      	orrs	r3, r2
34185ac0:	d04b      	beq.n	34185b5a <HAL_RCCEx_PeriphCLKConfig+0x1a56>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
34185ac2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185ac6:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34185aca:	4b45      	ldr	r3, [pc, #276]	@ (34185be0 <HAL_RCCEx_PeriphCLKConfig+0x1adc>)
34185acc:	429a      	cmp	r2, r3
34185ace:	d116      	bne.n	34185afe <HAL_RCCEx_PeriphCLKConfig+0x19fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34185ad0:	4b3a      	ldr	r3, [pc, #232]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185ad2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34185ad6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185ada:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185ade:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185ae2:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34185ae4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185ae8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34185aea:	3b01      	subs	r3, #1
34185aec:	041b      	lsls	r3, r3, #16
34185aee:	4313      	orrs	r3, r2
34185af0:	4a32      	ldr	r2, [pc, #200]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185af2:	430b      	orrs	r3, r1
34185af4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34185af8:	f7fe fa5c 	bl	34183fb4 <LL_RCC_IC9_Enable>
34185afc:	e026      	b.n	34185b4c <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
34185afe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185b02:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34185b06:	4b37      	ldr	r3, [pc, #220]	@ (34185be4 <HAL_RCCEx_PeriphCLKConfig+0x1ae0>)
34185b08:	429a      	cmp	r2, r3
34185b0a:	d116      	bne.n	34185b3a <HAL_RCCEx_PeriphCLKConfig+0x1a36>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34185b0c:	4b2b      	ldr	r3, [pc, #172]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185b0e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34185b12:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185b16:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185b1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185b1e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34185b20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185b24:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34185b26:	3b01      	subs	r3, #1
34185b28:	041b      	lsls	r3, r3, #16
34185b2a:	4313      	orrs	r3, r2
34185b2c:	4a23      	ldr	r2, [pc, #140]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185b2e:	430b      	orrs	r3, r1
34185b30:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34185b34:	f7fe fa76 	bl	34184024 <LL_RCC_IC14_Enable>
34185b38:	e008      	b.n	34185b4c <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
34185b3a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185b3e:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34185b42:	4b29      	ldr	r3, [pc, #164]	@ (34185be8 <HAL_RCCEx_PeriphCLKConfig+0x1ae4>)
34185b44:	429a      	cmp	r2, r3
34185b46:	d101      	bne.n	34185b4c <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    {
      LL_RCC_CLKP_Enable();
34185b48:	f7fe face 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
34185b4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185b50:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
34185b54:	4618      	mov	r0, r3
34185b56:	f7fd ff15 	bl	34183984 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
34185b5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185b5e:	e9d3 2300 	ldrd	r2, r3, [r3]
34185b62:	2100      	movs	r1, #0
34185b64:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
34185b68:	f003 0320 	and.w	r3, r3, #32
34185b6c:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
34185b70:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
34185b74:	4603      	mov	r3, r0
34185b76:	460a      	mov	r2, r1
34185b78:	4313      	orrs	r3, r2
34185b7a:	d067      	beq.n	34185c4c <HAL_RCCEx_PeriphCLKConfig+0x1b48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
34185b7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185b80:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34185b84:	4b19      	ldr	r3, [pc, #100]	@ (34185bec <HAL_RCCEx_PeriphCLKConfig+0x1ae8>)
34185b86:	429a      	cmp	r2, r3
34185b88:	d132      	bne.n	34185bf0 <HAL_RCCEx_PeriphCLKConfig+0x1aec>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34185b8a:	4b0c      	ldr	r3, [pc, #48]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185b8c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34185b90:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185b94:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185b98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185b9c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34185b9e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185ba2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34185ba4:	3b01      	subs	r3, #1
34185ba6:	041b      	lsls	r3, r3, #16
34185ba8:	4313      	orrs	r3, r2
34185baa:	4a04      	ldr	r2, [pc, #16]	@ (34185bbc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34185bac:	430b      	orrs	r3, r1
34185bae:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34185bb2:	f7fe f9ff 	bl	34183fb4 <LL_RCC_IC9_Enable>
34185bb6:	e042      	b.n	34185c3e <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
34185bb8:	07020420 	.word	0x07020420
34185bbc:	56028000 	.word	0x56028000
34185bc0:	07030420 	.word	0x07030420
34185bc4:	07010420 	.word	0x07010420
34185bc8:	07020820 	.word	0x07020820
34185bcc:	07030820 	.word	0x07030820
34185bd0:	07010820 	.word	0x07010820
34185bd4:	07020c20 	.word	0x07020c20
34185bd8:	07030c20 	.word	0x07030c20
34185bdc:	07010c20 	.word	0x07010c20
34185be0:	07021020 	.word	0x07021020
34185be4:	07031020 	.word	0x07031020
34185be8:	07011020 	.word	0x07011020
34185bec:	07021420 	.word	0x07021420
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
34185bf0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185bf4:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34185bf8:	4bc2      	ldr	r3, [pc, #776]	@ (34185f04 <HAL_RCCEx_PeriphCLKConfig+0x1e00>)
34185bfa:	429a      	cmp	r2, r3
34185bfc:	d116      	bne.n	34185c2c <HAL_RCCEx_PeriphCLKConfig+0x1b28>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34185bfe:	4bc2      	ldr	r3, [pc, #776]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185c00:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34185c04:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185c08:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185c0c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185c10:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34185c12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185c16:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34185c18:	3b01      	subs	r3, #1
34185c1a:	041b      	lsls	r3, r3, #16
34185c1c:	4313      	orrs	r3, r2
34185c1e:	4aba      	ldr	r2, [pc, #744]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185c20:	430b      	orrs	r3, r1
34185c22:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34185c26:	f7fe f9fd 	bl	34184024 <LL_RCC_IC14_Enable>
34185c2a:	e008      	b.n	34185c3e <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
34185c2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185c30:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34185c34:	4bb5      	ldr	r3, [pc, #724]	@ (34185f0c <HAL_RCCEx_PeriphCLKConfig+0x1e08>)
34185c36:	429a      	cmp	r2, r3
34185c38:	d101      	bne.n	34185c3e <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    {
      LL_RCC_CLKP_Enable();
34185c3a:	f7fe fa55 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
34185c3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185c42:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34185c46:	4618      	mov	r0, r3
34185c48:	f7fd fe9c 	bl	34183984 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
34185c4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185c50:	e9d3 2300 	ldrd	r2, r3, [r3]
34185c54:	2100      	movs	r1, #0
34185c56:	67b9      	str	r1, [r7, #120]	@ 0x78
34185c58:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34185c5c:	67fb      	str	r3, [r7, #124]	@ 0x7c
34185c5e:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
34185c62:	4603      	mov	r3, r0
34185c64:	460a      	mov	r2, r1
34185c66:	4313      	orrs	r3, r2
34185c68:	d04b      	beq.n	34185d02 <HAL_RCCEx_PeriphCLKConfig+0x1bfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
34185c6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185c6e:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34185c72:	4ba7      	ldr	r3, [pc, #668]	@ (34185f10 <HAL_RCCEx_PeriphCLKConfig+0x1e0c>)
34185c74:	429a      	cmp	r2, r3
34185c76:	d116      	bne.n	34185ca6 <HAL_RCCEx_PeriphCLKConfig+0x1ba2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34185c78:	4ba3      	ldr	r3, [pc, #652]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185c7a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34185c7e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185c82:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185c86:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185c8a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34185c8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185c90:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34185c92:	3b01      	subs	r3, #1
34185c94:	041b      	lsls	r3, r3, #16
34185c96:	4313      	orrs	r3, r2
34185c98:	4a9b      	ldr	r2, [pc, #620]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185c9a:	430b      	orrs	r3, r1
34185c9c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34185ca0:	f7fe f97a 	bl	34183f98 <LL_RCC_IC8_Enable>
34185ca4:	e026      	b.n	34185cf4 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
34185ca6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185caa:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34185cae:	4b99      	ldr	r3, [pc, #612]	@ (34185f14 <HAL_RCCEx_PeriphCLKConfig+0x1e10>)
34185cb0:	429a      	cmp	r2, r3
34185cb2:	d116      	bne.n	34185ce2 <HAL_RCCEx_PeriphCLKConfig+0x1bde>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34185cb4:	4b94      	ldr	r3, [pc, #592]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185cb6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34185cba:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185cbe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185cc2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185cc6:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34185cc8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185ccc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34185cce:	3b01      	subs	r3, #1
34185cd0:	041b      	lsls	r3, r3, #16
34185cd2:	4313      	orrs	r3, r2
34185cd4:	4a8c      	ldr	r2, [pc, #560]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185cd6:	430b      	orrs	r3, r1
34185cd8:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34185cdc:	f7fe f96a 	bl	34183fb4 <LL_RCC_IC9_Enable>
34185ce0:	e008      	b.n	34185cf4 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
34185ce2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185ce6:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34185cea:	4b8b      	ldr	r3, [pc, #556]	@ (34185f18 <HAL_RCCEx_PeriphCLKConfig+0x1e14>)
34185cec:	429a      	cmp	r2, r3
34185cee:	d101      	bne.n	34185cf4 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    {
      LL_RCC_CLKP_Enable();
34185cf0:	f7fe f9fa 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
34185cf4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185cf8:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34185cfc:	4618      	mov	r0, r3
34185cfe:	f7fd fe41 	bl	34183984 <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
34185d02:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185d06:	e9d3 2300 	ldrd	r2, r3, [r3]
34185d0a:	2100      	movs	r1, #0
34185d0c:	6739      	str	r1, [r7, #112]	@ 0x70
34185d0e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34185d12:	677b      	str	r3, [r7, #116]	@ 0x74
34185d14:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
34185d18:	4603      	mov	r3, r0
34185d1a:	460a      	mov	r2, r1
34185d1c:	4313      	orrs	r3, r2
34185d1e:	d04b      	beq.n	34185db8 <HAL_RCCEx_PeriphCLKConfig+0x1cb4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
34185d20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185d24:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34185d28:	4b7c      	ldr	r3, [pc, #496]	@ (34185f1c <HAL_RCCEx_PeriphCLKConfig+0x1e18>)
34185d2a:	429a      	cmp	r2, r3
34185d2c:	d116      	bne.n	34185d5c <HAL_RCCEx_PeriphCLKConfig+0x1c58>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34185d2e:	4b76      	ldr	r3, [pc, #472]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185d30:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34185d34:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185d38:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185d3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185d40:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34185d42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185d46:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34185d48:	3b01      	subs	r3, #1
34185d4a:	041b      	lsls	r3, r3, #16
34185d4c:	4313      	orrs	r3, r2
34185d4e:	4a6e      	ldr	r2, [pc, #440]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185d50:	430b      	orrs	r3, r1
34185d52:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34185d56:	f7fe f92d 	bl	34183fb4 <LL_RCC_IC9_Enable>
34185d5a:	e026      	b.n	34185daa <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
34185d5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185d60:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34185d64:	4b6e      	ldr	r3, [pc, #440]	@ (34185f20 <HAL_RCCEx_PeriphCLKConfig+0x1e1c>)
34185d66:	429a      	cmp	r2, r3
34185d68:	d116      	bne.n	34185d98 <HAL_RCCEx_PeriphCLKConfig+0x1c94>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34185d6a:	4b67      	ldr	r3, [pc, #412]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185d6c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34185d70:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185d74:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185d78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185d7c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34185d7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185d82:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34185d84:	3b01      	subs	r3, #1
34185d86:	041b      	lsls	r3, r3, #16
34185d88:	4313      	orrs	r3, r2
34185d8a:	4a5f      	ldr	r2, [pc, #380]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185d8c:	430b      	orrs	r3, r1
34185d8e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34185d92:	f7fe f947 	bl	34184024 <LL_RCC_IC14_Enable>
34185d96:	e008      	b.n	34185daa <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
34185d98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185d9c:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34185da0:	4b60      	ldr	r3, [pc, #384]	@ (34185f24 <HAL_RCCEx_PeriphCLKConfig+0x1e20>)
34185da2:	429a      	cmp	r2, r3
34185da4:	d101      	bne.n	34185daa <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    {
      LL_RCC_CLKP_Enable();
34185da6:	f7fe f99f 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
34185daa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185dae:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34185db2:	4618      	mov	r0, r3
34185db4:	f7fd fdf1 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
34185db8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185dbc:	e9d3 2300 	ldrd	r2, r3, [r3]
34185dc0:	2100      	movs	r1, #0
34185dc2:	66b9      	str	r1, [r7, #104]	@ 0x68
34185dc4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34185dc8:	66fb      	str	r3, [r7, #108]	@ 0x6c
34185dca:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
34185dce:	4603      	mov	r3, r0
34185dd0:	460a      	mov	r2, r1
34185dd2:	4313      	orrs	r3, r2
34185dd4:	d04b      	beq.n	34185e6e <HAL_RCCEx_PeriphCLKConfig+0x1d6a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
34185dd6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185dda:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34185dde:	4b52      	ldr	r3, [pc, #328]	@ (34185f28 <HAL_RCCEx_PeriphCLKConfig+0x1e24>)
34185de0:	429a      	cmp	r2, r3
34185de2:	d116      	bne.n	34185e12 <HAL_RCCEx_PeriphCLKConfig+0x1d0e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34185de4:	4b48      	ldr	r3, [pc, #288]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185de6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34185dea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185dee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185df2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185df6:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34185df8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185dfc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34185dfe:	3b01      	subs	r3, #1
34185e00:	041b      	lsls	r3, r3, #16
34185e02:	4313      	orrs	r3, r2
34185e04:	4a40      	ldr	r2, [pc, #256]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185e06:	430b      	orrs	r3, r1
34185e08:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34185e0c:	f7fe f8d2 	bl	34183fb4 <LL_RCC_IC9_Enable>
34185e10:	e026      	b.n	34185e60 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
34185e12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185e16:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34185e1a:	4b44      	ldr	r3, [pc, #272]	@ (34185f2c <HAL_RCCEx_PeriphCLKConfig+0x1e28>)
34185e1c:	429a      	cmp	r2, r3
34185e1e:	d116      	bne.n	34185e4e <HAL_RCCEx_PeriphCLKConfig+0x1d4a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34185e20:	4b39      	ldr	r3, [pc, #228]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185e22:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34185e26:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185e2a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185e2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185e32:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34185e34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185e38:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34185e3a:	3b01      	subs	r3, #1
34185e3c:	041b      	lsls	r3, r3, #16
34185e3e:	4313      	orrs	r3, r2
34185e40:	4a31      	ldr	r2, [pc, #196]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185e42:	430b      	orrs	r3, r1
34185e44:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34185e48:	f7fe f8ec 	bl	34184024 <LL_RCC_IC14_Enable>
34185e4c:	e008      	b.n	34185e60 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
34185e4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185e52:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34185e56:	4b36      	ldr	r3, [pc, #216]	@ (34185f30 <HAL_RCCEx_PeriphCLKConfig+0x1e2c>)
34185e58:	429a      	cmp	r2, r3
34185e5a:	d101      	bne.n	34185e60 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    {
      LL_RCC_CLKP_Enable();
34185e5c:	f7fe f944 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
34185e60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185e64:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34185e68:	4618      	mov	r0, r3
34185e6a:	f7fd fd96 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
34185e6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185e72:	e9d3 2300 	ldrd	r2, r3, [r3]
34185e76:	2100      	movs	r1, #0
34185e78:	6639      	str	r1, [r7, #96]	@ 0x60
34185e7a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34185e7e:	667b      	str	r3, [r7, #100]	@ 0x64
34185e80:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
34185e84:	4603      	mov	r3, r0
34185e86:	460a      	mov	r2, r1
34185e88:	4313      	orrs	r3, r2
34185e8a:	d067      	beq.n	34185f5c <HAL_RCCEx_PeriphCLKConfig+0x1e58>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
34185e8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185e90:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34185e94:	4b27      	ldr	r3, [pc, #156]	@ (34185f34 <HAL_RCCEx_PeriphCLKConfig+0x1e30>)
34185e96:	429a      	cmp	r2, r3
34185e98:	d116      	bne.n	34185ec8 <HAL_RCCEx_PeriphCLKConfig+0x1dc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34185e9a:	4b1b      	ldr	r3, [pc, #108]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185e9c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34185ea0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185ea4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185ea8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185eac:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34185eae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185eb2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34185eb4:	3b01      	subs	r3, #1
34185eb6:	041b      	lsls	r3, r3, #16
34185eb8:	4313      	orrs	r3, r2
34185eba:	4a13      	ldr	r2, [pc, #76]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185ebc:	430b      	orrs	r3, r1
34185ebe:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34185ec2:	f7fe f877 	bl	34183fb4 <LL_RCC_IC9_Enable>
34185ec6:	e042      	b.n	34185f4e <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
34185ec8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185ecc:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34185ed0:	4b19      	ldr	r3, [pc, #100]	@ (34185f38 <HAL_RCCEx_PeriphCLKConfig+0x1e34>)
34185ed2:	429a      	cmp	r2, r3
34185ed4:	d132      	bne.n	34185f3c <HAL_RCCEx_PeriphCLKConfig+0x1e38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34185ed6:	4b0c      	ldr	r3, [pc, #48]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185ed8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34185edc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185ee0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185ee4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185ee8:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34185eea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185eee:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34185ef0:	3b01      	subs	r3, #1
34185ef2:	041b      	lsls	r3, r3, #16
34185ef4:	4313      	orrs	r3, r2
34185ef6:	4a04      	ldr	r2, [pc, #16]	@ (34185f08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34185ef8:	430b      	orrs	r3, r1
34185efa:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34185efe:	f7fe f891 	bl	34184024 <LL_RCC_IC14_Enable>
34185f02:	e024      	b.n	34185f4e <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
34185f04:	07031420 	.word	0x07031420
34185f08:	56028000 	.word	0x56028000
34185f0c:	07011420 	.word	0x07011420
34185f10:	07021820 	.word	0x07021820
34185f14:	07031820 	.word	0x07031820
34185f18:	07011820 	.word	0x07011820
34185f1c:	07020030 	.word	0x07020030
34185f20:	07030030 	.word	0x07030030
34185f24:	07010030 	.word	0x07010030
34185f28:	07020430 	.word	0x07020430
34185f2c:	07030430 	.word	0x07030430
34185f30:	07010430 	.word	0x07010430
34185f34:	07020830 	.word	0x07020830
34185f38:	07030830 	.word	0x07030830
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
34185f3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185f40:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34185f44:	4bb3      	ldr	r3, [pc, #716]	@ (34186214 <HAL_RCCEx_PeriphCLKConfig+0x2110>)
34185f46:	429a      	cmp	r2, r3
34185f48:	d101      	bne.n	34185f4e <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    {
      LL_RCC_CLKP_Enable();
34185f4a:	f7fe f8cd 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
34185f4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185f52:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
34185f56:	4618      	mov	r0, r3
34185f58:	f7fd fd1f 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
34185f5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185f60:	e9d3 2300 	ldrd	r2, r3, [r3]
34185f64:	2100      	movs	r1, #0
34185f66:	65b9      	str	r1, [r7, #88]	@ 0x58
34185f68:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34185f6c:	65fb      	str	r3, [r7, #92]	@ 0x5c
34185f6e:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
34185f72:	4603      	mov	r3, r0
34185f74:	460a      	mov	r2, r1
34185f76:	4313      	orrs	r3, r2
34185f78:	d04b      	beq.n	34186012 <HAL_RCCEx_PeriphCLKConfig+0x1f0e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
34185f7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185f7e:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34185f82:	4ba5      	ldr	r3, [pc, #660]	@ (34186218 <HAL_RCCEx_PeriphCLKConfig+0x2114>)
34185f84:	429a      	cmp	r2, r3
34185f86:	d116      	bne.n	34185fb6 <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34185f88:	4ba4      	ldr	r3, [pc, #656]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34185f8a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34185f8e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185f92:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185f96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185f9a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34185f9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185fa0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34185fa2:	3b01      	subs	r3, #1
34185fa4:	041b      	lsls	r3, r3, #16
34185fa6:	4313      	orrs	r3, r2
34185fa8:	4a9c      	ldr	r2, [pc, #624]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34185faa:	430b      	orrs	r3, r1
34185fac:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34185fb0:	f7fe f800 	bl	34183fb4 <LL_RCC_IC9_Enable>
34185fb4:	e026      	b.n	34186004 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
34185fb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185fba:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34185fbe:	4b98      	ldr	r3, [pc, #608]	@ (34186220 <HAL_RCCEx_PeriphCLKConfig+0x211c>)
34185fc0:	429a      	cmp	r2, r3
34185fc2:	d116      	bne.n	34185ff2 <HAL_RCCEx_PeriphCLKConfig+0x1eee>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34185fc4:	4b95      	ldr	r3, [pc, #596]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34185fc6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34185fca:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34185fce:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34185fd2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185fd6:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34185fd8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185fdc:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34185fde:	3b01      	subs	r3, #1
34185fe0:	041b      	lsls	r3, r3, #16
34185fe2:	4313      	orrs	r3, r2
34185fe4:	4a8d      	ldr	r2, [pc, #564]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34185fe6:	430b      	orrs	r3, r1
34185fe8:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34185fec:	f7fe f81a 	bl	34184024 <LL_RCC_IC14_Enable>
34185ff0:	e008      	b.n	34186004 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
34185ff2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34185ff6:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34185ffa:	4b8a      	ldr	r3, [pc, #552]	@ (34186224 <HAL_RCCEx_PeriphCLKConfig+0x2120>)
34185ffc:	429a      	cmp	r2, r3
34185ffe:	d101      	bne.n	34186004 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    {
      LL_RCC_CLKP_Enable();
34186000:	f7fe f872 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
34186004:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186008:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418600c:	4618      	mov	r0, r3
3418600e:	f7fd fcc4 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
34186012:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186016:	e9d3 2300 	ldrd	r2, r3, [r3]
3418601a:	2100      	movs	r1, #0
3418601c:	6539      	str	r1, [r7, #80]	@ 0x50
3418601e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34186022:	657b      	str	r3, [r7, #84]	@ 0x54
34186024:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
34186028:	4603      	mov	r3, r0
3418602a:	460a      	mov	r2, r1
3418602c:	4313      	orrs	r3, r2
3418602e:	d04b      	beq.n	341860c8 <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
34186030:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186034:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34186038:	4b7b      	ldr	r3, [pc, #492]	@ (34186228 <HAL_RCCEx_PeriphCLKConfig+0x2124>)
3418603a:	429a      	cmp	r2, r3
3418603c:	d116      	bne.n	3418606c <HAL_RCCEx_PeriphCLKConfig+0x1f68>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418603e:	4b77      	ldr	r3, [pc, #476]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34186040:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34186044:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186048:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418604c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186050:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34186052:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186056:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34186058:	3b01      	subs	r3, #1
3418605a:	041b      	lsls	r3, r3, #16
3418605c:	4313      	orrs	r3, r2
3418605e:	4a6f      	ldr	r2, [pc, #444]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34186060:	430b      	orrs	r3, r1
34186062:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34186066:	f7fd ffa5 	bl	34183fb4 <LL_RCC_IC9_Enable>
3418606a:	e026      	b.n	341860ba <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
3418606c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186070:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34186074:	4b6d      	ldr	r3, [pc, #436]	@ (3418622c <HAL_RCCEx_PeriphCLKConfig+0x2128>)
34186076:	429a      	cmp	r2, r3
34186078:	d116      	bne.n	341860a8 <HAL_RCCEx_PeriphCLKConfig+0x1fa4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418607a:	4b68      	ldr	r3, [pc, #416]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3418607c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34186080:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186084:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186088:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418608c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418608e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186092:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34186094:	3b01      	subs	r3, #1
34186096:	041b      	lsls	r3, r3, #16
34186098:	4313      	orrs	r3, r2
3418609a:	4a60      	ldr	r2, [pc, #384]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3418609c:	430b      	orrs	r3, r1
3418609e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341860a2:	f7fd ffbf 	bl	34184024 <LL_RCC_IC14_Enable>
341860a6:	e008      	b.n	341860ba <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
341860a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341860ac:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
341860b0:	4b5f      	ldr	r3, [pc, #380]	@ (34186230 <HAL_RCCEx_PeriphCLKConfig+0x212c>)
341860b2:	429a      	cmp	r2, r3
341860b4:	d101      	bne.n	341860ba <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    {
      LL_RCC_CLKP_Enable();
341860b6:	f7fe f817 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
341860ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341860be:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
341860c2:	4618      	mov	r0, r3
341860c4:	f7fd fc69 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
341860c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341860cc:	e9d3 2300 	ldrd	r2, r3, [r3]
341860d0:	2100      	movs	r1, #0
341860d2:	64b9      	str	r1, [r7, #72]	@ 0x48
341860d4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
341860d8:	64fb      	str	r3, [r7, #76]	@ 0x4c
341860da:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
341860de:	4603      	mov	r3, r0
341860e0:	460a      	mov	r2, r1
341860e2:	4313      	orrs	r3, r2
341860e4:	d04b      	beq.n	3418617e <HAL_RCCEx_PeriphCLKConfig+0x207a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
341860e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341860ea:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
341860ee:	4b51      	ldr	r3, [pc, #324]	@ (34186234 <HAL_RCCEx_PeriphCLKConfig+0x2130>)
341860f0:	429a      	cmp	r2, r3
341860f2:	d116      	bne.n	34186122 <HAL_RCCEx_PeriphCLKConfig+0x201e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341860f4:	4b49      	ldr	r3, [pc, #292]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341860f6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341860fa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341860fe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186102:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186106:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34186108:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418610c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3418610e:	3b01      	subs	r3, #1
34186110:	041b      	lsls	r3, r3, #16
34186112:	4313      	orrs	r3, r2
34186114:	4a41      	ldr	r2, [pc, #260]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34186116:	430b      	orrs	r3, r1
34186118:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3418611c:	f7fd ff4a 	bl	34183fb4 <LL_RCC_IC9_Enable>
34186120:	e026      	b.n	34186170 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
34186122:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186126:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3418612a:	4b43      	ldr	r3, [pc, #268]	@ (34186238 <HAL_RCCEx_PeriphCLKConfig+0x2134>)
3418612c:	429a      	cmp	r2, r3
3418612e:	d116      	bne.n	3418615e <HAL_RCCEx_PeriphCLKConfig+0x205a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34186130:	4b3a      	ldr	r3, [pc, #232]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34186132:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34186136:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418613a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418613e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186142:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34186144:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186148:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3418614a:	3b01      	subs	r3, #1
3418614c:	041b      	lsls	r3, r3, #16
3418614e:	4313      	orrs	r3, r2
34186150:	4a32      	ldr	r2, [pc, #200]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34186152:	430b      	orrs	r3, r1
34186154:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34186158:	f7fd ff64 	bl	34184024 <LL_RCC_IC14_Enable>
3418615c:	e008      	b.n	34186170 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
3418615e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186162:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
34186166:	4b35      	ldr	r3, [pc, #212]	@ (3418623c <HAL_RCCEx_PeriphCLKConfig+0x2138>)
34186168:	429a      	cmp	r2, r3
3418616a:	d101      	bne.n	34186170 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    {
      LL_RCC_CLKP_Enable();
3418616c:	f7fd ffbc 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
34186170:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186174:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34186178:	4618      	mov	r0, r3
3418617a:	f7fd fc0e 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
3418617e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186182:	e9d3 2300 	ldrd	r2, r3, [r3]
34186186:	2100      	movs	r1, #0
34186188:	6439      	str	r1, [r7, #64]	@ 0x40
3418618a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3418618e:	647b      	str	r3, [r7, #68]	@ 0x44
34186190:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
34186194:	4603      	mov	r3, r0
34186196:	460a      	mov	r2, r1
34186198:	4313      	orrs	r3, r2
3418619a:	d065      	beq.n	34186268 <HAL_RCCEx_PeriphCLKConfig+0x2164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
3418619c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341861a0:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
341861a4:	4b26      	ldr	r3, [pc, #152]	@ (34186240 <HAL_RCCEx_PeriphCLKConfig+0x213c>)
341861a6:	429a      	cmp	r2, r3
341861a8:	d116      	bne.n	341861d8 <HAL_RCCEx_PeriphCLKConfig+0x20d4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341861aa:	4b1c      	ldr	r3, [pc, #112]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341861ac:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341861b0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341861b4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341861b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341861bc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341861be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341861c2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341861c4:	3b01      	subs	r3, #1
341861c6:	041b      	lsls	r3, r3, #16
341861c8:	4313      	orrs	r3, r2
341861ca:	4a14      	ldr	r2, [pc, #80]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341861cc:	430b      	orrs	r3, r1
341861ce:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341861d2:	f7fd feef 	bl	34183fb4 <LL_RCC_IC9_Enable>
341861d6:	e040      	b.n	3418625a <HAL_RCCEx_PeriphCLKConfig+0x2156>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
341861d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341861dc:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
341861e0:	4b18      	ldr	r3, [pc, #96]	@ (34186244 <HAL_RCCEx_PeriphCLKConfig+0x2140>)
341861e2:	429a      	cmp	r2, r3
341861e4:	d130      	bne.n	34186248 <HAL_RCCEx_PeriphCLKConfig+0x2144>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341861e6:	4b0d      	ldr	r3, [pc, #52]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341861e8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341861ec:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341861f0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341861f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341861f8:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341861fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341861fe:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34186200:	3b01      	subs	r3, #1
34186202:	041b      	lsls	r3, r3, #16
34186204:	4313      	orrs	r3, r2
34186206:	4a05      	ldr	r2, [pc, #20]	@ (3418621c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34186208:	430b      	orrs	r3, r1
3418620a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3418620e:	f7fd ff09 	bl	34184024 <LL_RCC_IC14_Enable>
34186212:	e022      	b.n	3418625a <HAL_RCCEx_PeriphCLKConfig+0x2156>
34186214:	07010830 	.word	0x07010830
34186218:	07020c30 	.word	0x07020c30
3418621c:	56028000 	.word	0x56028000
34186220:	07030c30 	.word	0x07030c30
34186224:	07010c30 	.word	0x07010c30
34186228:	07021030 	.word	0x07021030
3418622c:	07031030 	.word	0x07031030
34186230:	07011030 	.word	0x07011030
34186234:	07021430 	.word	0x07021430
34186238:	07031430 	.word	0x07031430
3418623c:	07011430 	.word	0x07011430
34186240:	07021830 	.word	0x07021830
34186244:	07031830 	.word	0x07031830
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
34186248:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418624c:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34186250:	4bc8      	ldr	r3, [pc, #800]	@ (34186574 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
34186252:	429a      	cmp	r2, r3
34186254:	d101      	bne.n	3418625a <HAL_RCCEx_PeriphCLKConfig+0x2156>
    {
      LL_RCC_CLKP_Enable();
34186256:	f7fd ff47 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
3418625a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418625e:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
34186262:	4618      	mov	r0, r3
34186264:	f7fd fb99 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
34186268:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418626c:	e9d3 2300 	ldrd	r2, r3, [r3]
34186270:	2100      	movs	r1, #0
34186272:	63b9      	str	r1, [r7, #56]	@ 0x38
34186274:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34186278:	63fb      	str	r3, [r7, #60]	@ 0x3c
3418627a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
3418627e:	4603      	mov	r3, r0
34186280:	460a      	mov	r2, r1
34186282:	4313      	orrs	r3, r2
34186284:	d04b      	beq.n	3418631e <HAL_RCCEx_PeriphCLKConfig+0x221a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
34186286:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418628a:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3418628e:	4bba      	ldr	r3, [pc, #744]	@ (34186578 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
34186290:	429a      	cmp	r2, r3
34186292:	d116      	bne.n	341862c2 <HAL_RCCEx_PeriphCLKConfig+0x21be>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34186294:	4bb9      	ldr	r3, [pc, #740]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34186296:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418629a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418629e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341862a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341862a6:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341862a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341862ac:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341862ae:	3b01      	subs	r3, #1
341862b0:	041b      	lsls	r3, r3, #16
341862b2:	4313      	orrs	r3, r2
341862b4:	4ab1      	ldr	r2, [pc, #708]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341862b6:	430b      	orrs	r3, r1
341862b8:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341862bc:	f7fd fe7a 	bl	34183fb4 <LL_RCC_IC9_Enable>
341862c0:	e026      	b.n	34186310 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
341862c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341862c6:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
341862ca:	4bad      	ldr	r3, [pc, #692]	@ (34186580 <HAL_RCCEx_PeriphCLKConfig+0x247c>)
341862cc:	429a      	cmp	r2, r3
341862ce:	d116      	bne.n	341862fe <HAL_RCCEx_PeriphCLKConfig+0x21fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341862d0:	4baa      	ldr	r3, [pc, #680]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341862d2:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341862d6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341862da:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341862de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341862e2:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341862e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341862e8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341862ea:	3b01      	subs	r3, #1
341862ec:	041b      	lsls	r3, r3, #16
341862ee:	4313      	orrs	r3, r2
341862f0:	4aa2      	ldr	r2, [pc, #648]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341862f2:	430b      	orrs	r3, r1
341862f4:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341862f8:	f7fd fe94 	bl	34184024 <LL_RCC_IC14_Enable>
341862fc:	e008      	b.n	34186310 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
341862fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186302:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34186306:	4b9f      	ldr	r3, [pc, #636]	@ (34186584 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34186308:	429a      	cmp	r2, r3
3418630a:	d101      	bne.n	34186310 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    {
      LL_RCC_CLKP_Enable();
3418630c:	f7fd feec 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
34186310:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186314:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
34186318:	4618      	mov	r0, r3
3418631a:	f7fd fb3e 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
3418631e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186322:	e9d3 2300 	ldrd	r2, r3, [r3]
34186326:	2100      	movs	r1, #0
34186328:	6339      	str	r1, [r7, #48]	@ 0x30
3418632a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3418632e:	637b      	str	r3, [r7, #52]	@ 0x34
34186330:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34186334:	4603      	mov	r3, r0
34186336:	460a      	mov	r2, r1
34186338:	4313      	orrs	r3, r2
3418633a:	d04b      	beq.n	341863d4 <HAL_RCCEx_PeriphCLKConfig+0x22d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
3418633c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186340:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34186344:	4a90      	ldr	r2, [pc, #576]	@ (34186588 <HAL_RCCEx_PeriphCLKConfig+0x2484>)
34186346:	4293      	cmp	r3, r2
34186348:	d116      	bne.n	34186378 <HAL_RCCEx_PeriphCLKConfig+0x2274>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418634a:	4b8c      	ldr	r3, [pc, #560]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3418634c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34186350:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186354:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186358:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418635c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418635e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186362:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34186364:	3b01      	subs	r3, #1
34186366:	041b      	lsls	r3, r3, #16
34186368:	4313      	orrs	r3, r2
3418636a:	4a84      	ldr	r2, [pc, #528]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3418636c:	430b      	orrs	r3, r1
3418636e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34186372:	f7fd fe1f 	bl	34183fb4 <LL_RCC_IC9_Enable>
34186376:	e026      	b.n	341863c6 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
34186378:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418637c:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34186380:	4a82      	ldr	r2, [pc, #520]	@ (3418658c <HAL_RCCEx_PeriphCLKConfig+0x2488>)
34186382:	4293      	cmp	r3, r2
34186384:	d116      	bne.n	341863b4 <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34186386:	4b7d      	ldr	r3, [pc, #500]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34186388:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418638c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186390:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186394:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186398:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418639a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418639e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341863a0:	3b01      	subs	r3, #1
341863a2:	041b      	lsls	r3, r3, #16
341863a4:	4313      	orrs	r3, r2
341863a6:	4a75      	ldr	r2, [pc, #468]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341863a8:	430b      	orrs	r3, r1
341863aa:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341863ae:	f7fd fe39 	bl	34184024 <LL_RCC_IC14_Enable>
341863b2:	e008      	b.n	341863c6 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
341863b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341863b8:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
341863bc:	4a74      	ldr	r2, [pc, #464]	@ (34186590 <HAL_RCCEx_PeriphCLKConfig+0x248c>)
341863be:	4293      	cmp	r3, r2
341863c0:	d101      	bne.n	341863c6 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    {
      LL_RCC_CLKP_Enable();
341863c2:	f7fd fe91 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
341863c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341863ca:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
341863ce:	4618      	mov	r0, r3
341863d0:	f7fd fae3 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
341863d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341863d8:	e9d3 2300 	ldrd	r2, r3, [r3]
341863dc:	2100      	movs	r1, #0
341863de:	62b9      	str	r1, [r7, #40]	@ 0x28
341863e0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
341863e4:	62fb      	str	r3, [r7, #44]	@ 0x2c
341863e6:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
341863ea:	4603      	mov	r3, r0
341863ec:	460a      	mov	r2, r1
341863ee:	4313      	orrs	r3, r2
341863f0:	d04b      	beq.n	3418648a <HAL_RCCEx_PeriphCLKConfig+0x2386>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
341863f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341863f6:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
341863fa:	4a66      	ldr	r2, [pc, #408]	@ (34186594 <HAL_RCCEx_PeriphCLKConfig+0x2490>)
341863fc:	4293      	cmp	r3, r2
341863fe:	d116      	bne.n	3418642e <HAL_RCCEx_PeriphCLKConfig+0x232a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34186400:	4b5e      	ldr	r3, [pc, #376]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34186402:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34186406:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418640a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418640e:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34186412:	6c91      	ldr	r1, [r2, #72]	@ 0x48
34186414:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34186418:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
3418641a:	3a01      	subs	r2, #1
3418641c:	0412      	lsls	r2, r2, #16
3418641e:	430a      	orrs	r2, r1
34186420:	4956      	ldr	r1, [pc, #344]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34186422:	4313      	orrs	r3, r2
34186424:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34186428:	f7fd fdc4 	bl	34183fb4 <LL_RCC_IC9_Enable>
3418642c:	e026      	b.n	3418647c <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
3418642e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186432:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34186436:	4a58      	ldr	r2, [pc, #352]	@ (34186598 <HAL_RCCEx_PeriphCLKConfig+0x2494>)
34186438:	4293      	cmp	r3, r2
3418643a:	d116      	bne.n	3418646a <HAL_RCCEx_PeriphCLKConfig+0x2366>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418643c:	4b4f      	ldr	r3, [pc, #316]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3418643e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34186442:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34186446:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418644a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3418644e:	6f11      	ldr	r1, [r2, #112]	@ 0x70
34186450:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34186454:	6f52      	ldr	r2, [r2, #116]	@ 0x74
34186456:	3a01      	subs	r2, #1
34186458:	0412      	lsls	r2, r2, #16
3418645a:	430a      	orrs	r2, r1
3418645c:	4947      	ldr	r1, [pc, #284]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3418645e:	4313      	orrs	r3, r2
34186460:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34186464:	f7fd fdde 	bl	34184024 <LL_RCC_IC14_Enable>
34186468:	e008      	b.n	3418647c <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
3418646a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418646e:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34186472:	4a4a      	ldr	r2, [pc, #296]	@ (3418659c <HAL_RCCEx_PeriphCLKConfig+0x2498>)
34186474:	4293      	cmp	r3, r2
34186476:	d101      	bne.n	3418647c <HAL_RCCEx_PeriphCLKConfig+0x2378>
    {
      LL_RCC_CLKP_Enable();
34186478:	f7fd fe36 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
3418647c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186480:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34186484:	4618      	mov	r0, r3
34186486:	f7fd fa88 	bl	3418399a <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
3418648a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418648e:	e9d3 2300 	ldrd	r2, r3, [r3]
34186492:	2100      	movs	r1, #0
34186494:	6239      	str	r1, [r7, #32]
34186496:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3418649a:	627b      	str	r3, [r7, #36]	@ 0x24
3418649c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
341864a0:	4603      	mov	r3, r0
341864a2:	460a      	mov	r2, r1
341864a4:	4313      	orrs	r3, r2
341864a6:	d014      	beq.n	341864d2 <HAL_RCCEx_PeriphCLKConfig+0x23ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
341864a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341864ac:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
341864b0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
341864b4:	4618      	mov	r0, r3
341864b6:	f7fd fa18 	bl	341838ea <LL_RCC_SetOTGPHYCKREFClockSource>
341864ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341864be:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
341864c2:	0fdb      	lsrs	r3, r3, #31
341864c4:	2b01      	cmp	r3, #1
341864c6:	d102      	bne.n	341864ce <HAL_RCCEx_PeriphCLKConfig+0x23ca>
341864c8:	f7fd f83c 	bl	34183544 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
341864cc:	e001      	b.n	341864d2 <HAL_RCCEx_PeriphCLKConfig+0x23ce>
341864ce:	f7fd f829 	bl	34183524 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
341864d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341864d6:	e9d3 2300 	ldrd	r2, r3, [r3]
341864da:	2100      	movs	r1, #0
341864dc:	61b9      	str	r1, [r7, #24]
341864de:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
341864e2:	61fb      	str	r3, [r7, #28]
341864e4:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
341864e8:	4603      	mov	r3, r0
341864ea:	460a      	mov	r2, r1
341864ec:	4313      	orrs	r3, r2
341864ee:	d014      	beq.n	3418651a <HAL_RCCEx_PeriphCLKConfig+0x2416>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
341864f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341864f4:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
341864f8:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
341864fc:	4618      	mov	r0, r3
341864fe:	f7fd f9f4 	bl	341838ea <LL_RCC_SetOTGPHYCKREFClockSource>
34186502:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186506:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
3418650a:	0fdb      	lsrs	r3, r3, #31
3418650c:	2b01      	cmp	r3, #1
3418650e:	d102      	bne.n	34186516 <HAL_RCCEx_PeriphCLKConfig+0x2412>
34186510:	f7fd f818 	bl	34183544 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34186514:	e001      	b.n	3418651a <HAL_RCCEx_PeriphCLKConfig+0x2416>
34186516:	f7fd f805 	bl	34183524 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
3418651a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418651e:	e9d3 2300 	ldrd	r2, r3, [r3]
34186522:	2100      	movs	r1, #0
34186524:	6139      	str	r1, [r7, #16]
34186526:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3418652a:	617b      	str	r3, [r7, #20]
3418652c:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
34186530:	4603      	mov	r3, r0
34186532:	460a      	mov	r2, r1
34186534:	4313      	orrs	r3, r2
34186536:	d053      	beq.n	341865e0 <HAL_RCCEx_PeriphCLKConfig+0x24dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));

    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
34186538:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418653c:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34186540:	4a17      	ldr	r2, [pc, #92]	@ (341865a0 <HAL_RCCEx_PeriphCLKConfig+0x249c>)
34186542:	4293      	cmp	r3, r2
34186544:	d12e      	bne.n	341865a4 <HAL_RCCEx_PeriphCLKConfig+0x24a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34186546:	4b0d      	ldr	r3, [pc, #52]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34186548:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418654c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34186550:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34186554:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34186558:	6f91      	ldr	r1, [r2, #120]	@ 0x78
3418655a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3418655e:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34186560:	3a01      	subs	r2, #1
34186562:	0412      	lsls	r2, r2, #16
34186564:	430a      	orrs	r2, r1
34186566:	4905      	ldr	r1, [pc, #20]	@ (3418657c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34186568:	4313      	orrs	r3, r2
3418656a:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418656e:	f7fd fd67 	bl	34184040 <LL_RCC_IC15_Enable>
34186572:	e020      	b.n	341865b6 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
34186574:	07011830 	.word	0x07011830
34186578:	07021c30 	.word	0x07021c30
3418657c:	56028000 	.word	0x56028000
34186580:	07031c30 	.word	0x07031c30
34186584:	07011c30 	.word	0x07011c30
34186588:	07020034 	.word	0x07020034
3418658c:	07030034 	.word	0x07030034
34186590:	07010034 	.word	0x07010034
34186594:	07020434 	.word	0x07020434
34186598:	07030434 	.word	0x07030434
3418659c:	07010434 	.word	0x07010434
341865a0:	03020c14 	.word	0x03020c14
    }
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
341865a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341865a8:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
341865ac:	4a43      	ldr	r2, [pc, #268]	@ (341866bc <HAL_RCCEx_PeriphCLKConfig+0x25b8>)
341865ae:	4293      	cmp	r3, r2
341865b0:	d101      	bne.n	341865b6 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
    {
      LL_RCC_CLKP_Enable();
341865b2:	f7fd fd99 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
341865b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341865ba:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
341865be:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
341865c2:	4618      	mov	r0, r3
341865c4:	f7fd f986 	bl	341838d4 <LL_RCC_SetOTGPHYClockSource>
341865c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341865cc:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
341865d0:	0fdb      	lsrs	r3, r3, #31
341865d2:	2b01      	cmp	r3, #1
341865d4:	d102      	bne.n	341865dc <HAL_RCCEx_PeriphCLKConfig+0x24d8>
341865d6:	f7fc ffb5 	bl	34183544 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
341865da:	e001      	b.n	341865e0 <HAL_RCCEx_PeriphCLKConfig+0x24dc>
341865dc:	f7fc ffa2 	bl	34183524 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
341865e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341865e4:	e9d3 2300 	ldrd	r2, r3, [r3]
341865e8:	2100      	movs	r1, #0
341865ea:	60b9      	str	r1, [r7, #8]
341865ec:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
341865f0:	60fb      	str	r3, [r7, #12]
341865f2:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
341865f6:	4603      	mov	r3, r0
341865f8:	460a      	mov	r2, r1
341865fa:	4313      	orrs	r3, r2
341865fc:	d03b      	beq.n	34186676 <HAL_RCCEx_PeriphCLKConfig+0x2572>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));

    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
341865fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186602:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34186606:	4a2e      	ldr	r2, [pc, #184]	@ (341866c0 <HAL_RCCEx_PeriphCLKConfig+0x25bc>)
34186608:	4293      	cmp	r3, r2
3418660a:	d116      	bne.n	3418663a <HAL_RCCEx_PeriphCLKConfig+0x2536>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418660c:	4b2d      	ldr	r3, [pc, #180]	@ (341866c4 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
3418660e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34186612:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34186616:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418661a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3418661e:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34186620:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34186624:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34186626:	3a01      	subs	r2, #1
34186628:	0412      	lsls	r2, r2, #16
3418662a:	430a      	orrs	r2, r1
3418662c:	4925      	ldr	r1, [pc, #148]	@ (341866c4 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
3418662e:	4313      	orrs	r3, r2
34186630:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34186634:	f7fd fd04 	bl	34184040 <LL_RCC_IC15_Enable>
34186638:	e008      	b.n	3418664c <HAL_RCCEx_PeriphCLKConfig+0x2548>
    }
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
3418663a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418663e:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34186642:	4a21      	ldr	r2, [pc, #132]	@ (341866c8 <HAL_RCCEx_PeriphCLKConfig+0x25c4>)
34186644:	4293      	cmp	r3, r2
34186646:	d101      	bne.n	3418664c <HAL_RCCEx_PeriphCLKConfig+0x2548>
    {
      LL_RCC_CLKP_Enable();
34186648:	f7fd fd4e 	bl	341840e8 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3418664c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186650:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34186654:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34186658:	4618      	mov	r0, r3
3418665a:	f7fd f93b 	bl	341838d4 <LL_RCC_SetOTGPHYClockSource>
3418665e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186662:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34186666:	0fdb      	lsrs	r3, r3, #31
34186668:	2b01      	cmp	r3, #1
3418666a:	d102      	bne.n	34186672 <HAL_RCCEx_PeriphCLKConfig+0x256e>
3418666c:	f7fc ff6a 	bl	34183544 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34186670:	e001      	b.n	34186676 <HAL_RCCEx_PeriphCLKConfig+0x2572>
34186672:	f7fc ff57 	bl	34183524 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
34186676:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418667a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418667e:	2100      	movs	r1, #0
34186680:	6039      	str	r1, [r7, #0]
34186682:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34186686:	607b      	str	r3, [r7, #4]
34186688:	e9d7 0100 	ldrd	r0, r1, [r7]
3418668c:	4603      	mov	r3, r0
3418668e:	460a      	mov	r2, r1
34186690:	4313      	orrs	r3, r2
34186692:	d006      	beq.n	341866a2 <HAL_RCCEx_PeriphCLKConfig+0x259e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
34186694:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186698:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
3418669c:	4618      	mov	r0, r3
3418669e:	f7fd f9cd 	bl	34183a3c <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
341866a2:	f897 31c6 	ldrb.w	r3, [r7, #454]	@ 0x1c6
341866a6:	2b00      	cmp	r3, #0
341866a8:	d101      	bne.n	341866ae <HAL_RCCEx_PeriphCLKConfig+0x25aa>
  {
    return HAL_OK;
341866aa:	2300      	movs	r3, #0
341866ac:	e000      	b.n	341866b0 <HAL_RCCEx_PeriphCLKConfig+0x25ac>
  }
  return HAL_ERROR;
341866ae:	2301      	movs	r3, #1
}
341866b0:	4618      	mov	r0, r3
341866b2:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
341866b6:	46bd      	mov	sp, r7
341866b8:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
341866bc:	03010c14 	.word	0x03010c14
341866c0:	03021414 	.word	0x03021414
341866c4:	56028000 	.word	0x56028000
341866c8:	03011414 	.word	0x03011414

341866cc <HAL_RCCEx_GetPLL1CLKFreq>:
  * @brief  Return PLL1 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL1 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL1CLKFreq(void)
{
341866cc:	b5f0      	push	{r4, r5, r6, r7, lr}
341866ce:	b087      	sub	sp, #28
341866d0:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
341866d2:	2300      	movs	r3, #0
341866d4:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL1_IsReady() != 0U)
341866d6:	f7fd f9d5 	bl	34183a84 <LL_RCC_PLL1_IsReady>
341866da:	4603      	mov	r3, r0
341866dc:	2b00      	cmp	r3, #0
341866de:	d02a      	beq.n	34186736 <HAL_RCCEx_GetPLL1CLKFreq+0x6a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
341866e0:	f7fd fa38 	bl	34183b54 <LL_RCC_PLL1P_IsEnabled>
341866e4:	4603      	mov	r3, r0
341866e6:	2b00      	cmp	r3, #0
341866e8:	d031      	beq.n	3418674e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
341866ea:	f7fd f9bd 	bl	34183a68 <LL_RCC_PLL1_GetSource>
341866ee:	4603      	mov	r3, r0
341866f0:	4618      	mov	r0, r3
341866f2:	f000 f903 	bl	341868fc <RCCEx_GetPLLSourceFreq>
341866f6:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
341866f8:	68bb      	ldr	r3, [r7, #8]
341866fa:	2b00      	cmp	r3, #0
341866fc:	d027      	beq.n	3418674e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
      {
        divm = LL_RCC_PLL1_GetM();
341866fe:	f7fd f9f9 	bl	34183af4 <LL_RCC_PLL1_GetM>
34186702:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34186704:	687b      	ldr	r3, [r7, #4]
34186706:	2b00      	cmp	r3, #0
34186708:	d021      	beq.n	3418674e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
3418670a:	f7fd f9e3 	bl	34183ad4 <LL_RCC_PLL1_GetN>
3418670e:	4605      	mov	r5, r0
34186710:	f7fd fa34 	bl	34183b7c <LL_RCC_PLL1_GetFRACN>
34186714:	4606      	mov	r6, r0
34186716:	f7fd f9fd 	bl	34183b14 <LL_RCC_PLL1_GetP1>
3418671a:	4604      	mov	r4, r0
3418671c:	f7fd fa0a 	bl	34183b34 <LL_RCC_PLL1_GetP2>
34186720:	4603      	mov	r3, r0
34186722:	9301      	str	r3, [sp, #4]
34186724:	9400      	str	r4, [sp, #0]
34186726:	4633      	mov	r3, r6
34186728:	462a      	mov	r2, r5
3418672a:	6879      	ldr	r1, [r7, #4]
3418672c:	68b8      	ldr	r0, [r7, #8]
3418672e:	f000 f943 	bl	341869b8 <RCCEx_CalcPLLFreq>
34186732:	60f8      	str	r0, [r7, #12]
34186734:	e00b      	b.n	3418674e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
                                            LL_RCC_PLL1_GetP1(), LL_RCC_PLL1_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL1_IsEnabledBypass() != 0U)
34186736:	f7fd f9b9 	bl	34183aac <LL_RCC_PLL1_IsEnabledBypass>
3418673a:	4603      	mov	r3, r0
3418673c:	2b00      	cmp	r3, #0
3418673e:	d006      	beq.n	3418674e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34186740:	f7fd f992 	bl	34183a68 <LL_RCC_PLL1_GetSource>
34186744:	4603      	mov	r3, r0
34186746:	4618      	mov	r0, r3
34186748:	f000 f8d8 	bl	341868fc <RCCEx_GetPLLSourceFreq>
3418674c:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
3418674e:	68fb      	ldr	r3, [r7, #12]
}
34186750:	4618      	mov	r0, r3
34186752:	3714      	adds	r7, #20
34186754:	46bd      	mov	sp, r7
34186756:	bdf0      	pop	{r4, r5, r6, r7, pc}

34186758 <HAL_RCCEx_GetPLL2CLKFreq>:
  * @brief  Return PLL2 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL2 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL2CLKFreq(void)
{
34186758:	b5f0      	push	{r4, r5, r6, r7, lr}
3418675a:	b087      	sub	sp, #28
3418675c:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3418675e:	2300      	movs	r3, #0
34186760:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL2_IsReady() != 0U)
34186762:	f7fd fa27 	bl	34183bb4 <LL_RCC_PLL2_IsReady>
34186766:	4603      	mov	r3, r0
34186768:	2b00      	cmp	r3, #0
3418676a:	d02a      	beq.n	341867c2 <HAL_RCCEx_GetPLL2CLKFreq+0x6a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
3418676c:	f7fd fa8a 	bl	34183c84 <LL_RCC_PLL2P_IsEnabled>
34186770:	4603      	mov	r3, r0
34186772:	2b00      	cmp	r3, #0
34186774:	d031      	beq.n	341867da <HAL_RCCEx_GetPLL2CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34186776:	f7fd fa0f 	bl	34183b98 <LL_RCC_PLL2_GetSource>
3418677a:	4603      	mov	r3, r0
3418677c:	4618      	mov	r0, r3
3418677e:	f000 f8bd 	bl	341868fc <RCCEx_GetPLLSourceFreq>
34186782:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34186784:	68bb      	ldr	r3, [r7, #8]
34186786:	2b00      	cmp	r3, #0
34186788:	d027      	beq.n	341867da <HAL_RCCEx_GetPLL2CLKFreq+0x82>
      {

        divm = LL_RCC_PLL2_GetM();
3418678a:	f7fd fa4b 	bl	34183c24 <LL_RCC_PLL2_GetM>
3418678e:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34186790:	687b      	ldr	r3, [r7, #4]
34186792:	2b00      	cmp	r3, #0
34186794:	d021      	beq.n	341867da <HAL_RCCEx_GetPLL2CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
34186796:	f7fd fa35 	bl	34183c04 <LL_RCC_PLL2_GetN>
3418679a:	4605      	mov	r5, r0
3418679c:	f7fd fa86 	bl	34183cac <LL_RCC_PLL2_GetFRACN>
341867a0:	4606      	mov	r6, r0
341867a2:	f7fd fa4f 	bl	34183c44 <LL_RCC_PLL2_GetP1>
341867a6:	4604      	mov	r4, r0
341867a8:	f7fd fa5c 	bl	34183c64 <LL_RCC_PLL2_GetP2>
341867ac:	4603      	mov	r3, r0
341867ae:	9301      	str	r3, [sp, #4]
341867b0:	9400      	str	r4, [sp, #0]
341867b2:	4633      	mov	r3, r6
341867b4:	462a      	mov	r2, r5
341867b6:	6879      	ldr	r1, [r7, #4]
341867b8:	68b8      	ldr	r0, [r7, #8]
341867ba:	f000 f8fd 	bl	341869b8 <RCCEx_CalcPLLFreq>
341867be:	60f8      	str	r0, [r7, #12]
341867c0:	e00b      	b.n	341867da <HAL_RCCEx_GetPLL2CLKFreq+0x82>
                                            LL_RCC_PLL2_GetP1(), LL_RCC_PLL2_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL2_IsEnabledBypass() != 0U)
341867c2:	f7fd fa0b 	bl	34183bdc <LL_RCC_PLL2_IsEnabledBypass>
341867c6:	4603      	mov	r3, r0
341867c8:	2b00      	cmp	r3, #0
341867ca:	d006      	beq.n	341867da <HAL_RCCEx_GetPLL2CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
341867cc:	f7fd f9e4 	bl	34183b98 <LL_RCC_PLL2_GetSource>
341867d0:	4603      	mov	r3, r0
341867d2:	4618      	mov	r0, r3
341867d4:	f000 f892 	bl	341868fc <RCCEx_GetPLLSourceFreq>
341867d8:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
341867da:	68fb      	ldr	r3, [r7, #12]
}
341867dc:	4618      	mov	r0, r3
341867de:	3714      	adds	r7, #20
341867e0:	46bd      	mov	sp, r7
341867e2:	bdf0      	pop	{r4, r5, r6, r7, pc}

341867e4 <HAL_RCCEx_GetPLL3CLKFreq>:
  * @brief  Return PLL3 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL3 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL3CLKFreq(void)
{
341867e4:	b5f0      	push	{r4, r5, r6, r7, lr}
341867e6:	b087      	sub	sp, #28
341867e8:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
341867ea:	2300      	movs	r3, #0
341867ec:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL3_IsReady() != 0U)
341867ee:	f7fd fa79 	bl	34183ce4 <LL_RCC_PLL3_IsReady>
341867f2:	4603      	mov	r3, r0
341867f4:	2b00      	cmp	r3, #0
341867f6:	d02a      	beq.n	3418684e <HAL_RCCEx_GetPLL3CLKFreq+0x6a>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
341867f8:	f7fd fadc 	bl	34183db4 <LL_RCC_PLL3P_IsEnabled>
341867fc:	4603      	mov	r3, r0
341867fe:	2b00      	cmp	r3, #0
34186800:	d031      	beq.n	34186866 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34186802:	f7fd fa61 	bl	34183cc8 <LL_RCC_PLL3_GetSource>
34186806:	4603      	mov	r3, r0
34186808:	4618      	mov	r0, r3
3418680a:	f000 f877 	bl	341868fc <RCCEx_GetPLLSourceFreq>
3418680e:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34186810:	68bb      	ldr	r3, [r7, #8]
34186812:	2b00      	cmp	r3, #0
34186814:	d027      	beq.n	34186866 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
      {
        divm = LL_RCC_PLL3_GetM();
34186816:	f7fd fa9d 	bl	34183d54 <LL_RCC_PLL3_GetM>
3418681a:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
3418681c:	687b      	ldr	r3, [r7, #4]
3418681e:	2b00      	cmp	r3, #0
34186820:	d021      	beq.n	34186866 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
34186822:	f7fd fa87 	bl	34183d34 <LL_RCC_PLL3_GetN>
34186826:	4605      	mov	r5, r0
34186828:	f7fd fad8 	bl	34183ddc <LL_RCC_PLL3_GetFRACN>
3418682c:	4606      	mov	r6, r0
3418682e:	f7fd faa1 	bl	34183d74 <LL_RCC_PLL3_GetP1>
34186832:	4604      	mov	r4, r0
34186834:	f7fd faae 	bl	34183d94 <LL_RCC_PLL3_GetP2>
34186838:	4603      	mov	r3, r0
3418683a:	9301      	str	r3, [sp, #4]
3418683c:	9400      	str	r4, [sp, #0]
3418683e:	4633      	mov	r3, r6
34186840:	462a      	mov	r2, r5
34186842:	6879      	ldr	r1, [r7, #4]
34186844:	68b8      	ldr	r0, [r7, #8]
34186846:	f000 f8b7 	bl	341869b8 <RCCEx_CalcPLLFreq>
3418684a:	60f8      	str	r0, [r7, #12]
3418684c:	e00b      	b.n	34186866 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
                                            LL_RCC_PLL3_GetP1(), LL_RCC_PLL3_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL3_IsEnabledBypass() != 0U)
3418684e:	f7fd fa5d 	bl	34183d0c <LL_RCC_PLL3_IsEnabledBypass>
34186852:	4603      	mov	r3, r0
34186854:	2b00      	cmp	r3, #0
34186856:	d006      	beq.n	34186866 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34186858:	f7fd fa36 	bl	34183cc8 <LL_RCC_PLL3_GetSource>
3418685c:	4603      	mov	r3, r0
3418685e:	4618      	mov	r0, r3
34186860:	f000 f84c 	bl	341868fc <RCCEx_GetPLLSourceFreq>
34186864:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34186866:	68fb      	ldr	r3, [r7, #12]
}
34186868:	4618      	mov	r0, r3
3418686a:	3714      	adds	r7, #20
3418686c:	46bd      	mov	sp, r7
3418686e:	bdf0      	pop	{r4, r5, r6, r7, pc}

34186870 <HAL_RCCEx_GetPLL4CLKFreq>:
  * @brief  Return PLL4 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL4 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL4CLKFreq(void)
{
34186870:	b5f0      	push	{r4, r5, r6, r7, lr}
34186872:	b087      	sub	sp, #28
34186874:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34186876:	2300      	movs	r3, #0
34186878:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL4_IsReady() != 0U)
3418687a:	f7fd facb 	bl	34183e14 <LL_RCC_PLL4_IsReady>
3418687e:	4603      	mov	r3, r0
34186880:	2b00      	cmp	r3, #0
34186882:	d02a      	beq.n	341868da <HAL_RCCEx_GetPLL4CLKFreq+0x6a>
  {
    if (LL_RCC_PLL4P_IsEnabled() != 0U)
34186884:	f7fd fb2e 	bl	34183ee4 <LL_RCC_PLL4P_IsEnabled>
34186888:	4603      	mov	r3, r0
3418688a:	2b00      	cmp	r3, #0
3418688c:	d031      	beq.n	341868f2 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3418688e:	f7fd fab3 	bl	34183df8 <LL_RCC_PLL4_GetSource>
34186892:	4603      	mov	r3, r0
34186894:	4618      	mov	r0, r3
34186896:	f000 f831 	bl	341868fc <RCCEx_GetPLLSourceFreq>
3418689a:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3418689c:	68bb      	ldr	r3, [r7, #8]
3418689e:	2b00      	cmp	r3, #0
341868a0:	d027      	beq.n	341868f2 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
      {

        divm = LL_RCC_PLL4_GetM();
341868a2:	f7fd faef 	bl	34183e84 <LL_RCC_PLL4_GetM>
341868a6:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
341868a8:	687b      	ldr	r3, [r7, #4]
341868aa:	2b00      	cmp	r3, #0
341868ac:	d021      	beq.n	341868f2 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
341868ae:	f7fd fad9 	bl	34183e64 <LL_RCC_PLL4_GetN>
341868b2:	4605      	mov	r5, r0
341868b4:	f7fd fb2a 	bl	34183f0c <LL_RCC_PLL4_GetFRACN>
341868b8:	4606      	mov	r6, r0
341868ba:	f7fd faf3 	bl	34183ea4 <LL_RCC_PLL4_GetP1>
341868be:	4604      	mov	r4, r0
341868c0:	f7fd fb00 	bl	34183ec4 <LL_RCC_PLL4_GetP2>
341868c4:	4603      	mov	r3, r0
341868c6:	9301      	str	r3, [sp, #4]
341868c8:	9400      	str	r4, [sp, #0]
341868ca:	4633      	mov	r3, r6
341868cc:	462a      	mov	r2, r5
341868ce:	6879      	ldr	r1, [r7, #4]
341868d0:	68b8      	ldr	r0, [r7, #8]
341868d2:	f000 f871 	bl	341869b8 <RCCEx_CalcPLLFreq>
341868d6:	60f8      	str	r0, [r7, #12]
341868d8:	e00b      	b.n	341868f2 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
                                            LL_RCC_PLL4_GetP1(), LL_RCC_PLL4_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL4_IsEnabledBypass() != 0U)
341868da:	f7fd faaf 	bl	34183e3c <LL_RCC_PLL4_IsEnabledBypass>
341868de:	4603      	mov	r3, r0
341868e0:	2b00      	cmp	r3, #0
341868e2:	d006      	beq.n	341868f2 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
341868e4:	f7fd fa88 	bl	34183df8 <LL_RCC_PLL4_GetSource>
341868e8:	4603      	mov	r3, r0
341868ea:	4618      	mov	r0, r3
341868ec:	f000 f806 	bl	341868fc <RCCEx_GetPLLSourceFreq>
341868f0:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
341868f2:	68fb      	ldr	r3, [r7, #12]
}
341868f4:	4618      	mov	r0, r3
341868f6:	3714      	adds	r7, #20
341868f8:	46bd      	mov	sp, r7
341868fa:	bdf0      	pop	{r4, r5, r6, r7, pc}

341868fc <RCCEx_GetPLLSourceFreq>:
  * @brief  Return PLL source clock frequency
  * @param  PLLsource PLL source clock
  * @retval PLL source clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
341868fc:	b580      	push	{r7, lr}
341868fe:	b084      	sub	sp, #16
34186900:	af00      	add	r7, sp, #0
34186902:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
34186904:	2300      	movs	r3, #0
34186906:	60fb      	str	r3, [r7, #12]

  switch (PLLsource)
34186908:	687b      	ldr	r3, [r7, #4]
3418690a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418690e:	d039      	beq.n	34186984 <RCCEx_GetPLLSourceFreq+0x88>
34186910:	687b      	ldr	r3, [r7, #4]
34186912:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34186916:	d838      	bhi.n	3418698a <RCCEx_GetPLLSourceFreq+0x8e>
34186918:	687b      	ldr	r3, [r7, #4]
3418691a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418691e:	d029      	beq.n	34186974 <RCCEx_GetPLLSourceFreq+0x78>
34186920:	687b      	ldr	r3, [r7, #4]
34186922:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34186926:	d830      	bhi.n	3418698a <RCCEx_GetPLLSourceFreq+0x8e>
34186928:	687b      	ldr	r3, [r7, #4]
3418692a:	2b00      	cmp	r3, #0
3418692c:	d004      	beq.n	34186938 <RCCEx_GetPLLSourceFreq+0x3c>
3418692e:	687b      	ldr	r3, [r7, #4]
34186930:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34186934:	d00e      	beq.n	34186954 <RCCEx_GetPLLSourceFreq+0x58>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
      break;

    default:
      /* unexpected case */
      break;
34186936:	e028      	b.n	3418698a <RCCEx_GetPLLSourceFreq+0x8e>
      if (LL_RCC_HSI_IsReady() != 0U)
34186938:	f7fc fe26 	bl	34183588 <LL_RCC_HSI_IsReady>
3418693c:	4603      	mov	r3, r0
3418693e:	2b00      	cmp	r3, #0
34186940:	d025      	beq.n	3418698e <RCCEx_GetPLLSourceFreq+0x92>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34186942:	f7fc fe33 	bl	341835ac <LL_RCC_HSI_GetDivider>
34186946:	4603      	mov	r3, r0
34186948:	09db      	lsrs	r3, r3, #7
3418694a:	4a16      	ldr	r2, [pc, #88]	@ (341869a4 <RCCEx_GetPLLSourceFreq+0xa8>)
3418694c:	fa22 f303 	lsr.w	r3, r2, r3
34186950:	60fb      	str	r3, [r7, #12]
      break;
34186952:	e01c      	b.n	3418698e <RCCEx_GetPLLSourceFreq+0x92>
      if (LL_RCC_MSI_IsReady() != 0U)
34186954:	f7fc fe38 	bl	341835c8 <LL_RCC_MSI_IsReady>
34186958:	4603      	mov	r3, r0
3418695a:	2b00      	cmp	r3, #0
3418695c:	d019      	beq.n	34186992 <RCCEx_GetPLLSourceFreq+0x96>
        if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3418695e:	f7fc fe45 	bl	341835ec <LL_RCC_MSI_GetFrequency>
34186962:	4603      	mov	r3, r0
34186964:	2b00      	cmp	r3, #0
34186966:	d102      	bne.n	3418696e <RCCEx_GetPLLSourceFreq+0x72>
          pllinputfreq = MSI_VALUE;
34186968:	4b0f      	ldr	r3, [pc, #60]	@ (341869a8 <RCCEx_GetPLLSourceFreq+0xac>)
3418696a:	60fb      	str	r3, [r7, #12]
      break;
3418696c:	e011      	b.n	34186992 <RCCEx_GetPLLSourceFreq+0x96>
          pllinputfreq = 16000000UL;
3418696e:	4b0f      	ldr	r3, [pc, #60]	@ (341869ac <RCCEx_GetPLLSourceFreq+0xb0>)
34186970:	60fb      	str	r3, [r7, #12]
      break;
34186972:	e00e      	b.n	34186992 <RCCEx_GetPLLSourceFreq+0x96>
      if (LL_RCC_HSE_IsReady() != 0U)
34186974:	f7fc fdf6 	bl	34183564 <LL_RCC_HSE_IsReady>
34186978:	4603      	mov	r3, r0
3418697a:	2b00      	cmp	r3, #0
3418697c:	d00b      	beq.n	34186996 <RCCEx_GetPLLSourceFreq+0x9a>
        pllinputfreq = HSE_VALUE;
3418697e:	4b0c      	ldr	r3, [pc, #48]	@ (341869b0 <RCCEx_GetPLLSourceFreq+0xb4>)
34186980:	60fb      	str	r3, [r7, #12]
      break;
34186982:	e008      	b.n	34186996 <RCCEx_GetPLLSourceFreq+0x9a>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
34186984:	4b0b      	ldr	r3, [pc, #44]	@ (341869b4 <RCCEx_GetPLLSourceFreq+0xb8>)
34186986:	60fb      	str	r3, [r7, #12]
      break;
34186988:	e006      	b.n	34186998 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3418698a:	bf00      	nop
3418698c:	e004      	b.n	34186998 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3418698e:	bf00      	nop
34186990:	e002      	b.n	34186998 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34186992:	bf00      	nop
34186994:	e000      	b.n	34186998 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34186996:	bf00      	nop
  }

  return pllinputfreq;
34186998:	68fb      	ldr	r3, [r7, #12]
}
3418699a:	4618      	mov	r0, r3
3418699c:	3710      	adds	r7, #16
3418699e:	46bd      	mov	sp, r7
341869a0:	bd80      	pop	{r7, pc}
341869a2:	bf00      	nop
341869a4:	03d09000 	.word	0x03d09000
341869a8:	003d0900 	.word	0x003d0900
341869ac:	00f42400 	.word	0x00f42400
341869b0:	02dc6c00 	.word	0x02dc6c00
341869b4:	00bb8000 	.word	0x00bb8000

341869b8 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
341869b8:	b480      	push	{r7}
341869ba:	b087      	sub	sp, #28
341869bc:	af00      	add	r7, sp, #0
341869be:	60f8      	str	r0, [r7, #12]
341869c0:	60b9      	str	r1, [r7, #8]
341869c2:	607a      	str	r2, [r7, #4]
341869c4:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
341869c6:	68fb      	ldr	r3, [r7, #12]
341869c8:	ee07 3a90 	vmov	s15, r3
341869cc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341869d0:	687b      	ldr	r3, [r7, #4]
341869d2:	ee07 3a90 	vmov	s15, r3
341869d6:	eef8 6a67 	vcvt.f32.u32	s13, s15
341869da:	683b      	ldr	r3, [r7, #0]
341869dc:	ee07 3a90 	vmov	s15, r3
341869e0:	eeb8 6a67 	vcvt.f32.u32	s12, s15
341869e4:	eddf 5a19 	vldr	s11, [pc, #100]	@ 34186a4c <RCCEx_CalcPLLFreq+0x94>
341869e8:	eec6 7a25 	vdiv.f32	s15, s12, s11
341869ec:	ee76 7aa7 	vadd.f32	s15, s13, s15
341869f0:	ee67 6a27 	vmul.f32	s13, s14, s15
341869f4:	68bb      	ldr	r3, [r7, #8]
341869f6:	ee07 3a90 	vmov	s15, r3
341869fa:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341869fe:	eec6 7a87 	vdiv.f32	s15, s13, s14
34186a02:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)P1;
34186a06:	6a3b      	ldr	r3, [r7, #32]
34186a08:	ee07 3a90 	vmov	s15, r3
34186a0c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34186a10:	edd7 6a05 	vldr	s13, [r7, #20]
34186a14:	eec6 7a87 	vdiv.f32	s15, s13, s14
34186a18:	edc7 7a05 	vstr	s15, [r7, #20]
  freq = freq / (float_t)P2;
34186a1c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34186a1e:	ee07 3a90 	vmov	s15, r3
34186a22:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34186a26:	edd7 6a05 	vldr	s13, [r7, #20]
34186a2a:	eec6 7a87 	vdiv.f32	s15, s13, s14
34186a2e:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
34186a32:	edd7 7a05 	vldr	s15, [r7, #20]
34186a36:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34186a3a:	ee17 3a90 	vmov	r3, s15
}
34186a3e:	4618      	mov	r0, r3
34186a40:	371c      	adds	r7, #28
34186a42:	46bd      	mov	sp, r7
34186a44:	f85d 7b04 	ldr.w	r7, [sp], #4
34186a48:	4770      	bx	lr
34186a4a:	bf00      	nop
34186a4c:	4b800000 	.word	0x4b800000

34186a50 <LL_AHB5_GRP1_IsEnabledClock>:
  *
  *         (*) value not defined in all devices.
  * @retval uint32_t
  */
__STATIC_INLINE uint32_t LL_AHB5_GRP1_IsEnabledClock(uint32_t Periphs)
{
34186a50:	b480      	push	{r7}
34186a52:	b083      	sub	sp, #12
34186a54:	af00      	add	r7, sp, #0
34186a56:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(RCC->AHB5ENR, Periphs) == Periphs) ? 1UL : 0UL);
34186a58:	4b08      	ldr	r3, [pc, #32]	@ (34186a7c <LL_AHB5_GRP1_IsEnabledClock+0x2c>)
34186a5a:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
34186a5e:	687b      	ldr	r3, [r7, #4]
34186a60:	4013      	ands	r3, r2
34186a62:	687a      	ldr	r2, [r7, #4]
34186a64:	429a      	cmp	r2, r3
34186a66:	d101      	bne.n	34186a6c <LL_AHB5_GRP1_IsEnabledClock+0x1c>
34186a68:	2301      	movs	r3, #1
34186a6a:	e000      	b.n	34186a6e <LL_AHB5_GRP1_IsEnabledClock+0x1e>
34186a6c:	2300      	movs	r3, #0
}
34186a6e:	4618      	mov	r0, r3
34186a70:	370c      	adds	r7, #12
34186a72:	46bd      	mov	sp, r7
34186a74:	f85d 7b04 	ldr.w	r7, [sp], #4
34186a78:	4770      	bx	lr
34186a7a:	bf00      	nop
34186a7c:	56028000 	.word	0x56028000

34186a80 <HAL_XSPI_Init>:
  *         in the XSPI_InitTypeDef and initialize the associated handle.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Init(XSPI_HandleTypeDef *hxspi)
{
34186a80:	b580      	push	{r7, lr}
34186a82:	b086      	sub	sp, #24
34186a84:	af02      	add	r7, sp, #8
34186a86:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34186a88:	2300      	movs	r3, #0
34186a8a:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
34186a8c:	f7fa fd98 	bl	341815c0 <HAL_GetTick>
34186a90:	60b8      	str	r0, [r7, #8]

  /* Check the XSPI handle allocation */
  if (hxspi == NULL)
34186a92:	687b      	ldr	r3, [r7, #4]
34186a94:	2b00      	cmp	r3, #0
34186a96:	d102      	bne.n	34186a9e <HAL_XSPI_Init+0x1e>
  {
    status = HAL_ERROR;
34186a98:	2301      	movs	r3, #1
34186a9a:	73fb      	strb	r3, [r7, #15]
34186a9c:	e0ec      	b.n	34186c78 <HAL_XSPI_Init+0x1f8>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
    /* Initialize error code */
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
34186a9e:	687b      	ldr	r3, [r7, #4]
34186aa0:	2200      	movs	r2, #0
34186aa2:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Check if the state is the reset state */
    if (hxspi->State == HAL_XSPI_STATE_RESET)
34186aa4:	687b      	ldr	r3, [r7, #4]
34186aa6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34186aa8:	2b00      	cmp	r3, #0
34186aaa:	f040 80e5 	bne.w	34186c78 <HAL_XSPI_Init+0x1f8>

      /* Init the low level hardware */
      hxspi->MspInitCallback(hxspi);
#else
      /* Initialization of the low level hardware */
      HAL_XSPI_MspInit(hxspi);
34186aae:	6878      	ldr	r0, [r7, #4]
34186ab0:	f7fa f868 	bl	34180b84 <HAL_XSPI_MspInit>
#endif /* defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the XSPI memory access */
      (void)HAL_XSPI_SetTimeout(hxspi, HAL_XSPI_TIMEOUT_DEFAULT_VALUE);
34186ab4:	f241 3188 	movw	r1, #5000	@ 0x1388
34186ab8:	6878      	ldr	r0, [r7, #4]
34186aba:	f000 f933 	bl	34186d24 <HAL_XSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, free running clock, clock mode */
      MODIFY_REG(hxspi->Instance->DCR1,
34186abe:	687b      	ldr	r3, [r7, #4]
34186ac0:	681b      	ldr	r3, [r3, #0]
34186ac2:	689a      	ldr	r2, [r3, #8]
34186ac4:	4b6f      	ldr	r3, [pc, #444]	@ (34186c84 <HAL_XSPI_Init+0x204>)
34186ac6:	4013      	ands	r3, r2
34186ac8:	687a      	ldr	r2, [r7, #4]
34186aca:	68d1      	ldr	r1, [r2, #12]
34186acc:	687a      	ldr	r2, [r7, #4]
34186ace:	6912      	ldr	r2, [r2, #16]
34186ad0:	0412      	lsls	r2, r2, #16
34186ad2:	4311      	orrs	r1, r2
34186ad4:	687a      	ldr	r2, [r7, #4]
34186ad6:	6952      	ldr	r2, [r2, #20]
34186ad8:	3a01      	subs	r2, #1
34186ada:	0212      	lsls	r2, r2, #8
34186adc:	4311      	orrs	r1, r2
34186ade:	687a      	ldr	r2, [r7, #4]
34186ae0:	69d2      	ldr	r2, [r2, #28]
34186ae2:	4311      	orrs	r1, r2
34186ae4:	687a      	ldr	r2, [r7, #4]
34186ae6:	6812      	ldr	r2, [r2, #0]
34186ae8:	430b      	orrs	r3, r1
34186aea:	6093      	str	r3, [r2, #8]
                 (XSPI_DCR1_MTYP | XSPI_DCR1_DEVSIZE | XSPI_DCR1_CSHT | XSPI_DCR1_FRCK | XSPI_DCR1_CKMODE),
                 (hxspi->Init.MemoryType | ((hxspi->Init.MemorySize) << XSPI_DCR1_DEVSIZE_Pos) |
                  ((hxspi->Init.ChipSelectHighTimeCycle - 1U) << XSPI_DCR1_CSHT_Pos) | hxspi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
34186aec:	687b      	ldr	r3, [r7, #4]
34186aee:	681b      	ldr	r3, [r3, #0]
34186af0:	68db      	ldr	r3, [r3, #12]
34186af2:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
34186af6:	687b      	ldr	r3, [r7, #4]
34186af8:	6a1a      	ldr	r2, [r3, #32]
34186afa:	687b      	ldr	r3, [r7, #4]
34186afc:	681b      	ldr	r3, [r3, #0]
34186afe:	430a      	orrs	r2, r1
34186b00:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
34186b02:	687b      	ldr	r3, [r7, #4]
34186b04:	681b      	ldr	r3, [r3, #0]
34186b06:	691b      	ldr	r3, [r3, #16]
34186b08:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
34186b0c:	687b      	ldr	r3, [r7, #4]
34186b0e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34186b10:	041a      	lsls	r2, r3, #16
34186b12:	687b      	ldr	r3, [r7, #4]
34186b14:	681b      	ldr	r3, [r3, #0]
34186b16:	430a      	orrs	r2, r1
34186b18:	611a      	str	r2, [r3, #16]

      /* Configure maximum transfer */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
34186b1a:	687b      	ldr	r3, [r7, #4]
34186b1c:	681b      	ldr	r3, [r3, #0]
34186b1e:	691b      	ldr	r3, [r3, #16]
34186b20:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34186b24:	687b      	ldr	r3, [r7, #4]
34186b26:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
34186b28:	687b      	ldr	r3, [r7, #4]
34186b2a:	681b      	ldr	r3, [r3, #0]
34186b2c:	430a      	orrs	r2, r1
34186b2e:	611a      	str	r2, [r3, #16]
                 (hxspi->Init.MaxTran << XSPI_DCR3_MAXTRAN_Pos));

      /* Configure refresh */
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
34186b30:	687b      	ldr	r3, [r7, #4]
34186b32:	681b      	ldr	r3, [r3, #0]
34186b34:	687a      	ldr	r2, [r7, #4]
34186b36:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34186b38:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
34186b3a:	687b      	ldr	r3, [r7, #4]
34186b3c:	681b      	ldr	r3, [r3, #0]
34186b3e:	681b      	ldr	r3, [r3, #0]
34186b40:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
34186b44:	687b      	ldr	r3, [r7, #4]
34186b46:	685b      	ldr	r3, [r3, #4]
34186b48:	3b01      	subs	r3, #1
34186b4a:	021a      	lsls	r2, r3, #8
34186b4c:	687b      	ldr	r3, [r7, #4]
34186b4e:	681b      	ldr	r3, [r3, #0]
34186b50:	430a      	orrs	r2, r1
34186b52:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34186b54:	687b      	ldr	r3, [r7, #4]
34186b56:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34186b58:	9300      	str	r3, [sp, #0]
34186b5a:	68bb      	ldr	r3, [r7, #8]
34186b5c:	2200      	movs	r2, #0
34186b5e:	2120      	movs	r1, #32
34186b60:	6878      	ldr	r0, [r7, #4]
34186b62:	f000 fa1b 	bl	34186f9c <XSPI_WaitFlagStateUntilTimeout>
34186b66:	4603      	mov	r3, r0
34186b68:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
34186b6a:	7bfb      	ldrb	r3, [r7, #15]
34186b6c:	2b00      	cmp	r3, #0
34186b6e:	f040 8083 	bne.w	34186c78 <HAL_XSPI_Init+0x1f8>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
34186b72:	687b      	ldr	r3, [r7, #4]
34186b74:	681b      	ldr	r3, [r3, #0]
34186b76:	68db      	ldr	r3, [r3, #12]
34186b78:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34186b7c:	687b      	ldr	r3, [r7, #4]
34186b7e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34186b80:	687b      	ldr	r3, [r7, #4]
34186b82:	681b      	ldr	r3, [r3, #0]
34186b84:	430a      	orrs	r2, r1
34186b86:	60da      	str	r2, [r3, #12]
                   ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));

        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
34186b88:	687b      	ldr	r3, [r7, #4]
34186b8a:	681b      	ldr	r3, [r3, #0]
34186b8c:	4a3e      	ldr	r2, [pc, #248]	@ (34186c88 <HAL_XSPI_Init+0x208>)
34186b8e:	4293      	cmp	r3, r2
34186b90:	d018      	beq.n	34186bc4 <HAL_XSPI_Init+0x144>
34186b92:	687b      	ldr	r3, [r7, #4]
34186b94:	681b      	ldr	r3, [r3, #0]
34186b96:	4a3d      	ldr	r2, [pc, #244]	@ (34186c8c <HAL_XSPI_Init+0x20c>)
34186b98:	4293      	cmp	r3, r2
34186b9a:	d013      	beq.n	34186bc4 <HAL_XSPI_Init+0x144>
34186b9c:	687b      	ldr	r3, [r7, #4]
34186b9e:	681b      	ldr	r3, [r3, #0]
34186ba0:	4a3b      	ldr	r2, [pc, #236]	@ (34186c90 <HAL_XSPI_Init+0x210>)
34186ba2:	4293      	cmp	r3, r2
34186ba4:	d00e      	beq.n	34186bc4 <HAL_XSPI_Init+0x144>
34186ba6:	687b      	ldr	r3, [r7, #4]
34186ba8:	681b      	ldr	r3, [r3, #0]
34186baa:	4a3a      	ldr	r2, [pc, #232]	@ (34186c94 <HAL_XSPI_Init+0x214>)
34186bac:	4293      	cmp	r3, r2
34186bae:	d009      	beq.n	34186bc4 <HAL_XSPI_Init+0x144>
34186bb0:	687b      	ldr	r3, [r7, #4]
34186bb2:	681b      	ldr	r3, [r3, #0]
34186bb4:	4a38      	ldr	r2, [pc, #224]	@ (34186c98 <HAL_XSPI_Init+0x218>)
34186bb6:	4293      	cmp	r3, r2
34186bb8:	d004      	beq.n	34186bc4 <HAL_XSPI_Init+0x144>
34186bba:	687b      	ldr	r3, [r7, #4]
34186bbc:	681b      	ldr	r3, [r3, #0]
34186bbe:	4a37      	ldr	r2, [pc, #220]	@ (34186c9c <HAL_XSPI_Init+0x21c>)
34186bc0:	4293      	cmp	r3, r2
34186bc2:	d10f      	bne.n	34186be4 <HAL_XSPI_Init+0x164>
        {
          /* The configuration of clock prescaler trigger automatically a calibration process.
          So it is necessary to wait the calibration is complete */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34186bc4:	687b      	ldr	r3, [r7, #4]
34186bc6:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34186bc8:	9300      	str	r3, [sp, #0]
34186bca:	68bb      	ldr	r3, [r7, #8]
34186bcc:	2200      	movs	r2, #0
34186bce:	2120      	movs	r1, #32
34186bd0:	6878      	ldr	r0, [r7, #4]
34186bd2:	f000 f9e3 	bl	34186f9c <XSPI_WaitFlagStateUntilTimeout>
34186bd6:	4603      	mov	r3, r0
34186bd8:	73fb      	strb	r3, [r7, #15]
          if (status != HAL_OK)
34186bda:	7bfb      	ldrb	r3, [r7, #15]
34186bdc:	2b00      	cmp	r3, #0
34186bde:	d001      	beq.n	34186be4 <HAL_XSPI_Init+0x164>
          {
            return status;
34186be0:	7bfb      	ldrb	r3, [r7, #15]
34186be2:	e04a      	b.n	34186c7a <HAL_XSPI_Init+0x1fa>
          }
        }
        /* Configure Dual Memory mode and CS Selection */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
34186be4:	687b      	ldr	r3, [r7, #4]
34186be6:	681b      	ldr	r3, [r3, #0]
34186be8:	681b      	ldr	r3, [r3, #0]
34186bea:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34186bee:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34186bf2:	687a      	ldr	r2, [r7, #4]
34186bf4:	6891      	ldr	r1, [r2, #8]
34186bf6:	687a      	ldr	r2, [r7, #4]
34186bf8:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
34186bfa:	4311      	orrs	r1, r2
34186bfc:	687a      	ldr	r2, [r7, #4]
34186bfe:	6812      	ldr	r2, [r2, #0]
34186c00:	430b      	orrs	r3, r1
34186c02:	6013      	str	r3, [r2, #0]
                   (hxspi->Init.MemoryMode | hxspi->Init.MemorySelect));

        /* Configure sample shifting */
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT), hxspi->Init.SampleShifting);
34186c04:	687b      	ldr	r3, [r7, #4]
34186c06:	681b      	ldr	r3, [r3, #0]
34186c08:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34186c0c:	f023 4180 	bic.w	r1, r3, #1073741824	@ 0x40000000
34186c10:	687b      	ldr	r3, [r7, #4]
34186c12:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34186c14:	687b      	ldr	r3, [r7, #4]
34186c16:	681b      	ldr	r3, [r3, #0]
34186c18:	430a      	orrs	r2, r1
34186c1a:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108

        /* Enable XSPI */
        HAL_XSPI_ENABLE(hxspi);
34186c1e:	687b      	ldr	r3, [r7, #4]
34186c20:	681b      	ldr	r3, [r3, #0]
34186c22:	681a      	ldr	r2, [r3, #0]
34186c24:	687b      	ldr	r3, [r7, #4]
34186c26:	681b      	ldr	r3, [r3, #0]
34186c28:	f042 0201 	orr.w	r2, r2, #1
34186c2c:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after XSPI enable */
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
34186c2e:	687b      	ldr	r3, [r7, #4]
34186c30:	699b      	ldr	r3, [r3, #24]
34186c32:	2b02      	cmp	r3, #2
34186c34:	d107      	bne.n	34186c46 <HAL_XSPI_Init+0x1c6>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
34186c36:	687b      	ldr	r3, [r7, #4]
34186c38:	681b      	ldr	r3, [r3, #0]
34186c3a:	689a      	ldr	r2, [r3, #8]
34186c3c:	687b      	ldr	r3, [r7, #4]
34186c3e:	681b      	ldr	r3, [r3, #0]
34186c40:	f042 0202 	orr.w	r2, r2, #2
34186c44:	609a      	str	r2, [r3, #8]
        }

        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
34186c46:	687b      	ldr	r3, [r7, #4]
34186c48:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34186c4a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34186c4e:	d107      	bne.n	34186c60 <HAL_XSPI_Init+0x1e0>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
34186c50:	687b      	ldr	r3, [r7, #4]
34186c52:	681b      	ldr	r3, [r3, #0]
34186c54:	689a      	ldr	r2, [r3, #8]
34186c56:	687b      	ldr	r3, [r7, #4]
34186c58:	681b      	ldr	r3, [r3, #0]
34186c5a:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
34186c5e:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the XSPI state */
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34186c60:	687b      	ldr	r3, [r7, #4]
34186c62:	68db      	ldr	r3, [r3, #12]
34186c64:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34186c68:	d103      	bne.n	34186c72 <HAL_XSPI_Init+0x1f2>
        {
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
34186c6a:	687b      	ldr	r3, [r7, #4]
34186c6c:	2201      	movs	r2, #1
34186c6e:	659a      	str	r2, [r3, #88]	@ 0x58
34186c70:	e002      	b.n	34186c78 <HAL_XSPI_Init+0x1f8>
        }
        else
        {
          hxspi->State = HAL_XSPI_STATE_READY;
34186c72:	687b      	ldr	r3, [r7, #4]
34186c74:	2202      	movs	r2, #2
34186c76:	659a      	str	r2, [r3, #88]	@ 0x58
        }
      }
    }
  }
  return status;
34186c78:	7bfb      	ldrb	r3, [r7, #15]
}
34186c7a:	4618      	mov	r0, r3
34186c7c:	3710      	adds	r7, #16
34186c7e:	46bd      	mov	sp, r7
34186c80:	bd80      	pop	{r7, pc}
34186c82:	bf00      	nop
34186c84:	f8e0c0fc 	.word	0xf8e0c0fc
34186c88:	58025000 	.word	0x58025000
34186c8c:	48025000 	.word	0x48025000
34186c90:	5802a000 	.word	0x5802a000
34186c94:	4802a000 	.word	0x4802a000
34186c98:	5802d000 	.word	0x5802d000
34186c9c:	4802d000 	.word	0x4802d000

34186ca0 <HAL_XSPI_HyperbusCfg>:
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_HyperbusCfg(XSPI_HandleTypeDef *hxspi, const XSPI_HyperbusCfgTypeDef *pCfg,
                                       uint32_t Timeout)
{
34186ca0:	b580      	push	{r7, lr}
34186ca2:	b08a      	sub	sp, #40	@ 0x28
34186ca4:	af02      	add	r7, sp, #8
34186ca6:	60f8      	str	r0, [r7, #12]
34186ca8:	60b9      	str	r1, [r7, #8]
34186caa:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
34186cac:	f7fa fc88 	bl	341815c0 <HAL_GetTick>
34186cb0:	61b8      	str	r0, [r7, #24]
  assert_param(IS_XSPI_ACCESS_TIME_CYCLE(pCfg->AccessTimeCycle));
  assert_param(IS_XSPI_WRITE_ZERO_LATENCY(pCfg->WriteZeroLatency));
  assert_param(IS_XSPI_LATENCY_MODE(pCfg->LatencyMode));

  /* Check the state of the driver */
  state = hxspi->State;
34186cb2:	68fb      	ldr	r3, [r7, #12]
34186cb4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34186cb6:	617b      	str	r3, [r7, #20]
  if ((state == HAL_XSPI_STATE_HYPERBUS_INIT) || (state == HAL_XSPI_STATE_READY))
34186cb8:	697b      	ldr	r3, [r7, #20]
34186cba:	2b01      	cmp	r3, #1
34186cbc:	d002      	beq.n	34186cc4 <HAL_XSPI_HyperbusCfg+0x24>
34186cbe:	697b      	ldr	r3, [r7, #20]
34186cc0:	2b02      	cmp	r3, #2
34186cc2:	d125      	bne.n	34186d10 <HAL_XSPI_HyperbusCfg+0x70>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
34186cc4:	687b      	ldr	r3, [r7, #4]
34186cc6:	9300      	str	r3, [sp, #0]
34186cc8:	69bb      	ldr	r3, [r7, #24]
34186cca:	2200      	movs	r2, #0
34186ccc:	2120      	movs	r1, #32
34186cce:	68f8      	ldr	r0, [r7, #12]
34186cd0:	f000 f964 	bl	34186f9c <XSPI_WaitFlagStateUntilTimeout>
34186cd4:	4603      	mov	r3, r0
34186cd6:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
34186cd8:	7ffb      	ldrb	r3, [r7, #31]
34186cda:	2b00      	cmp	r3, #0
34186cdc:	d115      	bne.n	34186d0a <HAL_XSPI_HyperbusCfg+0x6a>
    {
      /* Configure Hyperbus configuration Latency register */
      WRITE_REG(hxspi->Instance->HLCR, ((pCfg->RWRecoveryTimeCycle << XSPI_HLCR_TRWR_Pos) |
34186cde:	68bb      	ldr	r3, [r7, #8]
34186ce0:	681b      	ldr	r3, [r3, #0]
34186ce2:	041a      	lsls	r2, r3, #16
34186ce4:	68bb      	ldr	r3, [r7, #8]
34186ce6:	685b      	ldr	r3, [r3, #4]
34186ce8:	021b      	lsls	r3, r3, #8
34186cea:	431a      	orrs	r2, r3
34186cec:	68bb      	ldr	r3, [r7, #8]
34186cee:	689b      	ldr	r3, [r3, #8]
34186cf0:	ea42 0103 	orr.w	r1, r2, r3
34186cf4:	68bb      	ldr	r3, [r7, #8]
34186cf6:	68da      	ldr	r2, [r3, #12]
34186cf8:	68fb      	ldr	r3, [r7, #12]
34186cfa:	681b      	ldr	r3, [r3, #0]
34186cfc:	430a      	orrs	r2, r1
34186cfe:	f8c3 2200 	str.w	r2, [r3, #512]	@ 0x200
                                        (pCfg->AccessTimeCycle << XSPI_HLCR_TACC_Pos)     |
                                        pCfg->WriteZeroLatency | pCfg->LatencyMode));

      /* Update the state */
      hxspi->State = HAL_XSPI_STATE_READY;
34186d02:	68fb      	ldr	r3, [r7, #12]
34186d04:	2202      	movs	r2, #2
34186d06:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34186d08:	e007      	b.n	34186d1a <HAL_XSPI_HyperbusCfg+0x7a>
    }
    else
    {
      status = HAL_BUSY;
34186d0a:	2302      	movs	r3, #2
34186d0c:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
34186d0e:	e004      	b.n	34186d1a <HAL_XSPI_HyperbusCfg+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
34186d10:	2301      	movs	r3, #1
34186d12:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34186d14:	68fb      	ldr	r3, [r7, #12]
34186d16:	2210      	movs	r2, #16
34186d18:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
34186d1a:	7ffb      	ldrb	r3, [r7, #31]
}
34186d1c:	4618      	mov	r0, r3
34186d1e:	3720      	adds	r7, #32
34186d20:	46bd      	mov	sp, r7
34186d22:	bd80      	pop	{r7, pc}

34186d24 <HAL_XSPI_SetTimeout>:
  * @param  hxspi   : XSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval HAL state
  */
HAL_StatusTypeDef HAL_XSPI_SetTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Timeout)
{
34186d24:	b480      	push	{r7}
34186d26:	b083      	sub	sp, #12
34186d28:	af00      	add	r7, sp, #0
34186d2a:	6078      	str	r0, [r7, #4]
34186d2c:	6039      	str	r1, [r7, #0]
  hxspi->Timeout = Timeout;
34186d2e:	687b      	ldr	r3, [r7, #4]
34186d30:	683a      	ldr	r2, [r7, #0]
34186d32:	661a      	str	r2, [r3, #96]	@ 0x60
  return HAL_OK;
34186d34:	2300      	movs	r3, #0
}
34186d36:	4618      	mov	r0, r3
34186d38:	370c      	adds	r7, #12
34186d3a:	46bd      	mov	sp, r7
34186d3c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186d40:	4770      	bx	lr
	...

34186d44 <HAL_XSPIM_Config>:
  * @param  pCfg     : Pointer to Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPIM_Config(XSPI_HandleTypeDef *hxspi, const XSPIM_CfgTypeDef *pCfg, uint32_t Timeout)
{
34186d44:	b580      	push	{r7, lr}
34186d46:	b08e      	sub	sp, #56	@ 0x38
34186d48:	af00      	add	r7, sp, #0
34186d4a:	60f8      	str	r0, [r7, #12]
34186d4c:	60b9      	str	r1, [r7, #8]
34186d4e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34186d50:	2300      	movs	r3, #0
34186d52:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
  uint8_t index;
  uint8_t xspi_enabled = 0U;
34186d56:	2300      	movs	r3, #0
34186d58:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36

  XSPIM_CfgTypeDef IOM_cfg[XSPI_NB_INSTANCE] = {0};
34186d5c:	f107 0310 	add.w	r3, r7, #16
34186d60:	2224      	movs	r2, #36	@ 0x24
34186d62:	2100      	movs	r1, #0
34186d64:	4618      	mov	r0, r3
34186d66:	f000 fc09 	bl	3418757c <memset>
  assert_param(IS_XSPIM_NCS_OVR(pCfg->nCSOverride));
  assert_param(IS_XSPIM_IO_PORT(pCfg->IOPort));
  assert_param(IS_XSPIM_REQ2ACKTIME(pCfg->Req2AckTime));

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
34186d6a:	2300      	movs	r3, #0
34186d6c:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34186d70:	e014      	b.n	34186d9c <HAL_XSPIM_Config+0x58>
  {
    XSPIM_GetConfig(index + 1U, &(IOM_cfg[index]));
34186d72:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34186d76:	3301      	adds	r3, #1
34186d78:	b2d8      	uxtb	r0, r3
34186d7a:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
34186d7e:	f107 0110 	add.w	r1, r7, #16
34186d82:	4613      	mov	r3, r2
34186d84:	005b      	lsls	r3, r3, #1
34186d86:	4413      	add	r3, r2
34186d88:	009b      	lsls	r3, r3, #2
34186d8a:	440b      	add	r3, r1
34186d8c:	4619      	mov	r1, r3
34186d8e:	f000 f93b 	bl	34187008 <XSPIM_GetConfig>
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
34186d92:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34186d96:	3301      	adds	r3, #1
34186d98:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34186d9c:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34186da0:	2b02      	cmp	r3, #2
34186da2:	d9e6      	bls.n	34186d72 <HAL_XSPIM_Config+0x2e>
  }

  /********** Disable all XSPI to configure XSPI IO Manager **********/
  if (__HAL_RCC_XSPI1_IS_CLK_ENABLED() != 0U)
34186da4:	2020      	movs	r0, #32
34186da6:	f7ff fe53 	bl	34186a50 <LL_AHB5_GRP1_IsEnabledClock>
34186daa:	4603      	mov	r3, r0
34186dac:	2b00      	cmp	r3, #0
34186dae:	d011      	beq.n	34186dd4 <HAL_XSPIM_Config+0x90>
  {
    if ((XSPI1->CR & XSPI_CR_EN) != 0U)
34186db0:	4b76      	ldr	r3, [pc, #472]	@ (34186f8c <HAL_XSPIM_Config+0x248>)
34186db2:	681b      	ldr	r3, [r3, #0]
34186db4:	f003 0301 	and.w	r3, r3, #1
34186db8:	2b00      	cmp	r3, #0
34186dba:	d00b      	beq.n	34186dd4 <HAL_XSPIM_Config+0x90>
    {
      CLEAR_BIT(XSPI1->CR, XSPI_CR_EN);
34186dbc:	4b73      	ldr	r3, [pc, #460]	@ (34186f8c <HAL_XSPIM_Config+0x248>)
34186dbe:	681b      	ldr	r3, [r3, #0]
34186dc0:	4a72      	ldr	r2, [pc, #456]	@ (34186f8c <HAL_XSPIM_Config+0x248>)
34186dc2:	f023 0301 	bic.w	r3, r3, #1
34186dc6:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x1U;
34186dc8:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34186dcc:	f043 0301 	orr.w	r3, r3, #1
34186dd0:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI2_IS_CLK_ENABLED() != 0U)
34186dd4:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34186dd8:	f7ff fe3a 	bl	34186a50 <LL_AHB5_GRP1_IsEnabledClock>
34186ddc:	4603      	mov	r3, r0
34186dde:	2b00      	cmp	r3, #0
34186de0:	d011      	beq.n	34186e06 <HAL_XSPIM_Config+0xc2>
  {
    if ((XSPI2->CR & XSPI_CR_EN) != 0U)
34186de2:	4b6b      	ldr	r3, [pc, #428]	@ (34186f90 <HAL_XSPIM_Config+0x24c>)
34186de4:	681b      	ldr	r3, [r3, #0]
34186de6:	f003 0301 	and.w	r3, r3, #1
34186dea:	2b00      	cmp	r3, #0
34186dec:	d00b      	beq.n	34186e06 <HAL_XSPIM_Config+0xc2>
    {
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
34186dee:	4b68      	ldr	r3, [pc, #416]	@ (34186f90 <HAL_XSPIM_Config+0x24c>)
34186df0:	681b      	ldr	r3, [r3, #0]
34186df2:	4a67      	ldr	r2, [pc, #412]	@ (34186f90 <HAL_XSPIM_Config+0x24c>)
34186df4:	f023 0301 	bic.w	r3, r3, #1
34186df8:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x2U;
34186dfa:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34186dfe:	f043 0302 	orr.w	r3, r3, #2
34186e02:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI3_IS_CLK_ENABLED() != 0U)
34186e06:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
34186e0a:	f7ff fe21 	bl	34186a50 <LL_AHB5_GRP1_IsEnabledClock>
34186e0e:	4603      	mov	r3, r0
34186e10:	2b00      	cmp	r3, #0
34186e12:	d011      	beq.n	34186e38 <HAL_XSPIM_Config+0xf4>
  {
    if ((XSPI3->CR & XSPI_CR_EN) != 0U)
34186e14:	4b5f      	ldr	r3, [pc, #380]	@ (34186f94 <HAL_XSPIM_Config+0x250>)
34186e16:	681b      	ldr	r3, [r3, #0]
34186e18:	f003 0301 	and.w	r3, r3, #1
34186e1c:	2b00      	cmp	r3, #0
34186e1e:	d00b      	beq.n	34186e38 <HAL_XSPIM_Config+0xf4>
    {
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
34186e20:	4b5b      	ldr	r3, [pc, #364]	@ (34186f90 <HAL_XSPIM_Config+0x24c>)
34186e22:	681b      	ldr	r3, [r3, #0]
34186e24:	4a5a      	ldr	r2, [pc, #360]	@ (34186f90 <HAL_XSPIM_Config+0x24c>)
34186e26:	f023 0301 	bic.w	r3, r3, #1
34186e2a:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x4U;
34186e2c:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34186e30:	f043 0304 	orr.w	r3, r3, #4
34186e34:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }

  /***************** Deactivation of previous configuration *****************/
  CLEAR_REG(XSPIM->CR);
34186e38:	4b57      	ldr	r3, [pc, #348]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186e3a:	2200      	movs	r2, #0
34186e3c:	601a      	str	r2, [r3, #0]

  /******************** Activation of new configuration *********************/
  MODIFY_REG(XSPIM->CR, XSPIM_CR_REQ2ACK_TIME, ((pCfg->Req2AckTime - 1U) << XSPIM_CR_REQ2ACK_TIME_Pos));
34186e3e:	4b56      	ldr	r3, [pc, #344]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186e40:	681b      	ldr	r3, [r3, #0]
34186e42:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
34186e46:	68bb      	ldr	r3, [r7, #8]
34186e48:	689b      	ldr	r3, [r3, #8]
34186e4a:	3b01      	subs	r3, #1
34186e4c:	041b      	lsls	r3, r3, #16
34186e4e:	4952      	ldr	r1, [pc, #328]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186e50:	4313      	orrs	r3, r2
34186e52:	600b      	str	r3, [r1, #0]

  if (hxspi->Instance == XSPI1)
34186e54:	68fb      	ldr	r3, [r7, #12]
34186e56:	681b      	ldr	r3, [r3, #0]
34186e58:	4a4c      	ldr	r2, [pc, #304]	@ (34186f8c <HAL_XSPIM_Config+0x248>)
34186e5a:	4293      	cmp	r3, r2
34186e5c:	d110      	bne.n	34186e80 <HAL_XSPIM_Config+0x13c>
  {
    IOM_cfg[0].IOPort = pCfg->IOPort ;
34186e5e:	68bb      	ldr	r3, [r7, #8]
34186e60:	685b      	ldr	r3, [r3, #4]
34186e62:	617b      	str	r3, [r7, #20]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
34186e64:	68bb      	ldr	r3, [r7, #8]
34186e66:	681b      	ldr	r3, [r3, #0]
34186e68:	2b00      	cmp	r3, #0
34186e6a:	d03e      	beq.n	34186eea <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O1 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
34186e6c:	4b4a      	ldr	r3, [pc, #296]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186e6e:	681b      	ldr	r3, [r3, #0]
34186e70:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34186e74:	68bb      	ldr	r3, [r7, #8]
34186e76:	681b      	ldr	r3, [r3, #0]
34186e78:	4947      	ldr	r1, [pc, #284]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186e7a:	4313      	orrs	r3, r2
34186e7c:	600b      	str	r3, [r1, #0]
34186e7e:	e034      	b.n	34186eea <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI2)
34186e80:	68fb      	ldr	r3, [r7, #12]
34186e82:	681b      	ldr	r3, [r3, #0]
34186e84:	4a42      	ldr	r2, [pc, #264]	@ (34186f90 <HAL_XSPIM_Config+0x24c>)
34186e86:	4293      	cmp	r3, r2
34186e88:	d110      	bne.n	34186eac <HAL_XSPIM_Config+0x168>
  {
    IOM_cfg[1].IOPort = pCfg->IOPort ;
34186e8a:	68bb      	ldr	r3, [r7, #8]
34186e8c:	685b      	ldr	r3, [r3, #4]
34186e8e:	623b      	str	r3, [r7, #32]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
34186e90:	68bb      	ldr	r3, [r7, #8]
34186e92:	681b      	ldr	r3, [r3, #0]
34186e94:	2b00      	cmp	r3, #0
34186e96:	d028      	beq.n	34186eea <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O2 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
34186e98:	4b3f      	ldr	r3, [pc, #252]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186e9a:	681b      	ldr	r3, [r3, #0]
34186e9c:	f023 0250 	bic.w	r2, r3, #80	@ 0x50
34186ea0:	68bb      	ldr	r3, [r7, #8]
34186ea2:	681b      	ldr	r3, [r3, #0]
34186ea4:	493c      	ldr	r1, [pc, #240]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186ea6:	4313      	orrs	r3, r2
34186ea8:	600b      	str	r3, [r1, #0]
34186eaa:	e01e      	b.n	34186eea <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI3)
34186eac:	68fb      	ldr	r3, [r7, #12]
34186eae:	681b      	ldr	r3, [r3, #0]
34186eb0:	4a38      	ldr	r2, [pc, #224]	@ (34186f94 <HAL_XSPIM_Config+0x250>)
34186eb2:	4293      	cmp	r3, r2
34186eb4:	d111      	bne.n	34186eda <HAL_XSPIM_Config+0x196>
  {
    if (pCfg->IOPort == HAL_XSPIM_IOPORT_1)
34186eb6:	68bb      	ldr	r3, [r7, #8]
34186eb8:	685b      	ldr	r3, [r3, #4]
34186eba:	2b00      	cmp	r3, #0
34186ebc:	d104      	bne.n	34186ec8 <HAL_XSPIM_Config+0x184>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_2 ;
34186ebe:	2301      	movs	r3, #1
34186ec0:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_2 ;
34186ec2:	2301      	movs	r3, #1
34186ec4:	623b      	str	r3, [r7, #32]
34186ec6:	e010      	b.n	34186eea <HAL_XSPIM_Config+0x1a6>
    }
    else if (pCfg->IOPort == HAL_XSPIM_IOPORT_2)
34186ec8:	68bb      	ldr	r3, [r7, #8]
34186eca:	685b      	ldr	r3, [r3, #4]
34186ecc:	2b01      	cmp	r3, #1
34186ece:	d10c      	bne.n	34186eea <HAL_XSPIM_Config+0x1a6>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_1 ;
34186ed0:	2300      	movs	r3, #0
34186ed2:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_1 ;
34186ed4:	2300      	movs	r3, #0
34186ed6:	623b      	str	r3, [r7, #32]
34186ed8:	e007      	b.n	34186eea <HAL_XSPIM_Config+0x1a6>
      /* Nothing to do */
    }
  }
  else
  {
    hxspi->ErrorCode |= HAL_XSPI_ERROR_INVALID_PARAM;
34186eda:	68fb      	ldr	r3, [r7, #12]
34186edc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34186ede:	f043 0208 	orr.w	r2, r3, #8
34186ee2:	68fb      	ldr	r3, [r7, #12]
34186ee4:	65da      	str	r2, [r3, #92]	@ 0x5c
    return HAL_ERROR;
34186ee6:	2301      	movs	r3, #1
34186ee8:	e04c      	b.n	34186f84 <HAL_XSPIM_Config+0x240>
  }

  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
34186eea:	2300      	movs	r3, #0
34186eec:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34186ef0:	e02a      	b.n	34186f48 <HAL_XSPIM_Config+0x204>
  {
    if (IOM_cfg[index].IOPort == IOM_cfg[index + 1U].IOPort)
34186ef2:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
34186ef6:	4613      	mov	r3, r2
34186ef8:	005b      	lsls	r3, r3, #1
34186efa:	4413      	add	r3, r2
34186efc:	009b      	lsls	r3, r3, #2
34186efe:	3338      	adds	r3, #56	@ 0x38
34186f00:	443b      	add	r3, r7
34186f02:	3b24      	subs	r3, #36	@ 0x24
34186f04:	6819      	ldr	r1, [r3, #0]
34186f06:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34186f0a:	1c5a      	adds	r2, r3, #1
34186f0c:	4613      	mov	r3, r2
34186f0e:	005b      	lsls	r3, r3, #1
34186f10:	4413      	add	r3, r2
34186f12:	009b      	lsls	r3, r3, #2
34186f14:	3338      	adds	r3, #56	@ 0x38
34186f16:	443b      	add	r3, r7
34186f18:	3b24      	subs	r3, #36	@ 0x24
34186f1a:	681b      	ldr	r3, [r3, #0]
34186f1c:	4299      	cmp	r1, r3
34186f1e:	d105      	bne.n	34186f2c <HAL_XSPIM_Config+0x1e8>
    {
      /*Mux*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MUXEN);
34186f20:	4b1d      	ldr	r3, [pc, #116]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186f22:	681b      	ldr	r3, [r3, #0]
34186f24:	4a1c      	ldr	r2, [pc, #112]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186f26:	f043 0301 	orr.w	r3, r3, #1
34186f2a:	6013      	str	r3, [r2, #0]
    }
    else
    {
      /* Nothing to do */
    }
    if (IOM_cfg[0].IOPort == HAL_XSPIM_IOPORT_2)
34186f2c:	697b      	ldr	r3, [r7, #20]
34186f2e:	2b01      	cmp	r3, #1
34186f30:	d105      	bne.n	34186f3e <HAL_XSPIM_Config+0x1fa>
    {
      /*Mode*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MODE);
34186f32:	4b19      	ldr	r3, [pc, #100]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186f34:	681b      	ldr	r3, [r3, #0]
34186f36:	4a18      	ldr	r2, [pc, #96]	@ (34186f98 <HAL_XSPIM_Config+0x254>)
34186f38:	f043 0302 	orr.w	r3, r3, #2
34186f3c:	6013      	str	r3, [r2, #0]
  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
34186f3e:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34186f42:	3301      	adds	r3, #1
34186f44:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34186f48:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34186f4c:	2b00      	cmp	r3, #0
34186f4e:	d0d0      	beq.n	34186ef2 <HAL_XSPIM_Config+0x1ae>
      /* Nothing to do */
    }
  }

  /******* Re-enable both XSPI after configure XSPI IO Manager ********/
  if ((xspi_enabled & 0x1U) != 0U)
34186f50:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34186f54:	f003 0301 	and.w	r3, r3, #1
34186f58:	2b00      	cmp	r3, #0
34186f5a:	d005      	beq.n	34186f68 <HAL_XSPIM_Config+0x224>
  {
    SET_BIT(XSPI1->CR, XSPI_CR_EN);
34186f5c:	4b0b      	ldr	r3, [pc, #44]	@ (34186f8c <HAL_XSPIM_Config+0x248>)
34186f5e:	681b      	ldr	r3, [r3, #0]
34186f60:	4a0a      	ldr	r2, [pc, #40]	@ (34186f8c <HAL_XSPIM_Config+0x248>)
34186f62:	f043 0301 	orr.w	r3, r3, #1
34186f66:	6013      	str	r3, [r2, #0]
  }
  if ((xspi_enabled & 0x2U) != 0U)
34186f68:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34186f6c:	f003 0302 	and.w	r3, r3, #2
34186f70:	2b00      	cmp	r3, #0
34186f72:	d005      	beq.n	34186f80 <HAL_XSPIM_Config+0x23c>
  {
    SET_BIT(XSPI2->CR, XSPI_CR_EN);
34186f74:	4b06      	ldr	r3, [pc, #24]	@ (34186f90 <HAL_XSPIM_Config+0x24c>)
34186f76:	681b      	ldr	r3, [r3, #0]
34186f78:	4a05      	ldr	r2, [pc, #20]	@ (34186f90 <HAL_XSPIM_Config+0x24c>)
34186f7a:	f043 0301 	orr.w	r3, r3, #1
34186f7e:	6013      	str	r3, [r2, #0]
  }

  return status;
34186f80:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
}
34186f84:	4618      	mov	r0, r3
34186f86:	3738      	adds	r7, #56	@ 0x38
34186f88:	46bd      	mov	sp, r7
34186f8a:	bd80      	pop	{r7, pc}
34186f8c:	58025000 	.word	0x58025000
34186f90:	5802a000 	.word	0x5802a000
34186f94:	5802d000 	.word	0x5802d000
34186f98:	5802b400 	.word	0x5802b400

34186f9c <XSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_WaitFlagStateUntilTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
34186f9c:	b580      	push	{r7, lr}
34186f9e:	b084      	sub	sp, #16
34186fa0:	af00      	add	r7, sp, #0
34186fa2:	60f8      	str	r0, [r7, #12]
34186fa4:	60b9      	str	r1, [r7, #8]
34186fa6:	603b      	str	r3, [r7, #0]
34186fa8:	4613      	mov	r3, r2
34186faa:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34186fac:	e019      	b.n	34186fe2 <XSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34186fae:	69bb      	ldr	r3, [r7, #24]
34186fb0:	f1b3 3fff 	cmp.w	r3, #4294967295
34186fb4:	d015      	beq.n	34186fe2 <XSPI_WaitFlagStateUntilTimeout+0x46>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34186fb6:	f7fa fb03 	bl	341815c0 <HAL_GetTick>
34186fba:	4602      	mov	r2, r0
34186fbc:	683b      	ldr	r3, [r7, #0]
34186fbe:	1ad3      	subs	r3, r2, r3
34186fc0:	69ba      	ldr	r2, [r7, #24]
34186fc2:	429a      	cmp	r2, r3
34186fc4:	d302      	bcc.n	34186fcc <XSPI_WaitFlagStateUntilTimeout+0x30>
34186fc6:	69bb      	ldr	r3, [r7, #24]
34186fc8:	2b00      	cmp	r3, #0
34186fca:	d10a      	bne.n	34186fe2 <XSPI_WaitFlagStateUntilTimeout+0x46>
      {
        hxspi->State     = HAL_XSPI_STATE_READY;
34186fcc:	68fb      	ldr	r3, [r7, #12]
34186fce:	2202      	movs	r2, #2
34186fd0:	659a      	str	r2, [r3, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
34186fd2:	68fb      	ldr	r3, [r7, #12]
34186fd4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34186fd6:	f043 0201 	orr.w	r2, r3, #1
34186fda:	68fb      	ldr	r3, [r7, #12]
34186fdc:	65da      	str	r2, [r3, #92]	@ 0x5c

        return HAL_TIMEOUT;
34186fde:	2303      	movs	r3, #3
34186fe0:	e00e      	b.n	34187000 <XSPI_WaitFlagStateUntilTimeout+0x64>
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34186fe2:	68fb      	ldr	r3, [r7, #12]
34186fe4:	681b      	ldr	r3, [r3, #0]
34186fe6:	6a1a      	ldr	r2, [r3, #32]
34186fe8:	68bb      	ldr	r3, [r7, #8]
34186fea:	4013      	ands	r3, r2
34186fec:	2b00      	cmp	r3, #0
34186fee:	bf14      	ite	ne
34186ff0:	2301      	movne	r3, #1
34186ff2:	2300      	moveq	r3, #0
34186ff4:	b2db      	uxtb	r3, r3
34186ff6:	461a      	mov	r2, r3
34186ff8:	79fb      	ldrb	r3, [r7, #7]
34186ffa:	429a      	cmp	r2, r3
34186ffc:	d1d7      	bne.n	34186fae <XSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
34186ffe:	2300      	movs	r3, #0
}
34187000:	4618      	mov	r0, r3
34187002:	3710      	adds	r7, #16
34187004:	46bd      	mov	sp, r7
34187006:	bd80      	pop	{r7, pc}

34187008 <XSPIM_GetConfig>:
  * @param  instance_nb : number of the instance
  * @param  pCfg         : configuration of the IO Manager for the instance
  * @retval HAL status
  */
static void XSPIM_GetConfig(uint8_t instance_nb, XSPIM_CfgTypeDef *pCfg)
{
34187008:	b480      	push	{r7}
3418700a:	b085      	sub	sp, #20
3418700c:	af00      	add	r7, sp, #0
3418700e:	4603      	mov	r3, r0
34187010:	6039      	str	r1, [r7, #0]
34187012:	71fb      	strb	r3, [r7, #7]
  uint32_t mux;
  uint32_t mode;

  if (instance_nb == 1U)
34187014:	79fb      	ldrb	r3, [r7, #7]
34187016:	2b01      	cmp	r3, #1
34187018:	d124      	bne.n	34187064 <XSPIM_GetConfig+0x5c>
  {
    if ((XSPIM->CR & XSPIM_CR_MODE) == 0U)
3418701a:	4b2c      	ldr	r3, [pc, #176]	@ (341870cc <XSPIM_GetConfig+0xc4>)
3418701c:	681b      	ldr	r3, [r3, #0]
3418701e:	f003 0302 	and.w	r3, r3, #2
34187022:	2b00      	cmp	r3, #0
34187024:	d103      	bne.n	3418702e <XSPIM_GetConfig+0x26>
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
34187026:	683b      	ldr	r3, [r7, #0]
34187028:	2200      	movs	r2, #0
3418702a:	605a      	str	r2, [r3, #4]
3418702c:	e002      	b.n	34187034 <XSPIM_GetConfig+0x2c>
    }
    else
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
3418702e:	683b      	ldr	r3, [r7, #0]
34187030:	2201      	movs	r2, #1
34187032:	605a      	str	r2, [r3, #4]
    }

    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
34187034:	4b25      	ldr	r3, [pc, #148]	@ (341870cc <XSPIM_GetConfig+0xc4>)
34187036:	681b      	ldr	r3, [r3, #0]
34187038:	f003 0310 	and.w	r3, r3, #16
3418703c:	2b10      	cmp	r3, #16
3418703e:	d003      	beq.n	34187048 <XSPIM_GetConfig+0x40>
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
34187040:	683b      	ldr	r3, [r7, #0]
34187042:	2200      	movs	r2, #0
34187044:	601a      	str	r2, [r3, #0]
    else
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
    }
  }
}
34187046:	e03a      	b.n	341870be <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O1) == XSPIM_CR_CSSEL_OVR_O1)
34187048:	4b20      	ldr	r3, [pc, #128]	@ (341870cc <XSPIM_GetConfig+0xc4>)
3418704a:	681b      	ldr	r3, [r3, #0]
3418704c:	f003 0320 	and.w	r3, r3, #32
34187050:	2b20      	cmp	r3, #32
34187052:	d103      	bne.n	3418705c <XSPIM_GetConfig+0x54>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
34187054:	683b      	ldr	r3, [r7, #0]
34187056:	2270      	movs	r2, #112	@ 0x70
34187058:	601a      	str	r2, [r3, #0]
}
3418705a:	e030      	b.n	341870be <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
3418705c:	683b      	ldr	r3, [r7, #0]
3418705e:	2210      	movs	r2, #16
34187060:	601a      	str	r2, [r3, #0]
}
34187062:	e02c      	b.n	341870be <XSPIM_GetConfig+0xb6>
    mux = (XSPIM->CR & XSPIM_CR_MUXEN);
34187064:	4b19      	ldr	r3, [pc, #100]	@ (341870cc <XSPIM_GetConfig+0xc4>)
34187066:	681b      	ldr	r3, [r3, #0]
34187068:	f003 0301 	and.w	r3, r3, #1
3418706c:	60fb      	str	r3, [r7, #12]
    mode = ((XSPIM->CR & XSPIM_CR_MODE) >> XSPIM_CR_MODE_Pos);
3418706e:	4b17      	ldr	r3, [pc, #92]	@ (341870cc <XSPIM_GetConfig+0xc4>)
34187070:	681b      	ldr	r3, [r3, #0]
34187072:	085b      	lsrs	r3, r3, #1
34187074:	f003 0301 	and.w	r3, r3, #1
34187078:	60bb      	str	r3, [r7, #8]
    if (mux != mode)
3418707a:	68fa      	ldr	r2, [r7, #12]
3418707c:	68bb      	ldr	r3, [r7, #8]
3418707e:	429a      	cmp	r2, r3
34187080:	d003      	beq.n	3418708a <XSPIM_GetConfig+0x82>
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
34187082:	683b      	ldr	r3, [r7, #0]
34187084:	2200      	movs	r2, #0
34187086:	605a      	str	r2, [r3, #4]
34187088:	e002      	b.n	34187090 <XSPIM_GetConfig+0x88>
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
3418708a:	683b      	ldr	r3, [r7, #0]
3418708c:	2201      	movs	r2, #1
3418708e:	605a      	str	r2, [r3, #4]
    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
34187090:	4b0e      	ldr	r3, [pc, #56]	@ (341870cc <XSPIM_GetConfig+0xc4>)
34187092:	681b      	ldr	r3, [r3, #0]
34187094:	f003 0310 	and.w	r3, r3, #16
34187098:	2b10      	cmp	r3, #16
3418709a:	d003      	beq.n	341870a4 <XSPIM_GetConfig+0x9c>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
3418709c:	683b      	ldr	r3, [r7, #0]
3418709e:	2200      	movs	r2, #0
341870a0:	601a      	str	r2, [r3, #0]
}
341870a2:	e00c      	b.n	341870be <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O2) == XSPIM_CR_CSSEL_OVR_O2)
341870a4:	4b09      	ldr	r3, [pc, #36]	@ (341870cc <XSPIM_GetConfig+0xc4>)
341870a6:	681b      	ldr	r3, [r3, #0]
341870a8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341870ac:	2b40      	cmp	r3, #64	@ 0x40
341870ae:	d103      	bne.n	341870b8 <XSPIM_GetConfig+0xb0>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
341870b0:	683b      	ldr	r3, [r7, #0]
341870b2:	2270      	movs	r2, #112	@ 0x70
341870b4:	601a      	str	r2, [r3, #0]
}
341870b6:	e002      	b.n	341870be <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
341870b8:	683b      	ldr	r3, [r7, #0]
341870ba:	2210      	movs	r2, #16
341870bc:	601a      	str	r2, [r3, #0]
}
341870be:	bf00      	nop
341870c0:	3714      	adds	r7, #20
341870c2:	46bd      	mov	sp, r7
341870c4:	f85d 7b04 	ldr.w	r7, [sp], #4
341870c8:	4770      	bx	lr
341870ca:	bf00      	nop
341870cc:	5802b400 	.word	0x5802b400

341870d0 <BOOT_Application>:
  *  @addtogroup BOOT_XIP_Exported_Functions Boot XIP exported functions
  * @{
  */

BOOTStatus_TypeDef BOOT_Application(void)
{
341870d0:	b580      	push	{r7, lr}
341870d2:	b082      	sub	sp, #8
341870d4:	af00      	add	r7, sp, #0
  BOOTStatus_TypeDef retr;

  /* mount the memory */
  retr = MapMemory();
341870d6:	f000 f80e 	bl	341870f6 <MapMemory>
341870da:	4603      	mov	r3, r0
341870dc:	71fb      	strb	r3, [r7, #7]
  if (BOOT_OK == retr)
341870de:	79fb      	ldrb	r3, [r7, #7]
341870e0:	2b00      	cmp	r3, #0
341870e2:	d103      	bne.n	341870ec <BOOT_Application+0x1c>
  {
    /* jump on the application */
    retr = JumpToApplication();
341870e4:	f000 f836 	bl	34187154 <JumpToApplication>
341870e8:	4603      	mov	r3, r0
341870ea:	71fb      	strb	r3, [r7, #7]
  }
  return retr;
341870ec:	79fb      	ldrb	r3, [r7, #7]
}
341870ee:	4618      	mov	r0, r3
341870f0:	3708      	adds	r7, #8
341870f2:	46bd      	mov	sp, r7
341870f4:	bd80      	pop	{r7, pc}

341870f6 <MapMemory>:
/**
  * @brief  this function maps the memory
  * @return @ref BOOTStatus_TypeDef
  */
BOOTStatus_TypeDef MapMemory(void)
{
341870f6:	b580      	push	{r7, lr}
341870f8:	b082      	sub	sp, #8
341870fa:	af00      	add	r7, sp, #0
  BOOTStatus_TypeDef retr = BOOT_OK;
341870fc:	2300      	movs	r3, #0
341870fe:	71fb      	strb	r3, [r7, #7]

  /* Map all the memory */
  for (uint8_t index = 0; index < (sizeof(extmem_list_config) / sizeof(EXTMEM_DefinitionTypeDef)); index++)
34187100:	2300      	movs	r3, #0
34187102:	71bb      	strb	r3, [r7, #6]
34187104:	e01d      	b.n	34187142 <MapMemory+0x4c>
  {
    switch(EXTMEM_MemoryMappedMode(index, EXTMEM_ENABLE))
34187106:	79bb      	ldrb	r3, [r7, #6]
34187108:	2100      	movs	r1, #0
3418710a:	4618      	mov	r0, r3
3418710c:	f000 f954 	bl	341873b8 <EXTMEM_MemoryMappedMode>
34187110:	4603      	mov	r3, r0
34187112:	f1b3 3fff 	cmp.w	r3, #4294967295
34187116:	d002      	beq.n	3418711e <MapMemory+0x28>
34187118:	2b00      	cmp	r3, #0
3418711a:	d00e      	beq.n	3418713a <MapMemory+0x44>
3418711c:	e00a      	b.n	34187134 <MapMemory+0x3e>
    {
      case EXTMEM_ERROR_NOTSUPPORTED :
           if (EXTMEM_MEMORY_BOOTXIP ==  index)
3418711e:	79bb      	ldrb	r3, [r7, #6]
34187120:	2b00      	cmp	r3, #0
34187122:	d102      	bne.n	3418712a <MapMemory+0x34>
           {
             retr = BOOT_ERROR_INCOMPATIBLEMEMORY;
34187124:	2304      	movs	r3, #4
34187126:	71fb      	strb	r3, [r7, #7]
           {
            /* We considers the memory will be not used any more */
            EXTMEM_DeInit(index);
           }
      case EXTMEM_OK:
      break;
34187128:	e007      	b.n	3418713a <MapMemory+0x44>
            EXTMEM_DeInit(index);
3418712a:	79bb      	ldrb	r3, [r7, #6]
3418712c:	4618      	mov	r0, r3
3418712e:	f000 f905 	bl	3418733c <EXTMEM_DeInit>
      break;
34187132:	e002      	b.n	3418713a <MapMemory+0x44>
      default :
        retr = BOOT_ERROR_MAPPEDMODEFAIL;
34187134:	2303      	movs	r3, #3
34187136:	71fb      	strb	r3, [r7, #7]
      break;
34187138:	e000      	b.n	3418713c <MapMemory+0x46>
      break;
3418713a:	bf00      	nop
  for (uint8_t index = 0; index < (sizeof(extmem_list_config) / sizeof(EXTMEM_DefinitionTypeDef)); index++)
3418713c:	79bb      	ldrb	r3, [r7, #6]
3418713e:	3301      	adds	r3, #1
34187140:	71bb      	strb	r3, [r7, #6]
34187142:	79bb      	ldrb	r3, [r7, #6]
34187144:	2b00      	cmp	r3, #0
34187146:	d0de      	beq.n	34187106 <MapMemory+0x10>
    }
  }
  return retr;
34187148:	79fb      	ldrb	r3, [r7, #7]
}
3418714a:	4618      	mov	r0, r3
3418714c:	3708      	adds	r7, #8
3418714e:	46bd      	mov	sp, r7
34187150:	bd80      	pop	{r7, pc}
	...

34187154 <JumpToApplication>:
/**
  * @brief  This function jumps to the application through its vector table
  * @return @ref BOOTStatus_TypeDef
  */
BOOTStatus_TypeDef JumpToApplication(void)
{
34187154:	b590      	push	{r4, r7, lr}
34187156:	b091      	sub	sp, #68	@ 0x44
34187158:	af00      	add	r7, sp, #0
3418715a:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3418715e:	3b40      	subs	r3, #64	@ 0x40
34187160:	331f      	adds	r3, #31
34187162:	095b      	lsrs	r3, r3, #5
34187164:	015c      	lsls	r4, r3, #5
  uint32_t primask_bit;
  typedef  void (*pFunction)(void);
  static pFunction JumpToApp;
  uint32_t Application_vector;

  if (EXTMEM_OK != EXTMEM_GetMapAddress(EXTMEM_MEMORY_BOOTXIP, &Application_vector))
34187166:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3418716a:	4619      	mov	r1, r3
3418716c:	2000      	movs	r0, #0
3418716e:	f000 f97b 	bl	34187468 <EXTMEM_GetMapAddress>
34187172:	4603      	mov	r3, r0
34187174:	2b00      	cmp	r3, #0
34187176:	d001      	beq.n	3418717c <JumpToApplication+0x28>
  {
      return BOOT_ERROR_INCOMPATIBLEMEMORY;
34187178:	2304      	movs	r3, #4
3418717a:	e095      	b.n	341872a8 <JumpToApplication+0x154>
  }

  /* Suspend SysTick */
  HAL_SuspendTick();
3418717c:	f7fa fa50 	bl	34181620 <HAL_SuspendTick>

#if defined(__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
  /* if I-Cache is enabled, disable I-Cache-----------------------------------*/
  if (SCB->CCR & SCB_CCR_IC_Msk)
34187180:	4b4b      	ldr	r3, [pc, #300]	@ (341872b0 <JumpToApplication+0x15c>)
34187182:	695b      	ldr	r3, [r3, #20]
34187184:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34187188:	2b00      	cmp	r3, #0
3418718a:	d016      	beq.n	341871ba <JumpToApplication+0x66>
  __ASM volatile ("dsb 0xF":::"memory");
3418718c:	f3bf 8f4f 	dsb	sy
}
34187190:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34187192:	f3bf 8f6f 	isb	sy
}
34187196:	bf00      	nop
    SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
34187198:	4b45      	ldr	r3, [pc, #276]	@ (341872b0 <JumpToApplication+0x15c>)
3418719a:	695b      	ldr	r3, [r3, #20]
3418719c:	4a44      	ldr	r2, [pc, #272]	@ (341872b0 <JumpToApplication+0x15c>)
3418719e:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
341871a2:	6153      	str	r3, [r2, #20]
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
341871a4:	4b42      	ldr	r3, [pc, #264]	@ (341872b0 <JumpToApplication+0x15c>)
341871a6:	2200      	movs	r2, #0
341871a8:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
341871ac:	f3bf 8f4f 	dsb	sy
}
341871b0:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
341871b2:	f3bf 8f6f 	isb	sy
}
341871b6:	bf00      	nop
}
341871b8:	bf00      	nop
  }
#endif /* defined(__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U) */

#if defined(__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
  /* if D-Cache is enabled, disable D-Cache-----------------------------------*/
  if (SCB->CCR & SCB_CCR_DC_Msk)
341871ba:	4b3d      	ldr	r3, [pc, #244]	@ (341872b0 <JumpToApplication+0x15c>)
341871bc:	695b      	ldr	r3, [r3, #20]
341871be:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
341871c2:	2b00      	cmp	r3, #0
341871c4:	d043      	beq.n	3418724e <JumpToApplication+0xfa>
    #if ((defined(__GNUC__) || defined(__clang__)) && !defined(__OPTIMIZE__))
       __ALIGNED(__SCB_DCACHE_LINE_SIZE)
    #endif
    ;

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
341871c6:	4b3a      	ldr	r3, [pc, #232]	@ (341872b0 <JumpToApplication+0x15c>)
341871c8:	2200      	movs	r2, #0
341871ca:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
341871ce:	f3bf 8f4f 	dsb	sy
}
341871d2:	bf00      	nop
    __DSB();

    SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
341871d4:	4b36      	ldr	r3, [pc, #216]	@ (341872b0 <JumpToApplication+0x15c>)
341871d6:	695b      	ldr	r3, [r3, #20]
341871d8:	4a35      	ldr	r2, [pc, #212]	@ (341872b0 <JumpToApplication+0x15c>)
341871da:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
341871de:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
341871e0:	f3bf 8f4f 	dsb	sy
}
341871e4:	bf00      	nop
    /* As we can't align the stack to the cache line size, invalidate each of the variables */
      SCB->DCCIMVAC = (uint32_t)&locals.sets;
      SCB->DCCIMVAC = (uint32_t)&locals.ways;
      SCB->DCCIMVAC = (uint32_t)&locals.ccsidr;
    #else
      SCB->DCCIMVAC = (uint32_t)&locals;
341871e6:	4b32      	ldr	r3, [pc, #200]	@ (341872b0 <JumpToApplication+0x15c>)
341871e8:	4622      	mov	r2, r4
341871ea:	f8c3 2270 	str.w	r2, [r3, #624]	@ 0x270
  __ASM volatile ("dsb 0xF":::"memory");
341871ee:	f3bf 8f4f 	dsb	sy
}
341871f2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
341871f4:	f3bf 8f6f 	isb	sy
}
341871f8:	bf00      	nop
    #endif
      __DSB();
      __ISB();
    #endif

    locals.ccsidr = SCB->CCSIDR;
341871fa:	4b2d      	ldr	r3, [pc, #180]	@ (341872b0 <JumpToApplication+0x15c>)
341871fc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187200:	6023      	str	r3, [r4, #0]
                                            /* clean & invalidate D-Cache */
    locals.sets = (uint32_t)(CCSIDR_SETS(locals.ccsidr));
34187202:	6823      	ldr	r3, [r4, #0]
34187204:	0b5b      	lsrs	r3, r3, #13
34187206:	f3c3 030e 	ubfx	r3, r3, #0, #15
3418720a:	6063      	str	r3, [r4, #4]
    do {
      locals.ways = (uint32_t)(CCSIDR_WAYS(locals.ccsidr));
3418720c:	6823      	ldr	r3, [r4, #0]
3418720e:	08db      	lsrs	r3, r3, #3
34187210:	f3c3 0309 	ubfx	r3, r3, #0, #10
34187214:	60a3      	str	r3, [r4, #8]
      do {
        SCB->DCCISW = (((locals.sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
34187216:	6863      	ldr	r3, [r4, #4]
34187218:	015a      	lsls	r2, r3, #5
3418721a:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
3418721e:	4013      	ands	r3, r2
                       ((locals.ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
34187220:	68a2      	ldr	r2, [r4, #8]
34187222:	0792      	lsls	r2, r2, #30
        SCB->DCCISW = (((locals.sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
34187224:	4922      	ldr	r1, [pc, #136]	@ (341872b0 <JumpToApplication+0x15c>)
34187226:	4313      	orrs	r3, r2
34187228:	f8c1 3274 	str.w	r3, [r1, #628]	@ 0x274
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (locals.ways-- != 0U);
3418722c:	68a3      	ldr	r3, [r4, #8]
3418722e:	1e5a      	subs	r2, r3, #1
34187230:	60a2      	str	r2, [r4, #8]
34187232:	2b00      	cmp	r3, #0
34187234:	d1ef      	bne.n	34187216 <JumpToApplication+0xc2>
    } while(locals.sets-- != 0U);
34187236:	6863      	ldr	r3, [r4, #4]
34187238:	1e5a      	subs	r2, r3, #1
3418723a:	6062      	str	r2, [r4, #4]
3418723c:	2b00      	cmp	r3, #0
3418723e:	d1e5      	bne.n	3418720c <JumpToApplication+0xb8>
  __ASM volatile ("dsb 0xF":::"memory");
34187240:	f3bf 8f4f 	dsb	sy
}
34187244:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34187246:	f3bf 8f6f 	isb	sy
}
3418724a:	bf00      	nop

    __DSB();
    __ISB();
  #endif
}
3418724c:	bf00      	nop
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
3418724e:	f3ef 8310 	mrs	r3, PRIMASK
34187252:	62fb      	str	r3, [r7, #44]	@ 0x2c
  return(result);
34187254:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    SCB_DisableDCache();
  }
#endif /* defined(__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U) */

  /* Initialize user application's Stack Pointer & Jump to user application  */
  primask_bit = __get_PRIMASK();
34187256:	63fb      	str	r3, [r7, #60]	@ 0x3c
  __ASM volatile ("cpsid i" : : : "memory");
34187258:	b672      	cpsid	i
}
3418725a:	bf00      	nop
  __disable_irq();

  /* Apply offsets for image location and vector table offset */
  Application_vector += EXTMEM_XIP_IMAGE_OFFSET + EXTMEM_HEADER_OFFSET;
3418725c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418725e:	f503 1380 	add.w	r3, r3, #1048576	@ 0x100000
34187262:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34187266:	62bb      	str	r3, [r7, #40]	@ 0x28

  SCB->VTOR = (uint32_t)Application_vector;
34187268:	4a11      	ldr	r2, [pc, #68]	@ (341872b0 <JumpToApplication+0x15c>)
3418726a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418726c:	6093      	str	r3, [r2, #8]
  JumpToApp = (pFunction) (*(__IO uint32_t *)(Application_vector + 4u));
3418726e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34187270:	3304      	adds	r3, #4
34187272:	681b      	ldr	r3, [r3, #0]
34187274:	461a      	mov	r2, r3
34187276:	4b0f      	ldr	r3, [pc, #60]	@ (341872b4 <JumpToApplication+0x160>)
34187278:	601a      	str	r2, [r3, #0]
3418727a:	2300      	movs	r3, #0
3418727c:	633b      	str	r3, [r7, #48]	@ 0x30
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
3418727e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34187280:	f383 880a 	msr	MSPLIM, r3
#endif
}
34187284:	bf00      	nop
     (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
  /* on ARM v8m, set MSPLIM before setting MSP to avoid unwanted stack overflow faults */
  __set_MSPLIM(0x00000000);
#endif  /* __ARM_ARCH_8M_MAIN__ or __ARM_ARCH_8M_BASE__ */

  __set_MSP(*(__IO uint32_t*) Application_vector);
34187286:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34187288:	681b      	ldr	r3, [r3, #0]
3418728a:	637b      	str	r3, [r7, #52]	@ 0x34
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
3418728c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3418728e:	f383 8808 	msr	MSP, r3
}
34187292:	bf00      	nop
34187294:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34187296:	63bb      	str	r3, [r7, #56]	@ 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
34187298:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418729a:	f383 8810 	msr	PRIMASK, r3
}
3418729e:	bf00      	nop

  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);

  JumpToApp();
341872a0:	4b04      	ldr	r3, [pc, #16]	@ (341872b4 <JumpToApplication+0x160>)
341872a2:	681b      	ldr	r3, [r3, #0]
341872a4:	4798      	blx	r3
  return BOOT_OK;
341872a6:	2300      	movs	r3, #0
}
341872a8:	4618      	mov	r0, r3
341872aa:	3744      	adds	r7, #68	@ 0x44
341872ac:	46bd      	mov	sp, r7
341872ae:	bd90      	pop	{r4, r7, pc}
341872b0:	e000ed00 	.word	0xe000ed00
341872b4:	341c00fc 	.word	0x341c00fc

341872b8 <EXTMEM_Init>:
/** @defgroup EXTMEM_Exported_Functions External Memory Exported Functions
  * @{
  */

EXTMEM_StatusTypeDef EXTMEM_Init(uint32_t MemId, uint32_t ClockInput)
{
341872b8:	b580      	push	{r7, lr}
341872ba:	b084      	sub	sp, #16
341872bc:	af00      	add	r7, sp, #0
341872be:	6078      	str	r0, [r7, #4]
341872c0:	6039      	str	r1, [r7, #0]
  EXTMEM_StatusTypeDef retr = EXTMEM_ERROR_INVALID_ID;
341872c2:	23fb      	movs	r3, #251	@ 0xfb
341872c4:	73fb      	strb	r3, [r7, #15]
  EXTMEM_FUNC_CALL();

  /* control the memory ID */
  if (MemId < (sizeof(extmem_list_config) / sizeof(EXTMEM_DefinitionTypeDef)))
341872c6:	687b      	ldr	r3, [r7, #4]
341872c8:	2b00      	cmp	r3, #0
341872ca:	d12f      	bne.n	3418732c <EXTMEM_Init+0x74>
  {
    retr = EXTMEM_OK;
341872cc:	2300      	movs	r3, #0
341872ce:	73fb      	strb	r3, [r7, #15]
    switch (extmem_list_config[MemId].MemType)
341872d0:	4919      	ldr	r1, [pc, #100]	@ (34187338 <EXTMEM_Init+0x80>)
341872d2:	687a      	ldr	r2, [r7, #4]
341872d4:	4613      	mov	r3, r2
341872d6:	009b      	lsls	r3, r3, #2
341872d8:	4413      	add	r3, r2
341872da:	009b      	lsls	r3, r3, #2
341872dc:	440b      	add	r3, r1
341872de:	781b      	ldrb	r3, [r3, #0]
341872e0:	2b04      	cmp	r3, #4
341872e2:	d120      	bne.n	34187326 <EXTMEM_Init+0x6e>
#endif /* EXTMEM_DRIVER_PSRAM == 1 */
#if EXTMEM_DRIVER_USER == 1
    case EXTMEM_USER :{
      /* Initialize the SFDP memory */
      EXTMEM_DRIVER_USER_StatusTypeDef status;
      status = EXTMEM_DRIVER_USER_Init(MemId,
341872e4:	687a      	ldr	r2, [r7, #4]
341872e6:	4613      	mov	r3, r2
341872e8:	009b      	lsls	r3, r3, #2
341872ea:	4413      	add	r3, r2
341872ec:	009b      	lsls	r3, r3, #2
341872ee:	3308      	adds	r3, #8
341872f0:	4a11      	ldr	r2, [pc, #68]	@ (34187338 <EXTMEM_Init+0x80>)
341872f2:	4413      	add	r3, r2
341872f4:	3304      	adds	r3, #4
341872f6:	4619      	mov	r1, r3
341872f8:	6878      	ldr	r0, [r7, #4]
341872fa:	f000 f8f1 	bl	341874e0 <EXTMEM_DRIVER_USER_Init>
341872fe:	4603      	mov	r3, r0
34187300:	73bb      	strb	r3, [r7, #14]
                                       &extmem_list_config[MemId].UserObject);
      switch(status){
34187302:	f997 300e 	ldrsb.w	r3, [r7, #14]
34187306:	f113 0f80 	cmn.w	r3, #128	@ 0x80
3418730a:	d002      	beq.n	34187312 <EXTMEM_Init+0x5a>
3418730c:	2b00      	cmp	r3, #0
3418730e:	d003      	beq.n	34187318 <EXTMEM_Init+0x60>
34187310:	e005      	b.n	3418731e <EXTMEM_Init+0x66>
      case EXTMEM_DRIVER_USER_NOTSUPPORTED:{
        retr = EXTMEM_ERROR_NOTSUPPORTED;
34187312:	23ff      	movs	r3, #255	@ 0xff
34187314:	73fb      	strb	r3, [r7, #15]
        break;
34187316:	e005      	b.n	34187324 <EXTMEM_Init+0x6c>
      }
      case EXTMEM_DRIVER_USER_OK:{
        /* nothing to do */
        retr = EXTMEM_OK;
34187318:	2300      	movs	r3, #0
3418731a:	73fb      	strb	r3, [r7, #15]
        break;
3418731c:	e002      	b.n	34187324 <EXTMEM_Init+0x6c>
      }
      default:{
        retr = EXTMEM_ERROR_DRIVER;
3418731e:	23fd      	movs	r3, #253	@ 0xfd
34187320:	73fb      	strb	r3, [r7, #15]
        break;
34187322:	bf00      	nop
      }
      }
      break;
34187324:	e002      	b.n	3418732c <EXTMEM_Init+0x74>
    }
#endif /* EXTMEM_DRIVER_USER == 1 */
    default:{
        EXTMEM_DEBUG("\terror unknown type\n");
        retr = EXTMEM_ERROR_UNKNOWNMEMORY;
34187326:	23fe      	movs	r3, #254	@ 0xfe
34187328:	73fb      	strb	r3, [r7, #15]
        break;
3418732a:	bf00      	nop
      }
    }
  }
  return retr;
3418732c:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
34187330:	4618      	mov	r0, r3
34187332:	3710      	adds	r7, #16
34187334:	46bd      	mov	sp, r7
34187336:	bd80      	pop	{r7, pc}
34187338:	341c0100 	.word	0x341c0100

3418733c <EXTMEM_DeInit>:

EXTMEM_StatusTypeDef EXTMEM_DeInit(uint32_t MemId)
{
3418733c:	b580      	push	{r7, lr}
3418733e:	b084      	sub	sp, #16
34187340:	af00      	add	r7, sp, #0
34187342:	6078      	str	r0, [r7, #4]
  EXTMEM_StatusTypeDef retr = EXTMEM_ERROR_INVALID_ID;
34187344:	23fb      	movs	r3, #251	@ 0xfb
34187346:	73fb      	strb	r3, [r7, #15]
  EXTMEM_FUNC_CALL();

  /* control the memory ID */
  if (MemId < (sizeof(extmem_list_config) / sizeof(EXTMEM_DefinitionTypeDef)))
34187348:	687b      	ldr	r3, [r7, #4]
3418734a:	2b00      	cmp	r3, #0
3418734c:	d12c      	bne.n	341873a8 <EXTMEM_DeInit+0x6c>
  {
    retr = EXTMEM_OK;
3418734e:	2300      	movs	r3, #0
34187350:	73fb      	strb	r3, [r7, #15]
    switch (extmem_list_config[MemId].MemType)
34187352:	4918      	ldr	r1, [pc, #96]	@ (341873b4 <EXTMEM_DeInit+0x78>)
34187354:	687a      	ldr	r2, [r7, #4]
34187356:	4613      	mov	r3, r2
34187358:	009b      	lsls	r3, r3, #2
3418735a:	4413      	add	r3, r2
3418735c:	009b      	lsls	r3, r3, #2
3418735e:	440b      	add	r3, r1
34187360:	781b      	ldrb	r3, [r3, #0]
34187362:	2b04      	cmp	r3, #4
34187364:	d11d      	bne.n	341873a2 <EXTMEM_DeInit+0x66>
      }
#endif /* EXTMEM_DRIVER_PSRAM == 1 */
#if EXTMEM_DRIVER_USER == 1
    case EXTMEM_USER :{
      /* Initialize the SFDP memory */
      EXTMEM_DRIVER_USER_StatusTypeDef status = EXTMEM_DRIVER_USER_DeInit(&extmem_list_config[MemId].UserObject);
34187366:	687a      	ldr	r2, [r7, #4]
34187368:	4613      	mov	r3, r2
3418736a:	009b      	lsls	r3, r3, #2
3418736c:	4413      	add	r3, r2
3418736e:	009b      	lsls	r3, r3, #2
34187370:	3308      	adds	r3, #8
34187372:	4a10      	ldr	r2, [pc, #64]	@ (341873b4 <EXTMEM_DeInit+0x78>)
34187374:	4413      	add	r3, r2
34187376:	3304      	adds	r3, #4
34187378:	4618      	mov	r0, r3
3418737a:	f000 f8c6 	bl	3418750a <EXTMEM_DRIVER_USER_DeInit>
3418737e:	4603      	mov	r3, r0
34187380:	73bb      	strb	r3, [r7, #14]
      switch(status){
34187382:	f997 300e 	ldrsb.w	r3, [r7, #14]
34187386:	f113 0f80 	cmn.w	r3, #128	@ 0x80
3418738a:	d002      	beq.n	34187392 <EXTMEM_DeInit+0x56>
3418738c:	2b00      	cmp	r3, #0
3418738e:	d006      	beq.n	3418739e <EXTMEM_DeInit+0x62>
34187390:	e002      	b.n	34187398 <EXTMEM_DeInit+0x5c>
      case EXTMEM_DRIVER_USER_NOTSUPPORTED:
        retr = EXTMEM_ERROR_NOTSUPPORTED;
34187392:	23ff      	movs	r3, #255	@ 0xff
34187394:	73fb      	strb	r3, [r7, #15]
        break;
34187396:	e003      	b.n	341873a0 <EXTMEM_DeInit+0x64>
      case EXTMEM_DRIVER_USER_OK:
        /* nothing to do, the returned status is already set to EXTMEM_OK */
        break;
      default:
        retr = EXTMEM_ERROR_DRIVER;
34187398:	23fd      	movs	r3, #253	@ 0xfd
3418739a:	73fb      	strb	r3, [r7, #15]
        break;
3418739c:	e000      	b.n	341873a0 <EXTMEM_DeInit+0x64>
        break;
3418739e:	bf00      	nop
      }
      break;
341873a0:	e002      	b.n	341873a8 <EXTMEM_DeInit+0x6c>
    }
#endif /* EXTMEM_DRIVER_USER == 1 */
      default:{
        EXTMEM_DEBUG("\terror unknown type\n");
        retr = EXTMEM_ERROR_UNKNOWNMEMORY;
341873a2:	23fe      	movs	r3, #254	@ 0xfe
341873a4:	73fb      	strb	r3, [r7, #15]
        break;
341873a6:	bf00      	nop
      }
    }
  }
  return retr;
341873a8:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
341873ac:	4618      	mov	r0, r3
341873ae:	3710      	adds	r7, #16
341873b0:	46bd      	mov	sp, r7
341873b2:	bd80      	pop	{r7, pc}
341873b4:	341c0100 	.word	0x341c0100

341873b8 <EXTMEM_MemoryMappedMode>:
  }
  return retr;
}

EXTMEM_StatusTypeDef EXTMEM_MemoryMappedMode(uint32_t MemId, EXTMEM_StateTypeDef State)
{
341873b8:	b580      	push	{r7, lr}
341873ba:	b084      	sub	sp, #16
341873bc:	af00      	add	r7, sp, #0
341873be:	6078      	str	r0, [r7, #4]
341873c0:	460b      	mov	r3, r1
341873c2:	70fb      	strb	r3, [r7, #3]
  EXTMEM_StatusTypeDef retr = EXTMEM_ERROR_INVALID_ID;
341873c4:	23fb      	movs	r3, #251	@ 0xfb
341873c6:	73fb      	strb	r3, [r7, #15]
  EXTMEM_FUNC_CALL();
  /* control the memory ID */
  if (MemId < (sizeof(extmem_list_config) / sizeof(EXTMEM_DefinitionTypeDef)))
341873c8:	687b      	ldr	r3, [r7, #4]
341873ca:	2b00      	cmp	r3, #0
341873cc:	d143      	bne.n	34187456 <EXTMEM_MemoryMappedMode+0x9e>
  {
    retr = EXTMEM_OK;
341873ce:	2300      	movs	r3, #0
341873d0:	73fb      	strb	r3, [r7, #15]
    switch (extmem_list_config[MemId].MemType)
341873d2:	4924      	ldr	r1, [pc, #144]	@ (34187464 <EXTMEM_MemoryMappedMode+0xac>)
341873d4:	687a      	ldr	r2, [r7, #4]
341873d6:	4613      	mov	r3, r2
341873d8:	009b      	lsls	r3, r3, #2
341873da:	4413      	add	r3, r2
341873dc:	009b      	lsls	r3, r3, #2
341873de:	440b      	add	r3, r1
341873e0:	781b      	ldrb	r3, [r3, #0]
341873e2:	2b03      	cmp	r3, #3
341873e4:	d031      	beq.n	3418744a <EXTMEM_MemoryMappedMode+0x92>
341873e6:	2b04      	cmp	r3, #4
341873e8:	d132      	bne.n	34187450 <EXTMEM_MemoryMappedMode+0x98>
#endif /* EXTMEM_DRIVER_PSRAM == 1 */
#if EXTMEM_DRIVER_USER == 1
     case EXTMEM_USER :{
       /* Initialize the SFDP memory */
       EXTMEM_DRIVER_USER_StatusTypeDef status;
       if (EXTMEM_ENABLE == State)
341873ea:	78fb      	ldrb	r3, [r7, #3]
341873ec:	2b00      	cmp	r3, #0
341873ee:	d10e      	bne.n	3418740e <EXTMEM_MemoryMappedMode+0x56>
       {
         status = EXTMEM_DRIVER_USER_Enable_MemoryMappedMode(&extmem_list_config[MemId].UserObject);
341873f0:	687a      	ldr	r2, [r7, #4]
341873f2:	4613      	mov	r3, r2
341873f4:	009b      	lsls	r3, r3, #2
341873f6:	4413      	add	r3, r2
341873f8:	009b      	lsls	r3, r3, #2
341873fa:	3308      	adds	r3, #8
341873fc:	4a19      	ldr	r2, [pc, #100]	@ (34187464 <EXTMEM_MemoryMappedMode+0xac>)
341873fe:	4413      	add	r3, r2
34187400:	3304      	adds	r3, #4
34187402:	4618      	mov	r0, r3
34187404:	f000 f88f 	bl	34187526 <EXTMEM_DRIVER_USER_Enable_MemoryMappedMode>
34187408:	4603      	mov	r3, r0
3418740a:	73bb      	strb	r3, [r7, #14]
3418740c:	e00d      	b.n	3418742a <EXTMEM_MemoryMappedMode+0x72>
       }
       else
       {
         status = EXTMEM_DRIVER_USER_Disable_MemoryMappedMode(&extmem_list_config[MemId].UserObject);
3418740e:	687a      	ldr	r2, [r7, #4]
34187410:	4613      	mov	r3, r2
34187412:	009b      	lsls	r3, r3, #2
34187414:	4413      	add	r3, r2
34187416:	009b      	lsls	r3, r3, #2
34187418:	3308      	adds	r3, #8
3418741a:	4a12      	ldr	r2, [pc, #72]	@ (34187464 <EXTMEM_MemoryMappedMode+0xac>)
3418741c:	4413      	add	r3, r2
3418741e:	3304      	adds	r3, #4
34187420:	4618      	mov	r0, r3
34187422:	f000 f88e 	bl	34187542 <EXTMEM_DRIVER_USER_Disable_MemoryMappedMode>
34187426:	4603      	mov	r3, r0
34187428:	73bb      	strb	r3, [r7, #14]
       }
       switch(status){
3418742a:	f997 300e 	ldrsb.w	r3, [r7, #14]
3418742e:	f113 0f80 	cmn.w	r3, #128	@ 0x80
34187432:	d002      	beq.n	3418743a <EXTMEM_MemoryMappedMode+0x82>
34187434:	2b00      	cmp	r3, #0
34187436:	d006      	beq.n	34187446 <EXTMEM_MemoryMappedMode+0x8e>
34187438:	e002      	b.n	34187440 <EXTMEM_MemoryMappedMode+0x88>
       case EXTMEM_DRIVER_USER_NOTSUPPORTED:
         retr = EXTMEM_ERROR_NOTSUPPORTED;
3418743a:	23ff      	movs	r3, #255	@ 0xff
3418743c:	73fb      	strb	r3, [r7, #15]
         break;
3418743e:	e003      	b.n	34187448 <EXTMEM_MemoryMappedMode+0x90>
       case EXTMEM_DRIVER_USER_OK:
         break;
       default:
         retr = EXTMEM_ERROR_DRIVER;
34187440:	23fd      	movs	r3, #253	@ 0xfd
34187442:	73fb      	strb	r3, [r7, #15]
         break;
34187444:	e000      	b.n	34187448 <EXTMEM_MemoryMappedMode+0x90>
         break;
34187446:	bf00      	nop
       }
       break;
34187448:	e005      	b.n	34187456 <EXTMEM_MemoryMappedMode+0x9e>
    }
#endif /* EXTMEM_DRIVER_USER == 1 */
    case EXTMEM_SDCARD :
      retr = EXTMEM_ERROR_NOTSUPPORTED;
3418744a:	23ff      	movs	r3, #255	@ 0xff
3418744c:	73fb      	strb	r3, [r7, #15]
    break;
3418744e:	e002      	b.n	34187456 <EXTMEM_MemoryMappedMode+0x9e>
    default:{
        EXTMEM_DEBUG("\terror unknown type\n");
        retr = EXTMEM_ERROR_UNKNOWNMEMORY;
34187450:	23fe      	movs	r3, #254	@ 0xfe
34187452:	73fb      	strb	r3, [r7, #15]
        break;
34187454:	bf00      	nop
      }
    }
  }
  return retr;
34187456:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
3418745a:	4618      	mov	r0, r3
3418745c:	3710      	adds	r7, #16
3418745e:	46bd      	mov	sp, r7
34187460:	bd80      	pop	{r7, pc}
34187462:	bf00      	nop
34187464:	341c0100 	.word	0x341c0100

34187468 <EXTMEM_GetMapAddress>:

EXTMEM_StatusTypeDef EXTMEM_GetMapAddress(uint32_t MemId, uint32_t *BaseAddress)
{
34187468:	b580      	push	{r7, lr}
3418746a:	b084      	sub	sp, #16
3418746c:	af00      	add	r7, sp, #0
3418746e:	6078      	str	r0, [r7, #4]
34187470:	6039      	str	r1, [r7, #0]
  EXTMEM_StatusTypeDef retr = EXTMEM_ERROR_INVALID_ID;
34187472:	23fb      	movs	r3, #251	@ 0xfb
34187474:	73fb      	strb	r3, [r7, #15]
  EXTMEM_FUNC_CALL();
  /* control the memory ID */
  if (MemId < (sizeof(extmem_list_config) / sizeof(EXTMEM_DefinitionTypeDef)))
34187476:	687b      	ldr	r3, [r7, #4]
34187478:	2b00      	cmp	r3, #0
3418747a:	d129      	bne.n	341874d0 <EXTMEM_GetMapAddress+0x68>
  {
    retr = EXTMEM_OK;
3418747c:	2300      	movs	r3, #0
3418747e:	73fb      	strb	r3, [r7, #15]
    switch (extmem_list_config[MemId].MemType)
34187480:	4916      	ldr	r1, [pc, #88]	@ (341874dc <EXTMEM_GetMapAddress+0x74>)
34187482:	687a      	ldr	r2, [r7, #4]
34187484:	4613      	mov	r3, r2
34187486:	009b      	lsls	r3, r3, #2
34187488:	4413      	add	r3, r2
3418748a:	009b      	lsls	r3, r3, #2
3418748c:	440b      	add	r3, r1
3418748e:	781b      	ldrb	r3, [r3, #0]
34187490:	2b04      	cmp	r3, #4
34187492:	d11a      	bne.n	341874ca <EXTMEM_GetMapAddress+0x62>
        break;
      }
#endif /* EXTMEM_DRIVER_PSRAM == 1 */
#if EXTMEM_DRIVER_USER == 1
      case EXTMEM_USER:{
        switch(EXTMEM_DRIVER_USER_GetMapAddress(&extmem_list_config[MemId].UserObject, BaseAddress))
34187494:	687a      	ldr	r2, [r7, #4]
34187496:	4613      	mov	r3, r2
34187498:	009b      	lsls	r3, r3, #2
3418749a:	4413      	add	r3, r2
3418749c:	009b      	lsls	r3, r3, #2
3418749e:	3308      	adds	r3, #8
341874a0:	4a0e      	ldr	r2, [pc, #56]	@ (341874dc <EXTMEM_GetMapAddress+0x74>)
341874a2:	4413      	add	r3, r2
341874a4:	3304      	adds	r3, #4
341874a6:	6839      	ldr	r1, [r7, #0]
341874a8:	4618      	mov	r0, r3
341874aa:	f000 f858 	bl	3418755e <EXTMEM_DRIVER_USER_GetMapAddress>
341874ae:	4603      	mov	r3, r0
341874b0:	f113 0f80 	cmn.w	r3, #128	@ 0x80
341874b4:	d002      	beq.n	341874bc <EXTMEM_GetMapAddress+0x54>
341874b6:	2b00      	cmp	r3, #0
341874b8:	d103      	bne.n	341874c2 <EXTMEM_GetMapAddress+0x5a>
        {
          case EXTMEM_DRIVER_USER_OK:
          break;
341874ba:	e005      	b.n	341874c8 <EXTMEM_GetMapAddress+0x60>
          case EXTMEM_DRIVER_USER_NOTSUPPORTED:
            retr = EXTMEM_ERROR_NOTSUPPORTED;
341874bc:	23ff      	movs	r3, #255	@ 0xff
341874be:	73fb      	strb	r3, [r7, #15]
          break;
341874c0:	e002      	b.n	341874c8 <EXTMEM_GetMapAddress+0x60>
          default :
            retr = EXTMEM_ERROR_DRIVER;
341874c2:	23fd      	movs	r3, #253	@ 0xfd
341874c4:	73fb      	strb	r3, [r7, #15]
          break;
341874c6:	bf00      	nop
        }
      break;
341874c8:	e002      	b.n	341874d0 <EXTMEM_GetMapAddress+0x68>
      }
#endif /* EXTMEM_DRIVER_USER == 1 */
      default :
      {
        retr = EXTMEM_ERROR_UNKNOWNMEMORY;
341874ca:	23fe      	movs	r3, #254	@ 0xfe
341874cc:	73fb      	strb	r3, [r7, #15]
        break;
341874ce:	bf00      	nop
      }
    }
  }
  return retr;
341874d0:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
341874d4:	4618      	mov	r0, r3
341874d6:	3710      	adds	r7, #16
341874d8:	46bd      	mov	sp, r7
341874da:	bd80      	pop	{r7, pc}
341874dc:	341c0100 	.word	0x341c0100

341874e0 <EXTMEM_DRIVER_USER_Init>:
  * @{
  */

__weak EXTMEM_DRIVER_USER_StatusTypeDef EXTMEM_DRIVER_USER_Init(uint32_t MemoryId,
                                                         EXTMEM_DRIVER_USER_ObjectTypeDef* UserObject)
{
341874e0:	b480      	push	{r7}
341874e2:	b085      	sub	sp, #20
341874e4:	af00      	add	r7, sp, #0
341874e6:	6078      	str	r0, [r7, #4]
341874e8:	6039      	str	r1, [r7, #0]
  EXTMEM_DRIVER_USER_StatusTypeDef retr = EXTMEM_DRIVER_USER_NOTSUPPORTED;
341874ea:	2380      	movs	r3, #128	@ 0x80
341874ec:	73fb      	strb	r3, [r7, #15]
  UserObject->MemID = MemoryId;     /* Keep the memory id, could be used to control more than one user memory */
341874ee:	683b      	ldr	r3, [r7, #0]
341874f0:	687a      	ldr	r2, [r7, #4]
341874f2:	601a      	str	r2, [r3, #0]
  UserObject->PtrUserDriver = NULL; /* could be used to link data with the memory id */
341874f4:	683b      	ldr	r3, [r7, #0]
341874f6:	2200      	movs	r2, #0
341874f8:	605a      	str	r2, [r3, #4]
  return retr;
341874fa:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
341874fe:	4618      	mov	r0, r3
34187500:	3714      	adds	r7, #20
34187502:	46bd      	mov	sp, r7
34187504:	f85d 7b04 	ldr.w	r7, [sp], #4
34187508:	4770      	bx	lr

3418750a <EXTMEM_DRIVER_USER_DeInit>:

__weak EXTMEM_DRIVER_USER_StatusTypeDef EXTMEM_DRIVER_USER_DeInit(EXTMEM_DRIVER_USER_ObjectTypeDef* UserObject)
{
3418750a:	b480      	push	{r7}
3418750c:	b085      	sub	sp, #20
3418750e:	af00      	add	r7, sp, #0
34187510:	6078      	str	r0, [r7, #4]
  EXTMEM_DRIVER_USER_StatusTypeDef retr = EXTMEM_DRIVER_USER_NOTSUPPORTED;
34187512:	2380      	movs	r3, #128	@ 0x80
34187514:	73fb      	strb	r3, [r7, #15]
  (void)UserObject;
  return retr;
34187516:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
3418751a:	4618      	mov	r0, r3
3418751c:	3714      	adds	r7, #20
3418751e:	46bd      	mov	sp, r7
34187520:	f85d 7b04 	ldr.w	r7, [sp], #4
34187524:	4770      	bx	lr

34187526 <EXTMEM_DRIVER_USER_Enable_MemoryMappedMode>:
  (void)*UserObject;
  return retr;
}

__weak EXTMEM_DRIVER_USER_StatusTypeDef EXTMEM_DRIVER_USER_Enable_MemoryMappedMode(EXTMEM_DRIVER_USER_ObjectTypeDef* UserObject)
{
34187526:	b480      	push	{r7}
34187528:	b085      	sub	sp, #20
3418752a:	af00      	add	r7, sp, #0
3418752c:	6078      	str	r0, [r7, #4]
  EXTMEM_DRIVER_USER_StatusTypeDef retr = EXTMEM_DRIVER_USER_NOTSUPPORTED;
3418752e:	2380      	movs	r3, #128	@ 0x80
34187530:	73fb      	strb	r3, [r7, #15]
  (void)*UserObject;
  return retr;
34187532:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
34187536:	4618      	mov	r0, r3
34187538:	3714      	adds	r7, #20
3418753a:	46bd      	mov	sp, r7
3418753c:	f85d 7b04 	ldr.w	r7, [sp], #4
34187540:	4770      	bx	lr

34187542 <EXTMEM_DRIVER_USER_Disable_MemoryMappedMode>:

__weak EXTMEM_DRIVER_USER_StatusTypeDef EXTMEM_DRIVER_USER_Disable_MemoryMappedMode(EXTMEM_DRIVER_USER_ObjectTypeDef* UserObject)
{
34187542:	b480      	push	{r7}
34187544:	b085      	sub	sp, #20
34187546:	af00      	add	r7, sp, #0
34187548:	6078      	str	r0, [r7, #4]
  EXTMEM_DRIVER_USER_StatusTypeDef retr = EXTMEM_DRIVER_USER_NOTSUPPORTED;
3418754a:	2380      	movs	r3, #128	@ 0x80
3418754c:	73fb      	strb	r3, [r7, #15]
  (void)*UserObject;
  return retr;
3418754e:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
34187552:	4618      	mov	r0, r3
34187554:	3714      	adds	r7, #20
34187556:	46bd      	mov	sp, r7
34187558:	f85d 7b04 	ldr.w	r7, [sp], #4
3418755c:	4770      	bx	lr

3418755e <EXTMEM_DRIVER_USER_GetMapAddress>:

__weak EXTMEM_DRIVER_USER_StatusTypeDef EXTMEM_DRIVER_USER_GetMapAddress(EXTMEM_DRIVER_USER_ObjectTypeDef* UserObject, uint32_t* BaseAddress)
{
3418755e:	b480      	push	{r7}
34187560:	b085      	sub	sp, #20
34187562:	af00      	add	r7, sp, #0
34187564:	6078      	str	r0, [r7, #4]
34187566:	6039      	str	r1, [r7, #0]
  EXTMEM_DRIVER_USER_StatusTypeDef retr = EXTMEM_DRIVER_USER_NOTSUPPORTED;
34187568:	2380      	movs	r3, #128	@ 0x80
3418756a:	73fb      	strb	r3, [r7, #15]
  (void)*UserObject;
  (void)BaseAddress;
  return retr;
3418756c:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
34187570:	4618      	mov	r0, r3
34187572:	3714      	adds	r7, #20
34187574:	46bd      	mov	sp, r7
34187576:	f85d 7b04 	ldr.w	r7, [sp], #4
3418757a:	4770      	bx	lr

3418757c <memset>:
3418757c:	4402      	add	r2, r0
3418757e:	4603      	mov	r3, r0
34187580:	4293      	cmp	r3, r2
34187582:	d100      	bne.n	34187586 <memset+0xa>
34187584:	4770      	bx	lr
34187586:	f803 1b01 	strb.w	r1, [r3], #1
3418758a:	e7f9      	b.n	34187580 <memset+0x4>

3418758c <__libc_init_array>:
3418758c:	b570      	push	{r4, r5, r6, lr}
3418758e:	4d0d      	ldr	r5, [pc, #52]	@ (341875c4 <__libc_init_array+0x38>)
34187590:	2600      	movs	r6, #0
34187592:	4c0d      	ldr	r4, [pc, #52]	@ (341875c8 <__libc_init_array+0x3c>)
34187594:	1b64      	subs	r4, r4, r5
34187596:	10a4      	asrs	r4, r4, #2
34187598:	42a6      	cmp	r6, r4
3418759a:	d109      	bne.n	341875b0 <__libc_init_array+0x24>
3418759c:	4d0b      	ldr	r5, [pc, #44]	@ (341875cc <__libc_init_array+0x40>)
3418759e:	2600      	movs	r6, #0
341875a0:	4c0b      	ldr	r4, [pc, #44]	@ (341875d0 <__libc_init_array+0x44>)
341875a2:	f000 f817 	bl	341875d4 <_init>
341875a6:	1b64      	subs	r4, r4, r5
341875a8:	10a4      	asrs	r4, r4, #2
341875aa:	42a6      	cmp	r6, r4
341875ac:	d105      	bne.n	341875ba <__libc_init_array+0x2e>
341875ae:	bd70      	pop	{r4, r5, r6, pc}
341875b0:	f855 3b04 	ldr.w	r3, [r5], #4
341875b4:	3601      	adds	r6, #1
341875b6:	4798      	blx	r3
341875b8:	e7ee      	b.n	34187598 <__libc_init_array+0xc>
341875ba:	f855 3b04 	ldr.w	r3, [r5], #4
341875be:	3601      	adds	r6, #1
341875c0:	4798      	blx	r3
341875c2:	e7f2      	b.n	341875aa <__libc_init_array+0x1e>
341875c4:	341875ec 	.word	0x341875ec
341875c8:	341875ec 	.word	0x341875ec
341875cc:	341875ec 	.word	0x341875ec
341875d0:	341875f0 	.word	0x341875f0

341875d4 <_init>:
341875d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341875d6:	bf00      	nop
341875d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
341875da:	bc08      	pop	{r3}
341875dc:	469e      	mov	lr, r3
341875de:	4770      	bx	lr

341875e0 <_fini>:
341875e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341875e2:	bf00      	nop
341875e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
341875e6:	bc08      	pop	{r3}
341875e8:	469e      	mov	lr, r3
341875ea:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

34187600 <SECURE_SystemCoreClockUpdate>:
34187600:	e97f e97f 	sg
34187604:	f7f9 be66 	b.w	341812d4 <__acle_se_SECURE_SystemCoreClockUpdate>
	...
