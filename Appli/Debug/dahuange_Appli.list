
dahuange_Appli.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000eb64  34000750  34000750  00000750  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00004838  3400f2b8  3400f2b8  0000f2b8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .version      0000000c  34013af0  34013af0  00013af0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  34013afc  34013afc  00013c80  2**0
                  CONTENTS, READONLY
  5 .ARM          00000008  34013afc  34013afc  00013afc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  34013b04  34013c80  00013c80  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  34013b04  34013b04  00013b04  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .fini_array   00000004  34013b08  34013b08  00013b08  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .data         0000013c  34013b0c  34013b0c  00013b0c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .noncacheable 00000000  34013c48  34013c48  00013c80  2**0
                  CONTENTS
 11 .gnu.sgstubs  00000020  34013c60  34013c60  00013c60  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .bss          000bc948  34013c80  34013c80  00013c80  2**3
                  ALLOC
 13 .EXTRAM       00339000  90000000  90000000  00014000  2**5
                  ALLOC
 14 ._user_heap_stack 00000a00  340d05c8  340d05c8  00013c80  2**0
                  ALLOC
 15 .EXTRAM       00000000  90339000  90339000  00013c80  2**0
                  CONTENTS
 16 .ARM.attributes 0000003a  00000000  00000000  00013c80  2**0
                  CONTENTS, READONLY
 17 .debug_info   00060582  00000000  00000000  00013cba  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_abbrev 00009591  00000000  00000000  0007423c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_aranges 00002b20  00000000  00000000  0007d7d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  0007025e  00000000  00000000  000802f0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0004ec4a  00000000  00000000  000f054e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    002f4d7f  00000000  00000000  0013f198  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000086  00000000  00000000  00433f17  2**0
                  CONTENTS, READONLY
 24 .debug_loclists 0001da76  00000000  00000000  00433f9d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_rnglists 000031c3  00000000  00000000  00451a13  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 26 .debug_frame  00008378  00000000  00000000  00454bd8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 27 .debug_line_str 00000041  00000000  00000000  0045cf50  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

34000750 <__do_global_dtors_aux>:
34000750:	b510      	push	{r4, lr}
34000752:	4c05      	ldr	r4, [pc, #20]	@ (34000768 <__do_global_dtors_aux+0x18>)
34000754:	7823      	ldrb	r3, [r4, #0]
34000756:	b933      	cbnz	r3, 34000766 <__do_global_dtors_aux+0x16>
34000758:	4b04      	ldr	r3, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x1c>)
3400075a:	b113      	cbz	r3, 34000762 <__do_global_dtors_aux+0x12>
3400075c:	4804      	ldr	r0, [pc, #16]	@ (34000770 <__do_global_dtors_aux+0x20>)
3400075e:	f3af 8000 	nop.w
34000762:	2301      	movs	r3, #1
34000764:	7023      	strb	r3, [r4, #0]
34000766:	bd10      	pop	{r4, pc}
34000768:	34013c80 	.word	0x34013c80
3400076c:	00000000 	.word	0x00000000
34000770:	3400f29c 	.word	0x3400f29c

34000774 <frame_dummy>:
34000774:	b508      	push	{r3, lr}
34000776:	4b03      	ldr	r3, [pc, #12]	@ (34000784 <frame_dummy+0x10>)
34000778:	b11b      	cbz	r3, 34000782 <frame_dummy+0xe>
3400077a:	4903      	ldr	r1, [pc, #12]	@ (34000788 <frame_dummy+0x14>)
3400077c:	4803      	ldr	r0, [pc, #12]	@ (3400078c <frame_dummy+0x18>)
3400077e:	f3af 8000 	nop.w
34000782:	bd08      	pop	{r3, pc}
34000784:	00000000 	.word	0x00000000
34000788:	34013c84 	.word	0x34013c84
3400078c:	3400f29c 	.word	0x3400f29c

34000790 <evision_api_st_ae_new>:
34000790:	b510      	push	{r4, lr}
34000792:	4604      	mov	r4, r0
34000794:	b090      	sub	sp, #64	@ 0x40
34000796:	b160      	cbz	r0, 340007b2 <evision_api_st_ae_new+0x22>
34000798:	2300      	movs	r3, #0
3400079a:	4c07      	ldr	r4, [pc, #28]	@ (340007b8 <evision_api_st_ae_new+0x28>)
3400079c:	2140      	movs	r1, #64	@ 0x40
3400079e:	7023      	strb	r3, [r4, #0]
340007a0:	65a0      	str	r0, [r4, #88]	@ 0x58
340007a2:	4b06      	ldr	r3, [pc, #24]	@ (340007bc <evision_api_st_ae_new+0x2c>)
340007a4:	4668      	mov	r0, sp
340007a6:	4a06      	ldr	r2, [pc, #24]	@ (340007c0 <evision_api_st_ae_new+0x30>)
340007a8:	f00c ff8c 	bl	3400d6c4 <sniprintf>
340007ac:	4668      	mov	r0, sp
340007ae:	6da3      	ldr	r3, [r4, #88]	@ 0x58
340007b0:	4798      	blx	r3
340007b2:	4620      	mov	r0, r4
340007b4:	b010      	add	sp, #64	@ 0x40
340007b6:	bd10      	pop	{r4, pc}
340007b8:	34013ca0 	.word	0x34013ca0
340007bc:	34013af0 	.word	0x34013af0
340007c0:	340109bf 	.word	0x340109bf

340007c4 <evision_api_st_ae_delete>:
340007c4:	2800      	cmp	r0, #0
340007c6:	bf14      	ite	ne
340007c8:	2001      	movne	r0, #1
340007ca:	f04f 30ff 	moveq.w	r0, #4294967295
340007ce:	4770      	bx	lr

340007d0 <sTiPARvPaB>:
340007d0:	2238      	movs	r2, #56	@ 0x38
340007d2:	230a      	movs	r3, #10
340007d4:	e9c0 2304 	strd	r2, r3, [r0, #16]
340007d8:	2364      	movs	r3, #100	@ 0x64
340007da:	222d      	movs	r2, #45	@ 0x2d
340007dc:	2178      	movs	r1, #120	@ 0x78
340007de:	e9c0 3206 	strd	r3, r2, [r0, #24]
340007e2:	f240 52dc 	movw	r2, #1500	@ 0x5dc
340007e6:	b530      	push	{r4, r5, lr}
340007e8:	e9c0 1208 	strd	r1, r2, [r0, #32]
340007ec:	f241 7470 	movw	r4, #6000	@ 0x1770
340007f0:	f642 62e0 	movw	r2, #12000	@ 0x2ee0
340007f4:	e9c0 420a 	strd	r4, r2, [r0, #40]	@ 0x28
340007f8:	a50b      	add	r5, pc, #44	@ (adr r5, 34000828 <sTiPARvPaB+0x58>)
340007fa:	e9d5 4500 	ldrd	r4, r5, [r5]
340007fe:	2205      	movs	r2, #5
34000800:	f04f 0c00 	mov.w	ip, #0
34000804:	6502      	str	r2, [r0, #80]	@ 0x50
34000806:	f248 02e8 	movw	r2, #33000	@ 0x80e8
3400080a:	e9c0 c210 	strd	ip, r2, [r0, #64]	@ 0x40
3400080e:	2201      	movs	r2, #1
34000810:	e9c0 450c 	strd	r4, r5, [r0, #48]	@ 0x30
34000814:	a506      	add	r5, pc, #24	@ (adr r5, 34000830 <sTiPARvPaB+0x60>)
34000816:	e9d5 4500 	ldrd	r4, r5, [r5]
3400081a:	e9c0 2312 	strd	r2, r3, [r0, #72]	@ 0x48
3400081e:	e9c0 450e 	strd	r4, r5, [r0, #56]	@ 0x38
34000822:	bd30      	pop	{r4, r5, pc}
34000824:	f3af 8000 	nop.w
34000828:	40000000 	.word	0x40000000
3400082c:	3f947ae1 	.word	0x3f947ae1
34000830:	e0000000 	.word	0xe0000000
34000834:	3f70624d 	.word	0x3f70624d

34000838 <evision_api_st_ae_init>:
34000838:	b510      	push	{r4, lr}
3400083a:	4604      	mov	r4, r0
3400083c:	b120      	cbz	r0, 34000848 <evision_api_st_ae_init+0x10>
3400083e:	f7ff ffc7 	bl	340007d0 <sTiPARvPaB>
34000842:	2001      	movs	r0, #1
34000844:	7020      	strb	r0, [r4, #0]
34000846:	bd10      	pop	{r4, pc}
34000848:	f04f 30ff 	mov.w	r0, #4294967295
3400084c:	e7fb      	b.n	34000846 <evision_api_st_ae_init+0xe>

3400084e <evision_api_st_ae_process>:
3400084e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34000852:	460e      	mov	r6, r1
34000854:	4604      	mov	r4, r0
34000856:	2800      	cmp	r0, #0
34000858:	f000 80e1 	beq.w	34000a1e <evision_api_st_ae_process+0x1d0>
3400085c:	7801      	ldrb	r1, [r0, #0]
3400085e:	2901      	cmp	r1, #1
34000860:	d10b      	bne.n	3400087a <evision_api_st_ae_process+0x2c>
34000862:	2102      	movs	r1, #2
34000864:	7001      	strb	r1, [r0, #0]
34000866:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34000868:	e9c4 2601 	strd	r2, r6, [r4, #4]
3400086c:	42b5      	cmp	r5, r6
3400086e:	d208      	bcs.n	34000882 <evision_api_st_ae_process+0x34>
34000870:	6c61      	ldr	r1, [r4, #68]	@ 0x44
34000872:	4291      	cmp	r1, r2
34000874:	d905      	bls.n	34000882 <evision_api_st_ae_process+0x34>
34000876:	60a5      	str	r5, [r4, #8]
34000878:	e04c      	b.n	34000914 <evision_api_st_ae_process+0xc6>
3400087a:	2902      	cmp	r1, #2
3400087c:	d0f3      	beq.n	34000866 <evision_api_st_ae_process+0x18>
3400087e:	2000      	movs	r0, #0
34000880:	e049      	b.n	34000916 <evision_api_st_ae_process+0xc8>
34000882:	f8d4 c010 	ldr.w	ip, [r4, #16]
34000886:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
3400088a:	ee07 ca90 	vmov	s15, ip
3400088e:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34000892:	ee07 3a90 	vmov	s15, r3
34000896:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3400089a:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
3400089e:	ee37 7b05 	vadd.f64	d7, d7, d5
340008a2:	ee86 0b07 	vdiv.f64	d0, d6, d7
340008a6:	6d21      	ldr	r1, [r4, #80]	@ 0x50
340008a8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
340008ac:	428b      	cmp	r3, r1
340008ae:	d24b      	bcs.n	34000948 <evision_api_st_ae_process+0xfa>
340008b0:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
340008b4:	eeb4 0ae7 	vcmpe.f32	s0, s15
340008b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008bc:	d444      	bmi.n	34000948 <evision_api_st_ae_process+0xfa>
340008be:	6c61      	ldr	r1, [r4, #68]	@ 0x44
340008c0:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
340008c4:	428a      	cmp	r2, r1
340008c6:	d220      	bcs.n	3400090a <evision_api_st_ae_process+0xbc>
340008c8:	2a01      	cmp	r2, #1
340008ca:	4613      	mov	r3, r2
340008cc:	bf38      	it	cc
340008ce:	2301      	movcc	r3, #1
340008d0:	ee07 3a90 	vmov	s15, r3
340008d4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340008d8:	ee67 7a80 	vmul.f32	s15, s15, s0
340008dc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340008e0:	ee17 3a90 	vmov	r3, s15
340008e4:	428b      	cmp	r3, r1
340008e6:	bfc1      	itttt	gt
340008e8:	ee07 1a90 	vmovgt	s15, r1
340008ec:	eeb8 6ae7 	vcvtgt.f32.s32	s12, s15
340008f0:	ee07 2a90 	vmovgt	s15, r2
340008f4:	eef8 6a67 	vcvtgt.f32.u32	s13, s15
340008f8:	bfc3      	ittte	gt
340008fa:	eec6 7a26 	vdivgt.f32	s15, s12, s13
340008fe:	460b      	movgt	r3, r1
34000900:	ee80 0a27 	vdivgt.f32	s0, s0, s15
34000904:	eeb0 0a47 	vmovle.f32	s0, s14
34000908:	6063      	str	r3, [r4, #4]
3400090a:	eeb4 0ac7 	vcmpe.f32	s0, s14
3400090e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000912:	dc02      	bgt.n	3400091a <evision_api_st_ae_process+0xcc>
34000914:	2001      	movs	r0, #1
34000916:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3400091a:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
3400091e:	f00d fdf3 	bl	3400e508 <log10>
34000922:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
34000926:	ee20 0b07 	vmul.f64	d0, d0, d7
3400092a:	ed9f 7b3f 	vldr	d7, [pc, #252]	@ 34000a28 <evision_api_st_ae_process+0x1da>
3400092e:	ee20 0b07 	vmul.f64	d0, d0, d7
34000932:	eebd 0bc0 	vcvt.s32.f64	s0, d0
34000936:	ee10 3a10 	vmov	r3, s0
3400093a:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
3400093c:	4433      	add	r3, r6
3400093e:	4293      	cmp	r3, r2
34000940:	bfd4      	ite	le
34000942:	60a3      	strle	r3, [r4, #8]
34000944:	60a2      	strgt	r2, [r4, #8]
34000946:	e7e5      	b.n	34000914 <evision_api_st_ae_process+0xc6>
34000948:	ebac 0703 	sub.w	r7, ip, r3
3400094c:	69e1      	ldr	r1, [r4, #28]
3400094e:	ea87 70e7 	eor.w	r0, r7, r7, asr #31
34000952:	eba0 70e7 	sub.w	r0, r0, r7, asr #31
34000956:	4288      	cmp	r0, r1
34000958:	d847      	bhi.n	340009ea <evision_api_st_ae_process+0x19c>
3400095a:	6a60      	ldr	r0, [r4, #36]	@ 0x24
3400095c:	f8d4 e014 	ldr.w	lr, [r4, #20]
34000960:	69a1      	ldr	r1, [r4, #24]
34000962:	eb0e 080c 	add.w	r8, lr, ip
34000966:	4598      	cmp	r8, r3
34000968:	fb07 f101 	mul.w	r1, r7, r1
3400096c:	d243      	bcs.n	340009f6 <evision_api_st_ae_process+0x1a8>
3400096e:	ee07 0a90 	vmov	s15, r0
34000972:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 34000a30 <evision_api_st_ae_process+0x1e2>
34000976:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3400097a:	ee67 7a87 	vmul.f32	s15, s15, s14
3400097e:	ee07 1a10 	vmov	s14, r1
34000982:	eef1 6a67 	vneg.f32	s13, s15
34000986:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
3400098a:	eeb4 7ae6 	vcmpe.f32	s14, s13
3400098e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000992:	d504      	bpl.n	3400099e <evision_api_st_ae_process+0x150>
34000994:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34000998:	ee17 3a90 	vmov	r3, s15
3400099c:	4259      	negs	r1, r3
3400099e:	2900      	cmp	r1, #0
340009a0:	d0b8      	beq.n	34000914 <evision_api_st_ae_process+0xc6>
340009a2:	42b5      	cmp	r5, r6
340009a4:	d132      	bne.n	34000a0c <evision_api_st_ae_process+0x1be>
340009a6:	6c60      	ldr	r0, [r4, #68]	@ 0x44
340009a8:	4290      	cmp	r0, r2
340009aa:	d801      	bhi.n	340009b0 <evision_api_st_ae_process+0x162>
340009ac:	2900      	cmp	r1, #0
340009ae:	da2d      	bge.n	34000a0c <evision_api_st_ae_process+0x1be>
340009b0:	fb02 7707 	mla	r7, r2, r7, r7
340009b4:	ee07 2a90 	vmov	s15, r2
340009b8:	ee06 7a90 	vmov	s13, r7
340009bc:	2900      	cmp	r1, #0
340009be:	eeb8 7be7 	vcvt.f64.s32	d7, s15
340009c2:	eeb8 6be6 	vcvt.f64.s32	d6, s13
340009c6:	da1e      	bge.n	34000a06 <evision_api_st_ae_process+0x1b8>
340009c8:	ed94 5b0e 	vldr	d5, [r4, #56]	@ 0x38
340009cc:	eea5 7b06 	vfma.f64	d7, d5, d6
340009d0:	eebd 7bc7 	vcvt.s32.f64	s14, d7
340009d4:	ee17 2a10 	vmov	r2, s14
340009d8:	6c23      	ldr	r3, [r4, #64]	@ 0x40
340009da:	429a      	cmp	r2, r3
340009dc:	bfb8      	it	lt
340009de:	461a      	movlt	r2, r3
340009e0:	4282      	cmp	r2, r0
340009e2:	bfd4      	ite	le
340009e4:	6062      	strle	r2, [r4, #4]
340009e6:	6060      	strgt	r0, [r4, #4]
340009e8:	e794      	b.n	34000914 <evision_api_st_ae_process+0xc6>
340009ea:	6a21      	ldr	r1, [r4, #32]
340009ec:	4288      	cmp	r0, r1
340009ee:	bf2c      	ite	cs
340009f0:	6ae0      	ldrcs	r0, [r4, #44]	@ 0x2c
340009f2:	6aa0      	ldrcc	r0, [r4, #40]	@ 0x28
340009f4:	e7b2      	b.n	3400095c <evision_api_st_ae_process+0x10e>
340009f6:	ebac 0c0e 	sub.w	ip, ip, lr
340009fa:	459c      	cmp	ip, r3
340009fc:	dd8a      	ble.n	34000914 <evision_api_st_ae_process+0xc6>
340009fe:	4281      	cmp	r1, r0
34000a00:	bfa8      	it	ge
34000a02:	4601      	movge	r1, r0
34000a04:	e7cb      	b.n	3400099e <evision_api_st_ae_process+0x150>
34000a06:	ed94 5b0c 	vldr	d5, [r4, #48]	@ 0x30
34000a0a:	e7df      	b.n	340009cc <evision_api_st_ae_process+0x17e>
34000a0c:	440e      	add	r6, r1
34000a0e:	42b5      	cmp	r5, r6
34000a10:	f73f af31 	bgt.w	34000876 <evision_api_st_ae_process+0x28>
34000a14:	6ce5      	ldr	r5, [r4, #76]	@ 0x4c
34000a16:	42b5      	cmp	r5, r6
34000a18:	bfa8      	it	ge
34000a1a:	4635      	movge	r5, r6
34000a1c:	e72b      	b.n	34000876 <evision_api_st_ae_process+0x28>
34000a1e:	f04f 30ff 	mov.w	r0, #4294967295
34000a22:	e778      	b.n	34000916 <evision_api_st_ae_process+0xc8>
34000a24:	f3af 8000 	nop.w
34000a28:	00000000 	.word	0x00000000
34000a2c:	408f4000 	.word	0x408f4000
34000a30:	3f59999a 	.word	0x3f59999a
34000a34:	00000000 	.word	0x00000000

34000a38 <eLGgzyBnqV>:
34000a38:	ed90 5aad 	vldr	s10, [r0, #692]	@ 0x2b4
34000a3c:	b530      	push	{r4, r5, lr}
34000a3e:	ed2d 8b10 	vpush	{d8-d15}
34000a42:	ed90 7ba8 	vldr	d7, [r0, #672]	@ 0x2a0
34000a46:	eeb5 5ac0 	vcmpe.f32	s10, #0.0
34000a4a:	b089      	sub	sp, #36	@ 0x24
34000a4c:	ed8d 7b00 	vstr	d7, [sp]
34000a50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a54:	ed90 7ba4 	vldr	d7, [r0, #656]	@ 0x290
34000a58:	4604      	mov	r4, r0
34000a5a:	ed91 4a01 	vldr	s8, [r1, #4]
34000a5e:	ed91 2a00 	vldr	s4, [r1]
34000a62:	ed91 fb02 	vldr	d15, [r1, #8]
34000a66:	ed91 eb04 	vldr	d14, [r1, #16]
34000a6a:	ed90 3b12 	vldr	d3, [r0, #72]	@ 0x48
34000a6e:	ed90 cbaa 	vldr	d12, [r0, #680]	@ 0x2a8
34000a72:	ed90 bb16 	vldr	d11, [r0, #88]	@ 0x58
34000a76:	ed8d 7b04 	vstr	d7, [sp, #16]
34000a7a:	ed90 6ba6 	vldr	d6, [r0, #664]	@ 0x298
34000a7e:	dc09      	bgt.n	34000a94 <eLGgzyBnqV+0x5c>
34000a80:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
34000a84:	48d6      	ldr	r0, [pc, #856]	@ (34000de0 <eLGgzyBnqV+0x3a8>)
34000a86:	4798      	blx	r3
34000a88:	f04f 30ff 	mov.w	r0, #4294967295
34000a8c:	b009      	add	sp, #36	@ 0x24
34000a8e:	ecbd 8b10 	vpop	{d8-d15}
34000a92:	bd30      	pop	{r4, r5, pc}
34000a94:	eeb8 4b44 	vcvt.f64.u32	d4, s8
34000a98:	ed9f 7bc3 	vldr	d7, [pc, #780]	@ 34000da8 <eLGgzyBnqV+0x370>
34000a9c:	eeb8 2b42 	vcvt.f64.u32	d2, s4
34000aa0:	ee24 7b07 	vmul.f64	d7, d4, d7
34000aa4:	eeb4 7bc2 	vcmpe.f64	d7, d2
34000aa8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000aac:	dd0f      	ble.n	34000ace <eLGgzyBnqV+0x96>
34000aae:	ed90 7b1c 	vldr	d7, [r0, #112]	@ 0x70
34000ab2:	ed9f 1bbf 	vldr	d1, [pc, #764]	@ 34000db0 <eLGgzyBnqV+0x378>
34000ab6:	ee37 1b01 	vadd.f64	d1, d7, d1
34000aba:	ed9f 7bbf 	vldr	d7, [pc, #764]	@ 34000db8 <eLGgzyBnqV+0x380>
34000abe:	eeb4 1bc7 	vcmpe.f64	d1, d7
34000ac2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ac6:	fe37 7b01 	vselgt.f64	d7, d7, d1
34000aca:	ed80 7b1c 	vstr	d7, [r0, #112]	@ 0x70
34000ace:	ed9f 7bbc 	vldr	d7, [pc, #752]	@ 34000dc0 <eLGgzyBnqV+0x388>
34000ad2:	ee24 4b07 	vmul.f64	d4, d4, d7
34000ad6:	eeb4 4bc2 	vcmpe.f64	d4, d2
34000ada:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ade:	d510      	bpl.n	34000b02 <eLGgzyBnqV+0xca>
34000ae0:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
34000ae4:	ed9f 4bb2 	vldr	d4, [pc, #712]	@ 34000db0 <eLGgzyBnqV+0x378>
34000ae8:	ee37 7b44 	vsub.f64	d7, d7, d4
34000aec:	ed9f 4bb6 	vldr	d4, [pc, #728]	@ 34000dc8 <eLGgzyBnqV+0x390>
34000af0:	eeb4 7bc4 	vcmpe.f64	d7, d4
34000af4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000af8:	bf58      	it	pl
34000afa:	eeb0 4b47 	vmovpl.f64	d4, d7
34000afe:	ed84 4b1c 	vstr	d4, [r4, #112]	@ 0x70
34000b02:	f894 5050 	ldrb.w	r5, [r4, #80]	@ 0x50
34000b06:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
34000b0a:	2d01      	cmp	r5, #1
34000b0c:	d164      	bne.n	34000bd8 <eLGgzyBnqV+0x1a0>
34000b0e:	ed9f 7bb0 	vldr	d7, [pc, #704]	@ 34000dd0 <eLGgzyBnqV+0x398>
34000b12:	ee3f 4b4e 	vsub.f64	d4, d15, d14
34000b16:	ee84 db07 	vdiv.f64	d13, d4, d7
34000b1a:	ee3f 4b0e 	vadd.f64	d4, d15, d14
34000b1e:	ee84 ab07 	vdiv.f64	d10, d4, d7
34000b22:	eeb0 7bcd 	vabs.f64	d7, d13
34000b26:	eeb4 5bc7 	vcmpe.f64	d5, d7
34000b2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b2e:	eeb0 4bca 	vabs.f64	d4, d10
34000b32:	db3c      	blt.n	34000bae <eLGgzyBnqV+0x176>
34000b34:	eeb4 5bc4 	vcmpe.f64	d5, d4
34000b38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b3c:	db37      	blt.n	34000bae <eLGgzyBnqV+0x176>
34000b3e:	2300      	movs	r3, #0
34000b40:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34000b44:	ee83 9b0c 	vdiv.f64	d9, d3, d12
34000b48:	eebc 9bc9 	vcvt.u32.f64	s18, d9
34000b4c:	eeb8 9b49 	vcvt.f64.u32	d9, s18
34000b50:	ee29 9b0c 	vmul.f64	d9, d9, d12
34000b54:	2200      	movs	r2, #0
34000b56:	eefc 5bc9 	vcvt.u32.f64	s11, d9
34000b5a:	eeb0 8b49 	vmov.f64	d8, d9
34000b5e:	edcd 5a03 	vstr	s11, [sp, #12]
34000b62:	f884 2060 	strb.w	r2, [r4, #96]	@ 0x60
34000b66:	2b00      	cmp	r3, #0
34000b68:	f000 808c 	beq.w	34000c84 <eLGgzyBnqV+0x24c>
34000b6c:	eef7 0bcb 	vcvt.f32.f64	s1, d11
34000b70:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
34000b74:	ed8d 6b06 	vstr	d6, [sp, #24]
34000b78:	f00e f836 	bl	3400ebe8 <powf>
34000b7c:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
34000b80:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34000b84:	eeb0 5bce 	vabs.f64	d5, d14
34000b88:	ee20 0b07 	vmul.f64	d0, d0, d7
34000b8c:	eeb0 7bcf 	vabs.f64	d7, d15
34000b90:	eeb4 7bc5 	vcmpe.f64	d7, d5
34000b94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b98:	ed9d 6b06 	vldr	d6, [sp, #24]
34000b9c:	dd34      	ble.n	34000c08 <eLGgzyBnqV+0x1d0>
34000b9e:	eeb5 fbc0 	vcmpe.f64	d15, #0.0
34000ba2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ba6:	d534      	bpl.n	34000c12 <eLGgzyBnqV+0x1da>
34000ba8:	ee39 0b40 	vsub.f64	d0, d9, d0
34000bac:	e033      	b.n	34000c16 <eLGgzyBnqV+0x1de>
34000bae:	eeb4 5bc4 	vcmpe.f64	d5, d4
34000bb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bb6:	d525      	bpl.n	34000c04 <eLGgzyBnqV+0x1cc>
34000bb8:	ee8a 4b0d 	vdiv.f64	d4, d10, d13
34000bbc:	ed94 5aae 	vldr	s10, [r4, #696]	@ 0x2b8
34000bc0:	eeb0 4bc4 	vabs.f64	d4, d4
34000bc4:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
34000bc8:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000bcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bd0:	bfb4      	ite	lt
34000bd2:	2301      	movlt	r3, #1
34000bd4:	2300      	movge	r3, #0
34000bd6:	e7b5      	b.n	34000b44 <eLGgzyBnqV+0x10c>
34000bd8:	eeb0 7bcf 	vabs.f64	d7, d15
34000bdc:	eeb0 4bce 	vabs.f64	d4, d14
34000be0:	eeb4 4b47 	vcmp.f64	d4, d7
34000be4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000be8:	fe34 7b07 	vselgt.f64	d7, d4, d7
34000bec:	eeb4 7bc5 	vcmpe.f64	d7, d5
34000bf0:	ed9f ab79 	vldr	d10, [pc, #484]	@ 34000dd8 <eLGgzyBnqV+0x3a0>
34000bf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bf8:	eeb0 db4a 	vmov.f64	d13, d10
34000bfc:	bf8c      	ite	hi
34000bfe:	2301      	movhi	r3, #1
34000c00:	2300      	movls	r3, #0
34000c02:	e79f      	b.n	34000b44 <eLGgzyBnqV+0x10c>
34000c04:	2301      	movs	r3, #1
34000c06:	e79d      	b.n	34000b44 <eLGgzyBnqV+0x10c>
34000c08:	eeb5 ebc0 	vcmpe.f64	d14, #0.0
34000c0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c10:	d5ca      	bpl.n	34000ba8 <eLGgzyBnqV+0x170>
34000c12:	ee39 0b00 	vadd.f64	d0, d9, d0
34000c16:	ed94 7b3c 	vldr	d7, [r4, #240]	@ 0xf0
34000c1a:	eeb4 7bc0 	vcmpe.f64	d7, d0
34000c1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c22:	d503      	bpl.n	34000c2c <eLGgzyBnqV+0x1f4>
34000c24:	eeb0 bb46 	vmov.f64	d11, d6
34000c28:	eeb0 0b47 	vmov.f64	d0, d7
34000c2c:	ed94 7b3a 	vldr	d7, [r4, #232]	@ 0xe8
34000c30:	eeb4 7bc0 	vcmpe.f64	d7, d0
34000c34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c38:	dd03      	ble.n	34000c42 <eLGgzyBnqV+0x20a>
34000c3a:	eeb0 bb46 	vmov.f64	d11, d6
34000c3e:	eeb0 0b47 	vmov.f64	d0, d7
34000c42:	ee80 8b0c 	vdiv.f64	d8, d0, d12
34000c46:	eebc 8bc8 	vcvt.u32.f64	s16, d8
34000c4a:	eeb8 8b48 	vcvt.f64.u32	d8, s16
34000c4e:	2d01      	cmp	r5, #1
34000c50:	ee2c 8b08 	vmul.f64	d8, d12, d8
34000c54:	d116      	bne.n	34000c84 <eLGgzyBnqV+0x24c>
34000c56:	f8b4 30e0 	ldrh.w	r3, [r4, #224]	@ 0xe0
34000c5a:	2b02      	cmp	r3, #2
34000c5c:	d85f      	bhi.n	34000d1e <eLGgzyBnqV+0x2e6>
34000c5e:	eefc 7bc9 	vcvt.u32.f64	s15, d9
34000c62:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34000c66:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
34000c6a:	ed82 7b20 	vstr	d7, [r2, #128]	@ 0x80
34000c6e:	ed82 8b26 	vstr	d8, [r2, #152]	@ 0x98
34000c72:	eb04 1203 	add.w	r2, r4, r3, lsl #4
34000c76:	3301      	adds	r3, #1
34000c78:	ed82 db2c 	vstr	d13, [r2, #176]	@ 0xb0
34000c7c:	ed82 ab2e 	vstr	d10, [r2, #184]	@ 0xb8
34000c80:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34000c84:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000c88:	bb4b      	cbnz	r3, 34000cde <eLGgzyBnqV+0x2a6>
34000c8a:	2210      	movs	r2, #16
34000c8c:	f104 0188 	add.w	r1, r4, #136	@ 0x88
34000c90:	f104 0080 	add.w	r0, r4, #128	@ 0x80
34000c94:	ed8d 6b06 	vstr	d6, [sp, #24]
34000c98:	f00c fe22 	bl	3400d8e0 <memmove>
34000c9c:	2210      	movs	r2, #16
34000c9e:	f104 01a0 	add.w	r1, r4, #160	@ 0xa0
34000ca2:	f104 0098 	add.w	r0, r4, #152	@ 0x98
34000ca6:	f00c fe1b 	bl	3400d8e0 <memmove>
34000caa:	e9d4 2330 	ldrd	r2, r3, [r4, #192]	@ 0xc0
34000cae:	ed84 9b24 	vstr	d9, [r4, #144]	@ 0x90
34000cb2:	e9c4 232c 	strd	r2, r3, [r4, #176]	@ 0xb0
34000cb6:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	@ 0xc8
34000cba:	ed84 8b2a 	vstr	d8, [r4, #168]	@ 0xa8
34000cbe:	e9c4 232e 	strd	r2, r3, [r4, #184]	@ 0xb8
34000cc2:	e9d4 2334 	ldrd	r2, r3, [r4, #208]	@ 0xd0
34000cc6:	ed9d 6b06 	vldr	d6, [sp, #24]
34000cca:	e9c4 2330 	strd	r2, r3, [r4, #192]	@ 0xc0
34000cce:	e9d4 2336 	ldrd	r2, r3, [r4, #216]	@ 0xd8
34000cd2:	ed84 db34 	vstr	d13, [r4, #208]	@ 0xd0
34000cd6:	ed84 ab36 	vstr	d10, [r4, #216]	@ 0xd8
34000cda:	e9c4 2332 	strd	r2, r3, [r4, #200]	@ 0xc8
34000cde:	eefc 7bc8 	vcvt.u32.f64	s15, d8
34000ce2:	ee17 3a90 	vmov	r3, s15
34000ce6:	ed94 7b1a 	vldr	d7, [r4, #104]	@ 0x68
34000cea:	9a03      	ldr	r2, [sp, #12]
34000cec:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
34000cf0:	4293      	cmp	r3, r2
34000cf2:	bf1c      	itt	ne
34000cf4:	2301      	movne	r3, #1
34000cf6:	f884 3060 	strbne.w	r3, [r4, #96]	@ 0x60
34000cfa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000cfe:	dd71      	ble.n	34000de4 <eLGgzyBnqV+0x3ac>
34000d00:	2301      	movs	r3, #1
34000d02:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34000d06:	ed9d 7b00 	vldr	d7, [sp]
34000d0a:	eeb4 bbc7 	vcmpe.f64	d11, d7
34000d0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000d12:	d579      	bpl.n	34000e08 <eLGgzyBnqV+0x3d0>
34000d14:	ed9d 7b04 	vldr	d7, [sp, #16]
34000d18:	ee3b 6b07 	vadd.f64	d6, d11, d7
34000d1c:	e066      	b.n	34000dec <eLGgzyBnqV+0x3b4>
34000d1e:	ed94 7b2a 	vldr	d7, [r4, #168]	@ 0xa8
34000d22:	ed94 5aaf 	vldr	s10, [r4, #700]	@ 0x2bc
34000d26:	ee38 7b47 	vsub.f64	d7, d8, d7
34000d2a:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
34000d2e:	eeb0 7bc7 	vabs.f64	d7, d7
34000d32:	eeb4 7bc5 	vcmpe.f64	d7, d5
34000d36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000d3a:	db2c      	blt.n	34000d96 <eLGgzyBnqV+0x35e>
34000d3c:	ed94 7b28 	vldr	d7, [r4, #160]	@ 0xa0
34000d40:	ee38 7b47 	vsub.f64	d7, d8, d7
34000d44:	eeb0 7bc7 	vabs.f64	d7, d7
34000d48:	eeb4 5bc7 	vcmpe.f64	d5, d7
34000d4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000d50:	dd21      	ble.n	34000d96 <eLGgzyBnqV+0x35e>
34000d52:	ed94 0b32 	vldr	d0, [r4, #200]	@ 0xc8
34000d56:	ed94 7b30 	vldr	d7, [r4, #192]	@ 0xc0
34000d5a:	ee3a 0b40 	vsub.f64	d0, d10, d0
34000d5e:	ee3d 7b47 	vsub.f64	d7, d13, d7
34000d62:	ee20 0b00 	vmul.f64	d0, d0, d0
34000d66:	eea7 0b07 	vfma.f64	d0, d7, d7
34000d6a:	ed8d 6b06 	vstr	d6, [sp, #24]
34000d6e:	f00d fbff 	bl	3400e570 <sqrt>
34000d72:	ed94 7ab0 	vldr	s14, [r4, #704]	@ 0x2c0
34000d76:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000d7a:	eeb4 0bc7 	vcmpe.f64	d0, d7
34000d7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000d82:	ed9d 6b06 	vldr	d6, [sp, #24]
34000d86:	d506      	bpl.n	34000d96 <eLGgzyBnqV+0x35e>
34000d88:	eefc 7bc9 	vcvt.u32.f64	s15, d9
34000d8c:	f884 5078 	strb.w	r5, [r4, #120]	@ 0x78
34000d90:	eeb8 8b67 	vcvt.f64.u32	d8, s15
34000d94:	e776      	b.n	34000c84 <eLGgzyBnqV+0x24c>
34000d96:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000d9a:	2b01      	cmp	r3, #1
34000d9c:	bf04      	itt	eq
34000d9e:	2300      	moveq	r3, #0
34000da0:	f884 3078 	strbeq.w	r3, [r4, #120]	@ 0x78
34000da4:	e76e      	b.n	34000c84 <eLGgzyBnqV+0x24c>
34000da6:	bf00      	nop
34000da8:	9999999a 	.word	0x9999999a
34000dac:	3fa99999 	.word	0x3fa99999
34000db0:	47ae147b 	.word	0x47ae147b
34000db4:	3f847ae1 	.word	0x3f847ae1
34000db8:	33333334 	.word	0x33333334
34000dbc:	3fc33333 	.word	0x3fc33333
34000dc0:	33333333 	.word	0x33333333
34000dc4:	3fc33333 	.word	0x3fc33333
34000dc8:	11111111 	.word	0x11111111
34000dcc:	3fb11111 	.word	0x3fb11111
34000dd0:	667f3bcd 	.word	0x667f3bcd
34000dd4:	3ff6a09e 	.word	0x3ff6a09e
	...
34000de0:	340109d1 	.word	0x340109d1
34000de4:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34000de8:	2b00      	cmp	r3, #0
34000dea:	d18c      	bne.n	34000d06 <eLGgzyBnqV+0x2ce>
34000dec:	ee88 7b0c 	vdiv.f64	d7, d8, d12
34000df0:	eebc 7bc7 	vcvt.u32.f64	s14, d7
34000df4:	eeb8 7b47 	vcvt.f64.u32	d7, s14
34000df8:	ee27 7b0c 	vmul.f64	d7, d7, d12
34000dfc:	ed84 6b16 	vstr	d6, [r4, #88]	@ 0x58
34000e00:	ed84 7b12 	vstr	d7, [r4, #72]	@ 0x48
34000e04:	2001      	movs	r0, #1
34000e06:	e641      	b.n	34000a8c <eLGgzyBnqV+0x54>
34000e08:	ed9d 6b00 	vldr	d6, [sp]
34000e0c:	e7ee      	b.n	34000dec <eLGgzyBnqV+0x3b4>

34000e0e <FLXvKtIdpl>:
34000e0e:	ed90 6b1a 	vldr	d6, [r0, #104]	@ 0x68
34000e12:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000e16:	ed90 4b12 	vldr	d4, [r0, #72]	@ 0x48
34000e1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e1e:	ed90 5baa 	vldr	d5, [r0, #680]	@ 0x2a8
34000e22:	eeb0 7b46 	vmov.f64	d7, d6
34000e26:	bfdf      	itttt	le
34000e28:	ee84 7b05 	vdivle.f64	d7, d4, d5
34000e2c:	eebc 7bc7 	vcvtle.u32.f64	s14, d7
34000e30:	eeb8 7b47 	vcvtle.f64.u32	d7, s14
34000e34:	ee27 7b05 	vmulle.f64	d7, d7, d5
34000e38:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
34000e3c:	ed90 5b3c 	vldr	d5, [r0, #240]	@ 0xf0
34000e40:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000e44:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e4c:	bfc8      	it	gt
34000e4e:	eeb7 7bc5 	vcvtgt.f32.f64	s14, d5
34000e52:	ed90 5b3a 	vldr	d5, [r0, #232]	@ 0xe8
34000e56:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000e5a:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000e5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e62:	bf48      	it	mi
34000e64:	eeb7 7bc5 	vcvtmi.f32.f64	s14, d5
34000e68:	eeb7 5ac7 	vcvt.f64.f32	d5, s14
34000e6c:	f8d0 3274 	ldr.w	r3, [r0, #628]	@ 0x274
34000e70:	b530      	push	{r4, r5, lr}
34000e72:	ed80 5b12 	vstr	d5, [r0, #72]	@ 0x48
34000e76:	ed93 5a00 	vldr	s10, [r3]
34000e7a:	edd0 7aac 	vldr	s15, [r0, #688]	@ 0x2b0
34000e7e:	eeb4 5ac7 	vcmpe.f32	s10, s14
34000e82:	eef1 5a67 	vneg.f32	s11, s15
34000e86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e8a:	f04f 0100 	mov.w	r1, #0
34000e8e:	f8b0 30f8 	ldrh.w	r3, [r0, #248]	@ 0xf8
34000e92:	fe75 7aa7 	vselgt.f32	s15, s11, s15
34000e96:	3b01      	subs	r3, #1
34000e98:	b28a      	uxth	r2, r1
34000e9a:	4293      	cmp	r3, r2
34000e9c:	d805      	bhi.n	34000eaa <FLXvKtIdpl+0x9c>
34000e9e:	2244      	movs	r2, #68	@ 0x44
34000ea0:	fb02 0303 	mla	r3, r2, r3, r0
34000ea4:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34000ea8:	e011      	b.n	34000ece <FLXvKtIdpl+0xc0>
34000eaa:	eb00 0482 	add.w	r4, r0, r2, lsl #2
34000eae:	edd4 5a44 	vldr	s11, [r4, #272]	@ 0x110
34000eb2:	ee77 5aa5 	vadd.f32	s11, s15, s11
34000eb6:	eef4 5ac7 	vcmpe.f32	s11, s14
34000eba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ebe:	f101 0101 	add.w	r1, r1, #1
34000ec2:	dbe9      	blt.n	34000e98 <FLXvKtIdpl+0x8a>
34000ec4:	2344      	movs	r3, #68	@ 0x44
34000ec6:	fb03 0202 	mla	r2, r3, r2, r0
34000eca:	f502 7390 	add.w	r3, r2, #288	@ 0x120
34000ece:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000ed2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ed6:	f8c0 3274 	str.w	r3, [r0, #628]	@ 0x274
34000eda:	dc05      	bgt.n	34000ee8 <FLXvKtIdpl+0xda>
34000edc:	ed93 7a00 	vldr	s14, [r3]
34000ee0:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000ee4:	ed80 7b12 	vstr	d7, [r0, #72]	@ 0x48
34000ee8:	685a      	ldr	r2, [r3, #4]
34000eea:	f103 0138 	add.w	r1, r3, #56	@ 0x38
34000eee:	6042      	str	r2, [r0, #4]
34000ef0:	689a      	ldr	r2, [r3, #8]
34000ef2:	f103 0424 	add.w	r4, r3, #36	@ 0x24
34000ef6:	6082      	str	r2, [r0, #8]
34000ef8:	68da      	ldr	r2, [r3, #12]
34000efa:	60c2      	str	r2, [r0, #12]
34000efc:	691a      	ldr	r2, [r3, #16]
34000efe:	6102      	str	r2, [r0, #16]
34000f00:	f100 0238 	add.w	r2, r0, #56	@ 0x38
34000f04:	695d      	ldr	r5, [r3, #20]
34000f06:	330c      	adds	r3, #12
34000f08:	6145      	str	r5, [r0, #20]
34000f0a:	68dd      	ldr	r5, [r3, #12]
34000f0c:	300c      	adds	r0, #12
34000f0e:	60c5      	str	r5, [r0, #12]
34000f10:	691d      	ldr	r5, [r3, #16]
34000f12:	42a3      	cmp	r3, r4
34000f14:	6105      	str	r5, [r0, #16]
34000f16:	f851 5b04 	ldr.w	r5, [r1], #4
34000f1a:	f842 5b04 	str.w	r5, [r2], #4
34000f1e:	d1f1      	bne.n	34000f04 <FLXvKtIdpl+0xf6>
34000f20:	2001      	movs	r0, #1
34000f22:	bd30      	pop	{r4, r5, pc}

34000f24 <evision_api_awb_new>:
34000f24:	b510      	push	{r4, lr}
34000f26:	4604      	mov	r4, r0
34000f28:	b090      	sub	sp, #64	@ 0x40
34000f2a:	b170      	cbz	r0, 34000f4a <evision_api_awb_new+0x26>
34000f2c:	2300      	movs	r3, #0
34000f2e:	4c08      	ldr	r4, [pc, #32]	@ (34000f50 <evision_api_awb_new+0x2c>)
34000f30:	2140      	movs	r1, #64	@ 0x40
34000f32:	7023      	strb	r3, [r4, #0]
34000f34:	f8c4 02c8 	str.w	r0, [r4, #712]	@ 0x2c8
34000f38:	4b06      	ldr	r3, [pc, #24]	@ (34000f54 <evision_api_awb_new+0x30>)
34000f3a:	4668      	mov	r0, sp
34000f3c:	4a06      	ldr	r2, [pc, #24]	@ (34000f58 <evision_api_awb_new+0x34>)
34000f3e:	f00c fbc1 	bl	3400d6c4 <sniprintf>
34000f42:	4668      	mov	r0, sp
34000f44:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000f48:	4798      	blx	r3
34000f4a:	4620      	mov	r0, r4
34000f4c:	b010      	add	sp, #64	@ 0x40
34000f4e:	bd10      	pop	{r4, pc}
34000f50:	34013d00 	.word	0x34013d00
34000f54:	34013af6 	.word	0x34013af6
34000f58:	34010a11 	.word	0x34010a11

34000f5c <evision_api_awb_delete>:
34000f5c:	2800      	cmp	r0, #0
34000f5e:	bf14      	ite	ne
34000f60:	2001      	movne	r0, #1
34000f62:	f04f 30ff 	moveq.w	r0, #4294967295
34000f66:	4770      	bx	lr

34000f68 <evision_api_awb_set_profile>:
34000f68:	ed80 0a00 	vstr	s0, [r0]
34000f6c:	b530      	push	{r4, r5, lr}
34000f6e:	680c      	ldr	r4, [r1, #0]
34000f70:	6044      	str	r4, [r0, #4]
34000f72:	684c      	ldr	r4, [r1, #4]
34000f74:	6084      	str	r4, [r0, #8]
34000f76:	688c      	ldr	r4, [r1, #8]
34000f78:	60c4      	str	r4, [r0, #12]
34000f7a:	68c9      	ldr	r1, [r1, #12]
34000f7c:	f102 0424 	add.w	r4, r2, #36	@ 0x24
34000f80:	6101      	str	r1, [r0, #16]
34000f82:	f100 0138 	add.w	r1, r0, #56	@ 0x38
34000f86:	6815      	ldr	r5, [r2, #0]
34000f88:	320c      	adds	r2, #12
34000f8a:	6145      	str	r5, [r0, #20]
34000f8c:	f852 5c08 	ldr.w	r5, [r2, #-8]
34000f90:	300c      	adds	r0, #12
34000f92:	60c5      	str	r5, [r0, #12]
34000f94:	f852 5c04 	ldr.w	r5, [r2, #-4]
34000f98:	42a2      	cmp	r2, r4
34000f9a:	6105      	str	r5, [r0, #16]
34000f9c:	f853 5b04 	ldr.w	r5, [r3], #4
34000fa0:	f841 5b04 	str.w	r5, [r1], #4
34000fa4:	d1ef      	bne.n	34000f86 <evision_api_awb_set_profile+0x1e>
34000fa6:	bd30      	pop	{r4, r5, pc}

34000fa8 <evision_api_awb_init_profiles>:
34000fa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34000fac:	ed2d 8b06 	vpush	{d8-d10}
34000fb0:	460e      	mov	r6, r1
34000fb2:	eeb0 9b40 	vmov.f64	d9, d0
34000fb6:	eeb0 8b41 	vmov.f64	d8, d1
34000fba:	461d      	mov	r5, r3
34000fbc:	4604      	mov	r4, r0
34000fbe:	b0c7      	sub	sp, #284	@ 0x11c
34000fc0:	2800      	cmp	r0, #0
34000fc2:	f000 818f 	beq.w	340012e4 <evision_api_awb_init_profiles+0x33c>
34000fc6:	ed9f abcc 	vldr	d10, [pc, #816]	@ 340012f8 <evision_api_awb_init_profiles+0x350>
34000fca:	ed80 ab12 	vstr	d10, [r0, #72]	@ 0x48
34000fce:	2000      	movs	r0, #0
34000fd0:	49cf      	ldr	r1, [pc, #828]	@ (34001310 <evision_api_awb_init_profiles+0x368>)
34000fd2:	f04f 0800 	mov.w	r8, #0
34000fd6:	e9c4 0116 	strd	r0, r1, [r4, #88]	@ 0x58
34000fda:	e9c4 01a6 	strd	r0, r1, [r4, #664]	@ 0x298
34000fde:	e9c4 01aa 	strd	r0, r1, [r4, #680]	@ 0x2a8
34000fe2:	49cc      	ldr	r1, [pc, #816]	@ (34001314 <evision_api_awb_init_profiles+0x36c>)
34000fe4:	f8df 9360 	ldr.w	r9, [pc, #864]	@ 34001348 <evision_api_awb_init_profiles+0x3a0>
34000fe8:	f8c4 12b0 	str.w	r1, [r4, #688]	@ 0x2b0
34000fec:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
34000ff0:	f8c4 12b4 	str.w	r1, [r4, #692]	@ 0x2b4
34000ff4:	f04f 517c 	mov.w	r1, #1056964608	@ 0x3f000000
34000ff8:	e9c4 891a 	strd	r8, r9, [r4, #104]	@ 0x68
34000ffc:	f20f 3900 	addw	r9, pc, #768	@ 0x300
34001000:	e9d9 8900 	ldrd	r8, r9, [r9]
34001004:	e9c4 891c 	strd	r8, r9, [r4, #112]	@ 0x70
34001008:	e9c4 89a4 	strd	r8, r9, [r4, #656]	@ 0x290
3400100c:	f04f 0800 	mov.w	r8, #0
34001010:	f8c4 12b8 	str.w	r1, [r4, #696]	@ 0x2b8
34001014:	49c0      	ldr	r1, [pc, #768]	@ (34001318 <evision_api_awb_init_profiles+0x370>)
34001016:	f8df 9334 	ldr.w	r9, [pc, #820]	@ 3400134c <evision_api_awb_init_profiles+0x3a4>
3400101a:	f8c4 12bc 	str.w	r1, [r4, #700]	@ 0x2bc
3400101e:	f04f 517f 	mov.w	r1, #1069547520	@ 0x3fc00000
34001022:	2300      	movs	r3, #0
34001024:	e9c4 89a8 	strd	r8, r9, [r4, #672]	@ 0x2a0
34001028:	2701      	movs	r7, #1
3400102a:	f04f 0800 	mov.w	r8, #0
3400102e:	f8c4 12c0 	str.w	r1, [r4, #704]	@ 0x2c0
34001032:	1e71      	subs	r1, r6, #1
34001034:	f8df 9318 	ldr.w	r9, [pc, #792]	@ 34001350 <evision_api_awb_init_profiles+0x3a8>
34001038:	b288      	uxth	r0, r1
3400103a:	2804      	cmp	r0, #4
3400103c:	e9c4 89a0 	strd	r8, r9, [r4, #640]	@ 0x280
34001040:	f20f 29c4 	addw	r9, pc, #708	@ 0x2c4
34001044:	e9d9 8900 	ldrd	r8, r9, [r9]
34001048:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
3400104c:	e9c4 89a2 	strd	r8, r9, [r4, #648]	@ 0x288
34001050:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34001054:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34001058:	f8a4 7278 	strh.w	r7, [r4, #632]	@ 0x278
3400105c:	d914      	bls.n	34001088 <evision_api_awb_init_profiles+0xe0>
3400105e:	2305      	movs	r3, #5
34001060:	f44f 7180 	mov.w	r1, #256	@ 0x100
34001064:	4aad      	ldr	r2, [pc, #692]	@ (3400131c <evision_api_awb_init_profiles+0x374>)
34001066:	a806      	add	r0, sp, #24
34001068:	f00c fb2c 	bl	3400d6c4 <sniprintf>
3400106c:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34001070:	a806      	add	r0, sp, #24
34001072:	4798      	blx	r3
34001074:	f884 7050 	strb.w	r7, [r4, #80]	@ 0x50
34001078:	4620      	mov	r0, r4
3400107a:	b047      	add	sp, #284	@ 0x11c
3400107c:	ecbd 8b06 	vpop	{d8-d10}
34001080:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34001084:	f7ff bec3 	b.w	34000e0e <FLXvKtIdpl>
34001088:	ed95 7a00 	vldr	s14, [r5]
3400108c:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001090:	eeb4 0bc7 	vcmpe.f64	d0, d7
34001094:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001098:	dd12      	ble.n	340010c0 <evision_api_awb_init_profiles+0x118>
3400109a:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
3400109e:	48a0      	ldr	r0, [pc, #640]	@ (34001320 <evision_api_awb_init_profiles+0x378>)
340010a0:	4798      	blx	r3
340010a2:	ed95 7a00 	vldr	s14, [r5]
340010a6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
340010aa:	ed8d 9b00 	vstr	d9, [sp]
340010ae:	ed8d 7b02 	vstr	d7, [sp, #8]
340010b2:	4a9c      	ldr	r2, [pc, #624]	@ (34001324 <evision_api_awb_init_profiles+0x37c>)
340010b4:	f44f 7180 	mov.w	r1, #256	@ 0x100
340010b8:	a806      	add	r0, sp, #24
340010ba:	f00c fb03 	bl	3400d6c4 <sniprintf>
340010be:	e7d5      	b.n	3400106c <evision_api_awb_init_profiles+0xc4>
340010c0:	f04f 0c44 	mov.w	ip, #68	@ 0x44
340010c4:	fb0c 5806 	mla	r8, ip, r6, r5
340010c8:	ed18 7a11 	vldr	s14, [r8, #-68]	@ 0xffffffbc
340010cc:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
340010d0:	eeb4 1bc7 	vcmpe.f64	d1, d7
340010d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340010d8:	d541      	bpl.n	3400115e <evision_api_awb_init_profiles+0x1b6>
340010da:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
340010de:	4892      	ldr	r0, [pc, #584]	@ (34001328 <evision_api_awb_init_profiles+0x380>)
340010e0:	4798      	blx	r3
340010e2:	ed98 7a00 	vldr	s14, [r8]
340010e6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
340010ea:	ed8d 8b00 	vstr	d8, [sp]
340010ee:	ed8d 7b02 	vstr	d7, [sp, #8]
340010f2:	4a8e      	ldr	r2, [pc, #568]	@ (3400132c <evision_api_awb_init_profiles+0x384>)
340010f4:	e7de      	b.n	340010b4 <evision_api_awb_init_profiles+0x10c>
340010f6:	fb0c f708 	mul.w	r7, ip, r8
340010fa:	eb05 0907 	add.w	r9, r5, r7
340010fe:	3744      	adds	r7, #68	@ 0x44
34001100:	442f      	add	r7, r5
34001102:	ed99 7a00 	vldr	s14, [r9]
34001106:	edd7 7a00 	vldr	s15, [r7]
3400110a:	eeb4 7ae7 	vcmpe.f32	s14, s15
3400110e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001112:	f108 0a01 	add.w	sl, r8, #1
34001116:	f100 0001 	add.w	r0, r0, #1
3400111a:	db21      	blt.n	34001160 <evision_api_awb_init_profiles+0x1b8>
3400111c:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34001120:	4883      	ldr	r0, [pc, #524]	@ (34001330 <evision_api_awb_init_profiles+0x388>)
34001122:	4798      	blx	r3
34001124:	ed97 7a00 	vldr	s14, [r7]
34001128:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400112c:	ed8d 7b04 	vstr	d7, [sp, #16]
34001130:	f8cd a008 	str.w	sl, [sp, #8]
34001134:	ed99 7a00 	vldr	s14, [r9]
34001138:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400113c:	4643      	mov	r3, r8
3400113e:	ed8d 7b00 	vstr	d7, [sp]
34001142:	4a7c      	ldr	r2, [pc, #496]	@ (34001334 <evision_api_awb_init_profiles+0x38c>)
34001144:	f44f 7180 	mov.w	r1, #256	@ 0x100
34001148:	a806      	add	r0, sp, #24
3400114a:	f00c fabb 	bl	3400d6c4 <sniprintf>
3400114e:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34001152:	a806      	add	r0, sp, #24
34001154:	4798      	blx	r3
34001156:	2301      	movs	r3, #1
34001158:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
3400115c:	e78c      	b.n	34001078 <evision_api_awb_init_profiles+0xd0>
3400115e:	4618      	mov	r0, r3
34001160:	fa1f f880 	uxth.w	r8, r0
34001164:	4541      	cmp	r1, r8
34001166:	d8c6      	bhi.n	340010f6 <evision_api_awb_init_profiles+0x14e>
34001168:	2300      	movs	r3, #0
3400116a:	f04f 0c44 	mov.w	ip, #68	@ 0x44
3400116e:	1eb0      	subs	r0, r6, #2
34001170:	b29f      	uxth	r7, r3
34001172:	42b9      	cmp	r1, r7
34001174:	d839      	bhi.n	340011ea <evision_api_awb_init_profiles+0x242>
34001176:	ed84 9b3a 	vstr	d9, [r4, #232]	@ 0xe8
3400117a:	ed84 8b3c 	vstr	d8, [r4, #240]	@ 0xf0
3400117e:	2000      	movs	r0, #0
34001180:	f8a4 60f8 	strh.w	r6, [r4, #248]	@ 0xf8
34001184:	b283      	uxth	r3, r0
34001186:	4299      	cmp	r1, r3
34001188:	f100 0001 	add.w	r0, r0, #1
3400118c:	f200 808b 	bhi.w	340012a6 <evision_api_awb_init_profiles+0x2fe>
34001190:	2700      	movs	r7, #0
34001192:	46b8      	mov	r8, r7
34001194:	f104 0afc 	add.w	sl, r4, #252	@ 0xfc
34001198:	f504 7990 	add.w	r9, r4, #288	@ 0x120
3400119c:	eb05 0b07 	add.w	fp, r5, r7
340011a0:	eb09 0007 	add.w	r0, r9, r7
340011a4:	2244      	movs	r2, #68	@ 0x44
340011a6:	4659      	mov	r1, fp
340011a8:	f00c fc47 	bl	3400da3a <memcpy>
340011ac:	f8db 3000 	ldr.w	r3, [fp]
340011b0:	f108 0801 	add.w	r8, r8, #1
340011b4:	f84a 3b04 	str.w	r3, [sl], #4
340011b8:	fa1f f388 	uxth.w	r3, r8
340011bc:	429e      	cmp	r6, r3
340011be:	f107 0744 	add.w	r7, r7, #68	@ 0x44
340011c2:	d8eb      	bhi.n	3400119c <evision_api_awb_init_profiles+0x1f4>
340011c4:	1e73      	subs	r3, r6, #1
340011c6:	b29b      	uxth	r3, r3
340011c8:	2e00      	cmp	r6, #0
340011ca:	f103 0301 	add.w	r3, r3, #1
340011ce:	bf14      	ite	ne
340011d0:	461a      	movne	r2, r3
340011d2:	2201      	moveq	r2, #1
340011d4:	f8c4 9274 	str.w	r9, [r4, #628]	@ 0x274
340011d8:	f504 71b2 	add.w	r1, r4, #356	@ 0x164
340011dc:	3a01      	subs	r2, #1
340011de:	d16a      	bne.n	340012b6 <evision_api_awb_init_profiles+0x30e>
340011e0:	2301      	movs	r3, #1
340011e2:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
340011e6:	7023      	strb	r3, [r4, #0]
340011e8:	e746      	b.n	34001078 <evision_api_awb_init_profiles+0xd0>
340011ea:	eb02 0987 	add.w	r9, r2, r7, lsl #2
340011ee:	42b8      	cmp	r0, r7
340011f0:	edd9 7a00 	vldr	s15, [r9]
340011f4:	ea4f 0887 	mov.w	r8, r7, lsl #2
340011f8:	f107 0a01 	add.w	sl, r7, #1
340011fc:	d91e      	bls.n	3400123c <evision_api_awb_init_profiles+0x294>
340011fe:	f108 0804 	add.w	r8, r8, #4
34001202:	4490      	add	r8, r2
34001204:	ed98 7a00 	vldr	s14, [r8]
34001208:	eeb4 7ae7 	vcmpe.f32	s14, s15
3400120c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001210:	d814      	bhi.n	3400123c <evision_api_awb_init_profiles+0x294>
34001212:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34001216:	4848      	ldr	r0, [pc, #288]	@ (34001338 <evision_api_awb_init_profiles+0x390>)
34001218:	4798      	blx	r3
3400121a:	ed98 7a00 	vldr	s14, [r8]
3400121e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001222:	ed8d 7b04 	vstr	d7, [sp, #16]
34001226:	f8cd a008 	str.w	sl, [sp, #8]
3400122a:	ed99 7a00 	vldr	s14, [r9]
3400122e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001232:	463b      	mov	r3, r7
34001234:	ed8d 7b00 	vstr	d7, [sp]
34001238:	4a40      	ldr	r2, [pc, #256]	@ (3400133c <evision_api_awb_init_profiles+0x394>)
3400123a:	e783      	b.n	34001144 <evision_api_awb_init_profiles+0x19c>
3400123c:	fb0c f807 	mul.w	r8, ip, r7
34001240:	eb05 0a08 	add.w	sl, r5, r8
34001244:	ed9a 7a00 	vldr	s14, [sl]
34001248:	eeb4 7ae7 	vcmpe.f32	s14, s15
3400124c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001250:	f108 0844 	add.w	r8, r8, #68	@ 0x44
34001254:	44a8      	add	r8, r5
34001256:	da08      	bge.n	3400126a <evision_api_awb_init_profiles+0x2c2>
34001258:	ed98 7a00 	vldr	s14, [r8]
3400125c:	eeb4 7ae7 	vcmpe.f32	s14, s15
34001260:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001264:	f103 0301 	add.w	r3, r3, #1
34001268:	d882      	bhi.n	34001170 <evision_api_awb_init_profiles+0x1c8>
3400126a:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
3400126e:	4834      	ldr	r0, [pc, #208]	@ (34001340 <evision_api_awb_init_profiles+0x398>)
34001270:	4798      	blx	r3
34001272:	ed98 7a00 	vldr	s14, [r8]
34001276:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400127a:	ed8d 7b04 	vstr	d7, [sp, #16]
3400127e:	ed9a 7a00 	vldr	s14, [sl]
34001282:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001286:	ed8d 7b02 	vstr	d7, [sp, #8]
3400128a:	ed99 7a00 	vldr	s14, [r9]
3400128e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001292:	463b      	mov	r3, r7
34001294:	ed8d 7b00 	vstr	d7, [sp]
34001298:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400129c:	4a29      	ldr	r2, [pc, #164]	@ (34001344 <evision_api_awb_init_profiles+0x39c>)
3400129e:	a806      	add	r0, sp, #24
340012a0:	f00c fa10 	bl	3400d6c4 <sniprintf>
340012a4:	e753      	b.n	3400114e <evision_api_awb_init_profiles+0x1a6>
340012a6:	eb02 0783 	add.w	r7, r2, r3, lsl #2
340012aa:	683f      	ldr	r7, [r7, #0]
340012ac:	eb04 0383 	add.w	r3, r4, r3, lsl #2
340012b0:	f8c3 7110 	str.w	r7, [r3, #272]	@ 0x110
340012b4:	e766      	b.n	34001184 <evision_api_awb_init_profiles+0x1dc>
340012b6:	f8d4 3274 	ldr.w	r3, [r4, #628]	@ 0x274
340012ba:	ed91 6a00 	vldr	s12, [r1]
340012be:	ed93 7a00 	vldr	s14, [r3]
340012c2:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
340012c6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
340012ca:	ee36 6b4a 	vsub.f64	d6, d6, d10
340012ce:	ee37 7b4a 	vsub.f64	d7, d7, d10
340012d2:	eeb4 6bc7 	vcmpe.f64	d6, d7
340012d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340012da:	bf48      	it	mi
340012dc:	f8c4 1274 	strmi.w	r1, [r4, #628]	@ 0x274
340012e0:	3144      	adds	r1, #68	@ 0x44
340012e2:	e77b      	b.n	340011dc <evision_api_awb_init_profiles+0x234>
340012e4:	f04f 30ff 	mov.w	r0, #4294967295
340012e8:	b047      	add	sp, #284	@ 0x11c
340012ea:	ecbd 8b06 	vpop	{d8-d10}
340012ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340012f2:	bf00      	nop
340012f4:	f3af 8000 	nop.w
340012f8:	00000000 	.word	0x00000000
340012fc:	40b38800 	.word	0x40b38800
34001300:	9999999a 	.word	0x9999999a
34001304:	3fb99999 	.word	0x3fb99999
34001308:	00000000 	.word	0x00000000
3400130c:	406ea000 	.word	0x406ea000
34001310:	3ff00000 	.word	0x3ff00000
34001314:	42480000 	.word	0x42480000
34001318:	432f0000 	.word	0x432f0000
3400131c:	34010a21 	.word	0x34010a21
34001320:	34010a65 	.word	0x34010a65
34001324:	34010aec 	.word	0x34010aec
34001328:	34010b4a 	.word	0x34010b4a
3400132c:	34010bd2 	.word	0x34010bd2
34001330:	34010c2f 	.word	0x34010c2f
34001334:	34010c93 	.word	0x34010c93
34001338:	34010ceb 	.word	0x34010ceb
3400133c:	34010d5a 	.word	0x34010d5a
34001340:	34010dc4 	.word	0x34010dc4
34001344:	34010e1b 	.word	0x34010e1b
34001348:	bff00000 	.word	0xbff00000
3400134c:	40080000 	.word	0x40080000
34001350:	40240000 	.word	0x40240000

34001354 <evision_api_awb_run_average>:
34001354:	b530      	push	{r4, r5, lr}
34001356:	4605      	mov	r5, r0
34001358:	4614      	mov	r4, r2
3400135a:	b08d      	sub	sp, #52	@ 0x34
3400135c:	b952      	cbnz	r2, 34001374 <evision_api_awb_run_average+0x20>
3400135e:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
34001362:	481d      	ldr	r0, [pc, #116]	@ (340013d8 <evision_api_awb_run_average+0x84>)
34001364:	4798      	blx	r3
34001366:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
3400136a:	481c      	ldr	r0, [pc, #112]	@ (340013dc <evision_api_awb_run_average+0x88>)
3400136c:	4798      	blx	r3
3400136e:	4620      	mov	r0, r4
34001370:	b00d      	add	sp, #52	@ 0x34
34001372:	bd30      	pop	{r4, r5, pc}
34001374:	ed93 2b04 	vldr	d2, [r3, #16]
34001378:	ed93 1b02 	vldr	d1, [r3, #8]
3400137c:	ed93 0b00 	vldr	d0, [r3]
34001380:	aa0a      	add	r2, sp, #40	@ 0x28
34001382:	a908      	add	r1, sp, #32
34001384:	a806      	add	r0, sp, #24
34001386:	f000 f82f 	bl	340013e8 <fzFshUNXje>
3400138a:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
3400138e:	e9cd 2302 	strd	r2, r3, [sp, #8]
34001392:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	@ 0x28
34001396:	e9cd 2304 	strd	r2, r3, [sp, #16]
3400139a:	2301      	movs	r3, #1
3400139c:	4298      	cmp	r0, r3
3400139e:	4604      	mov	r4, r0
340013a0:	e9cd 3300 	strd	r3, r3, [sp]
340013a4:	d1df      	bne.n	34001366 <evision_api_awb_run_average+0x12>
340013a6:	4669      	mov	r1, sp
340013a8:	4628      	mov	r0, r5
340013aa:	f7ff fb45 	bl	34000a38 <eLGgzyBnqV>
340013ae:	2801      	cmp	r0, #1
340013b0:	4604      	mov	r4, r0
340013b2:	d003      	beq.n	340013bc <evision_api_awb_run_average+0x68>
340013b4:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
340013b8:	4809      	ldr	r0, [pc, #36]	@ (340013e0 <evision_api_awb_run_average+0x8c>)
340013ba:	e7d7      	b.n	3400136c <evision_api_awb_run_average+0x18>
340013bc:	f895 3060 	ldrb.w	r3, [r5, #96]	@ 0x60
340013c0:	2b01      	cmp	r3, #1
340013c2:	d1d4      	bne.n	3400136e <evision_api_awb_run_average+0x1a>
340013c4:	4628      	mov	r0, r5
340013c6:	f7ff fd22 	bl	34000e0e <FLXvKtIdpl>
340013ca:	2801      	cmp	r0, #1
340013cc:	4604      	mov	r4, r0
340013ce:	d0ce      	beq.n	3400136e <evision_api_awb_run_average+0x1a>
340013d0:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
340013d4:	4803      	ldr	r0, [pc, #12]	@ (340013e4 <evision_api_awb_run_average+0x90>)
340013d6:	e7c9      	b.n	3400136c <evision_api_awb_run_average+0x18>
340013d8:	34010ea1 	.word	0x34010ea1
340013dc:	34010f02 	.word	0x34010f02
340013e0:	34010f2b 	.word	0x34010f2b
340013e4:	34010f5f 	.word	0x34010f5f

340013e8 <fzFshUNXje>:
340013e8:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
340013ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340013f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
340013f2:	d409      	bmi.n	34001408 <fzFshUNXje+0x20>
340013f4:	eeb5 1bc0 	vcmpe.f64	d1, #0.0
340013f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340013fc:	d404      	bmi.n	34001408 <fzFshUNXje+0x20>
340013fe:	eeb5 2bc0 	vcmpe.f64	d2, #0.0
34001402:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001406:	d50d      	bpl.n	34001424 <fzFshUNXje+0x3c>
34001408:	ed8d 2b02 	vstr	d2, [sp, #8]
3400140c:	ed8d 1b00 	vstr	d1, [sp]
34001410:	ec53 2b10 	vmov	r2, r3, d0
34001414:	4844      	ldr	r0, [pc, #272]	@ (34001528 <fzFshUNXje+0x140>)
34001416:	f00c f8e5 	bl	3400d5e4 <iprintf>
3400141a:	f04f 30ff 	mov.w	r0, #4294967295
3400141e:	b005      	add	sp, #20
34001420:	f85d fb04 	ldr.w	pc, [sp], #4
34001424:	ed9f 7b32 	vldr	d7, [pc, #200]	@ 340014f0 <fzFshUNXje+0x108>
34001428:	eeb4 0bc7 	vcmpe.f64	d0, d7
3400142c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001430:	dc09      	bgt.n	34001446 <fzFshUNXje+0x5e>
34001432:	eeb4 1bc7 	vcmpe.f64	d1, d7
34001436:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400143a:	dc04      	bgt.n	34001446 <fzFshUNXje+0x5e>
3400143c:	eeb4 2bc7 	vcmpe.f64	d2, d7
34001440:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001444:	dd07      	ble.n	34001456 <fzFshUNXje+0x6e>
34001446:	ed8d 2b02 	vstr	d2, [sp, #8]
3400144a:	ed8d 1b00 	vstr	d1, [sp]
3400144e:	ec53 2b10 	vmov	r2, r3, d0
34001452:	4836      	ldr	r0, [pc, #216]	@ (3400152c <fzFshUNXje+0x144>)
34001454:	e7df      	b.n	34001416 <fzFshUNXje+0x2e>
34001456:	b128      	cbz	r0, 34001464 <fzFshUNXje+0x7c>
34001458:	b189      	cbz	r1, 3400147e <fzFshUNXje+0x96>
3400145a:	b9b2      	cbnz	r2, 3400148a <fzFshUNXje+0xa2>
3400145c:	4934      	ldr	r1, [pc, #208]	@ (34001530 <fzFshUNXje+0x148>)
3400145e:	4b35      	ldr	r3, [pc, #212]	@ (34001534 <fzFshUNXje+0x14c>)
34001460:	4608      	mov	r0, r1
34001462:	e007      	b.n	34001474 <fzFshUNXje+0x8c>
34001464:	b171      	cbz	r1, 34001484 <fzFshUNXje+0x9c>
34001466:	4933      	ldr	r1, [pc, #204]	@ (34001534 <fzFshUNXje+0x14c>)
34001468:	4831      	ldr	r0, [pc, #196]	@ (34001530 <fzFshUNXje+0x148>)
3400146a:	2a00      	cmp	r2, #0
3400146c:	4a30      	ldr	r2, [pc, #192]	@ (34001530 <fzFshUNXje+0x148>)
3400146e:	4b31      	ldr	r3, [pc, #196]	@ (34001534 <fzFshUNXje+0x14c>)
34001470:	bf18      	it	ne
34001472:	4613      	movne	r3, r2
34001474:	4602      	mov	r2, r0
34001476:	4830      	ldr	r0, [pc, #192]	@ (34001538 <fzFshUNXje+0x150>)
34001478:	f00c f8b4 	bl	3400d5e4 <iprintf>
3400147c:	e7cd      	b.n	3400141a <fzFshUNXje+0x32>
3400147e:	492c      	ldr	r1, [pc, #176]	@ (34001530 <fzFshUNXje+0x148>)
34001480:	482c      	ldr	r0, [pc, #176]	@ (34001534 <fzFshUNXje+0x14c>)
34001482:	e7f2      	b.n	3400146a <fzFshUNXje+0x82>
34001484:	492b      	ldr	r1, [pc, #172]	@ (34001534 <fzFshUNXje+0x14c>)
34001486:	4608      	mov	r0, r1
34001488:	e7ef      	b.n	3400146a <fzFshUNXje+0x82>
3400148a:	ed9f 7b1b 	vldr	d7, [pc, #108]	@ 340014f8 <fzFshUNXje+0x110>
3400148e:	ed9f 6b1c 	vldr	d6, [pc, #112]	@ 34001500 <fzFshUNXje+0x118>
34001492:	ee21 7b07 	vmul.f64	d7, d1, d7
34001496:	eeb3 5b00 	vmov.f64	d5, #48	@ 0x41800000  16.0
3400149a:	eea0 7b06 	vfma.f64	d7, d0, d6
3400149e:	ed9f 6b1a 	vldr	d6, [pc, #104]	@ 34001508 <fzFshUNXje+0x120>
340014a2:	eea2 7b05 	vfma.f64	d7, d2, d5
340014a6:	eea7 5b06 	vfma.f64	d5, d7, d6
340014aa:	ed9f 7b19 	vldr	d7, [pc, #100]	@ 34001510 <fzFshUNXje+0x128>
340014ae:	ed80 5b00 	vstr	d5, [r0]
340014b2:	ee27 7b41 	vnmul.f64	d7, d7, d1
340014b6:	eebb 5b0a 	vmov.f64	d5, #186	@ 0xc1d00000 -26.0
340014ba:	eea0 7b05 	vfma.f64	d7, d0, d5
340014be:	ed9f 5b16 	vldr	d5, [pc, #88]	@ 34001518 <fzFshUNXje+0x130>
340014c2:	eea2 7b05 	vfma.f64	d7, d2, d5
340014c6:	ee27 7b06 	vmul.f64	d7, d7, d6
340014ca:	ed81 7b00 	vstr	d7, [r1]
340014ce:	ed9f 7b14 	vldr	d7, [pc, #80]	@ 34001520 <fzFshUNXje+0x138>
340014d2:	ee27 1b41 	vnmul.f64	d1, d7, d1
340014d6:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
340014da:	eea0 1b05 	vfma.f64	d1, d0, d5
340014de:	eea2 1b47 	vfms.f64	d1, d2, d7
340014e2:	ee21 1b06 	vmul.f64	d1, d1, d6
340014e6:	2001      	movs	r0, #1
340014e8:	ed82 1b00 	vstr	d1, [r2]
340014ec:	e797      	b.n	3400141e <fzFshUNXje+0x36>
340014ee:	bf00      	nop
340014f0:	00000000 	.word	0x00000000
340014f4:	406fe000 	.word	0x406fe000
340014f8:	00000000 	.word	0x00000000
340014fc:	4063a000 	.word	0x4063a000
34001500:	00000000 	.word	0x00000000
34001504:	40478000 	.word	0x40478000
34001508:	00000000 	.word	0x00000000
3400150c:	3f700000 	.word	0x3f700000
34001510:	00000000 	.word	0x00000000
34001514:	40558000 	.word	0x40558000
34001518:	00000000 	.word	0x00000000
3400151c:	405c0000 	.word	0x405c0000
34001520:	00000000 	.word	0x00000000
34001524:	40598000 	.word	0x40598000
34001528:	34010f9c 	.word	0x34010f9c
3400152c:	34010fda 	.word	0x34010fda
34001530:	34010f96 	.word	0x34010f96
34001534:	34010f94 	.word	0x34010f94
34001538:	3401101a 	.word	0x3401101a

3400153c <__aeabi_ldivmod>:
3400153c:	b97b      	cbnz	r3, 3400155e <__aeabi_ldivmod+0x22>
3400153e:	b972      	cbnz	r2, 3400155e <__aeabi_ldivmod+0x22>
34001540:	2900      	cmp	r1, #0
34001542:	bfbe      	ittt	lt
34001544:	2000      	movlt	r0, #0
34001546:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
3400154a:	e006      	blt.n	3400155a <__aeabi_ldivmod+0x1e>
3400154c:	bf08      	it	eq
3400154e:	2800      	cmpeq	r0, #0
34001550:	bf1c      	itt	ne
34001552:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
34001556:	f04f 30ff 	movne.w	r0, #4294967295
3400155a:	f000 b9fb 	b.w	34001954 <__aeabi_idiv0>
3400155e:	f1ad 0c08 	sub.w	ip, sp, #8
34001562:	e96d ce04 	strd	ip, lr, [sp, #-16]!
34001566:	2900      	cmp	r1, #0
34001568:	db09      	blt.n	3400157e <__aeabi_ldivmod+0x42>
3400156a:	2b00      	cmp	r3, #0
3400156c:	db1a      	blt.n	340015a4 <__aeabi_ldivmod+0x68>
3400156e:	f000 f84d 	bl	3400160c <__udivmoddi4>
34001572:	f8dd e004 	ldr.w	lr, [sp, #4]
34001576:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
3400157a:	b004      	add	sp, #16
3400157c:	4770      	bx	lr
3400157e:	4240      	negs	r0, r0
34001580:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34001584:	2b00      	cmp	r3, #0
34001586:	db1b      	blt.n	340015c0 <__aeabi_ldivmod+0x84>
34001588:	f000 f840 	bl	3400160c <__udivmoddi4>
3400158c:	f8dd e004 	ldr.w	lr, [sp, #4]
34001590:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001594:	b004      	add	sp, #16
34001596:	4240      	negs	r0, r0
34001598:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
3400159c:	4252      	negs	r2, r2
3400159e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015a2:	4770      	bx	lr
340015a4:	4252      	negs	r2, r2
340015a6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015aa:	f000 f82f 	bl	3400160c <__udivmoddi4>
340015ae:	f8dd e004 	ldr.w	lr, [sp, #4]
340015b2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340015b6:	b004      	add	sp, #16
340015b8:	4240      	negs	r0, r0
340015ba:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
340015be:	4770      	bx	lr
340015c0:	4252      	negs	r2, r2
340015c2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015c6:	f000 f821 	bl	3400160c <__udivmoddi4>
340015ca:	f8dd e004 	ldr.w	lr, [sp, #4]
340015ce:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340015d2:	b004      	add	sp, #16
340015d4:	4252      	negs	r2, r2
340015d6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015da:	4770      	bx	lr

340015dc <__aeabi_uldivmod>:
340015dc:	b953      	cbnz	r3, 340015f4 <__aeabi_uldivmod+0x18>
340015de:	b94a      	cbnz	r2, 340015f4 <__aeabi_uldivmod+0x18>
340015e0:	2900      	cmp	r1, #0
340015e2:	bf08      	it	eq
340015e4:	2800      	cmpeq	r0, #0
340015e6:	bf1c      	itt	ne
340015e8:	f04f 31ff 	movne.w	r1, #4294967295
340015ec:	f04f 30ff 	movne.w	r0, #4294967295
340015f0:	f000 b9b0 	b.w	34001954 <__aeabi_idiv0>
340015f4:	f1ad 0c08 	sub.w	ip, sp, #8
340015f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
340015fc:	f000 f806 	bl	3400160c <__udivmoddi4>
34001600:	f8dd e004 	ldr.w	lr, [sp, #4]
34001604:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001608:	b004      	add	sp, #16
3400160a:	4770      	bx	lr

3400160c <__udivmoddi4>:
3400160c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34001610:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34001612:	4688      	mov	r8, r1
34001614:	4604      	mov	r4, r0
34001616:	468e      	mov	lr, r1
34001618:	2b00      	cmp	r3, #0
3400161a:	d14a      	bne.n	340016b2 <__udivmoddi4+0xa6>
3400161c:	428a      	cmp	r2, r1
3400161e:	4617      	mov	r7, r2
34001620:	d95f      	bls.n	340016e2 <__udivmoddi4+0xd6>
34001622:	fab2 f682 	clz	r6, r2
34001626:	b14e      	cbz	r6, 3400163c <__udivmoddi4+0x30>
34001628:	f1c6 0320 	rsb	r3, r6, #32
3400162c:	fa01 fe06 	lsl.w	lr, r1, r6
34001630:	40b7      	lsls	r7, r6
34001632:	40b4      	lsls	r4, r6
34001634:	fa20 f303 	lsr.w	r3, r0, r3
34001638:	ea43 0e0e 	orr.w	lr, r3, lr
3400163c:	ea4f 4817 	mov.w	r8, r7, lsr #16
34001640:	fa1f fc87 	uxth.w	ip, r7
34001644:	0c23      	lsrs	r3, r4, #16
34001646:	fbbe f1f8 	udiv	r1, lr, r8
3400164a:	fb08 ee11 	mls	lr, r8, r1, lr
3400164e:	fb01 f20c 	mul.w	r2, r1, ip
34001652:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
34001656:	429a      	cmp	r2, r3
34001658:	d907      	bls.n	3400166a <__udivmoddi4+0x5e>
3400165a:	18fb      	adds	r3, r7, r3
3400165c:	f101 30ff 	add.w	r0, r1, #4294967295
34001660:	d202      	bcs.n	34001668 <__udivmoddi4+0x5c>
34001662:	429a      	cmp	r2, r3
34001664:	f200 8154 	bhi.w	34001910 <__udivmoddi4+0x304>
34001668:	4601      	mov	r1, r0
3400166a:	1a9b      	subs	r3, r3, r2
3400166c:	b2a2      	uxth	r2, r4
3400166e:	fbb3 f0f8 	udiv	r0, r3, r8
34001672:	fb08 3310 	mls	r3, r8, r0, r3
34001676:	fb00 fc0c 	mul.w	ip, r0, ip
3400167a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3400167e:	4594      	cmp	ip, r2
34001680:	d90b      	bls.n	3400169a <__udivmoddi4+0x8e>
34001682:	18ba      	adds	r2, r7, r2
34001684:	f100 33ff 	add.w	r3, r0, #4294967295
34001688:	bf2c      	ite	cs
3400168a:	2401      	movcs	r4, #1
3400168c:	2400      	movcc	r4, #0
3400168e:	4594      	cmp	ip, r2
34001690:	d902      	bls.n	34001698 <__udivmoddi4+0x8c>
34001692:	2c00      	cmp	r4, #0
34001694:	f000 813f 	beq.w	34001916 <__udivmoddi4+0x30a>
34001698:	4618      	mov	r0, r3
3400169a:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
3400169e:	eba2 020c 	sub.w	r2, r2, ip
340016a2:	2100      	movs	r1, #0
340016a4:	b11d      	cbz	r5, 340016ae <__udivmoddi4+0xa2>
340016a6:	40f2      	lsrs	r2, r6
340016a8:	2300      	movs	r3, #0
340016aa:	e9c5 2300 	strd	r2, r3, [r5]
340016ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340016b2:	428b      	cmp	r3, r1
340016b4:	d905      	bls.n	340016c2 <__udivmoddi4+0xb6>
340016b6:	b10d      	cbz	r5, 340016bc <__udivmoddi4+0xb0>
340016b8:	e9c5 0100 	strd	r0, r1, [r5]
340016bc:	2100      	movs	r1, #0
340016be:	4608      	mov	r0, r1
340016c0:	e7f5      	b.n	340016ae <__udivmoddi4+0xa2>
340016c2:	fab3 f183 	clz	r1, r3
340016c6:	2900      	cmp	r1, #0
340016c8:	d14e      	bne.n	34001768 <__udivmoddi4+0x15c>
340016ca:	4543      	cmp	r3, r8
340016cc:	f0c0 8112 	bcc.w	340018f4 <__udivmoddi4+0x2e8>
340016d0:	4282      	cmp	r2, r0
340016d2:	f240 810f 	bls.w	340018f4 <__udivmoddi4+0x2e8>
340016d6:	4608      	mov	r0, r1
340016d8:	2d00      	cmp	r5, #0
340016da:	d0e8      	beq.n	340016ae <__udivmoddi4+0xa2>
340016dc:	e9c5 4e00 	strd	r4, lr, [r5]
340016e0:	e7e5      	b.n	340016ae <__udivmoddi4+0xa2>
340016e2:	2a00      	cmp	r2, #0
340016e4:	f000 80ac 	beq.w	34001840 <__udivmoddi4+0x234>
340016e8:	fab2 f682 	clz	r6, r2
340016ec:	2e00      	cmp	r6, #0
340016ee:	f040 80bb 	bne.w	34001868 <__udivmoddi4+0x25c>
340016f2:	1a8b      	subs	r3, r1, r2
340016f4:	ea4f 4e12 	mov.w	lr, r2, lsr #16
340016f8:	b2bc      	uxth	r4, r7
340016fa:	2101      	movs	r1, #1
340016fc:	0c02      	lsrs	r2, r0, #16
340016fe:	b280      	uxth	r0, r0
34001700:	fbb3 fcfe 	udiv	ip, r3, lr
34001704:	fb0e 331c 	mls	r3, lr, ip, r3
34001708:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
3400170c:	fb04 f20c 	mul.w	r2, r4, ip
34001710:	429a      	cmp	r2, r3
34001712:	d90e      	bls.n	34001732 <__udivmoddi4+0x126>
34001714:	18fb      	adds	r3, r7, r3
34001716:	f10c 38ff 	add.w	r8, ip, #4294967295
3400171a:	bf2c      	ite	cs
3400171c:	f04f 0901 	movcs.w	r9, #1
34001720:	f04f 0900 	movcc.w	r9, #0
34001724:	429a      	cmp	r2, r3
34001726:	d903      	bls.n	34001730 <__udivmoddi4+0x124>
34001728:	f1b9 0f00 	cmp.w	r9, #0
3400172c:	f000 80ec 	beq.w	34001908 <__udivmoddi4+0x2fc>
34001730:	46c4      	mov	ip, r8
34001732:	1a9b      	subs	r3, r3, r2
34001734:	fbb3 f8fe 	udiv	r8, r3, lr
34001738:	fb0e 3318 	mls	r3, lr, r8, r3
3400173c:	fb04 f408 	mul.w	r4, r4, r8
34001740:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
34001744:	4294      	cmp	r4, r2
34001746:	d90b      	bls.n	34001760 <__udivmoddi4+0x154>
34001748:	18ba      	adds	r2, r7, r2
3400174a:	f108 33ff 	add.w	r3, r8, #4294967295
3400174e:	bf2c      	ite	cs
34001750:	2001      	movcs	r0, #1
34001752:	2000      	movcc	r0, #0
34001754:	4294      	cmp	r4, r2
34001756:	d902      	bls.n	3400175e <__udivmoddi4+0x152>
34001758:	2800      	cmp	r0, #0
3400175a:	f000 80d1 	beq.w	34001900 <__udivmoddi4+0x2f4>
3400175e:	4698      	mov	r8, r3
34001760:	1b12      	subs	r2, r2, r4
34001762:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
34001766:	e79d      	b.n	340016a4 <__udivmoddi4+0x98>
34001768:	f1c1 0620 	rsb	r6, r1, #32
3400176c:	408b      	lsls	r3, r1
3400176e:	fa08 f401 	lsl.w	r4, r8, r1
34001772:	fa00 f901 	lsl.w	r9, r0, r1
34001776:	fa22 f706 	lsr.w	r7, r2, r6
3400177a:	fa28 f806 	lsr.w	r8, r8, r6
3400177e:	408a      	lsls	r2, r1
34001780:	431f      	orrs	r7, r3
34001782:	fa20 f306 	lsr.w	r3, r0, r6
34001786:	0c38      	lsrs	r0, r7, #16
34001788:	4323      	orrs	r3, r4
3400178a:	fa1f fc87 	uxth.w	ip, r7
3400178e:	0c1c      	lsrs	r4, r3, #16
34001790:	fbb8 fef0 	udiv	lr, r8, r0
34001794:	fb00 881e 	mls	r8, r0, lr, r8
34001798:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
3400179c:	fb0e f80c 	mul.w	r8, lr, ip
340017a0:	45a0      	cmp	r8, r4
340017a2:	d90e      	bls.n	340017c2 <__udivmoddi4+0x1b6>
340017a4:	193c      	adds	r4, r7, r4
340017a6:	f10e 3aff 	add.w	sl, lr, #4294967295
340017aa:	bf2c      	ite	cs
340017ac:	f04f 0b01 	movcs.w	fp, #1
340017b0:	f04f 0b00 	movcc.w	fp, #0
340017b4:	45a0      	cmp	r8, r4
340017b6:	d903      	bls.n	340017c0 <__udivmoddi4+0x1b4>
340017b8:	f1bb 0f00 	cmp.w	fp, #0
340017bc:	f000 80b8 	beq.w	34001930 <__udivmoddi4+0x324>
340017c0:	46d6      	mov	lr, sl
340017c2:	eba4 0408 	sub.w	r4, r4, r8
340017c6:	fa1f f883 	uxth.w	r8, r3
340017ca:	fbb4 f3f0 	udiv	r3, r4, r0
340017ce:	fb00 4413 	mls	r4, r0, r3, r4
340017d2:	fb03 fc0c 	mul.w	ip, r3, ip
340017d6:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
340017da:	45a4      	cmp	ip, r4
340017dc:	d90e      	bls.n	340017fc <__udivmoddi4+0x1f0>
340017de:	193c      	adds	r4, r7, r4
340017e0:	f103 30ff 	add.w	r0, r3, #4294967295
340017e4:	bf2c      	ite	cs
340017e6:	f04f 0801 	movcs.w	r8, #1
340017ea:	f04f 0800 	movcc.w	r8, #0
340017ee:	45a4      	cmp	ip, r4
340017f0:	d903      	bls.n	340017fa <__udivmoddi4+0x1ee>
340017f2:	f1b8 0f00 	cmp.w	r8, #0
340017f6:	f000 809f 	beq.w	34001938 <__udivmoddi4+0x32c>
340017fa:	4603      	mov	r3, r0
340017fc:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
34001800:	eba4 040c 	sub.w	r4, r4, ip
34001804:	fba0 ec02 	umull	lr, ip, r0, r2
34001808:	4564      	cmp	r4, ip
3400180a:	4673      	mov	r3, lr
3400180c:	46e0      	mov	r8, ip
3400180e:	d302      	bcc.n	34001816 <__udivmoddi4+0x20a>
34001810:	d107      	bne.n	34001822 <__udivmoddi4+0x216>
34001812:	45f1      	cmp	r9, lr
34001814:	d205      	bcs.n	34001822 <__udivmoddi4+0x216>
34001816:	ebbe 0302 	subs.w	r3, lr, r2
3400181a:	eb6c 0c07 	sbc.w	ip, ip, r7
3400181e:	3801      	subs	r0, #1
34001820:	46e0      	mov	r8, ip
34001822:	b15d      	cbz	r5, 3400183c <__udivmoddi4+0x230>
34001824:	ebb9 0203 	subs.w	r2, r9, r3
34001828:	eb64 0408 	sbc.w	r4, r4, r8
3400182c:	fa04 f606 	lsl.w	r6, r4, r6
34001830:	fa22 f301 	lsr.w	r3, r2, r1
34001834:	40cc      	lsrs	r4, r1
34001836:	431e      	orrs	r6, r3
34001838:	e9c5 6400 	strd	r6, r4, [r5]
3400183c:	2100      	movs	r1, #0
3400183e:	e736      	b.n	340016ae <__udivmoddi4+0xa2>
34001840:	fbb1 fcf2 	udiv	ip, r1, r2
34001844:	0c01      	lsrs	r1, r0, #16
34001846:	4614      	mov	r4, r2
34001848:	b280      	uxth	r0, r0
3400184a:	4696      	mov	lr, r2
3400184c:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001850:	2620      	movs	r6, #32
34001852:	4690      	mov	r8, r2
34001854:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34001858:	4610      	mov	r0, r2
3400185a:	fbb1 f1f2 	udiv	r1, r1, r2
3400185e:	eba3 0308 	sub.w	r3, r3, r8
34001862:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34001866:	e74b      	b.n	34001700 <__udivmoddi4+0xf4>
34001868:	40b7      	lsls	r7, r6
3400186a:	f1c6 0320 	rsb	r3, r6, #32
3400186e:	fa01 f206 	lsl.w	r2, r1, r6
34001872:	fa21 f803 	lsr.w	r8, r1, r3
34001876:	ea4f 4e17 	mov.w	lr, r7, lsr #16
3400187a:	fa20 f303 	lsr.w	r3, r0, r3
3400187e:	b2bc      	uxth	r4, r7
34001880:	40b0      	lsls	r0, r6
34001882:	4313      	orrs	r3, r2
34001884:	0c02      	lsrs	r2, r0, #16
34001886:	0c19      	lsrs	r1, r3, #16
34001888:	b280      	uxth	r0, r0
3400188a:	fbb8 f9fe 	udiv	r9, r8, lr
3400188e:	fb0e 8819 	mls	r8, lr, r9, r8
34001892:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001896:	fb09 f804 	mul.w	r8, r9, r4
3400189a:	4588      	cmp	r8, r1
3400189c:	d951      	bls.n	34001942 <__udivmoddi4+0x336>
3400189e:	1879      	adds	r1, r7, r1
340018a0:	f109 3cff 	add.w	ip, r9, #4294967295
340018a4:	bf2c      	ite	cs
340018a6:	f04f 0a01 	movcs.w	sl, #1
340018aa:	f04f 0a00 	movcc.w	sl, #0
340018ae:	4588      	cmp	r8, r1
340018b0:	d902      	bls.n	340018b8 <__udivmoddi4+0x2ac>
340018b2:	f1ba 0f00 	cmp.w	sl, #0
340018b6:	d031      	beq.n	3400191c <__udivmoddi4+0x310>
340018b8:	eba1 0108 	sub.w	r1, r1, r8
340018bc:	fbb1 f9fe 	udiv	r9, r1, lr
340018c0:	fb09 f804 	mul.w	r8, r9, r4
340018c4:	fb0e 1119 	mls	r1, lr, r9, r1
340018c8:	b29b      	uxth	r3, r3
340018ca:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340018ce:	4543      	cmp	r3, r8
340018d0:	d235      	bcs.n	3400193e <__udivmoddi4+0x332>
340018d2:	18fb      	adds	r3, r7, r3
340018d4:	f109 31ff 	add.w	r1, r9, #4294967295
340018d8:	bf2c      	ite	cs
340018da:	f04f 0a01 	movcs.w	sl, #1
340018de:	f04f 0a00 	movcc.w	sl, #0
340018e2:	4543      	cmp	r3, r8
340018e4:	d2bb      	bcs.n	3400185e <__udivmoddi4+0x252>
340018e6:	f1ba 0f00 	cmp.w	sl, #0
340018ea:	d1b8      	bne.n	3400185e <__udivmoddi4+0x252>
340018ec:	f1a9 0102 	sub.w	r1, r9, #2
340018f0:	443b      	add	r3, r7
340018f2:	e7b4      	b.n	3400185e <__udivmoddi4+0x252>
340018f4:	1a84      	subs	r4, r0, r2
340018f6:	eb68 0203 	sbc.w	r2, r8, r3
340018fa:	2001      	movs	r0, #1
340018fc:	4696      	mov	lr, r2
340018fe:	e6eb      	b.n	340016d8 <__udivmoddi4+0xcc>
34001900:	443a      	add	r2, r7
34001902:	f1a8 0802 	sub.w	r8, r8, #2
34001906:	e72b      	b.n	34001760 <__udivmoddi4+0x154>
34001908:	f1ac 0c02 	sub.w	ip, ip, #2
3400190c:	443b      	add	r3, r7
3400190e:	e710      	b.n	34001732 <__udivmoddi4+0x126>
34001910:	3902      	subs	r1, #2
34001912:	443b      	add	r3, r7
34001914:	e6a9      	b.n	3400166a <__udivmoddi4+0x5e>
34001916:	443a      	add	r2, r7
34001918:	3802      	subs	r0, #2
3400191a:	e6be      	b.n	3400169a <__udivmoddi4+0x8e>
3400191c:	eba7 0808 	sub.w	r8, r7, r8
34001920:	f1a9 0c02 	sub.w	ip, r9, #2
34001924:	4441      	add	r1, r8
34001926:	fbb1 f9fe 	udiv	r9, r1, lr
3400192a:	fb09 f804 	mul.w	r8, r9, r4
3400192e:	e7c9      	b.n	340018c4 <__udivmoddi4+0x2b8>
34001930:	f1ae 0e02 	sub.w	lr, lr, #2
34001934:	443c      	add	r4, r7
34001936:	e744      	b.n	340017c2 <__udivmoddi4+0x1b6>
34001938:	3b02      	subs	r3, #2
3400193a:	443c      	add	r4, r7
3400193c:	e75e      	b.n	340017fc <__udivmoddi4+0x1f0>
3400193e:	4649      	mov	r1, r9
34001940:	e78d      	b.n	3400185e <__udivmoddi4+0x252>
34001942:	eba1 0108 	sub.w	r1, r1, r8
34001946:	46cc      	mov	ip, r9
34001948:	fbb1 f9fe 	udiv	r9, r1, lr
3400194c:	fb09 f804 	mul.w	r8, r9, r4
34001950:	e7b8      	b.n	340018c4 <__udivmoddi4+0x2b8>
34001952:	bf00      	nop

34001954 <__aeabi_idiv0>:
34001954:	4770      	bx	lr
34001956:	bf00      	nop

34001958 <app_camera_init_crop_config>:
{
    float ratiox;
    float ratioy;
    float ratio;

    ratiox = (float)sensor_width / LCD_BG_WIDTH;
34001958:	ee07 1a90 	vmov	s15, r1
3400195c:	eef8 6a67 	vcvt.f32.u32	s13, s15
    ratioy = (float)sensor_height / LCD_BG_HEIGHT;
34001960:	ee07 2a90 	vmov	s15, r2
    ratiox = (float)sensor_width / LCD_BG_WIDTH;
34001964:	ed9f 6a19 	vldr	s12, [pc, #100]	@ 340019cc <app_camera_init_crop_config+0x74>
    ratioy = (float)sensor_height / LCD_BG_HEIGHT;
34001968:	eeb8 7a67 	vcvt.f32.u32	s14, s15
    ratiox = (float)sensor_width / LCD_BG_WIDTH;
3400196c:	eec6 5a86 	vdiv.f32	s11, s13, s12
    ratioy = (float)sensor_height / LCD_BG_HEIGHT;
34001970:	eec7 7a06 	vdiv.f32	s15, s14, s12
    ratio = MIN(ratiox, ratioy);
34001974:	eef4 5a67 	vcmp.f32	s11, s15
34001978:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400197c:	bf48      	it	mi
3400197e:	eef0 7a65 	vmovmi.f32	s15, s11

    roi->width = (uint32_t)MIN(LCD_BG_WIDTH * ratio, sensor_width);
34001982:	ee67 7a86 	vmul.f32	s15, s15, s12
34001986:	eef4 6ae7 	vcmpe.f32	s13, s15
3400198a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    roi->height = (uint32_t)MIN(LCD_BG_HEIGHT * ratio, sensor_height);
3400198e:	eeb4 7ae7 	vcmpe.f32	s14, s15
    roi->width = (uint32_t)MIN(LCD_BG_WIDTH * ratio, sensor_width);
34001992:	bfcc      	ite	gt
34001994:	eefc 6ae7 	vcvtgt.u32.f32	s13, s15
34001998:	eefc 6ae6 	vcvtle.u32.f32	s13, s13
    roi->height = (uint32_t)MIN(LCD_BG_HEIGHT * ratio, sensor_height);
3400199c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    roi->offset_x = (sensor_width - roi->width + 1) / 2;
340019a0:	ee16 3a90 	vmov	r3, s13
    roi->height = (uint32_t)MIN(LCD_BG_HEIGHT * ratio, sensor_height);
340019a4:	bfcc      	ite	gt
340019a6:	eebc 7ae7 	vcvtgt.u32.f32	s14, s15
340019aa:	eebc 7ac7 	vcvtle.u32.f32	s14, s14
    roi->offset_x = (sensor_width - roi->width + 1) / 2;
340019ae:	3101      	adds	r1, #1
340019b0:	1ac9      	subs	r1, r1, r3
    roi->offset_y = (sensor_height - roi->height + 1) / 2;
340019b2:	ee17 3a10 	vmov	r3, s14
340019b6:	3201      	adds	r2, #1
340019b8:	1ad2      	subs	r2, r2, r3
    roi->offset_x = (sensor_width - roi->width + 1) / 2;
340019ba:	0849      	lsrs	r1, r1, #1
    roi->offset_y = (sensor_height - roi->height + 1) / 2;
340019bc:	0852      	lsrs	r2, r2, #1
    roi->width = (uint32_t)MIN(LCD_BG_WIDTH * ratio, sensor_width);
340019be:	edc0 6a00 	vstr	s13, [r0]
    roi->height = (uint32_t)MIN(LCD_BG_HEIGHT * ratio, sensor_height);
340019c2:	ed80 7a01 	vstr	s14, [r0, #4]
    roi->offset_x = (sensor_width - roi->width + 1) / 2;
340019c6:	6081      	str	r1, [r0, #8]
    roi->offset_y = (sensor_height - roi->height + 1) / 2;
340019c8:	60c2      	str	r2, [r0, #12]
}
340019ca:	4770      	bx	lr
340019cc:	43f00000 	.word	0x43f00000

340019d0 <app_camera_init>:
{
340019d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cmw_camera_init.mirror_flip = CAMERA_MIRROR_FLIP;
340019d4:	f04f 0802 	mov.w	r8, #2
{
340019d8:	b095      	sub	sp, #84	@ 0x54
340019da:	4607      	mov	r7, r0
340019dc:	460e      	mov	r6, r1
340019de:	4615      	mov	r5, r2
    CMW_CameraInit_t cmw_camera_init = {0};
340019e0:	2100      	movs	r1, #0
340019e2:	2214      	movs	r2, #20
340019e4:	a803      	add	r0, sp, #12
{
340019e6:	461c      	mov	r4, r3
    CMW_CameraInit_t cmw_camera_init = {0};
340019e8:	f00b ff94 	bl	3400d914 <memset>
    CMW_CAMERA_Init(&cmw_camera_init);
340019ec:	a803      	add	r0, sp, #12
    cmw_camera_init.mirror_flip = CAMERA_MIRROR_FLIP;
340019ee:	f8cd 8020 	str.w	r8, [sp, #32]
    CMW_CAMERA_Init(&cmw_camera_init);
340019f2:	f00a fdeb 	bl	3400c5cc <CMW_CAMERA_Init>
    cmw_dcmipp_conf.output_width = LCD_BG_WIDTH;
340019f6:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
    cmw_dcmipp_conf.output_height = LCD_BG_HEIGHT;
340019fa:	e9cd 2209 	strd	r2, r2, [sp, #36]	@ 0x24
    hw_pitch = LCD_BG_WIDTH * 2;
340019fe:	f44f 7270 	mov.w	r2, #960	@ 0x3c0
    CMW_DCMIPP_Conf_t cmw_dcmipp_conf = {0};
34001a02:	2300      	movs	r3, #0
    cmw_dcmipp_conf.output_format = DCMIPP_PIXEL_PACKER_FORMAT_RGB565_1;
34001a04:	f04f 0a01 	mov.w	sl, #1
    cmw_dcmipp_conf.mode = CMW_Aspect_ratio_manual_roi;
34001a08:	f04f 0903 	mov.w	r9, #3
    hw_pitch = LCD_BG_WIDTH * 2;
34001a0c:	9202      	str	r2, [sp, #8]
    app_camera_init_crop_config(&cmw_dcmipp_conf.manual_conf, sensor_width, sensor_height);
34001a0e:	a810      	add	r0, sp, #64	@ 0x40
34001a10:	e9dd 1203 	ldrd	r1, r2, [sp, #12]
    CMW_DCMIPP_Conf_t cmw_dcmipp_conf = {0};
34001a14:	e9cd 330d 	strd	r3, r3, [sp, #52]	@ 0x34
    cmw_dcmipp_conf.output_bpp = 2;
34001a18:	e9cd a80b 	strd	sl, r8, [sp, #44]	@ 0x2c
    cmw_dcmipp_conf.mode = CMW_Aspect_ratio_manual_roi;
34001a1c:	f8cd 903c 	str.w	r9, [sp, #60]	@ 0x3c
    app_camera_init_crop_config(&cmw_dcmipp_conf.manual_conf, sensor_width, sensor_height);
34001a20:	f7ff ff9a 	bl	34001958 <app_camera_init_crop_config>
    CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &cmw_dcmipp_conf, &hw_pitch);
34001a24:	aa02      	add	r2, sp, #8
34001a26:	a909      	add	r1, sp, #36	@ 0x24
34001a28:	4650      	mov	r0, sl
34001a2a:	f00a fc89 	bl	3400c340 <CMW_CAMERA_SetPipeConfig>
    app_camera_nn_pipe_init(cmw_camera_init.width, cmw_camera_init.height);
34001a2e:	9b03      	ldr	r3, [sp, #12]
    CMW_DCMIPP_Conf_t cmw_dcmipp_conf = {0};
34001a30:	2210      	movs	r2, #16
    app_camera_nn_pipe_init(cmw_camera_init.width, cmw_camera_init.height);
34001a32:	9301      	str	r3, [sp, #4]
    CMW_DCMIPP_Conf_t cmw_dcmipp_conf = {0};
34001a34:	2300      	movs	r3, #0
34001a36:	a80b      	add	r0, sp, #44	@ 0x2c
34001a38:	4619      	mov	r1, r3
    app_camera_nn_pipe_init(cmw_camera_init.width, cmw_camera_init.height);
34001a3a:	f8dd b010 	ldr.w	fp, [sp, #16]
    CMW_DCMIPP_Conf_t cmw_dcmipp_conf = {0};
34001a3e:	f00b ff69 	bl	3400d914 <memset>
    cmw_dcmipp_conf.output_width  = NN_WIDTH;
34001a42:	f44f 7380 	mov.w	r3, #256	@ 0x100
    app_camera_init_crop_config(&cmw_dcmipp_conf.manual_conf, sensor_width, sensor_height);
34001a46:	465a      	mov	r2, fp
34001a48:	9901      	ldr	r1, [sp, #4]
34001a4a:	a810      	add	r0, sp, #64	@ 0x40
    cmw_dcmipp_conf.output_height = NN_HEIGHT;
34001a4c:	e9cd 3309 	strd	r3, r3, [sp, #36]	@ 0x24
    cmw_dcmipp_conf.enable_swap = 1;
34001a50:	e9cd 9a0c 	strd	r9, sl, [sp, #48]	@ 0x30
    cmw_dcmipp_conf.mode = CMW_Aspect_ratio_manual_roi;
34001a54:	f8cd 903c 	str.w	r9, [sp, #60]	@ 0x3c
    app_camera_init_crop_config(&cmw_dcmipp_conf.manual_conf, sensor_width, sensor_height);
34001a58:	f7ff ff7e 	bl	34001958 <app_camera_init_crop_config>
    uint32_t hw_pitch = NN_WIDTH * NN_BPP;
34001a5c:	f44f 7340 	mov.w	r3, #768	@ 0x300
    CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &cmw_dcmipp_conf, &hw_pitch);
34001a60:	4640      	mov	r0, r8
34001a62:	aa02      	add	r2, sp, #8
34001a64:	a909      	add	r1, sp, #36	@ 0x24
    uint32_t hw_pitch = NN_WIDTH * NN_BPP;
34001a66:	9302      	str	r3, [sp, #8]
    CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &cmw_dcmipp_conf, &hw_pitch);
34001a68:	f00a fc6a 	bl	3400c340 <CMW_CAMERA_SetPipeConfig>
    if (display_pipe_vsync_cb != NULL)
34001a6c:	b10f      	cbz	r7, 34001a72 <app_camera_init+0xa2>
        app_camera_display_pipe_vsync_user_cb = display_pipe_vsync_cb;
34001a6e:	4b07      	ldr	r3, [pc, #28]	@ (34001a8c <app_camera_init+0xbc>)
34001a70:	601f      	str	r7, [r3, #0]
    if (display_pipe_frame_cb != NULL)
34001a72:	b10e      	cbz	r6, 34001a78 <app_camera_init+0xa8>
        app_camera_display_pipe_frame_user_cb = display_pipe_frame_cb;
34001a74:	4b06      	ldr	r3, [pc, #24]	@ (34001a90 <app_camera_init+0xc0>)
34001a76:	601e      	str	r6, [r3, #0]
    if (nn_pipe_vsync_cb != NULL)
34001a78:	b10d      	cbz	r5, 34001a7e <app_camera_init+0xae>
        app_camera_nn_pipe_vsync_user_cb = nn_pipe_vsync_cb;
34001a7a:	4b06      	ldr	r3, [pc, #24]	@ (34001a94 <app_camera_init+0xc4>)
34001a7c:	601d      	str	r5, [r3, #0]
    if (nn_pipe_frame_cb != NULL)
34001a7e:	b10c      	cbz	r4, 34001a84 <app_camera_init+0xb4>
        app_camera_nn_pipe_frame_user_cb = nn_pipe_frame_cb;
34001a80:	4b05      	ldr	r3, [pc, #20]	@ (34001a98 <app_camera_init+0xc8>)
34001a82:	601c      	str	r4, [r3, #0]
}
34001a84:	b015      	add	sp, #84	@ 0x54
34001a86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34001a8a:	bf00      	nop
34001a8c:	34013fdc 	.word	0x34013fdc
34001a90:	34013fd8 	.word	0x34013fd8
34001a94:	34013fd4 	.word	0x34013fd4
34001a98:	34013fd0 	.word	0x34013fd0

34001a9c <app_camera_display_pipe_start>:
{
34001a9c:	460a      	mov	r2, r1
    CMW_CAMERA_Start(DCMIPP_PIPE1, display_pipe_destination, capture_mode);
34001a9e:	4601      	mov	r1, r0
34001aa0:	2001      	movs	r0, #1
34001aa2:	f00a bd0f 	b.w	3400c4c4 <CMW_CAMERA_Start>

34001aa6 <app_camera_display_pipe_set_address>:
{
34001aa6:	b510      	push	{r4, lr}
34001aa8:	4604      	mov	r4, r0
    HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE1, DCMIPP_MEMORY_ADDRESS_0, (uint32_t)display_pipe_destination);
34001aaa:	f00a fc45 	bl	3400c338 <CMW_CAMERA_GetDCMIPPHandle>
34001aae:	4623      	mov	r3, r4
}
34001ab0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE1, DCMIPP_MEMORY_ADDRESS_0, (uint32_t)display_pipe_destination);
34001ab4:	2200      	movs	r2, #0
34001ab6:	2101      	movs	r1, #1
34001ab8:	f002 bf57 	b.w	3400496a <HAL_DCMIPP_PIPE_SetMemoryAddress>

34001abc <app_camera_isp_update>:
    CMW_CAMERA_Run();
34001abc:	f00a bde2 	b.w	3400c684 <CMW_CAMERA_Run>

34001ac0 <MX_DCMIPP_ClockConfig>:

HAL_StatusTypeDef MX_DCMIPP_ClockConfig(DCMIPP_HandleTypeDef *hdcmipp)
{
34001ac0:	b500      	push	{lr}
34001ac2:	b0e5      	sub	sp, #404	@ 0x194
    RCC_PeriphCLKInitTypeDef rcc_periph_clk_init_struct = {0};
34001ac4:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34001ac8:	2100      	movs	r1, #0
34001aca:	4668      	mov	r0, sp
34001acc:	f00b ff22 	bl	3400d914 <memset>

    rcc_periph_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_DCMIPP | RCC_PERIPHCLK_CSI;
34001ad0:	2218      	movs	r2, #24
34001ad2:	2300      	movs	r3, #0
34001ad4:	e9cd 2300 	strd	r2, r3, [sp]
    rcc_periph_clk_init_struct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
34001ad8:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
    rcc_periph_clk_init_struct.ICSelection[RCC_IC17].ClockSelection = RCC_ICCLKSOURCE_PLL2;
    rcc_periph_clk_init_struct.ICSelection[RCC_IC17].ClockDivider = 3;
34001adc:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
    rcc_periph_clk_init_struct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
34001ae0:	9332      	str	r3, [sp, #200]	@ 0xc8
    rcc_periph_clk_init_struct.ICSelection[RCC_IC17].ClockDivider = 3;
34001ae2:	2303      	movs	r3, #3
34001ae4:	e9cd 1322 	strd	r1, r3, [sp, #136]	@ 0x88
    rcc_periph_clk_init_struct.ICSelection[RCC_IC18].ClockSelection = RCC_ICCLKSOURCE_PLL1;
    rcc_periph_clk_init_struct.ICSelection[RCC_IC18].ClockDivider = 40;
34001ae8:	2328      	movs	r3, #40	@ 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&rcc_periph_clk_init_struct) != HAL_OK)
34001aea:	4668      	mov	r0, sp
    rcc_periph_clk_init_struct.ICSelection[RCC_IC18].ClockDivider = 40;
34001aec:	9325      	str	r3, [sp, #148]	@ 0x94
    if (HAL_RCCEx_PeriphCLKConfig(&rcc_periph_clk_init_struct) != HAL_OK)
34001aee:	f004 fcb9 	bl	34006464 <HAL_RCCEx_PeriphCLKConfig>
    {
        return HAL_ERROR;
    }

    return HAL_OK;
}
34001af2:	3800      	subs	r0, #0
34001af4:	bf18      	it	ne
34001af6:	2001      	movne	r0, #1
34001af8:	b065      	add	sp, #404	@ 0x194
34001afa:	f85d fb04 	ldr.w	pc, [sp], #4
	...

34001b00 <app_lcd_init>:

static app_rectangle_t app_lcd_bg_area = {0};
static app_rectangle_t app_lcd_fg_area = {0};

void app_lcd_init(void)
{
34001b00:	b570      	push	{r4, r5, r6, lr}
    bsp_lcd_layer_config_t bsp_lcd_layer_config = {0};

    memset(app_lcd_bg_buffer, 0, sizeof(app_lcd_bg_buffer));
34001b02:	4d43      	ldr	r5, [pc, #268]	@ (34001c10 <app_lcd_init+0x110>)
{
34001b04:	b086      	sub	sp, #24
    bsp_lcd_layer_config_t bsp_lcd_layer_config = {0};
34001b06:	2218      	movs	r2, #24
34001b08:	2100      	movs	r1, #0
34001b0a:	4668      	mov	r0, sp
34001b0c:	f00b ff02 	bl	3400d914 <memset>
    memset(app_lcd_bg_buffer, 0, sizeof(app_lcd_bg_buffer));
34001b10:	f44f 12e1 	mov.w	r2, #1843200	@ 0x1c2000
34001b14:	2100      	movs	r1, #0
34001b16:	4628      	mov	r0, r5
34001b18:	f00b fefc 	bl	3400d914 <memset>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
34001b1c:	f3bf 8f4f 	dsb	sy
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;

      __DSB();

      do {
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34001b20:	f44f 4e61 	mov.w	lr, #57600	@ 0xe100
}
34001b24:	2300      	movs	r3, #0
34001b26:	f04e e001 	dls	lr, lr
34001b2a:	4a3a      	ldr	r2, [pc, #232]	@ (34001c14 <app_lcd_init+0x114>)
34001b2c:	18e9      	adds	r1, r5, r3
34001b2e:	f8c2 1270 	str.w	r1, [r2, #624]	@ 0x270
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
        op_size -=          __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
34001b32:	3320      	adds	r3, #32
34001b34:	f00f c007 	le	lr, 34001b2c <app_lcd_init+0x2c>
  __ASM volatile ("dsb 0xF":::"memory");
34001b38:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001b3c:	f3bf 8f6f 	isb	sy
    SCB_CleanInvalidateDCache_by_Addr(app_lcd_bg_buffer, sizeof(app_lcd_bg_buffer));
    memset(app_lcd_fg_buffer, 0, sizeof(app_lcd_fg_buffer));
34001b40:	4c35      	ldr	r4, [pc, #212]	@ (34001c18 <app_lcd_init+0x118>)
34001b42:	2100      	movs	r1, #0
34001b44:	4620      	mov	r0, r4
34001b46:	4a35      	ldr	r2, [pc, #212]	@ (34001c1c <app_lcd_init+0x11c>)
34001b48:	f00b fee4 	bl	3400d914 <memset>
  __ASM volatile ("dsb 0xF":::"memory");
34001b4c:	f3bf 8f4f 	dsb	sy
34001b50:	f64b 3e80 	movw	lr, #48000	@ 0xbb80
}
34001b54:	2300      	movs	r3, #0
34001b56:	f04e e001 	dls	lr, lr
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34001b5a:	4a2e      	ldr	r2, [pc, #184]	@ (34001c14 <app_lcd_init+0x114>)
34001b5c:	18e1      	adds	r1, r4, r3
34001b5e:	f8c2 1270 	str.w	r1, [r2, #624]	@ 0x270
      } while ( op_size > 0 );
34001b62:	3320      	adds	r3, #32
34001b64:	f00f c007 	le	lr, 34001b5c <app_lcd_init+0x5c>
  __ASM volatile ("dsb 0xF":::"memory");
34001b68:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001b6c:	f3bf 8f6f 	isb	sy
    SCB_CleanInvalidateDCache_by_Addr(app_lcd_fg_buffer, sizeof(app_lcd_fg_buffer));

    bsp_lcd_init();
34001b70:	f001 fd40 	bl	340035f4 <bsp_lcd_init>
    bsp_lcd_set_brightness(100);
34001b74:	2064      	movs	r0, #100	@ 0x64
34001b76:	f001 fd45 	bl	34003604 <bsp_lcd_set_brightness>

    bsp_lcd_layer_config.x0 = (BSP_LCD_WIDTH - LCD_BG_WIDTH) / 2;
    bsp_lcd_layer_config.y0 = (BSP_LCD_HEIGHT - LCD_BG_HEIGHT) / 2;
    bsp_lcd_layer_config.x1 = bsp_lcd_layer_config.x0 + LCD_BG_WIDTH;
    bsp_lcd_layer_config.y1 = bsp_lcd_layer_config.y0 + LCD_BG_HEIGHT;
34001b7a:	2400      	movs	r4, #0
34001b7c:	f44f 76f0 	mov.w	r6, #480	@ 0x1e0
34001b80:	22a0      	movs	r2, #160	@ 0xa0
34001b82:	f44f 7320 	mov.w	r3, #640	@ 0x280
34001b86:	e88d 005c 	stmia.w	sp, {r2, r3, r4, r6}
    bsp_lcd_layer_config.pixel_format = LCD_PIXEL_FORMAT_RGB565;
34001b8a:	2302      	movs	r3, #2
    bsp_lcd_layer_config.address = (uint32_t)app_lcd_bg_buffer[app_lcd_bg_buffer_disp_idx];
34001b8c:	f44f 22e1 	mov.w	r2, #460800	@ 0x70800
    bsp_lcd_layer_config.pixel_format = LCD_PIXEL_FORMAT_RGB565;
34001b90:	9304      	str	r3, [sp, #16]
    bsp_lcd_layer_config.address = (uint32_t)app_lcd_bg_buffer[app_lcd_bg_buffer_disp_idx];
34001b92:	4b23      	ldr	r3, [pc, #140]	@ (34001c20 <app_lcd_init+0x120>)
    bsp_lcd_config_layer(0, &bsp_lcd_layer_config);
34001b94:	4669      	mov	r1, sp
    bsp_lcd_layer_config.address = (uint32_t)app_lcd_bg_buffer[app_lcd_bg_buffer_disp_idx];
34001b96:	781b      	ldrb	r3, [r3, #0]
    bsp_lcd_config_layer(0, &bsp_lcd_layer_config);
34001b98:	4620      	mov	r0, r4
    bsp_lcd_layer_config.address = (uint32_t)app_lcd_bg_buffer[app_lcd_bg_buffer_disp_idx];
34001b9a:	fb02 5503 	mla	r5, r2, r3, r5
34001b9e:	9505      	str	r5, [sp, #20]
    bsp_lcd_config_layer(0, &bsp_lcd_layer_config);
34001ba0:	f001 fcba 	bl	34003518 <bsp_lcd_config_layer>

    app_lcd_bg_area.x_pos = bsp_lcd_layer_config.x0;
34001ba4:	9800      	ldr	r0, [sp, #0]
    app_lcd_bg_area.y_pos = bsp_lcd_layer_config.y0;
    app_lcd_bg_area.width = bsp_lcd_layer_config.x1 - bsp_lcd_layer_config.x0;
34001ba6:	9a01      	ldr	r2, [sp, #4]
    app_lcd_bg_area.x_pos = bsp_lcd_layer_config.x0;
34001ba8:	4b1e      	ldr	r3, [pc, #120]	@ (34001c24 <app_lcd_init+0x124>)
    app_lcd_bg_area.width = bsp_lcd_layer_config.x1 - bsp_lcd_layer_config.x0;
34001baa:	1a12      	subs	r2, r2, r0
    app_lcd_bg_area.y_pos = bsp_lcd_layer_config.y0;
34001bac:	9902      	ldr	r1, [sp, #8]
    app_lcd_bg_area.width = bsp_lcd_layer_config.x1 - bsp_lcd_layer_config.x0;
34001bae:	609a      	str	r2, [r3, #8]
    app_lcd_bg_area.height = bsp_lcd_layer_config.y1 - bsp_lcd_layer_config.y0;
34001bb0:	9a03      	ldr	r2, [sp, #12]
    app_lcd_bg_area.x_pos = bsp_lcd_layer_config.x0;
34001bb2:	6018      	str	r0, [r3, #0]
    app_lcd_bg_area.height = bsp_lcd_layer_config.y1 - bsp_lcd_layer_config.y0;
34001bb4:	1a52      	subs	r2, r2, r1
    app_lcd_bg_area.y_pos = bsp_lcd_layer_config.y0;
34001bb6:	6059      	str	r1, [r3, #4]
    app_lcd_bg_area.height = bsp_lcd_layer_config.y1 - bsp_lcd_layer_config.y0;
34001bb8:	60da      	str	r2, [r3, #12]

    bsp_lcd_layer_config.x0 = (BSP_LCD_WIDTH - LCD_FG_WIDTH) / 2;
    bsp_lcd_layer_config.y0 = (BSP_LCD_HEIGHT - LCD_FG_HEIGHT) / 2;
    bsp_lcd_layer_config.x1 = bsp_lcd_layer_config.x0 + LCD_FG_WIDTH;
34001bba:	f44f 7348 	mov.w	r3, #800	@ 0x320
34001bbe:	9301      	str	r3, [sp, #4]
    bsp_lcd_layer_config.y1 = bsp_lcd_layer_config.y0 + LCD_FG_HEIGHT;
    bsp_lcd_layer_config.pixel_format = LCD_PIXEL_FORMAT_ARGB4444;
34001bc0:	2304      	movs	r3, #4
34001bc2:	9304      	str	r3, [sp, #16]
    bsp_lcd_layer_config.address = (uint32_t)app_lcd_fg_buffer[1];
34001bc4:	4b18      	ldr	r3, [pc, #96]	@ (34001c28 <app_lcd_init+0x128>)
    bsp_lcd_config_layer(1, &bsp_lcd_layer_config);
34001bc6:	4669      	mov	r1, sp
34001bc8:	2001      	movs	r0, #1
    bsp_lcd_layer_config.address = (uint32_t)app_lcd_fg_buffer[1];
34001bca:	9305      	str	r3, [sp, #20]
    bsp_lcd_layer_config.x0 = (BSP_LCD_WIDTH - LCD_FG_WIDTH) / 2;
34001bcc:	9400      	str	r4, [sp, #0]
    bsp_lcd_layer_config.y0 = (BSP_LCD_HEIGHT - LCD_FG_HEIGHT) / 2;
34001bce:	9402      	str	r4, [sp, #8]
    bsp_lcd_layer_config.y1 = bsp_lcd_layer_config.y0 + LCD_FG_HEIGHT;
34001bd0:	9603      	str	r6, [sp, #12]
    bsp_lcd_config_layer(1, &bsp_lcd_layer_config);
34001bd2:	f001 fca1 	bl	34003518 <bsp_lcd_config_layer>

    app_lcd_fg_area.x_pos = bsp_lcd_layer_config.x0;
34001bd6:	9800      	ldr	r0, [sp, #0]
    app_lcd_fg_area.y_pos = bsp_lcd_layer_config.y0;
    app_lcd_fg_area.width = bsp_lcd_layer_config.x1 - bsp_lcd_layer_config.x0;
34001bd8:	9a01      	ldr	r2, [sp, #4]
    app_lcd_fg_area.x_pos = bsp_lcd_layer_config.x0;
34001bda:	4b14      	ldr	r3, [pc, #80]	@ (34001c2c <app_lcd_init+0x12c>)
    app_lcd_fg_area.width = bsp_lcd_layer_config.x1 - bsp_lcd_layer_config.x0;
34001bdc:	1a12      	subs	r2, r2, r0
    app_lcd_fg_area.y_pos = bsp_lcd_layer_config.y0;
34001bde:	9902      	ldr	r1, [sp, #8]
    app_lcd_fg_area.width = bsp_lcd_layer_config.x1 - bsp_lcd_layer_config.x0;
34001be0:	609a      	str	r2, [r3, #8]
    app_lcd_fg_area.height = bsp_lcd_layer_config.y1 - bsp_lcd_layer_config.y0;
34001be2:	9a03      	ldr	r2, [sp, #12]
    app_lcd_fg_area.x_pos = bsp_lcd_layer_config.x0;
34001be4:	6018      	str	r0, [r3, #0]
    app_lcd_fg_area.height = bsp_lcd_layer_config.y1 - bsp_lcd_layer_config.y0;
34001be6:	1a52      	subs	r2, r2, r1

    UTIL_LCD_SetFuncDriver(&bsp_lcd_driver);
34001be8:	4811      	ldr	r0, [pc, #68]	@ (34001c30 <app_lcd_init+0x130>)
    app_lcd_fg_area.y_pos = bsp_lcd_layer_config.y0;
34001bea:	6059      	str	r1, [r3, #4]
    app_lcd_fg_area.height = bsp_lcd_layer_config.y1 - bsp_lcd_layer_config.y0;
34001bec:	60da      	str	r2, [r3, #12]
    UTIL_LCD_SetFuncDriver(&bsp_lcd_driver);
34001bee:	f000 fdeb 	bl	340027c8 <UTIL_LCD_SetFuncDriver>
    UTIL_LCD_SetLayer(1);
34001bf2:	2001      	movs	r0, #1
34001bf4:	f000 fe18 	bl	34002828 <UTIL_LCD_SetLayer>
    UTIL_LCD_Clear(0x00000000);
34001bf8:	4620      	mov	r0, r4
34001bfa:	f000 fe8b 	bl	34002914 <UTIL_LCD_Clear>
    UTIL_LCD_SetFont(&Font20);
34001bfe:	480d      	ldr	r0, [pc, #52]	@ (34001c34 <app_lcd_init+0x134>)
34001c00:	f000 fe40 	bl	34002884 <UTIL_LCD_SetFont>
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
34001c04:	f04f 30ff 	mov.w	r0, #4294967295
34001c08:	f000 fe34 	bl	34002874 <UTIL_LCD_SetTextColor>
}
34001c0c:	b006      	add	sp, #24
34001c0e:	bd70      	pop	{r4, r5, r6, pc}
34001c10:	90177000 	.word	0x90177000
34001c14:	e000ed00 	.word	0xe000ed00
34001c18:	90000000 	.word	0x90000000
34001c1c:	00177000 	.word	0x00177000
34001c20:	34013b14 	.word	0x34013b14
34001c24:	34013ff0 	.word	0x34013ff0
34001c28:	900bb800 	.word	0x900bb800
34001c2c:	34013fe0 	.word	0x34013fe0
34001c30:	3401038c 	.word	0x3401038c
34001c34:	34013b0c 	.word	0x34013b0c

34001c38 <app_lcd_get_bg_buffer>:
}

uint8_t *app_lcd_get_bg_buffer(void)
{
    return app_lcd_get_bg_buffer_by_index(app_lcd_bg_buffer_fill_idx);
}
34001c38:	f44f 20e1 	mov.w	r0, #460800	@ 0x70800
    return app_lcd_get_bg_buffer_by_index(app_lcd_bg_buffer_fill_idx);
34001c3c:	4b02      	ldr	r3, [pc, #8]	@ (34001c48 <app_lcd_get_bg_buffer+0x10>)
    return app_lcd_bg_buffer[index];
34001c3e:	781a      	ldrb	r2, [r3, #0]
}
34001c40:	4b02      	ldr	r3, [pc, #8]	@ (34001c4c <app_lcd_get_bg_buffer+0x14>)
34001c42:	fb00 3002 	mla	r0, r0, r2, r3
34001c46:	4770      	bx	lr
34001c48:	34014000 	.word	0x34014000
34001c4c:	90177000 	.word	0x90177000

34001c50 <app_lcd_switch_bg_buffer>:

void app_lcd_switch_bg_buffer(void)
{
34001c50:	b510      	push	{r4, lr}
    app_lcd_bg_buffer_disp_idx = (app_lcd_bg_buffer_disp_idx + 1) % DISPLAY_BUFFER_NB;
34001c52:	4c0f      	ldr	r4, [pc, #60]	@ (34001c90 <app_lcd_switch_bg_buffer+0x40>)
    app_lcd_bg_buffer_fill_idx = (app_lcd_bg_buffer_fill_idx + 1) % DISPLAY_BUFFER_NB;
34001c54:	4a0f      	ldr	r2, [pc, #60]	@ (34001c94 <app_lcd_switch_bg_buffer+0x44>)
    app_lcd_bg_buffer_disp_idx = (app_lcd_bg_buffer_disp_idx + 1) % DISPLAY_BUFFER_NB;
34001c56:	7823      	ldrb	r3, [r4, #0]
34001c58:	3301      	adds	r3, #1
34001c5a:	f003 0303 	and.w	r3, r3, #3
34001c5e:	7023      	strb	r3, [r4, #0]
    app_lcd_bg_buffer_fill_idx = (app_lcd_bg_buffer_fill_idx + 1) % DISPLAY_BUFFER_NB;
34001c60:	7813      	ldrb	r3, [r2, #0]
34001c62:	3301      	adds	r3, #1
34001c64:	f003 0303 	and.w	r3, r3, #3
34001c68:	7013      	strb	r3, [r2, #0]

    HAL_LTDC_SetAddress_NoReload(bsp_lcd_get_ltdc_handle(), (uint32_t)app_lcd_bg_buffer[app_lcd_bg_buffer_disp_idx], 0);
34001c6a:	f001 fcd5 	bl	34003618 <bsp_lcd_get_ltdc_handle>
34001c6e:	7821      	ldrb	r1, [r4, #0]
34001c70:	f44f 24e1 	mov.w	r4, #460800	@ 0x70800
34001c74:	4b08      	ldr	r3, [pc, #32]	@ (34001c98 <app_lcd_switch_bg_buffer+0x48>)
34001c76:	2200      	movs	r2, #0
34001c78:	fb04 3101 	mla	r1, r4, r1, r3
34001c7c:	f004 f9d5 	bl	3400602a <HAL_LTDC_SetAddress_NoReload>
    HAL_LTDC_ReloadLayer(bsp_lcd_get_ltdc_handle(), LTDC_RELOAD_VERTICAL_BLANKING, 0);
34001c80:	f001 fcca 	bl	34003618 <bsp_lcd_get_ltdc_handle>
}
34001c84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_LTDC_ReloadLayer(bsp_lcd_get_ltdc_handle(), LTDC_RELOAD_VERTICAL_BLANKING, 0);
34001c88:	2200      	movs	r2, #0
34001c8a:	2102      	movs	r1, #2
34001c8c:	f004 b9b1 	b.w	34005ff2 <HAL_LTDC_ReloadLayer>
34001c90:	34013b14 	.word	0x34013b14
34001c94:	34014000 	.word	0x34014000
34001c98:	90177000 	.word	0x90177000

34001c9c <MX_CACHEAXI_Init>:

CACHEAXI_HandleTypeDef hcacheaxi;

/* CACHEAXI init function */
void MX_CACHEAXI_Init(void)
{
34001c9c:	b508      	push	{r3, lr}
  /* USER CODE END CACHEAXI_Init 0 */

  /* USER CODE BEGIN CACHEAXI_Init 1 */

  /* USER CODE END CACHEAXI_Init 1 */
  hcacheaxi.Instance = CACHEAXI;
34001c9e:	4805      	ldr	r0, [pc, #20]	@ (34001cb4 <MX_CACHEAXI_Init+0x18>)
34001ca0:	4b05      	ldr	r3, [pc, #20]	@ (34001cb8 <MX_CACHEAXI_Init+0x1c>)
34001ca2:	6003      	str	r3, [r0, #0]
  if (HAL_CACHEAXI_Init(&hcacheaxi) != HAL_OK)
34001ca4:	f001 fd3b 	bl	3400371e <HAL_CACHEAXI_Init>
34001ca8:	b118      	cbz	r0, 34001cb2 <MX_CACHEAXI_Init+0x16>
  }
  /* USER CODE BEGIN CACHEAXI_Init 2 */

  /* USER CODE END CACHEAXI_Init 2 */

}
34001caa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
34001cae:	f000 bd2f 	b.w	34002710 <Error_Handler>
}
34001cb2:	bd08      	pop	{r3, pc}
34001cb4:	34014004 	.word	0x34014004
34001cb8:	580dfc00 	.word	0x580dfc00

34001cbc <HAL_CACHEAXI_MspInit>:

void HAL_CACHEAXI_MspInit(CACHEAXI_HandleTypeDef* cacheaxiHandle)
{

  if(cacheaxiHandle->Instance==CACHEAXI)
34001cbc:	6802      	ldr	r2, [r0, #0]
34001cbe:	4b07      	ldr	r3, [pc, #28]	@ (34001cdc <HAL_CACHEAXI_MspInit+0x20>)
{
34001cc0:	b082      	sub	sp, #8
  if(cacheaxiHandle->Instance==CACHEAXI)
34001cc2:	429a      	cmp	r2, r3
34001cc4:	d108      	bne.n	34001cd8 <HAL_CACHEAXI_MspInit+0x1c>
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34001cc6:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34001cca:	4b05      	ldr	r3, [pc, #20]	@ (34001ce0 <HAL_CACHEAXI_MspInit+0x24>)
34001ccc:	f8c3 2a60 	str.w	r2, [r3, #2656]	@ 0xa60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5ENR);
34001cd0:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34001cd4:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001cd6:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_CACHEAXI_CLK_ENABLE();
  /* USER CODE BEGIN CACHEAXI_MspInit 1 */

  /* USER CODE END CACHEAXI_MspInit 1 */
  }
}
34001cd8:	b002      	add	sp, #8
34001cda:	4770      	bx	lr
34001cdc:	580dfc00 	.word	0x580dfc00
34001ce0:	56028000 	.word	0x56028000

34001ce4 <MX_DCMIPP_Init>:

DCMIPP_HandleTypeDef hdcmipp;

/* DCMIPP init function */
void MX_DCMIPP_Init(void)
{
34001ce4:	b510      	push	{r4, lr}

  /* USER CODE BEGIN DCMIPP_Init 0 */

  /* USER CODE END DCMIPP_Init 0 */

  DCMIPP_CSI_PIPE_ConfTypeDef pCSI_PipeConfig = {0};
34001ce6:	2400      	movs	r4, #0
  DCMIPP_PipeConfTypeDef pPipeConfig = {0};

  /* USER CODE BEGIN DCMIPP_Init 1 */

  /* USER CODE END DCMIPP_Init 1 */
  hdcmipp.Instance = DCMIPP;
34001ce8:	4830      	ldr	r0, [pc, #192]	@ (34001dac <MX_DCMIPP_Init+0xc8>)
34001cea:	4b31      	ldr	r3, [pc, #196]	@ (34001db0 <MX_DCMIPP_Init+0xcc>)
{
34001cec:	b08a      	sub	sp, #40	@ 0x28
  DCMIPP_CSI_PIPE_ConfTypeDef pCSI_PipeConfig = {0};
34001cee:	e9cd 4401 	strd	r4, r4, [sp, #4]
  DCMIPP_CSI_ConfTypeDef pCSI_Config = {0};
34001cf2:	e9cd 4403 	strd	r4, r4, [sp, #12]
34001cf6:	e9cd 4405 	strd	r4, r4, [sp, #20]
  DCMIPP_PipeConfTypeDef pPipeConfig = {0};
34001cfa:	e9cd 4407 	strd	r4, r4, [sp, #28]
34001cfe:	9409      	str	r4, [sp, #36]	@ 0x24
  hdcmipp.Instance = DCMIPP;
34001d00:	6003      	str	r3, [r0, #0]
  if (HAL_DCMIPP_Init(&hdcmipp) != HAL_OK)
34001d02:	f001 fe83 	bl	34003a0c <HAL_DCMIPP_Init>
34001d06:	b108      	cbz	r0, 34001d0c <MX_DCMIPP_Init+0x28>
  {
    Error_Handler();
34001d08:	f000 fd02 	bl	34002710 <Error_Handler>
  }

  /** Pipe 0 Config
  */
  pCSI_PipeConfig.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  pCSI_PipeConfig.DataTypeIDA = DCMIPP_DT_YUV420_8;
34001d0c:	2318      	movs	r3, #24
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_YUV420_8;
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE0, &pCSI_PipeConfig) != HAL_OK)
34001d0e:	2100      	movs	r1, #0
34001d10:	4826      	ldr	r0, [pc, #152]	@ (34001dac <MX_DCMIPP_Init+0xc8>)
34001d12:	aa01      	add	r2, sp, #4
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_YUV420_8;
34001d14:	e9cd 3302 	strd	r3, r3, [sp, #8]
  pCSI_PipeConfig.DataTypeMode = DCMIPP_DTMODE_DTIDA;
34001d18:	9401      	str	r4, [sp, #4]
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE0, &pCSI_PipeConfig) != HAL_OK)
34001d1a:	f001 ff19 	bl	34003b50 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34001d1e:	b108      	cbz	r0, 34001d24 <MX_DCMIPP_Init+0x40>
  {
    Error_Handler();
34001d20:	f000 fcf6 	bl	34002710 <Error_Handler>
  }
  pCSI_Config.PHYBitrate = DCMIPP_CSI_PHY_BT_80;
  pCSI_Config.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
34001d24:	2301      	movs	r3, #1
34001d26:	2400      	movs	r4, #0
34001d28:	e9cd 3405 	strd	r3, r4, [sp, #20]
  pCSI_Config.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
34001d2c:	f44f 7380 	mov.w	r3, #256	@ 0x100
  if (HAL_DCMIPP_CSI_SetConfig(&hdcmipp, &pCSI_Config) != HAL_OK)
34001d30:	481e      	ldr	r0, [pc, #120]	@ (34001dac <MX_DCMIPP_Init+0xc8>)
34001d32:	a904      	add	r1, sp, #16
  pCSI_Config.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
34001d34:	9304      	str	r3, [sp, #16]
  if (HAL_DCMIPP_CSI_SetConfig(&hdcmipp, &pCSI_Config) != HAL_OK)
34001d36:	f001 fe7d 	bl	34003a34 <HAL_DCMIPP_CSI_SetConfig>
34001d3a:	b108      	cbz	r0, 34001d40 <MX_DCMIPP_Init+0x5c>
  {
    Error_Handler();
34001d3c:	f000 fce8 	bl	34002710 <Error_Handler>
  }
  pPipeConfig.FrameRate = DCMIPP_FRAME_RATE_ALL;
  pPipeConfig.PixelPipePitch = 10;
34001d40:	230a      	movs	r3, #10
  pPipeConfig.PixelPackerFormat = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE0, &pPipeConfig) != HAL_OK)
34001d42:	2100      	movs	r1, #0
34001d44:	4819      	ldr	r0, [pc, #100]	@ (34001dac <MX_DCMIPP_Init+0xc8>)
34001d46:	aa07      	add	r2, sp, #28
  pPipeConfig.PixelPackerFormat = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
34001d48:	e9cd 3408 	strd	r3, r4, [sp, #32]
  pPipeConfig.FrameRate = DCMIPP_FRAME_RATE_ALL;
34001d4c:	9407      	str	r4, [sp, #28]
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE0, &pPipeConfig) != HAL_OK)
34001d4e:	f001 ff79 	bl	34003c44 <HAL_DCMIPP_PIPE_SetConfig>
34001d52:	b108      	cbz	r0, 34001d58 <MX_DCMIPP_Init+0x74>
  {
    Error_Handler();
34001d54:	f000 fcdc 	bl	34002710 <Error_Handler>
  }
  HAL_DCMIPP_CSI_SetVCConfig(&hdcmipp, 0U, DCMIPP_CSI_DT_BPP6);
34001d58:	2200      	movs	r2, #0
34001d5a:	4814      	ldr	r0, [pc, #80]	@ (34001dac <MX_DCMIPP_Init+0xc8>)
34001d5c:	4611      	mov	r1, r2
34001d5e:	f001 ff4d 	bl	34003bfc <HAL_DCMIPP_CSI_SetVCConfig>

  /** Pipe 1 Config
  */
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE1, &pCSI_PipeConfig) != HAL_OK)
34001d62:	2101      	movs	r1, #1
34001d64:	4811      	ldr	r0, [pc, #68]	@ (34001dac <MX_DCMIPP_Init+0xc8>)
34001d66:	aa01      	add	r2, sp, #4
34001d68:	f001 fef2 	bl	34003b50 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34001d6c:	b108      	cbz	r0, 34001d72 <MX_DCMIPP_Init+0x8e>
  {
    Error_Handler();
34001d6e:	f000 fccf 	bl	34002710 <Error_Handler>
  }
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE1, &pPipeConfig) != HAL_OK)
34001d72:	2101      	movs	r1, #1
34001d74:	480d      	ldr	r0, [pc, #52]	@ (34001dac <MX_DCMIPP_Init+0xc8>)
34001d76:	aa07      	add	r2, sp, #28
34001d78:	f001 ff64 	bl	34003c44 <HAL_DCMIPP_PIPE_SetConfig>
34001d7c:	b108      	cbz	r0, 34001d82 <MX_DCMIPP_Init+0x9e>
  {
    Error_Handler();
34001d7e:	f000 fcc7 	bl	34002710 <Error_Handler>
  }

  /** Pipe 2 Config
  */
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_RGB565;
34001d82:	2322      	movs	r3, #34	@ 0x22
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE2, &pCSI_PipeConfig) != HAL_OK)
34001d84:	2102      	movs	r1, #2
34001d86:	4809      	ldr	r0, [pc, #36]	@ (34001dac <MX_DCMIPP_Init+0xc8>)
34001d88:	aa01      	add	r2, sp, #4
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_RGB565;
34001d8a:	9303      	str	r3, [sp, #12]
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE2, &pCSI_PipeConfig) != HAL_OK)
34001d8c:	f001 fee0 	bl	34003b50 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34001d90:	b108      	cbz	r0, 34001d96 <MX_DCMIPP_Init+0xb2>
  {
    Error_Handler();
34001d92:	f000 fcbd 	bl	34002710 <Error_Handler>
  }
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE2, &pPipeConfig) != HAL_OK)
34001d96:	2102      	movs	r1, #2
34001d98:	4804      	ldr	r0, [pc, #16]	@ (34001dac <MX_DCMIPP_Init+0xc8>)
34001d9a:	aa07      	add	r2, sp, #28
34001d9c:	f001 ff52 	bl	34003c44 <HAL_DCMIPP_PIPE_SetConfig>
34001da0:	b108      	cbz	r0, 34001da6 <MX_DCMIPP_Init+0xc2>
  {
    Error_Handler();
34001da2:	f000 fcb5 	bl	34002710 <Error_Handler>
  }
  /* USER CODE BEGIN DCMIPP_Init 2 */

  /* USER CODE END DCMIPP_Init 2 */

}
34001da6:	b00a      	add	sp, #40	@ 0x28
34001da8:	bd10      	pop	{r4, pc}
34001daa:	bf00      	nop
34001dac:	34014010 	.word	0x34014010
34001db0:	58002000 	.word	0x58002000

34001db4 <MX_DMA2D_Init>:

DMA2D_HandleTypeDef hdma2d;

/* DMA2D init function */
void MX_DMA2D_Init(void)
{
34001db4:	b508      	push	{r3, lr}

  /* USER CODE BEGIN DMA2D_Init 1 */

  /* USER CODE END DMA2D_Init 1 */
  hdma2d.Instance = DMA2D;
  hdma2d.Init.Mode = DMA2D_M2M;
34001db6:	2300      	movs	r3, #0
  hdma2d.Instance = DMA2D;
34001db8:	480c      	ldr	r0, [pc, #48]	@ (34001dec <MX_DMA2D_Init+0x38>)
  hdma2d.Init.Mode = DMA2D_M2M;
34001dba:	4a0d      	ldr	r2, [pc, #52]	@ (34001df0 <MX_DMA2D_Init+0x3c>)
  hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
  hdma2d.Init.OutputOffset = 0;
  hdma2d.LayerCfg[1].InputOffset = 0;
  hdma2d.LayerCfg[1].InputColorMode = DMA2D_INPUT_RGB565;
  hdma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
  hdma2d.LayerCfg[1].InputAlpha = 0;
34001dbc:	e9c0 3313 	strd	r3, r3, [r0, #76]	@ 0x4c
  hdma2d.Init.Mode = DMA2D_M2M;
34001dc0:	e9c0 2300 	strd	r2, r3, [r0]
  hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
34001dc4:	2202      	movs	r2, #2
  hdma2d.Init.OutputOffset = 0;
34001dc6:	e9c0 2302 	strd	r2, r3, [r0, #8]
  hdma2d.LayerCfg[1].InputColorMode = DMA2D_INPUT_RGB565;
34001dca:	e9c0 3211 	strd	r3, r2, [r0, #68]	@ 0x44
  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
34001dce:	f002 ff5e 	bl	34004c8e <HAL_DMA2D_Init>
34001dd2:	b108      	cbz	r0, 34001dd8 <MX_DMA2D_Init+0x24>
  {
    Error_Handler();
34001dd4:	f000 fc9c 	bl	34002710 <Error_Handler>
  }
  if (HAL_DMA2D_ConfigLayer(&hdma2d, 1) != HAL_OK)
34001dd8:	2101      	movs	r1, #1
34001dda:	4804      	ldr	r0, [pc, #16]	@ (34001dec <MX_DMA2D_Init+0x38>)
34001ddc:	f003 f82c 	bl	34004e38 <HAL_DMA2D_ConfigLayer>
34001de0:	b118      	cbz	r0, 34001dea <MX_DMA2D_Init+0x36>
  }
  /* USER CODE BEGIN DMA2D_Init 2 */

  /* USER CODE END DMA2D_Init 2 */

}
34001de2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
34001de6:	f000 bc93 	b.w	34002710 <Error_Handler>
}
34001dea:	bd08      	pop	{r3, pc}
34001dec:	3401401c 	.word	0x3401401c
34001df0:	58021000 	.word	0x58021000

34001df4 <HAL_DMA2D_MspInit>:

void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* dma2dHandle)
{

  if(dma2dHandle->Instance==DMA2D)
34001df4:	6802      	ldr	r2, [r0, #0]
34001df6:	4b07      	ldr	r3, [pc, #28]	@ (34001e14 <HAL_DMA2D_MspInit+0x20>)
{
34001df8:	b082      	sub	sp, #8
  if(dma2dHandle->Instance==DMA2D)
34001dfa:	429a      	cmp	r2, r3
34001dfc:	d107      	bne.n	34001e0e <HAL_DMA2D_MspInit+0x1a>
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34001dfe:	2202      	movs	r2, #2
34001e00:	4b05      	ldr	r3, [pc, #20]	@ (34001e18 <HAL_DMA2D_MspInit+0x24>)
34001e02:	f8c3 2a60 	str.w	r2, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34001e06:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34001e0a:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001e0c:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_DMA2D_CLK_ENABLE();
  /* USER CODE BEGIN DMA2D_MspInit 1 */

  /* USER CODE END DMA2D_MspInit 1 */
  }
}
34001e0e:	b002      	add	sp, #8
34001e10:	4770      	bx	lr
34001e12:	bf00      	nop
34001e14:	58021000 	.word	0x58021000
34001e18:	56028000 	.word	0x56028000

34001e1c <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34001e1c:	4b04      	ldr	r3, [pc, #16]	@ (34001e30 <LL_AHB4_GRP1_EnableClock+0x14>)
{
34001e1e:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34001e20:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34001e24:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34001e28:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001e2a:	9b01      	ldr	r3, [sp, #4]
}
34001e2c:	b002      	add	sp, #8
34001e2e:	4770      	bx	lr
34001e30:	56028000 	.word	0x56028000

34001e34 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Configure pins
*/
void MX_GPIO_Init(void)
{
34001e34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34001e38:	b086      	sub	sp, #24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
34001e3a:	2214      	movs	r2, #20
34001e3c:	2100      	movs	r1, #0
34001e3e:	a801      	add	r0, sp, #4
34001e40:	f00b fd68 	bl	3400d914 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOD_CLK_ENABLE();
34001e44:	2008      	movs	r0, #8
34001e46:	f7ff ffe9 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOE_CLK_ENABLE();
34001e4a:	2010      	movs	r0, #16
34001e4c:	f7ff ffe6 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
34001e50:	2002      	movs	r0, #2
34001e52:	f7ff ffe3 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOH_CLK_ENABLE();
34001e56:	2080      	movs	r0, #128	@ 0x80
34001e58:	f7ff ffe0 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOP_CLK_ENABLE();
34001e5c:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34001e60:	f7ff ffdc 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOO_CLK_ENABLE();
34001e64:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34001e68:	f7ff ffd8 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOG_CLK_ENABLE();
34001e6c:	2040      	movs	r0, #64	@ 0x40
34001e6e:	f7ff ffd5 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOF_CLK_ENABLE();
34001e72:	2020      	movs	r0, #32
34001e74:	f7ff ffd2 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPION_CLK_ENABLE();
34001e78:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34001e7c:	f7ff ffce 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
34001e80:	2001      	movs	r0, #1
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);

  /*Configure GPIO pin : PE10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34001e82:	2401      	movs	r4, #1
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001e84:	2603      	movs	r6, #3
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34001e86:	f44f 6880 	mov.w	r8, #1024	@ 0x400
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001e8a:	2702      	movs	r7, #2
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_10, GPIO_PIN_SET);
34001e8c:	f8df a084 	ldr.w	sl, [pc, #132]	@ 34001f14 <MX_GPIO_Init+0xe0>
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_4, GPIO_PIN_RESET);
34001e90:	4d1f      	ldr	r5, [pc, #124]	@ (34001f10 <MX_GPIO_Init+0xdc>)
  __HAL_RCC_GPIOA_CLK_ENABLE();
34001e92:	f7ff ffc3 	bl	34001e1c <LL_AHB4_GRP1_EnableClock>
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_10, GPIO_PIN_SET);
34001e96:	4602      	mov	r2, r0
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
34001e98:	f8df 907c 	ldr.w	r9, [pc, #124]	@ 34001f18 <MX_GPIO_Init+0xe4>
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_10, GPIO_PIN_SET);
34001e9c:	4650      	mov	r0, sl
34001e9e:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34001ea2:	f003 f9c7 	bl	34005234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_4, GPIO_PIN_RESET);
34001ea6:	4628      	mov	r0, r5
34001ea8:	2200      	movs	r2, #0
34001eaa:	2150      	movs	r1, #80	@ 0x50
34001eac:	f003 f9c2 	bl	34005234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
34001eb0:	4648      	mov	r0, r9
34001eb2:	2200      	movs	r2, #0
34001eb4:	2108      	movs	r1, #8
34001eb6:	f003 f9bd 	bl	34005234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
34001eba:	2201      	movs	r2, #1
34001ebc:	4628      	mov	r0, r5
34001ebe:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34001ec2:	f003 f9b7 	bl	34005234 <HAL_GPIO_WritePin>
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
34001ec6:	4650      	mov	r0, sl
34001ec8:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34001eca:	e9cd 8401 	strd	r8, r4, [sp, #4]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001ece:	e9cd 7603 	strd	r7, r6, [sp, #12]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
34001ed2:	f003 f80f 	bl	34004ef4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG6 PG4 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_4;
34001ed6:	2350      	movs	r3, #80	@ 0x50
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
34001ed8:	4628      	mov	r0, r5
34001eda:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34001edc:	e9cd 3401 	strd	r3, r4, [sp, #4]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001ee0:	e9cd 4603 	strd	r4, r6, [sp, #12]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
34001ee4:	f003 f806 	bl	34004ef4 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA3 */
  GPIO_InitStruct.Pin = GPIO_PIN_3;
34001ee8:	2308      	movs	r3, #8
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34001eea:	4648      	mov	r0, r9
34001eec:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34001eee:	e9cd 3401 	strd	r3, r4, [sp, #4]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001ef2:	e9cd 4603 	strd	r4, r6, [sp, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34001ef6:	f002 fffd 	bl	34004ef4 <HAL_GPIO_Init>
  /*Configure GPIO pin : PG10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
34001efa:	4628      	mov	r0, r5
34001efc:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34001efe:	e9cd 8401 	strd	r8, r4, [sp, #4]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001f02:	e9cd 7603 	strd	r7, r6, [sp, #12]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
34001f06:	f002 fff5 	bl	34004ef4 <HAL_GPIO_Init>

}
34001f0a:	b006      	add	sp, #24
34001f0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34001f10:	56021800 	.word	0x56021800
34001f14:	56021000 	.word	0x56021000
34001f18:	56020000 	.word	0x56020000

34001f1c <MX_I2C2_Init>:

I2C_HandleTypeDef hi2c2;

/* I2C2 init function */
void MX_I2C2_Init(void)
{
34001f1c:	b508      	push	{r3, lr}
  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
34001f1e:	4812      	ldr	r0, [pc, #72]	@ (34001f68 <MX_I2C2_Init+0x4c>)
  hi2c2.Init.Timing = 0x30C0EDFF;
34001f20:	4a12      	ldr	r2, [pc, #72]	@ (34001f6c <MX_I2C2_Init+0x50>)
34001f22:	4b13      	ldr	r3, [pc, #76]	@ (34001f70 <MX_I2C2_Init+0x54>)
34001f24:	e9c0 2300 	strd	r2, r3, [r0]
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
34001f28:	2300      	movs	r3, #0
34001f2a:	2201      	movs	r2, #1
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
34001f2c:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
34001f30:	e9c0 3202 	strd	r3, r2, [r0, #8]
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
34001f34:	e9c0 3306 	strd	r3, r3, [r0, #24]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
34001f38:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
34001f3a:	f003 fada 	bl	340054f2 <HAL_I2C_Init>
34001f3e:	b108      	cbz	r0, 34001f44 <MX_I2C2_Init+0x28>
  {
    Error_Handler();
34001f40:	f000 fbe6 	bl	34002710 <Error_Handler>
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
34001f44:	2100      	movs	r1, #0
34001f46:	4808      	ldr	r0, [pc, #32]	@ (34001f68 <MX_I2C2_Init+0x4c>)
34001f48:	f003 fcfa 	bl	34005940 <HAL_I2CEx_ConfigAnalogFilter>
34001f4c:	b108      	cbz	r0, 34001f52 <MX_I2C2_Init+0x36>
  {
    Error_Handler();
34001f4e:	f000 fbdf 	bl	34002710 <Error_Handler>
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
34001f52:	2100      	movs	r1, #0
34001f54:	4804      	ldr	r0, [pc, #16]	@ (34001f68 <MX_I2C2_Init+0x4c>)
34001f56:	f003 fd19 	bl	3400598c <HAL_I2CEx_ConfigDigitalFilter>
34001f5a:	b118      	cbz	r0, 34001f64 <MX_I2C2_Init+0x48>
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}
34001f5c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
34001f60:	f000 bbd6 	b.w	34002710 <Error_Handler>
}
34001f64:	bd08      	pop	{r3, pc}
34001f66:	bf00      	nop
34001f68:	34014084 	.word	0x34014084
34001f6c:	50005800 	.word	0x50005800
34001f70:	30c0edff 	.word	0x30c0edff

34001f74 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
34001f74:	b510      	push	{r4, lr}
34001f76:	4604      	mov	r4, r0
34001f78:	b0ec      	sub	sp, #432	@ 0x1b0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
34001f7a:	2214      	movs	r2, #20
34001f7c:	2100      	movs	r1, #0
34001f7e:	a803      	add	r0, sp, #12
34001f80:	f00b fcc8 	bl	3400d914 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34001f84:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34001f88:	2100      	movs	r1, #0
34001f8a:	a808      	add	r0, sp, #32
34001f8c:	f00b fcc2 	bl	3400d914 <memset>
  if(i2cHandle->Instance==I2C2)
34001f90:	6822      	ldr	r2, [r4, #0]
34001f92:	4b18      	ldr	r3, [pc, #96]	@ (34001ff4 <HAL_I2C_MspInit+0x80>)
34001f94:	429a      	cmp	r2, r3
34001f96:	d12b      	bne.n	34001ff0 <HAL_I2C_MspInit+0x7c>

  /* USER CODE END I2C2_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C2;
34001f98:	2300      	movs	r3, #0
34001f9a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34001f9e:	e9cd 2308 	strd	r2, r3, [sp, #32]
    PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
34001fa2:	4b15      	ldr	r3, [pc, #84]	@ (34001ff8 <HAL_I2C_MspInit+0x84>)
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34001fa4:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
34001fa6:	9343      	str	r3, [sp, #268]	@ 0x10c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34001fa8:	f004 fa5c 	bl	34006464 <HAL_RCCEx_PeriphCLKConfig>
34001fac:	b108      	cbz	r0, 34001fb2 <HAL_I2C_MspInit+0x3e>
    {
      Error_Handler();
34001fae:	f000 fbaf 	bl	34002710 <Error_Handler>
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34001fb2:	2308      	movs	r3, #8
34001fb4:	4c11      	ldr	r4, [pc, #68]	@ (34001ffc <HAL_I2C_MspInit+0x88>)
    /**I2C2 GPIO Configuration
    PD4     ------> I2C2_SDA
    PD14     ------> I2C2_SCL
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_14;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
34001fb6:	f244 0210 	movw	r2, #16400	@ 0x4010
34001fba:	f8c4 3a5c 	str.w	r3, [r4, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34001fbe:	f8d4 325c 	ldr.w	r3, [r4, #604]	@ 0x25c
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001fc2:	2100      	movs	r1, #0
34001fc4:	9302      	str	r3, [sp, #8]
  (void)tmpreg;
34001fc6:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
34001fc8:	2312      	movs	r3, #18
34001fca:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001fce:	2303      	movs	r3, #3
34001fd0:	e9cd 1305 	strd	r1, r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
34001fd4:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
34001fd6:	480a      	ldr	r0, [pc, #40]	@ (34002000 <HAL_I2C_MspInit+0x8c>)
34001fd8:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
34001fda:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
34001fdc:	f002 ff8a 	bl	34004ef4 <HAL_GPIO_Init>
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB1ENSR1, Periphs);
34001fe0:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34001fe4:	f8c4 3a64 	str.w	r3, [r4, #2660]	@ 0xa64
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB1ENR1);
34001fe8:	f8d4 3264 	ldr.w	r3, [r4, #612]	@ 0x264
34001fec:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001fee:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_I2C2_CLK_ENABLE();
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
}
34001ff0:	b06c      	add	sp, #432	@ 0x1b0
34001ff2:	bd10      	pop	{r4, pc}
34001ff4:	50005800 	.word	0x50005800
34001ff8:	0700040c 	.word	0x0700040c
34001ffc:	56028000 	.word	0x56028000
34002000:	56020c00 	.word	0x56020c00

34002004 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{
34002004:	b508      	push	{r3, lr}

  if(i2cHandle->Instance==I2C2)
34002006:	6802      	ldr	r2, [r0, #0]
34002008:	4b09      	ldr	r3, [pc, #36]	@ (34002030 <HAL_I2C_MspDeInit+0x2c>)
3400200a:	429a      	cmp	r2, r3
3400200c:	d10f      	bne.n	3400202e <HAL_I2C_MspDeInit+0x2a>
  *         @arg @ref LL_APB1_GRP1_PERIPH_UART8
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
{
  WRITE_REG(RCC->APB1ENCR1, Periphs);
3400200e:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
34002012:	4b08      	ldr	r3, [pc, #32]	@ (34002034 <HAL_I2C_MspDeInit+0x30>)

    /**I2C2 GPIO Configuration
    PD4     ------> I2C2_SDA
    PD14     ------> I2C2_SCL
    */
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_4);
34002014:	2110      	movs	r1, #16
34002016:	4808      	ldr	r0, [pc, #32]	@ (34002038 <HAL_I2C_MspDeInit+0x34>)
34002018:	f8c3 2264 	str.w	r2, [r3, #612]	@ 0x264
3400201c:	f003 f85a 	bl	340050d4 <HAL_GPIO_DeInit>

  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
  }
}
34002020:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_14);
34002024:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
34002028:	4803      	ldr	r0, [pc, #12]	@ (34002038 <HAL_I2C_MspDeInit+0x34>)
3400202a:	f003 b853 	b.w	340050d4 <HAL_GPIO_DeInit>
}
3400202e:	bd08      	pop	{r3, pc}
34002030:	50005800 	.word	0x50005800
34002034:	56029000 	.word	0x56029000
34002038:	56020c00 	.word	0x56020c00

3400203c <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3400203c:	4b04      	ldr	r3, [pc, #16]	@ (34002050 <LL_AHB4_GRP1_EnableClock+0x14>)
{
3400203e:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002040:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34002044:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34002048:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400204a:	9b01      	ldr	r3, [sp, #4]
}
3400204c:	b002      	add	sp, #8
3400204e:	4770      	bx	lr
34002050:	56028000 	.word	0x56028000

34002054 <MX_LTDC_Init>:

LTDC_HandleTypeDef hltdc;

/* LTDC init function */
void MX_LTDC_Init(void)
{
34002054:	b530      	push	{r4, r5, lr}
34002056:	b09b      	sub	sp, #108	@ 0x6c

  /* USER CODE BEGIN LTDC_Init 0 */

  /* USER CODE END LTDC_Init 0 */

  LTDC_LayerCfgTypeDef pLayerCfg = {0};
34002058:	2234      	movs	r2, #52	@ 0x34
3400205a:	2100      	movs	r1, #0
3400205c:	4668      	mov	r0, sp
3400205e:	f00b fc59 	bl	3400d914 <memset>
  LTDC_LayerCfgTypeDef pLayerCfg1 = {0};
34002062:	2234      	movs	r2, #52	@ 0x34

  /* USER CODE BEGIN LTDC_Init 1 */

  /* USER CODE END LTDC_Init 1 */
  hltdc.Instance = LTDC;
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
34002064:	2400      	movs	r4, #0
  LTDC_LayerCfgTypeDef pLayerCfg1 = {0};
34002066:	2100      	movs	r1, #0
34002068:	eb0d 0002 	add.w	r0, sp, r2
3400206c:	f00b fc52 	bl	3400d914 <memset>
  hltdc.Instance = LTDC;
34002070:	4832      	ldr	r0, [pc, #200]	@ (3400213c <MX_LTDC_Init+0xe8>)
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
34002072:	4b33      	ldr	r3, [pc, #204]	@ (34002140 <MX_LTDC_Init+0xec>)
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
  hltdc.Init.HorizontalSync = 47;
  hltdc.Init.VerticalSync = 2;
34002074:	f04f 0e2f 	mov.w	lr, #47	@ 0x2f
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
34002078:	e9c0 3400 	strd	r3, r4, [r0]
  hltdc.Init.VerticalSync = 2;
3400207c:	2302      	movs	r3, #2
  hltdc.Init.AccumulatedHBP = 135;
  hltdc.Init.AccumulatedVBP = 34;
3400207e:	2287      	movs	r2, #135	@ 0x87
  hltdc.Init.VerticalSync = 2;
34002080:	e9c0 e305 	strd	lr, r3, [r0, #20]
  hltdc.Init.AccumulatedVBP = 34;
34002084:	2322      	movs	r3, #34	@ 0x22
  hltdc.Init.AccumulatedActiveW = 935;
  hltdc.Init.AccumulatedActiveH = 514;
34002086:	f240 31a7 	movw	r1, #935	@ 0x3a7
  hltdc.Init.AccumulatedVBP = 34;
3400208a:	e9c0 2307 	strd	r2, r3, [r0, #28]
  hltdc.Init.AccumulatedActiveH = 514;
3400208e:	f240 2302 	movw	r3, #514	@ 0x202
  hltdc.Init.TotalWidth = 975;
  hltdc.Init.TotalHeigh = 527;
34002092:	f240 35cf 	movw	r5, #975	@ 0x3cf
  hltdc.Init.AccumulatedActiveH = 514;
34002096:	e9c0 1309 	strd	r1, r3, [r0, #36]	@ 0x24
  hltdc.Init.TotalHeigh = 527;
3400209a:	f240 230f 	movw	r3, #527	@ 0x20f
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
3400209e:	e9c0 4402 	strd	r4, r4, [r0, #8]
  hltdc.Init.TotalHeigh = 527;
340020a2:	e9c0 530b 	strd	r5, r3, [r0, #44]	@ 0x2c
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
340020a6:	6104      	str	r4, [r0, #16]
  hltdc.Init.Backcolor.Blue = 0;
340020a8:	8684      	strh	r4, [r0, #52]	@ 0x34
  hltdc.Init.Backcolor.Green = 0;
  hltdc.Init.Backcolor.Red = 0;
340020aa:	f880 4036 	strb.w	r4, [r0, #54]	@ 0x36
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
340020ae:	f003 ff0d 	bl	34005ecc <HAL_LTDC_Init>
340020b2:	b108      	cbz	r0, 340020b8 <MX_LTDC_Init+0x64>
  {
    Error_Handler();
340020b4:	f000 fb2c 	bl	34002710 <Error_Handler>
  }
  pLayerCfg.WindowX0 = 0;
  pLayerCfg.WindowX1 = 800;
  pLayerCfg.WindowY0 = 0;
  pLayerCfg.WindowY1 = 480;
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB888;//565
340020b8:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
340020bc:	2206      	movs	r2, #6
340020be:	e9cd 3203 	strd	r3, r2, [sp, #12]
  pLayerCfg.Alpha = 0xFF;
340020c2:	22ff      	movs	r2, #255	@ 0xff
  pLayerCfg.Alpha0 = 0;
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
340020c4:	f44f 6cc0 	mov.w	ip, #1536	@ 0x600
  pLayerCfg.Alpha0 = 0;
340020c8:	e9cd 2405 	strd	r2, r4, [sp, #20]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
340020cc:	2207      	movs	r2, #7
  pLayerCfg.WindowX1 = 800;
340020ce:	f44f 7548 	mov.w	r5, #800	@ 0x320
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
340020d2:	e9cd c207 	strd	ip, r2, [sp, #28]
  pLayerCfg.ImageWidth = 800;
  pLayerCfg.ImageHeight = 480;
  pLayerCfg.Backcolor.Blue = 0;
  pLayerCfg.Backcolor.Green = 0;
  pLayerCfg.Backcolor.Red = 0;
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
340020d6:	4669      	mov	r1, sp
340020d8:	2200      	movs	r2, #0
340020da:	4818      	ldr	r0, [pc, #96]	@ (3400213c <MX_LTDC_Init+0xe8>)
  pLayerCfg.WindowY0 = 0;
340020dc:	e9cd 5401 	strd	r5, r4, [sp, #4]
  pLayerCfg.ImageWidth = 800;
340020e0:	e9cd 4509 	strd	r4, r5, [sp, #36]	@ 0x24
  pLayerCfg.WindowX0 = 0;
340020e4:	9400      	str	r4, [sp, #0]
  pLayerCfg.ImageHeight = 480;
340020e6:	930b      	str	r3, [sp, #44]	@ 0x2c
  pLayerCfg.Backcolor.Blue = 0;
340020e8:	f8ad 4030 	strh.w	r4, [sp, #48]	@ 0x30
  pLayerCfg.Backcolor.Red = 0;
340020ec:	f88d 4032 	strb.w	r4, [sp, #50]	@ 0x32
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
340020f0:	f003 ff46 	bl	34005f80 <HAL_LTDC_ConfigLayer>
340020f4:	b108      	cbz	r0, 340020fa <MX_LTDC_Init+0xa6>
  {
    Error_Handler();
340020f6:	f000 fb0b 	bl	34002710 <Error_Handler>
  }
  pLayerCfg1.WindowX0 = 0;
  pLayerCfg1.WindowX1 = 800;
  pLayerCfg1.WindowY0 = 0;
  pLayerCfg1.WindowY1 = 480;
  pLayerCfg1.PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
340020fa:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
340020fe:	2108      	movs	r1, #8
  pLayerCfg1.Alpha = 0;
  pLayerCfg1.Alpha0 = 0;
  pLayerCfg1.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34002100:	f44f 60c0 	mov.w	r0, #1536	@ 0x600
  pLayerCfg1.PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
34002104:	e9cd 2110 	strd	r2, r1, [sp, #64]	@ 0x40
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34002108:	2107      	movs	r1, #7
  pLayerCfg1.WindowX0 = 0;
3400210a:	2300      	movs	r3, #0
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
3400210c:	e9cd 0114 	strd	r0, r1, [sp, #80]	@ 0x50
  pLayerCfg1.FBStartAdress = 0;
  pLayerCfg1.ImageWidth = 800;
  pLayerCfg1.ImageHeight = 480;
34002110:	9218      	str	r2, [sp, #96]	@ 0x60
  pLayerCfg1.Backcolor.Blue = 0;
  pLayerCfg1.Backcolor.Green = 0;
  pLayerCfg1.Backcolor.Red = 0;
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg1, 1) != HAL_OK)
34002112:	480a      	ldr	r0, [pc, #40]	@ (3400213c <MX_LTDC_Init+0xe8>)
34002114:	2201      	movs	r2, #1
34002116:	a90d      	add	r1, sp, #52	@ 0x34
  pLayerCfg1.WindowX1 = 800;
34002118:	e9cd 350d 	strd	r3, r5, [sp, #52]	@ 0x34
  pLayerCfg1.Alpha0 = 0;
3400211c:	e9cd 3312 	strd	r3, r3, [sp, #72]	@ 0x48
  pLayerCfg1.ImageWidth = 800;
34002120:	e9cd 3516 	strd	r3, r5, [sp, #88]	@ 0x58
  pLayerCfg1.WindowY0 = 0;
34002124:	930f      	str	r3, [sp, #60]	@ 0x3c
  pLayerCfg1.Backcolor.Blue = 0;
34002126:	f8ad 3064 	strh.w	r3, [sp, #100]	@ 0x64
  pLayerCfg1.Backcolor.Red = 0;
3400212a:	f88d 3066 	strb.w	r3, [sp, #102]	@ 0x66
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg1, 1) != HAL_OK)
3400212e:	f003 ff27 	bl	34005f80 <HAL_LTDC_ConfigLayer>
34002132:	b108      	cbz	r0, 34002138 <MX_LTDC_Init+0xe4>
  {
    Error_Handler();
34002134:	f000 faec 	bl	34002710 <Error_Handler>
  }
  /* USER CODE BEGIN LTDC_Init 2 */

  /* USER CODE END LTDC_Init 2 */

}
34002138:	b01b      	add	sp, #108	@ 0x6c
3400213a:	bd30      	pop	{r4, r5, pc}
3400213c:	340140d8 	.word	0x340140d8
34002140:	58001000 	.word	0x58001000

34002144 <HAL_LTDC_MspInit>:

void HAL_LTDC_MspInit(LTDC_HandleTypeDef* ltdcHandle)
{
34002144:	b5f0      	push	{r4, r5, r6, r7, lr}
34002146:	4604      	mov	r4, r0
34002148:	b0eb      	sub	sp, #428	@ 0x1ac

  GPIO_InitTypeDef GPIO_InitStruct = {0};
3400214a:	2214      	movs	r2, #20
3400214c:	2100      	movs	r1, #0
3400214e:	a801      	add	r0, sp, #4
34002150:	f00b fbe0 	bl	3400d914 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34002154:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34002158:	2100      	movs	r1, #0
3400215a:	a806      	add	r0, sp, #24
3400215c:	f00b fbda 	bl	3400d914 <memset>
  if(ltdcHandle->Instance==LTDC)
34002160:	6822      	ldr	r2, [r4, #0]
34002162:	4b3a      	ldr	r3, [pc, #232]	@ (3400224c <HAL_LTDC_MspInit+0x108>)
34002164:	429a      	cmp	r2, r3
34002166:	d16e      	bne.n	34002246 <HAL_LTDC_MspInit+0x102>

  /* USER CODE END LTDC_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
34002168:	2300      	movs	r3, #0
3400216a:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3400216e:	e9cd 2306 	strd	r2, r3, [sp, #24]
    PeriphClkInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34002172:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34002176:	934c      	str	r3, [sp, #304]	@ 0x130
    PeriphClkInitStruct.ICSelection[RCC_IC16].ClockSelection = RCC_ICCLKSOURCE_PLL3;
    PeriphClkInitStruct.ICSelection[RCC_IC16].ClockDivider = 24;
34002178:	2318      	movs	r3, #24
3400217a:	f04f 5100 	mov.w	r1, #536870912	@ 0x20000000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
3400217e:	eb0d 0003 	add.w	r0, sp, r3
    PeriphClkInitStruct.ICSelection[RCC_IC16].ClockDivider = 24;
34002182:	e9cd 1326 	strd	r1, r3, [sp, #152]	@ 0x98
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34002186:	f004 f96d 	bl	34006464 <HAL_RCCEx_PeriphCLKConfig>
3400218a:	b108      	cbz	r0, 34002190 <HAL_LTDC_MspInit+0x4c>
    {
      Error_Handler();
3400218c:	f000 fac0 	bl	34002710 <Error_Handler>
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5ENSR, Periphs);
34002190:	2402      	movs	r4, #2
34002192:	4b2f      	ldr	r3, [pc, #188]	@ (34002250 <HAL_LTDC_MspInit+0x10c>)
    }

    /* LTDC clock enable */
    __HAL_RCC_LTDC_CLK_ENABLE();

    __HAL_RCC_GPIOB_CLK_ENABLE();
34002194:	4620      	mov	r0, r4
34002196:	f8c3 4a7c 	str.w	r4, [r3, #2684]	@ 0xa7c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5ENR);
3400219a:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
    */
    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_1
                          |GPIO_PIN_4|GPIO_PIN_10|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
3400219e:	2600      	movs	r6, #0
340021a0:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
340021a2:	9b00      	ldr	r3, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
340021a4:	f7ff ff4a 	bl	3400203c <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
340021a8:	2080      	movs	r0, #128	@ 0x80
340021aa:	f7ff ff47 	bl	3400203c <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOF_CLK_ENABLE();
340021ae:	2020      	movs	r0, #32
340021b0:	f7ff ff44 	bl	3400203c <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
340021b4:	2001      	movs	r0, #1
340021b6:	f7ff ff41 	bl	3400203c <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
340021ba:	2040      	movs	r0, #64	@ 0x40
340021bc:	f7ff ff3e 	bl	3400203c <LL_AHB4_GRP1_EnableClock>
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
340021c0:	2503      	movs	r5, #3
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
340021c2:	270e      	movs	r7, #14
    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_1
340021c4:	f649 4332 	movw	r3, #39986	@ 0x9c32
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
340021c8:	4822      	ldr	r0, [pc, #136]	@ (34002254 <HAL_LTDC_MspInit+0x110>)
340021ca:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340021cc:	e9cd 3401 	strd	r3, r4, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
340021d0:	e9cd 6503 	strd	r6, r5, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
340021d4:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
340021d6:	f002 fe8d 	bl	34004ef4 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_4;
340021da:	2310      	movs	r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
340021dc:	481e      	ldr	r0, [pc, #120]	@ (34002258 <HAL_LTDC_MspInit+0x114>)
340021de:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340021e0:	e9cd 3401 	strd	r3, r4, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
340021e4:	e9cd 6503 	strd	r6, r5, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
340021e8:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
340021ea:	f002 fe83 	bl	34004ef4 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
340021ee:	f44f 7340 	mov.w	r3, #768	@ 0x300
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
340021f2:	481a      	ldr	r0, [pc, #104]	@ (3400225c <HAL_LTDC_MspInit+0x118>)
340021f4:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340021f6:	e9cd 3401 	strd	r3, r4, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
340021fa:	e9cd 6503 	strd	r6, r5, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
340021fe:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
34002200:	f002 fe78 	bl	34004ef4 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_1|GPIO_PIN_15|GPIO_PIN_10
34002204:	f649 73a7 	movw	r3, #40871	@ 0x9fa7
                          |GPIO_PIN_12|GPIO_PIN_8|GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34002208:	4815      	ldr	r0, [pc, #84]	@ (34002260 <HAL_LTDC_MspInit+0x11c>)
3400220a:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3400220c:	e9cd 3401 	strd	r3, r4, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002210:	e9cd 6503 	strd	r6, r5, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34002214:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34002216:	f002 fe6d 	bl	34004ef4 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_2
3400221a:	f24b 2306 	movw	r3, #45574	@ 0xb206
                          |GPIO_PIN_9|GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
3400221e:	4811      	ldr	r0, [pc, #68]	@ (34002264 <HAL_LTDC_MspInit+0x120>)
34002220:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34002222:	e9cd 3401 	strd	r3, r4, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002226:	e9cd 6503 	strd	r6, r5, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
3400222a:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
3400222c:	f002 fe62 	bl	34004ef4 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_0;
34002230:	2301      	movs	r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34002232:	e9cd 3401 	strd	r3, r4, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_LCD;
34002236:	230a      	movs	r3, #10
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
34002238:	480a      	ldr	r0, [pc, #40]	@ (34002264 <HAL_LTDC_MspInit+0x120>)
3400223a:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
3400223c:	e9cd 6503 	strd	r6, r5, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF10_LCD;
34002240:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
34002242:	f002 fe57 	bl	34004ef4 <HAL_GPIO_Init>

  /* USER CODE BEGIN LTDC_MspInit 1 */

  /* USER CODE END LTDC_MspInit 1 */
  }
}
34002246:	b06b      	add	sp, #428	@ 0x1ac
34002248:	bdf0      	pop	{r4, r5, r6, r7, pc}
3400224a:	bf00      	nop
3400224c:	58001000 	.word	0x58001000
34002250:	56028000 	.word	0x56028000
34002254:	56020400 	.word	0x56020400
34002258:	56021c00 	.word	0x56021c00
3400225c:	56021400 	.word	0x56021400
34002260:	56020000 	.word	0x56020000
34002264:	56021800 	.word	0x56021800

34002268 <cam_disp_frame_cb>:

/* USER CODE BEGIN PV */

/* USER CODE END PV */
static void cam_disp_frame_cb(void)
{
34002268:	b508      	push	{r3, lr}
    app_lcd_switch_bg_buffer();
3400226a:	f7ff fcf1 	bl	34001c50 <app_lcd_switch_bg_buffer>
    app_camera_display_pipe_set_address(app_lcd_get_bg_buffer());
3400226e:	f7ff fce3 	bl	34001c38 <app_lcd_get_bg_buffer>
}
34002272:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    app_camera_display_pipe_set_address(app_lcd_get_bg_buffer());
34002276:	f7ff bc16 	b.w	34001aa6 <app_camera_display_pipe_set_address>
	...

3400227c <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
3400227c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  /* USER CODE BEGIN 1 */
	MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
3400227e:	4bd9      	ldr	r3, [pc, #868]	@ (340025e4 <main+0x368>)
34002280:	681a      	ldr	r2, [r3, #0]
34002282:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
34002286:	601a      	str	r2, [r3, #0]
	MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_DCACTIVE_Msk;
34002288:	681a      	ldr	r2, [r3, #0]
3400228a:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
3400228e:	601a      	str	r2, [r3, #0]
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34002290:	f5a3 4373 	sub.w	r3, r3, #62208	@ 0xf300
34002294:	695a      	ldr	r2, [r3, #20]
34002296:	f412 3200 	ands.w	r2, r2, #131072	@ 0x20000
3400229a:	d111      	bne.n	340022c0 <main+0x44>
  __ASM volatile ("dsb 0xF":::"memory");
3400229c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340022a0:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
340022a4:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
340022a8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340022ac:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
340022b0:	695a      	ldr	r2, [r3, #20]
340022b2:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
340022b6:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
340022b8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340022bc:	f3bf 8f6f 	isb	sy
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
340022c0:	4ac9      	ldr	r2, [pc, #804]	@ (340025e8 <main+0x36c>)
340022c2:	6953      	ldr	r3, [r2, #20]
340022c4:	f413 3380 	ands.w	r3, r3, #65536	@ 0x10000
340022c8:	d128      	bne.n	3400231c <main+0xa0>
    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
340022ca:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
340022ce:	f3bf 8f4f 	dsb	sy
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
340022d2:	f643 74e0 	movw	r4, #16352	@ 0x3fe0
    ccsidr = SCB->CCSIDR;
340022d6:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
340022da:	f3c3 00c9 	ubfx	r0, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
340022de:	f3c3 334e 	ubfx	r3, r3, #13, #15
340022e2:	015b      	lsls	r3, r3, #5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
340022e4:	f100 0e01 	add.w	lr, r0, #1
340022e8:	4601      	mov	r1, r0
340022ea:	f04e e001 	dls	lr, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
340022ee:	ea03 0604 	and.w	r6, r3, r4
340022f2:	ea46 7581 	orr.w	r5, r6, r1, lsl #30
340022f6:	f8c2 5260 	str.w	r5, [r2, #608]	@ 0x260
      } while (ways-- != 0U);
340022fa:	3901      	subs	r1, #1
340022fc:	f00f c807 	le	lr, 340022f2 <main+0x76>
    } while(sets-- != 0U);
34002300:	3b20      	subs	r3, #32
34002302:	f113 0f20 	cmn.w	r3, #32
34002306:	d1ed      	bne.n	340022e4 <main+0x68>
34002308:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
3400230c:	6953      	ldr	r3, [r2, #20]
3400230e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34002312:	6153      	str	r3, [r2, #20]
34002314:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002318:	f3bf 8f6f 	isb	sy
  WRITE_REG(RCC->AHB3ENSR, Periphs);
3400231c:	f44f 7500 	mov.w	r5, #512	@ 0x200

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
34002320:	f001 f9a4 	bl	3400366c <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
34002324:	f7ff fd86 	bl	34001e34 <MX_GPIO_Init>
  MX_CACHEAXI_Init();
34002328:	f7ff fcb8 	bl	34001c9c <MX_CACHEAXI_Init>
  MX_RAMCFG_Init();
3400232c:	f000 f9f2 	bl	34002714 <MX_RAMCFG_Init>
  MX_DCMIPP_Init();
34002330:	f7ff fcd8 	bl	34001ce4 <MX_DCMIPP_Init>
  MX_DMA2D_Init();
34002334:	f7ff fd3e 	bl	34001db4 <MX_DMA2D_Init>
  MX_I2C2_Init();
34002338:	f7ff fdf0 	bl	34001f1c <MX_I2C2_Init>
  MX_LTDC_Init();
3400233c:	f7ff fe8a 	bl	34002054 <MX_LTDC_Init>
  MX_USART1_UART_Init();
34002340:	f000 fc8c 	bl	34002c5c <MX_USART1_UART_Init>
  MX_XSPI1_Init();
34002344:	f000 fd0c 	bl	34002d60 <MX_XSPI1_Init>
  MX_XSPI2_Init();
34002348:	f000 fd58 	bl	34002dfc <MX_XSPI2_Init>
3400234c:	4ba7      	ldr	r3, [pc, #668]	@ (340025ec <main+0x370>)

  /* set all required IPs as secure privileged */
  __HAL_RCC_RIFSC_CLK_ENABLE();
  RIMC_MasterConfig_t RIMC_master = {0};
  RIMC_master.MasterCID = RIF_CID_1;
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
3400234e:	2402      	movs	r4, #2
34002350:	f8c3 5a58 	str.w	r5, [r3, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
34002354:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258

  /*RIMC configuration*/
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34002358:	2009      	movs	r0, #9
3400235a:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400235c:	9b01      	ldr	r3, [sp, #4]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
3400235e:	2303      	movs	r3, #3
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34002360:	a902      	add	r1, sp, #8
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34002362:	e9cd 4302 	strd	r4, r3, [sp, #8]
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34002366:	f007 fb31 	bl	340099cc <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DMA2D, &RIMC_master);
3400236a:	2008      	movs	r0, #8
3400236c:	a902      	add	r1, sp, #8
3400236e:	f007 fb2d 	bl	340099cc <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1, &RIMC_master);
34002372:	200a      	movs	r0, #10
34002374:	a902      	add	r1, sp, #8
34002376:	f007 fb29 	bl	340099cc <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2, &RIMC_master);
3400237a:	200b      	movs	r0, #11
3400237c:	a902      	add	r1, sp, #8
3400237e:	f007 fb25 	bl	340099cc <HAL_RIF_RIMC_ConfigMasterAttributes>

  /* RIF-Aware IPs Config */

  /* set up PWR configuration */
  HAL_PWR_ConfigAttributes(PWR_ITEM_0,PWR_SEC_NPRIV);
34002382:	2120      	movs	r1, #32
34002384:	2001      	movs	r0, #1
34002386:	f003 fe7d 	bl	34006084 <HAL_PWR_ConfigAttributes>

  /* set up GPIO configuration */
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400238a:	f240 3201 	movw	r2, #769	@ 0x301
3400238e:	2101      	movs	r1, #1
34002390:	4897      	ldr	r0, [pc, #604]	@ (340025f0 <main+0x374>)
34002392:	f002 ff5d 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002396:	4621      	mov	r1, r4
34002398:	f240 3201 	movw	r2, #769	@ 0x301
3400239c:	4894      	ldr	r0, [pc, #592]	@ (340025f0 <main+0x374>)
3400239e:	f002 ff57 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340023a2:	f240 3201 	movw	r2, #769	@ 0x301
340023a6:	2104      	movs	r1, #4
340023a8:	4891      	ldr	r0, [pc, #580]	@ (340025f0 <main+0x374>)
340023aa:	f002 ff51 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340023ae:	f240 3201 	movw	r2, #769	@ 0x301
340023b2:	2108      	movs	r1, #8
340023b4:	488e      	ldr	r0, [pc, #568]	@ (340025f0 <main+0x374>)
340023b6:	f002 ff4b 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_5,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340023ba:	f240 3201 	movw	r2, #769	@ 0x301
340023be:	2120      	movs	r1, #32
340023c0:	488b      	ldr	r0, [pc, #556]	@ (340025f0 <main+0x374>)
340023c2:	f002 ff45 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_7,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340023c6:	f240 3201 	movw	r2, #769	@ 0x301
340023ca:	2180      	movs	r1, #128	@ 0x80
340023cc:	4888      	ldr	r0, [pc, #544]	@ (340025f0 <main+0x374>)
340023ce:	f002 ff3f 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340023d2:	f240 3201 	movw	r2, #769	@ 0x301
340023d6:	f44f 7180 	mov.w	r1, #256	@ 0x100
340023da:	4885      	ldr	r0, [pc, #532]	@ (340025f0 <main+0x374>)
340023dc:	f002 ff38 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_9,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340023e0:	4629      	mov	r1, r5
340023e2:	f240 3201 	movw	r2, #769	@ 0x301
340023e6:	4882      	ldr	r0, [pc, #520]	@ (340025f0 <main+0x374>)
340023e8:	f002 ff32 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340023ec:	f240 3201 	movw	r2, #769	@ 0x301
340023f0:	f44f 6180 	mov.w	r1, #1024	@ 0x400
340023f4:	487e      	ldr	r0, [pc, #504]	@ (340025f0 <main+0x374>)
340023f6:	f002 ff2b 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_11,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340023fa:	f240 3201 	movw	r2, #769	@ 0x301
340023fe:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34002402:	487b      	ldr	r0, [pc, #492]	@ (340025f0 <main+0x374>)
34002404:	f002 ff24 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_12,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002408:	f240 3201 	movw	r2, #769	@ 0x301
3400240c:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34002410:	4877      	ldr	r0, [pc, #476]	@ (340025f0 <main+0x374>)
34002412:	f002 ff1d 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002416:	4621      	mov	r1, r4
34002418:	f240 3201 	movw	r2, #769	@ 0x301
3400241c:	4875      	ldr	r0, [pc, #468]	@ (340025f4 <main+0x378>)
3400241e:	f002 ff17 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002422:	f240 3201 	movw	r2, #769	@ 0x301
34002426:	f44f 6180 	mov.w	r1, #1024	@ 0x400
3400242a:	4872      	ldr	r0, [pc, #456]	@ (340025f4 <main+0x378>)
3400242c:	f002 ff10 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_11,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002430:	f240 3201 	movw	r2, #769	@ 0x301
34002434:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34002438:	486e      	ldr	r0, [pc, #440]	@ (340025f4 <main+0x378>)
3400243a:	f002 ff09 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_12,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400243e:	f240 3201 	movw	r2, #769	@ 0x301
34002442:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34002446:	486b      	ldr	r0, [pc, #428]	@ (340025f4 <main+0x378>)
34002448:	f002 ff02 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_15,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400244c:	f240 3201 	movw	r2, #769	@ 0x301
34002450:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34002454:	4867      	ldr	r0, [pc, #412]	@ (340025f4 <main+0x378>)
34002456:	f002 fefb 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400245a:	f240 3201 	movw	r2, #769	@ 0x301
3400245e:	2110      	movs	r1, #16
34002460:	4865      	ldr	r0, [pc, #404]	@ (340025f8 <main+0x37c>)
34002462:	f002 fef5 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_14,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002466:	f240 3201 	movw	r2, #769	@ 0x301
3400246a:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
3400246e:	4862      	ldr	r0, [pc, #392]	@ (340025f8 <main+0x37c>)
34002470:	f002 feee 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_5,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002474:	f240 3201 	movw	r2, #769	@ 0x301
34002478:	2120      	movs	r1, #32
3400247a:	4860      	ldr	r0, [pc, #384]	@ (340025fc <main+0x380>)
3400247c:	f002 fee8 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002480:	f240 3201 	movw	r2, #769	@ 0x301
34002484:	2140      	movs	r1, #64	@ 0x40
34002486:	485d      	ldr	r0, [pc, #372]	@ (340025fc <main+0x380>)
34002488:	f002 fee2 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400248c:	f240 3201 	movw	r2, #769	@ 0x301
34002490:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34002494:	4859      	ldr	r0, [pc, #356]	@ (340025fc <main+0x380>)
34002496:	f002 fedb 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOF,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400249a:	f240 3201 	movw	r2, #769	@ 0x301
3400249e:	f44f 7180 	mov.w	r1, #256	@ 0x100
340024a2:	4857      	ldr	r0, [pc, #348]	@ (34002600 <main+0x384>)
340024a4:	f002 fed4 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOF,GPIO_PIN_9,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340024a8:	4629      	mov	r1, r5
340024aa:	f240 3201 	movw	r2, #769	@ 0x301
340024ae:	4854      	ldr	r0, [pc, #336]	@ (34002600 <main+0x384>)
340024b0:	f002 fece 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340024b4:	f240 3201 	movw	r2, #769	@ 0x301
340024b8:	2101      	movs	r1, #1
340024ba:	4852      	ldr	r0, [pc, #328]	@ (34002604 <main+0x388>)
340024bc:	f002 fec8 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340024c0:	4621      	mov	r1, r4
340024c2:	f240 3201 	movw	r2, #769	@ 0x301
340024c6:	484f      	ldr	r0, [pc, #316]	@ (34002604 <main+0x388>)
340024c8:	f002 fec2 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340024cc:	f240 3201 	movw	r2, #769	@ 0x301
340024d0:	2104      	movs	r1, #4
340024d2:	484c      	ldr	r0, [pc, #304]	@ (34002604 <main+0x388>)
340024d4:	f002 febc 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340024d8:	f240 3201 	movw	r2, #769	@ 0x301
340024dc:	2110      	movs	r1, #16
340024de:	4849      	ldr	r0, [pc, #292]	@ (34002604 <main+0x388>)
340024e0:	f002 feb6 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340024e4:	f240 3201 	movw	r2, #769	@ 0x301
340024e8:	2140      	movs	r1, #64	@ 0x40
340024ea:	4846      	ldr	r0, [pc, #280]	@ (34002604 <main+0x388>)
340024ec:	f002 feb0 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_9,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340024f0:	4629      	mov	r1, r5
340024f2:	f240 3201 	movw	r2, #769	@ 0x301
340024f6:	4843      	ldr	r0, [pc, #268]	@ (34002604 <main+0x388>)
340024f8:	f002 feaa 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340024fc:	f240 3201 	movw	r2, #769	@ 0x301
34002500:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34002504:	483f      	ldr	r0, [pc, #252]	@ (34002604 <main+0x388>)
34002506:	f002 fea3 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_12,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400250a:	f240 3201 	movw	r2, #769	@ 0x301
3400250e:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34002512:	483c      	ldr	r0, [pc, #240]	@ (34002604 <main+0x388>)
34002514:	f002 fe9c 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_13,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002518:	f240 3201 	movw	r2, #769	@ 0x301
3400251c:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34002520:	4838      	ldr	r0, [pc, #224]	@ (34002604 <main+0x388>)
34002522:	f002 fe95 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_15,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002526:	f240 3201 	movw	r2, #769	@ 0x301
3400252a:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3400252e:	4835      	ldr	r0, [pc, #212]	@ (34002604 <main+0x388>)
34002530:	f002 fe8e 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOH,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002534:	f240 3201 	movw	r2, #769	@ 0x301
34002538:	2110      	movs	r1, #16
3400253a:	4833      	ldr	r0, [pc, #204]	@ (34002608 <main+0x38c>)
3400253c:	f002 fe88 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002540:	f240 3201 	movw	r2, #769	@ 0x301
34002544:	2101      	movs	r1, #1
34002546:	4831      	ldr	r0, [pc, #196]	@ (3400260c <main+0x390>)
34002548:	f002 fe82 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400254c:	4621      	mov	r1, r4
3400254e:	f240 3201 	movw	r2, #769	@ 0x301
34002552:	482e      	ldr	r0, [pc, #184]	@ (3400260c <main+0x390>)
34002554:	f002 fe7c 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002558:	f240 3201 	movw	r2, #769	@ 0x301
3400255c:	2104      	movs	r1, #4
3400255e:	482b      	ldr	r0, [pc, #172]	@ (3400260c <main+0x390>)
34002560:	f002 fe76 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002564:	f240 3201 	movw	r2, #769	@ 0x301
34002568:	2108      	movs	r1, #8
3400256a:	4828      	ldr	r0, [pc, #160]	@ (3400260c <main+0x390>)
3400256c:	f002 fe70 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002570:	f240 3201 	movw	r2, #769	@ 0x301
34002574:	2110      	movs	r1, #16
34002576:	4825      	ldr	r0, [pc, #148]	@ (3400260c <main+0x390>)
34002578:	f002 fe6a 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_5,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400257c:	f240 3201 	movw	r2, #769	@ 0x301
34002580:	2120      	movs	r1, #32
34002582:	4822      	ldr	r0, [pc, #136]	@ (3400260c <main+0x390>)
34002584:	f002 fe64 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002588:	f240 3201 	movw	r2, #769	@ 0x301
3400258c:	2140      	movs	r1, #64	@ 0x40
3400258e:	481f      	ldr	r0, [pc, #124]	@ (3400260c <main+0x390>)
34002590:	f002 fe5e 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002594:	f240 3201 	movw	r2, #769	@ 0x301
34002598:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400259c:	481b      	ldr	r0, [pc, #108]	@ (3400260c <main+0x390>)
3400259e:	f002 fe57 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_9,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340025a2:	4629      	mov	r1, r5
340025a4:	f240 3201 	movw	r2, #769	@ 0x301
340025a8:	4818      	ldr	r0, [pc, #96]	@ (3400260c <main+0x390>)
340025aa:	f002 fe51 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340025ae:	f240 3201 	movw	r2, #769	@ 0x301
340025b2:	f44f 6180 	mov.w	r1, #1024	@ 0x400
340025b6:	4815      	ldr	r0, [pc, #84]	@ (3400260c <main+0x390>)
340025b8:	f002 fe4a 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_11,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340025bc:	f240 3201 	movw	r2, #769	@ 0x301
340025c0:	f44f 6100 	mov.w	r1, #2048	@ 0x800
340025c4:	4811      	ldr	r0, [pc, #68]	@ (3400260c <main+0x390>)
340025c6:	f002 fe43 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340025ca:	f240 3201 	movw	r2, #769	@ 0x301
340025ce:	2101      	movs	r1, #1
340025d0:	480f      	ldr	r0, [pc, #60]	@ (34002610 <main+0x394>)
340025d2:	f002 fe3d 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
340025d6:	f240 3201 	movw	r2, #769	@ 0x301
340025da:	2104      	movs	r1, #4
340025dc:	480c      	ldr	r0, [pc, #48]	@ (34002610 <main+0x394>)
340025de:	f002 fe37 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
340025e2:	e017      	b.n	34002614 <main+0x398>
340025e4:	e001e000 	.word	0xe001e000
340025e8:	e000ed00 	.word	0xe000ed00
340025ec:	56028000 	.word	0x56028000
340025f0:	56020000 	.word	0x56020000
340025f4:	56020400 	.word	0x56020400
340025f8:	56020c00 	.word	0x56020c00
340025fc:	56021000 	.word	0x56021000
34002600:	56021400 	.word	0x56021400
34002604:	56021800 	.word	0x56021800
34002608:	56021c00 	.word	0x56021c00
3400260c:	56023400 	.word	0x56023400
34002610:	56023800 	.word	0x56023800
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002614:	f240 3201 	movw	r2, #769	@ 0x301
34002618:	2110      	movs	r1, #16
3400261a:	4839      	ldr	r0, [pc, #228]	@ (34002700 <main+0x484>)
3400261c:	f002 fe18 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_5,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002620:	f240 3201 	movw	r2, #769	@ 0x301
34002624:	2120      	movs	r1, #32
34002626:	4836      	ldr	r0, [pc, #216]	@ (34002700 <main+0x484>)
34002628:	f002 fe12 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400262c:	f240 3201 	movw	r2, #769	@ 0x301
34002630:	2101      	movs	r1, #1
34002632:	4834      	ldr	r0, [pc, #208]	@ (34002704 <main+0x488>)
34002634:	f002 fe0c 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002638:	4621      	mov	r1, r4
3400263a:	f240 3201 	movw	r2, #769	@ 0x301
3400263e:	4831      	ldr	r0, [pc, #196]	@ (34002704 <main+0x488>)
34002640:	f002 fe06 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002644:	f240 3201 	movw	r2, #769	@ 0x301
34002648:	2104      	movs	r1, #4
3400264a:	482e      	ldr	r0, [pc, #184]	@ (34002704 <main+0x488>)
3400264c:	f002 fe00 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002650:	f240 3201 	movw	r2, #769	@ 0x301
34002654:	2108      	movs	r1, #8
34002656:	482b      	ldr	r0, [pc, #172]	@ (34002704 <main+0x488>)
34002658:	f002 fdfa 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
3400265c:	f240 3201 	movw	r2, #769	@ 0x301
34002660:	2110      	movs	r1, #16
34002662:	4828      	ldr	r0, [pc, #160]	@ (34002704 <main+0x488>)
34002664:	f002 fdf4 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_5,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002668:	f240 3201 	movw	r2, #769	@ 0x301
3400266c:	2120      	movs	r1, #32
3400266e:	4825      	ldr	r0, [pc, #148]	@ (34002704 <main+0x488>)
34002670:	f002 fdee 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002674:	f240 3201 	movw	r2, #769	@ 0x301
34002678:	2140      	movs	r1, #64	@ 0x40
3400267a:	4822      	ldr	r0, [pc, #136]	@ (34002704 <main+0x488>)
3400267c:	f002 fde8 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_7,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34002680:	f240 3201 	movw	r2, #769	@ 0x301
34002684:	2180      	movs	r1, #128	@ 0x80
34002686:	481f      	ldr	r0, [pc, #124]	@ (34002704 <main+0x488>)
34002688:	f002 fde2 	bl	34005250 <HAL_GPIO_ConfigPinAttributes>
  MX_X_CUBE_AI_Init();
3400268c:	2406      	movs	r4, #6
3400268e:	f00a fce3 	bl	3400d058 <MX_X_CUBE_AI_Init>
    HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_10);
34002692:	4d1d      	ldr	r5, [pc, #116]	@ (34002708 <main+0x48c>)
34002694:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34002698:	4628      	mov	r0, r5
3400269a:	f002 fdd0 	bl	3400523e <HAL_GPIO_TogglePin>
    HAL_Delay(80);
3400269e:	2050      	movs	r0, #80	@ 0x50
340026a0:	f001 f808 	bl	340036b4 <HAL_Delay>
  for (int i = 0; i < 6; ++i)   //  2  Appli
340026a4:	3c01      	subs	r4, #1
340026a6:	d1f5      	bne.n	34002694 <main+0x418>
  app_lcd_init();
340026a8:	f7ff fa2a 	bl	34001b00 <app_lcd_init>
  memset(app_lcd_get_bg_buffer(), 0xFF, LCD_BG_WIDTH * LCD_BG_HEIGHT * 2);
340026ac:	f7ff fac4 	bl	34001c38 <app_lcd_get_bg_buffer>
340026b0:	f44f 22e1 	mov.w	r2, #460800	@ 0x70800
340026b4:	21ff      	movs	r1, #255	@ 0xff
340026b6:	f00b f92d 	bl	3400d914 <memset>
  HAL_LTDC_SetAddress_NoReload(bsp_lcd_get_ltdc_handle(),
340026ba:	f000 ffad 	bl	34003618 <bsp_lcd_get_ltdc_handle>
340026be:	4605      	mov	r5, r0
                               (uint32_t)app_lcd_get_bg_buffer(), 0);
340026c0:	f7ff faba 	bl	34001c38 <app_lcd_get_bg_buffer>
  HAL_LTDC_SetAddress_NoReload(bsp_lcd_get_ltdc_handle(),
340026c4:	4622      	mov	r2, r4
                               (uint32_t)app_lcd_get_bg_buffer(), 0);
340026c6:	4601      	mov	r1, r0
  HAL_LTDC_SetAddress_NoReload(bsp_lcd_get_ltdc_handle(),
340026c8:	4628      	mov	r0, r5
340026ca:	f003 fcae 	bl	3400602a <HAL_LTDC_SetAddress_NoReload>
  HAL_LTDC_ReloadLayer(bsp_lcd_get_ltdc_handle(), LTDC_RELOAD_VERTICAL_BLANKING, 0);
340026ce:	f000 ffa3 	bl	34003618 <bsp_lcd_get_ltdc_handle>
340026d2:	4622      	mov	r2, r4
340026d4:	2102      	movs	r1, #2
340026d6:	f003 fc8c 	bl	34005ff2 <HAL_LTDC_ReloadLayer>
  HAL_Delay(300);
340026da:	f44f 7096 	mov.w	r0, #300	@ 0x12c
340026de:	f000 ffe9 	bl	340036b4 <HAL_Delay>
  app_camera_init(NULL, cam_disp_frame_cb, NULL, NULL);
340026e2:	490a      	ldr	r1, [pc, #40]	@ (3400270c <main+0x490>)
340026e4:	4623      	mov	r3, r4
340026e6:	4622      	mov	r2, r4
340026e8:	4620      	mov	r0, r4
340026ea:	f7ff f971 	bl	340019d0 <app_camera_init>
  app_camera_display_pipe_start(app_lcd_get_bg_buffer(), CMW_MODE_CONTINUOUS);
340026ee:	f7ff faa3 	bl	34001c38 <app_lcd_get_bg_buffer>
340026f2:	4621      	mov	r1, r4
340026f4:	f7ff f9d2 	bl	34001a9c <app_camera_display_pipe_start>
	  app_camera_isp_update();
340026f8:	f7ff f9e0 	bl	34001abc <app_camera_isp_update>
  while (1)
340026fc:	e7fc      	b.n	340026f8 <main+0x47c>
340026fe:	bf00      	nop
34002700:	56023800 	.word	0x56023800
34002704:	56023c00 	.word	0x56023c00
34002708:	56021800 	.word	0x56021800
3400270c:	34002269 	.word	0x34002269

34002710 <Error_Handler>:
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
34002710:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
34002712:	e7fe      	b.n	34002712 <Error_Handler+0x2>

34002714 <MX_RAMCFG_Init>:
RAMCFG_HandleTypeDef hramcfg_SRAM5;
RAMCFG_HandleTypeDef hramcfg_SRAM6;

/* RAMCFG init function */
void MX_RAMCFG_Init(void)
{
34002714:	b508      	push	{r3, lr}

  /* USER CODE END RAMCFG_Init 1 */

  /** Initialize RAMCFG SRAM3
  */
  hramcfg_SRAM3.Instance = RAMCFG_SRAM3_AXI;
34002716:	4811      	ldr	r0, [pc, #68]	@ (3400275c <MX_RAMCFG_Init+0x48>)
34002718:	4b11      	ldr	r3, [pc, #68]	@ (34002760 <MX_RAMCFG_Init+0x4c>)
3400271a:	6003      	str	r3, [r0, #0]
  if (HAL_RAMCFG_Init(&hramcfg_SRAM3) != HAL_OK)
3400271c:	f003 fd1a 	bl	34006154 <HAL_RAMCFG_Init>
34002720:	b108      	cbz	r0, 34002726 <MX_RAMCFG_Init+0x12>
  {
    Error_Handler();
34002722:	f7ff fff5 	bl	34002710 <Error_Handler>
  }

  /** Initialize RAMCFG SRAM4
  */
  hramcfg_SRAM4.Instance = RAMCFG_SRAM4_AXI;
34002726:	480f      	ldr	r0, [pc, #60]	@ (34002764 <MX_RAMCFG_Init+0x50>)
34002728:	4b0f      	ldr	r3, [pc, #60]	@ (34002768 <MX_RAMCFG_Init+0x54>)
3400272a:	6003      	str	r3, [r0, #0]
  if (HAL_RAMCFG_Init(&hramcfg_SRAM4) != HAL_OK)
3400272c:	f003 fd12 	bl	34006154 <HAL_RAMCFG_Init>
34002730:	b108      	cbz	r0, 34002736 <MX_RAMCFG_Init+0x22>
  {
    Error_Handler();
34002732:	f7ff ffed 	bl	34002710 <Error_Handler>
  }

  /** Initialize RAMCFG SRAM5
  */
  hramcfg_SRAM5.Instance = RAMCFG_SRAM5_AXI;
34002736:	480d      	ldr	r0, [pc, #52]	@ (3400276c <MX_RAMCFG_Init+0x58>)
34002738:	4b0d      	ldr	r3, [pc, #52]	@ (34002770 <MX_RAMCFG_Init+0x5c>)
3400273a:	6003      	str	r3, [r0, #0]
  if (HAL_RAMCFG_Init(&hramcfg_SRAM5) != HAL_OK)
3400273c:	f003 fd0a 	bl	34006154 <HAL_RAMCFG_Init>
34002740:	b108      	cbz	r0, 34002746 <MX_RAMCFG_Init+0x32>
  {
    Error_Handler();
34002742:	f7ff ffe5 	bl	34002710 <Error_Handler>
  }

  /** Initialize RAMCFG SRAM6
  */
  hramcfg_SRAM6.Instance = RAMCFG_SRAM6_AXI;
34002746:	480b      	ldr	r0, [pc, #44]	@ (34002774 <MX_RAMCFG_Init+0x60>)
34002748:	4b0b      	ldr	r3, [pc, #44]	@ (34002778 <MX_RAMCFG_Init+0x64>)
3400274a:	6003      	str	r3, [r0, #0]
  if (HAL_RAMCFG_Init(&hramcfg_SRAM6) != HAL_OK)
3400274c:	f003 fd02 	bl	34006154 <HAL_RAMCFG_Init>
34002750:	b118      	cbz	r0, 3400275a <MX_RAMCFG_Init+0x46>
  }
  /* USER CODE BEGIN RAMCFG_Init 2 */

  /* USER CODE END RAMCFG_Init 2 */

}
34002752:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
34002756:	f7ff bfdb 	b.w	34002710 <Error_Handler>
}
3400275a:	bd08      	pop	{r3, pc}
3400275c:	340141a4 	.word	0x340141a4
34002760:	52023100 	.word	0x52023100
34002764:	34014198 	.word	0x34014198
34002768:	52023180 	.word	0x52023180
3400276c:	3401418c 	.word	0x3401418c
34002770:	52023200 	.word	0x52023200
34002774:	34014180 	.word	0x34014180
34002778:	52023280 	.word	0x52023280

3400277c <HAL_RAMCFG_MspInit>:
  WRITE_REG(RCC->AHB2ENSR, Periphs);
3400277c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34002780:	4b04      	ldr	r3, [pc, #16]	@ (34002794 <HAL_RAMCFG_MspInit+0x18>)

void HAL_RAMCFG_MspInit(RAMCFG_HandleTypeDef* ramcfgHandle)
{
34002782:	b082      	sub	sp, #8
34002784:	f8c3 2a54 	str.w	r2, [r3, #2644]	@ 0xa54
  tmpreg = READ_REG(RCC->AHB2ENR);
34002788:	f8d3 3254 	ldr.w	r3, [r3, #596]	@ 0x254
3400278c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400278e:	9b01      	ldr	r3, [sp, #4]
    /* RAMCFG clock enable */
    __HAL_RCC_RAMCFG_CLK_ENABLE();
  /* USER CODE BEGIN RAMCFG_MspInit 1 */

  /* USER CODE END RAMCFG_MspInit 1 */
}
34002790:	b002      	add	sp, #8
34002792:	4770      	bx	lr
34002794:	56028000 	.word	0x56028000

34002798 <__acle_se_SECURE_RegisterCallback>:
  * @param  CallbackId  callback identifier
  * @param  func        pointer to non-secure function
  * @retval None
  */
CMSE_NS_ENTRY void SECURE_RegisterCallback(SECURE_CallbackIDTypeDef CallbackId, void *func)
{
34002798:	b2c0      	uxtb	r0, r0
3400279a:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
  if(func != NULL)
3400279e:	b111      	cbz	r1, 340027a6 <__acle_se_SECURE_RegisterCallback+0xe>
  {
    switch(CallbackId)
340027a0:	b140      	cbz	r0, 340027b4 <__acle_se_SECURE_RegisterCallback+0x1c>
340027a2:	2801      	cmp	r0, #1
340027a4:	d009      	beq.n	340027ba <__acle_se_SECURE_RegisterCallback+0x22>
      default:
        /* unknown */
        break;
    }
  }
}
340027a6:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
340027aa:	e89f 900f 	clrm	{r0, r1, r2, r3, ip, APSR}
340027ae:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
340027b2:	4774      	bxns	lr
        pSecureFaultCallback = func;
340027b4:	4b02      	ldr	r3, [pc, #8]	@ (340027c0 <__acle_se_SECURE_RegisterCallback+0x28>)
        pSecureErrorCallback = func;
340027b6:	6019      	str	r1, [r3, #0]
}
340027b8:	e7f5      	b.n	340027a6 <__acle_se_SECURE_RegisterCallback+0xe>
        pSecureErrorCallback = func;
340027ba:	4b02      	ldr	r3, [pc, #8]	@ (340027c4 <__acle_se_SECURE_RegisterCallback+0x2c>)
340027bc:	e7fb      	b.n	340027b6 <__acle_se_SECURE_RegisterCallback+0x1e>
340027be:	bf00      	nop
340027c0:	340141b4 	.word	0x340141b4
340027c4:	340141b0 	.word	0x340141b0

340027c8 <UTIL_LCD_SetFuncDriver>:
/**
  * @brief  Link board LCD drivers to STM32 LCD Utility drivers
  * @param  pDrv Structure of LCD functions
  */
void UTIL_LCD_SetFuncDriver(const LCD_UTILS_Drv_t *pDrv)
{
340027c8:	b570      	push	{r4, r5, r6, lr}
  FuncDriver.GetXSize       = pDrv->GetXSize;
  FuncDriver.GetYSize       = pDrv->GetYSize;
  FuncDriver.SetLayer       = pDrv->SetLayer;
  FuncDriver.GetFormat      = pDrv->GetFormat;

  DrawProp->LcdLayer = 0;
340027ca:	2500      	movs	r5, #0
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
340027cc:	4c14      	ldr	r4, [pc, #80]	@ (34002820 <UTIL_LCD_SetFuncDriver+0x58>)
340027ce:	6803      	ldr	r3, [r0, #0]
  FuncDriver.GetYSize       = pDrv->GetYSize;
340027d0:	6a02      	ldr	r2, [r0, #32]
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
340027d2:	6023      	str	r3, [r4, #0]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
340027d4:	6843      	ldr	r3, [r0, #4]
  FuncDriver.GetYSize       = pDrv->GetYSize;
340027d6:	6222      	str	r2, [r4, #32]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
340027d8:	6063      	str	r3, [r4, #4]
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
340027da:	6883      	ldr	r3, [r0, #8]
  FuncDriver.SetLayer       = pDrv->SetLayer;
340027dc:	6a42      	ldr	r2, [r0, #36]	@ 0x24
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
340027de:	60a3      	str	r3, [r4, #8]
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
340027e0:	68c3      	ldr	r3, [r0, #12]
  DrawProp->LcdLayer = 0;
340027e2:	4e10      	ldr	r6, [pc, #64]	@ (34002824 <UTIL_LCD_SetFuncDriver+0x5c>)
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
340027e4:	60e3      	str	r3, [r4, #12]
  FuncDriver.FillRect       = pDrv->FillRect;
340027e6:	6903      	ldr	r3, [r0, #16]
  FuncDriver.SetLayer       = pDrv->SetLayer;
340027e8:	6262      	str	r2, [r4, #36]	@ 0x24
  FuncDriver.FillRect       = pDrv->FillRect;
340027ea:	6123      	str	r3, [r4, #16]
  FuncDriver.GetPixel       = pDrv->GetPixel;
340027ec:	6943      	ldr	r3, [r0, #20]
  FuncDriver.GetFormat      = pDrv->GetFormat;
340027ee:	6a82      	ldr	r2, [r0, #40]	@ 0x28
  FuncDriver.GetPixel       = pDrv->GetPixel;
340027f0:	6163      	str	r3, [r4, #20]
  FuncDriver.SetPixel       = pDrv->SetPixel;
340027f2:	6983      	ldr	r3, [r0, #24]
  DrawProp->LcdDevice = 0;
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
340027f4:	f106 0114 	add.w	r1, r6, #20
  FuncDriver.SetPixel       = pDrv->SetPixel;
340027f8:	61a3      	str	r3, [r4, #24]
  FuncDriver.GetXSize       = pDrv->GetXSize;
340027fa:	69c3      	ldr	r3, [r0, #28]
  DrawProp->LcdDevice = 0;
340027fc:	e9c6 5503 	strd	r5, r5, [r6, #12]
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
34002800:	4628      	mov	r0, r5
  FuncDriver.GetXSize       = pDrv->GetXSize;
34002802:	61e3      	str	r3, [r4, #28]
  FuncDriver.GetFormat      = pDrv->GetFormat;
34002804:	62a2      	str	r2, [r4, #40]	@ 0x28
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
34002806:	4798      	blx	r3
  FuncDriver.GetYSize(0, &DrawProp->LcdYsize);
34002808:	6a23      	ldr	r3, [r4, #32]
3400280a:	f106 0118 	add.w	r1, r6, #24
3400280e:	4628      	mov	r0, r5
34002810:	4798      	blx	r3
  FuncDriver.GetFormat(0, &DrawProp->LcdPixelFormat);
34002812:	4628      	mov	r0, r5
34002814:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34002816:	f106 011c 	add.w	r1, r6, #28
}
3400281a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  FuncDriver.GetFormat(0, &DrawProp->LcdPixelFormat);
3400281e:	4718      	bx	r3
34002820:	340141b8 	.word	0x340141b8
34002824:	340141e4 	.word	0x340141e4

34002828 <UTIL_LCD_SetLayer>:
/**
  * @brief  Set the LCD layer.
  * @param  Layer  LCD layer
  */
void UTIL_LCD_SetLayer(uint32_t Layer)
{
34002828:	b570      	push	{r4, r5, r6, lr}
  if(FuncDriver.SetLayer != NULL)
3400282a:	4e10      	ldr	r6, [pc, #64]	@ (3400286c <UTIL_LCD_SetLayer+0x44>)
{
3400282c:	4605      	mov	r5, r0
  if(FuncDriver.SetLayer != NULL)
3400282e:	6a73      	ldr	r3, [r6, #36]	@ 0x24
34002830:	b1db      	cbz	r3, 3400286a <UTIL_LCD_SetLayer+0x42>
  {
    if(FuncDriver.SetLayer(DrawProp->LcdDevice, Layer) == 0)
34002832:	4c0f      	ldr	r4, [pc, #60]	@ (34002870 <UTIL_LCD_SetLayer+0x48>)
34002834:	4601      	mov	r1, r0
34002836:	6920      	ldr	r0, [r4, #16]
34002838:	4798      	blx	r3
3400283a:	b9b0      	cbnz	r0, 3400286a <UTIL_LCD_SetLayer+0x42>
    {
      DrawProp->LcdLayer = Layer;
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
3400283c:	eb04 1145 	add.w	r1, r4, r5, lsl #5
34002840:	69f3      	ldr	r3, [r6, #28]
34002842:	6920      	ldr	r0, [r4, #16]
      DrawProp->LcdLayer = Layer;
34002844:	60e5      	str	r5, [r4, #12]
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
34002846:	3114      	adds	r1, #20
34002848:	4798      	blx	r3
      FuncDriver.GetYSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdYsize);
3400284a:	68e1      	ldr	r1, [r4, #12]
3400284c:	6a33      	ldr	r3, [r6, #32]
3400284e:	eb04 1141 	add.w	r1, r4, r1, lsl #5
34002852:	6920      	ldr	r0, [r4, #16]
34002854:	3118      	adds	r1, #24
34002856:	4798      	blx	r3
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
34002858:	68e1      	ldr	r1, [r4, #12]
3400285a:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
3400285c:	eb04 1141 	add.w	r1, r4, r1, lsl #5
34002860:	6920      	ldr	r0, [r4, #16]
34002862:	311c      	adds	r1, #28
    }
  }
}
34002864:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
34002868:	4718      	bx	r3
}
3400286a:	bd70      	pop	{r4, r5, r6, pc}
3400286c:	340141b8 	.word	0x340141b8
34002870:	340141e4 	.word	0x340141e4

34002874 <UTIL_LCD_SetTextColor>:
  * @brief  Sets the LCD text color.
  * @param  Color  Text color code
  */
void UTIL_LCD_SetTextColor(uint32_t Color)
{
  DrawProp[DrawProp->LcdLayer].TextColor = Color;
34002874:	4a02      	ldr	r2, [pc, #8]	@ (34002880 <UTIL_LCD_SetTextColor+0xc>)
34002876:	68d3      	ldr	r3, [r2, #12]
34002878:	015b      	lsls	r3, r3, #5
3400287a:	50d0      	str	r0, [r2, r3]
}
3400287c:	4770      	bx	lr
3400287e:	bf00      	nop
34002880:	340141e4 	.word	0x340141e4

34002884 <UTIL_LCD_SetFont>:
  * @brief  Sets the LCD text font.
  * @param  fonts  Layer font to be used
  */
void UTIL_LCD_SetFont(sFONT *fonts)
{
  DrawProp[DrawProp->LcdLayer].pFont = fonts;
34002884:	4b02      	ldr	r3, [pc, #8]	@ (34002890 <UTIL_LCD_SetFont+0xc>)
34002886:	68da      	ldr	r2, [r3, #12]
34002888:	eb03 1342 	add.w	r3, r3, r2, lsl #5
3400288c:	6098      	str	r0, [r3, #8]
}
3400288e:	4770      	bx	lr
34002890:	340141e4 	.word	0x340141e4

34002894 <UTIL_LCD_FillRect>:
  * @param  Width  Rectangle width
  * @param  Height Rectangle height
  * @param  Color  Draw color
  */
void UTIL_LCD_FillRect(uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
34002894:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* Fill the rectangle */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34002896:	4d1d      	ldr	r5, [pc, #116]	@ (3400290c <UTIL_LCD_FillRect+0x78>)
{
34002898:	4607      	mov	r7, r0
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3400289a:	68e8      	ldr	r0, [r5, #12]
{
3400289c:	9c08      	ldr	r4, [sp, #32]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3400289e:	eb05 1040 	add.w	r0, r5, r0, lsl #5
340028a2:	f8d0 c01c 	ldr.w	ip, [r0, #28]
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
340028a6:	481a      	ldr	r0, [pc, #104]	@ (34002910 <UTIL_LCD_FillRect+0x7c>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340028a8:	f1bc 0f02 	cmp.w	ip, #2
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
340028ac:	6906      	ldr	r6, [r0, #16]
340028ae:	6928      	ldr	r0, [r5, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340028b0:	d10c      	bne.n	340028cc <UTIL_LCD_FillRect+0x38>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
340028b2:	0965      	lsrs	r5, r4, #5
340028b4:	ea4f 2c14 	mov.w	ip, r4, lsr #8
340028b8:	f405 65fc 	and.w	r5, r5, #2016	@ 0x7e0
340028bc:	f40c 4c78 	and.w	ip, ip, #63488	@ 0xf800
340028c0:	ea45 050c 	orr.w	r5, r5, ip
340028c4:	f3c4 04c4 	ubfx	r4, r4, #3, #5
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB888(Color));
  }
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
340028c8:	432c      	orrs	r4, r5
340028ca:	e004      	b.n	340028d6 <UTIL_LCD_FillRect+0x42>
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
340028cc:	69ed      	ldr	r5, [r5, #28]
340028ce:	2d01      	cmp	r5, #1
340028d0:	d109      	bne.n	340028e6 <UTIL_LCD_FillRect+0x52>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB888(Color));
340028d2:	f024 447f 	bic.w	r4, r4, #4278190080	@ 0xff000000
  }
  else /*LCD_PIXEL_FORMAT_ARGB8888*/
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
340028d6:	e9cd 3400 	strd	r3, r4, [sp]
340028da:	4613      	mov	r3, r2
340028dc:	460a      	mov	r2, r1
340028de:	4639      	mov	r1, r7
340028e0:	47b0      	blx	r6
  }
}
340028e2:	b003      	add	sp, #12
340028e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
340028e6:	f1bc 0f04 	cmp.w	ip, #4
340028ea:	d1f4      	bne.n	340028d6 <UTIL_LCD_FillRect+0x42>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
340028ec:	ea4f 7c14 	mov.w	ip, r4, lsr #28
340028f0:	f3c4 1503 	ubfx	r5, r4, #4, #4
340028f4:	ea45 350c 	orr.w	r5, r5, ip, lsl #12
340028f8:	ea4f 2c14 	mov.w	ip, r4, lsr #8
340028fc:	f00c 0cf0 	and.w	ip, ip, #240	@ 0xf0
34002900:	0b24      	lsrs	r4, r4, #12
34002902:	ea45 050c 	orr.w	r5, r5, ip
34002906:	f404 6470 	and.w	r4, r4, #3840	@ 0xf00
3400290a:	e7dd      	b.n	340028c8 <UTIL_LCD_FillRect+0x34>
3400290c:	340141e4 	.word	0x340141e4
34002910:	340141b8 	.word	0x340141b8

34002914 <UTIL_LCD_Clear>:
{
34002914:	b507      	push	{r0, r1, r2, lr}
  UTIL_LCD_FillRect(0, 0, DrawProp[DrawProp->LcdLayer].LcdXsize, DrawProp[DrawProp->LcdLayer].LcdYsize, Color);
34002916:	2100      	movs	r1, #0
34002918:	4a06      	ldr	r2, [pc, #24]	@ (34002934 <UTIL_LCD_Clear+0x20>)
3400291a:	68d3      	ldr	r3, [r2, #12]
3400291c:	9000      	str	r0, [sp, #0]
3400291e:	eb02 1243 	add.w	r2, r2, r3, lsl #5
34002922:	4608      	mov	r0, r1
34002924:	e9d2 2305 	ldrd	r2, r3, [r2, #20]
34002928:	f7ff ffb4 	bl	34002894 <UTIL_LCD_FillRect>
}
3400292c:	b003      	add	sp, #12
3400292e:	f85d fb04 	ldr.w	pc, [sp], #4
34002932:	bf00      	nop
34002934:	340141e4 	.word	0x340141e4

34002938 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
34002938:	b508      	push	{r3, lr}

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableVddIO2();
3400293a:	f003 fbf3 	bl	34006124 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2,PWR_VDDIO_RANGE_1V8);
3400293e:	2101      	movs	r1, #1
34002940:	4608      	mov	r0, r1
34002942:	f003 fbbf 	bl	340060c4 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO3();
34002946:	f003 fbf5 	bl	34006134 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3,PWR_VDDIO_RANGE_1V8);
3400294a:	2101      	movs	r1, #1
3400294c:	2002      	movs	r0, #2
3400294e:	f003 fbb9 	bl	340060c4 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO4();
34002952:	f003 fbf7 	bl	34006144 <HAL_PWREx_EnableVddIO4>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO4,PWR_VDDIO_RANGE_3V3);

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
34002956:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO4,PWR_VDDIO_RANGE_3V3);
3400295a:	2100      	movs	r1, #0
3400295c:	2003      	movs	r0, #3
3400295e:	f003 bbb1 	b.w	340060c4 <HAL_PWREx_ConfigVddIORange>

34002962 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34002962:	e7fe      	b.n	34002962 <NMI_Handler>

34002964 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
34002964:	e7fe      	b.n	34002964 <HardFault_Handler>

34002966 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34002966:	e7fe      	b.n	34002966 <MemManage_Handler>

34002968 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
34002968:	e7fe      	b.n	34002968 <BusFault_Handler>

3400296a <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
3400296a:	e7fe      	b.n	3400296a <UsageFault_Handler>

3400296c <SecureFault_Handler>:
void SecureFault_Handler(void)
{
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
3400296c:	e7fe      	b.n	3400296c <SecureFault_Handler>

3400296e <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
3400296e:	4770      	bx	lr

34002970 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
34002970:	4770      	bx	lr

34002972 <PendSV_Handler>:
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
34002972:	4770      	bx	lr

34002974 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
34002974:	f000 be8c 	b.w	34003690 <HAL_IncTick>

34002978 <DCMIPP_IRQHandler>:
void DCMIPP_IRQHandler(void)
{
  /* USER CODE BEGIN DCMIPP_IRQn 0 */

  /* USER CODE END DCMIPP_IRQn 0 */
  HAL_DCMIPP_IRQHandler(&hdcmipp);
34002978:	4801      	ldr	r0, [pc, #4]	@ (34002980 <DCMIPP_IRQHandler+0x8>)
3400297a:	f001 b9f2 	b.w	34003d62 <HAL_DCMIPP_IRQHandler>
3400297e:	bf00      	nop
34002980:	34014010 	.word	0x34014010

34002984 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
34002984:	4a0b      	ldr	r2, [pc, #44]	@ (340029b4 <_sbrk+0x30>)
{
34002986:	4603      	mov	r3, r0
  if (NULL == __sbrk_heap_end)
34002988:	6811      	ldr	r1, [r2, #0]
{
3400298a:	b510      	push	{r4, lr}
  if (NULL == __sbrk_heap_end)
3400298c:	b909      	cbnz	r1, 34002992 <_sbrk+0xe>
  {
    __sbrk_heap_end = &_end;
3400298e:	490a      	ldr	r1, [pc, #40]	@ (340029b8 <_sbrk+0x34>)
34002990:	6011      	str	r1, [r2, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
34002992:	6810      	ldr	r0, [r2, #0]
34002994:	4909      	ldr	r1, [pc, #36]	@ (340029bc <_sbrk+0x38>)
34002996:	4c0a      	ldr	r4, [pc, #40]	@ (340029c0 <_sbrk+0x3c>)
34002998:	4403      	add	r3, r0
3400299a:	1b09      	subs	r1, r1, r4
3400299c:	428b      	cmp	r3, r1
3400299e:	d906      	bls.n	340029ae <_sbrk+0x2a>
  {
    errno = ENOMEM;
340029a0:	f00b f816 	bl	3400d9d0 <__errno>
340029a4:	230c      	movs	r3, #12
340029a6:	6003      	str	r3, [r0, #0]
    return (void *)-1;
340029a8:	f04f 30ff 	mov.w	r0, #4294967295

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;

  return (void *)prev_heap_end;
}
340029ac:	bd10      	pop	{r4, pc}
  __sbrk_heap_end += incr;
340029ae:	6013      	str	r3, [r2, #0]
  return (void *)prev_heap_end;
340029b0:	e7fc      	b.n	340029ac <_sbrk+0x28>
340029b2:	bf00      	nop
340029b4:	34014224 	.word	0x34014224
340029b8:	340d05c8 	.word	0x340d05c8
340029bc:	34200000 	.word	0x34200000
340029c0:	00000800 	.word	0x00000800

340029c4 <SystemInit>:
  #endif /* defined (SCB_CSR_AIRCR_INIT) && (SCB_CSR_AIRCR_INIT == 1U) */

  #if defined (__FPU_USED) && (__FPU_USED == 1U) && \
      defined (TZ_FPU_NS_USAGE) && (TZ_FPU_NS_USAGE == 1U)

    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
340029c4:	491e      	ldr	r1, [pc, #120]	@ (34002a40 <SystemInit+0x7c>)
                   ((SCB_NSACR_CP10_11_VAL << SCB_NSACR_CP10_Pos) & (SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk));

    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
340029c6:	4a1f      	ldr	r2, [pc, #124]	@ (34002a44 <SystemInit+0x80>)
    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
340029c8:	f8d1 308c 	ldr.w	r3, [r1, #140]	@ 0x8c
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
340029cc:	b510      	push	{r4, lr}
340029ce:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
340029d2:	f8c1 308c 	str.w	r3, [r1, #140]	@ 0x8c
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
340029d6:	6b53      	ldr	r3, [r2, #52]	@ 0x34
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
340029d8:	f023 53e0 	bic.w	r3, r3, #469762048	@ 0x1c000000
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
340029dc:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
340029e0:	6353      	str	r3, [r2, #52]	@ 0x34
                   ((FPU_FPCCR_CLRONRET_VAL  << FPU_FPCCR_CLRONRET_Pos ) & FPU_FPCCR_CLRONRET_Msk );
  #endif

  #if defined (NVIC_INIT_ITNS0) && (NVIC_INIT_ITNS0 == 1U)
    NVIC->ITNS[0] = NVIC_INIT_ITNS0_VAL;
340029e2:	2200      	movs	r2, #0
340029e4:	4b18      	ldr	r3, [pc, #96]	@ (34002a48 <SystemInit+0x84>)
340029e6:	f8c3 2280 	str.w	r2, [r3, #640]	@ 0x280
  #endif

  #if defined (NVIC_INIT_ITNS1) && (NVIC_INIT_ITNS1 == 1U)
    NVIC->ITNS[1] = NVIC_INIT_ITNS1_VAL;
340029ea:	f8c3 2284 	str.w	r2, [r3, #644]	@ 0x284
  #endif

  #if defined (NVIC_INIT_ITNS2) && (NVIC_INIT_ITNS2 == 1U)
    NVIC->ITNS[2] = NVIC_INIT_ITNS2_VAL;
340029ee:	f8c3 2288 	str.w	r2, [r3, #648]	@ 0x288
  #endif

  #if defined (NVIC_INIT_ITNS3) && (NVIC_INIT_ITNS3 == 1U)
    NVIC->ITNS[3] = NVIC_INIT_ITNS3_VAL;
340029f2:	f8c3 228c 	str.w	r2, [r3, #652]	@ 0x28c
  #endif

  #if defined (NVIC_INIT_ITNS4) && (NVIC_INIT_ITNS4 == 1U)
    NVIC->ITNS[4] = NVIC_INIT_ITNS4_VAL;
340029f6:	f8c3 2290 	str.w	r2, [r3, #656]	@ 0x290
  #endif

  #if defined (NVIC_INIT_ITNS5) && (NVIC_INIT_ITNS5 == 1U)
    NVIC->ITNS[5] = NVIC_INIT_ITNS5_VAL;
340029fa:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  #endif

  #if defined (NVIC_INIT_ITNS6) && (NVIC_INIT_ITNS6 == 1U)
    NVIC->ITNS[6] = NVIC_INIT_ITNS6_VAL;
340029fe:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298
#else
  SCB->VTOR = INTVECT_START;
#endif  /* USER_VECT_TAB_ADDRESS */

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34002a02:	2201      	movs	r2, #1
  SCB->VTOR = INTVECT_START;
34002a04:	4b11      	ldr	r3, [pc, #68]	@ (34002a4c <SystemInit+0x88>)
34002a06:	608b      	str	r3, [r1, #8]
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34002a08:	4b11      	ldr	r3, [pc, #68]	@ (34002a50 <SystemInit+0x8c>)
34002a0a:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
34002a0e:	f8d3 0278 	ldr.w	r0, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34002a12:	688c      	ldr	r4, [r1, #8]
34002a14:	480f      	ldr	r0, [pc, #60]	@ (34002a54 <SystemInit+0x90>)
  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34002a16:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
  SYSCFG->INITSVTORCR = SCB->VTOR;
34002a1a:	6104      	str	r4, [r0, #16]
  (void) SYSCFG->INITSVTORCR;
34002a1c:	6900      	ldr	r0, [r0, #16]
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34002a1e:	f8c3 2278 	str.w	r2, [r3, #632]	@ 0x278
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34002a22:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34002a26:	4a0c      	ldr	r2, [pc, #48]	@ (34002a58 <SystemInit+0x94>)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34002a28:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34002a2c:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34002a30:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
34002a34:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34002a38:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34002a3c:	bd10      	pop	{r4, pc}
34002a3e:	bf00      	nop
34002a40:	e000ed00 	.word	0xe000ed00
34002a44:	e000ef00 	.word	0xe000ef00
34002a48:	e000e100 	.word	0xe000e100
34002a4c:	34000400 	.word	0x34000400
34002a50:	56028000 	.word	0x56028000
34002a54:	56008000 	.word	0x56008000
34002a58:	e002ed00 	.word	0xe002ed00

34002a5c <SystemCoreClockUpdate>:
  uint32_t pllp2 = 0;
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34002a5c:	4b6e      	ldr	r3, [pc, #440]	@ (34002c18 <SystemCoreClockUpdate+0x1bc>)
{
34002a5e:	b5f0      	push	{r4, r5, r6, r7, lr}
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34002a60:	6a1a      	ldr	r2, [r3, #32]
34002a62:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
34002a66:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
34002a6a:	f000 80b8 	beq.w	34002bde <SystemCoreClockUpdate+0x182>
34002a6e:	d806      	bhi.n	34002a7e <SystemCoreClockUpdate+0x22>
34002a70:	b962      	cbnz	r2, 34002a8c <SystemCoreClockUpdate+0x30>
  {
  case 0:  /* HSI used as system clock source (default after reset) */
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34002a72:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34002a74:	4b69      	ldr	r3, [pc, #420]	@ (34002c1c <SystemCoreClockUpdate+0x1c0>)
34002a76:	f3c2 12c1 	ubfx	r2, r2, #7, #2
34002a7a:	40d3      	lsrs	r3, r2
    break;
34002a7c:	e003      	b.n	34002a86 <SystemCoreClockUpdate+0x2a>
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34002a7e:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
34002a82:	d00b      	beq.n	34002a9c <SystemCoreClockUpdate+0x40>
  uint32_t sysclk = 0;
34002a84:	2300      	movs	r3, #0
    /* Nothing to do, should not occur */
    break;
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
34002a86:	4a66      	ldr	r2, [pc, #408]	@ (34002c20 <SystemCoreClockUpdate+0x1c4>)
34002a88:	6013      	str	r3, [r2, #0]
}
34002a8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34002a8c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
      sysclk = MSI_VALUE;
34002a8e:	4a65      	ldr	r2, [pc, #404]	@ (34002c24 <SystemCoreClockUpdate+0x1c8>)
34002a90:	f413 7f00 	tst.w	r3, #512	@ 0x200
34002a94:	4b64      	ldr	r3, [pc, #400]	@ (34002c28 <SystemCoreClockUpdate+0x1cc>)
34002a96:	bf08      	it	eq
34002a98:	4613      	moveq	r3, r2
34002a9a:	e7f4      	b.n	34002a86 <SystemCoreClockUpdate+0x2a>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34002a9c:	f8d3 20c4 	ldr.w	r2, [r3, #196]	@ 0xc4
34002aa0:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
34002aa4:	f1b2 5f80 	cmp.w	r2, #268435456	@ 0x10000000
34002aa8:	d02a      	beq.n	34002b00 <SystemCoreClockUpdate+0xa4>
34002aaa:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
34002aae:	d036      	beq.n	34002b1e <SystemCoreClockUpdate+0xc2>
34002ab0:	2a00      	cmp	r2, #0
34002ab2:	d143      	bne.n	34002b3c <SystemCoreClockUpdate+0xe0>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34002ab4:	f8d3 7080 	ldr.w	r7, [r3, #128]	@ 0x80
      if (pllbypass == 0U)
34002ab8:	013d      	lsls	r5, r7, #4
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34002aba:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34002abe:	f100 8096 	bmi.w	34002bee <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34002ac2:	f8d3 0084 	ldr.w	r0, [r3, #132]	@ 0x84
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34002ac6:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34002aca:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34002ace:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34002ad2:	460e      	mov	r6, r1
    switch (pllsource)
34002ad4:	f1b6 5f00 	cmp.w	r6, #536870912	@ 0x20000000
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34002ad8:	f3c2 65c2 	ubfx	r5, r2, #27, #3
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34002adc:	f3c7 5105 	ubfx	r1, r7, #20, #6
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
34002ae0:	f3c2 6202 	ubfx	r2, r2, #24, #3
    switch (pllsource)
34002ae4:	d04f      	beq.n	34002b86 <SystemCoreClockUpdate+0x12a>
34002ae6:	d87c      	bhi.n	34002be2 <SystemCoreClockUpdate+0x186>
34002ae8:	2e00      	cmp	r6, #0
34002aea:	d03c      	beq.n	34002b66 <SystemCoreClockUpdate+0x10a>
34002aec:	2600      	movs	r6, #0
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34002aee:	4b4a      	ldr	r3, [pc, #296]	@ (34002c18 <SystemCoreClockUpdate+0x1bc>)
        sysclk = MSI_VALUE;
34002af0:	4f4c      	ldr	r7, [pc, #304]	@ (34002c24 <SystemCoreClockUpdate+0x1c8>)
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34002af2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        sysclk = MSI_VALUE;
34002af4:	f413 7f00 	tst.w	r3, #512	@ 0x200
34002af8:	4b4b      	ldr	r3, [pc, #300]	@ (34002c28 <SystemCoreClockUpdate+0x1cc>)
34002afa:	bf08      	it	eq
34002afc:	463b      	moveq	r3, r7
34002afe:	e038      	b.n	34002b72 <SystemCoreClockUpdate+0x116>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34002b00:	f8d3 7090 	ldr.w	r7, [r3, #144]	@ 0x90
      if (pllbypass == 0U)
34002b04:	013c      	lsls	r4, r7, #4
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
34002b06:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34002b0a:	d470      	bmi.n	34002bee <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34002b0c:	f8d3 0094 	ldr.w	r0, [r3, #148]	@ 0x94
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34002b10:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34002b14:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34002b18:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34002b1c:	e7d9      	b.n	34002ad2 <SystemCoreClockUpdate+0x76>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34002b1e:	f8d3 70a0 	ldr.w	r7, [r3, #160]	@ 0xa0
      if (pllbypass == 0U)
34002b22:	0138      	lsls	r0, r7, #4
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34002b24:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34002b28:	d461      	bmi.n	34002bee <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34002b2a:	f8d3 00a4 	ldr.w	r0, [r3, #164]	@ 0xa4
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34002b2e:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34002b32:	f8d3 20a8 	ldr.w	r2, [r3, #168]	@ 0xa8
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34002b36:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34002b3a:	e7ca      	b.n	34002ad2 <SystemCoreClockUpdate+0x76>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34002b3c:	f8d3 70b0 	ldr.w	r7, [r3, #176]	@ 0xb0
      if (pllbypass == 0U)
34002b40:	013a      	lsls	r2, r7, #4
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34002b42:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34002b46:	d452      	bmi.n	34002bee <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34002b48:	f8d3 00b4 	ldr.w	r0, [r3, #180]	@ 0xb4
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34002b4c:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34002b50:	f8d3 20b8 	ldr.w	r2, [r3, #184]	@ 0xb8
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34002b54:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34002b58:	e7bb      	b.n	34002ad2 <SystemCoreClockUpdate+0x76>
    switch (pllsource)
34002b5a:	460a      	mov	r2, r1
34002b5c:	460d      	mov	r5, r1
34002b5e:	4608      	mov	r0, r1
34002b60:	460c      	mov	r4, r1
34002b62:	f04f 6600 	mov.w	r6, #134217728	@ 0x8000000
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34002b66:	4b2c      	ldr	r3, [pc, #176]	@ (34002c18 <SystemCoreClockUpdate+0x1bc>)
34002b68:	6c9f      	ldr	r7, [r3, #72]	@ 0x48
34002b6a:	4b2c      	ldr	r3, [pc, #176]	@ (34002c1c <SystemCoreClockUpdate+0x1c0>)
34002b6c:	f3c7 17c1 	ubfx	r7, r7, #7, #2
34002b70:	40fb      	lsrs	r3, r7
    if (pllbypass == 0U)
34002b72:	b14e      	cbz	r6, 34002b88 <SystemCoreClockUpdate+0x12c>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34002b74:	4a28      	ldr	r2, [pc, #160]	@ (34002c18 <SystemCoreClockUpdate+0x1bc>)
34002b76:	f8d2 20c4 	ldr.w	r2, [r2, #196]	@ 0xc4
34002b7a:	f3c2 4207 	ubfx	r2, r2, #16, #8
34002b7e:	3201      	adds	r2, #1
    sysclk = sysclk / ic_divider;
34002b80:	fbb3 f3f2 	udiv	r3, r3, r2
    break;
34002b84:	e77f      	b.n	34002a86 <SystemCoreClockUpdate+0x2a>
      sysclk = HSE_VALUE;
34002b86:	4b29      	ldr	r3, [pc, #164]	@ (34002c2c <SystemCoreClockUpdate+0x1d0>)
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34002b88:	ee07 0a10 	vmov	s14, r0
34002b8c:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
34002b90:	ee07 4a10 	vmov	s14, r4
34002b94:	ee07 3a90 	vmov	s15, r3
34002b98:	eddf 6a25 	vldr	s13, [pc, #148]	@ 34002c30 <SystemCoreClockUpdate+0x1d4>
34002b9c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34002ba0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34002ba4:	eea6 7a26 	vfma.f32	s14, s12, s13
34002ba8:	ee67 7a87 	vmul.f32	s15, s15, s14
34002bac:	ee07 1a10 	vmov	s14, r1
34002bb0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34002bb4:	eec7 6a87 	vdiv.f32	s13, s15, s14
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34002bb8:	ee07 5a90 	vmov	s15, r5
34002bbc:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
34002bc0:	ee07 2a90 	vmov	s15, r2
34002bc4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34002bc8:	ee27 7a27 	vmul.f32	s14, s14, s15
34002bcc:	eec6 7a87 	vdiv.f32	s15, s13, s14
34002bd0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34002bd4:	ee17 3a90 	vmov	r3, s15
34002bd8:	e7cc      	b.n	34002b74 <SystemCoreClockUpdate+0x118>
      sysclk = HSE_VALUE;
34002bda:	4b14      	ldr	r3, [pc, #80]	@ (34002c2c <SystemCoreClockUpdate+0x1d0>)
34002bdc:	e7ca      	b.n	34002b74 <SystemCoreClockUpdate+0x118>
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34002bde:	4b13      	ldr	r3, [pc, #76]	@ (34002c2c <SystemCoreClockUpdate+0x1d0>)
34002be0:	e751      	b.n	34002a86 <SystemCoreClockUpdate+0x2a>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34002be2:	f1b6 5f40 	cmp.w	r6, #805306368	@ 0x30000000
34002be6:	4b13      	ldr	r3, [pc, #76]	@ (34002c34 <SystemCoreClockUpdate+0x1d8>)
34002be8:	bf18      	it	ne
34002bea:	2300      	movne	r3, #0
34002bec:	e7cc      	b.n	34002b88 <SystemCoreClockUpdate+0x12c>
    switch (pllsource)
34002bee:	f1b1 5f00 	cmp.w	r1, #536870912	@ 0x20000000
34002bf2:	d0f2      	beq.n	34002bda <SystemCoreClockUpdate+0x17e>
34002bf4:	d809      	bhi.n	34002c0a <SystemCoreClockUpdate+0x1ae>
34002bf6:	2900      	cmp	r1, #0
34002bf8:	d0af      	beq.n	34002b5a <SystemCoreClockUpdate+0xfe>
34002bfa:	2200      	movs	r2, #0
34002bfc:	f04f 6600 	mov.w	r6, #134217728	@ 0x8000000
34002c00:	4615      	mov	r5, r2
34002c02:	4610      	mov	r0, r2
34002c04:	4614      	mov	r4, r2
34002c06:	4611      	mov	r1, r2
34002c08:	e771      	b.n	34002aee <SystemCoreClockUpdate+0x92>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34002c0a:	f1b1 5f40 	cmp.w	r1, #805306368	@ 0x30000000
34002c0e:	4b09      	ldr	r3, [pc, #36]	@ (34002c34 <SystemCoreClockUpdate+0x1d8>)
34002c10:	bf18      	it	ne
34002c12:	2300      	movne	r3, #0
34002c14:	e7ae      	b.n	34002b74 <SystemCoreClockUpdate+0x118>
34002c16:	bf00      	nop
34002c18:	56028000 	.word	0x56028000
34002c1c:	03d09000 	.word	0x03d09000
34002c20:	34013b18 	.word	0x34013b18
34002c24:	003d0900 	.word	0x003d0900
34002c28:	00f42400 	.word	0x00f42400
34002c2c:	02dc6c00 	.word	0x02dc6c00
34002c30:	33800000 	.word	0x33800000
34002c34:	00bb8000 	.word	0x00bb8000

34002c38 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34002c38:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34002c3c:	b500      	push	{lr}
  SystemCoreClockUpdate();
34002c3e:	f7ff ff0d 	bl	34002a5c <SystemCoreClockUpdate>

  return SystemCoreClock;
}
34002c42:	4b05      	ldr	r3, [pc, #20]	@ (34002c58 <__acle_se_SECURE_SystemCoreClockUpdate+0x20>)
34002c44:	f85d eb04 	ldr.w	lr, [sp], #4
34002c48:	6818      	ldr	r0, [r3, #0]
34002c4a:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34002c4e:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34002c52:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34002c56:	4774      	bxns	lr
34002c58:	34013b18 	.word	0x34013b18

34002c5c <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
34002c5c:	b508      	push	{r3, lr}

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
34002c5e:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
  huart1.Instance = USART1;
34002c62:	4815      	ldr	r0, [pc, #84]	@ (34002cb8 <MX_USART1_UART_Init+0x5c>)
  huart1.Init.BaudRate = 115200;
34002c64:	4a15      	ldr	r2, [pc, #84]	@ (34002cbc <MX_USART1_UART_Init+0x60>)
34002c66:	e9c0 2300 	strd	r2, r3, [r0]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
34002c6a:	2300      	movs	r3, #0
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
34002c6c:	220c      	movs	r2, #12
  huart1.Init.StopBits = UART_STOPBITS_1;
34002c6e:	e9c0 3302 	strd	r3, r3, [r0, #8]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
34002c72:	e9c0 2305 	strd	r2, r3, [r0, #20]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
34002c76:	e9c0 3307 	strd	r3, r3, [r0, #28]
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
34002c7a:	e9c0 3309 	strd	r3, r3, [r0, #36]	@ 0x24
  huart1.Init.Parity = UART_PARITY_NONE;
34002c7e:	6103      	str	r3, [r0, #16]
  if (HAL_UART_Init(&huart1) != HAL_OK)
34002c80:	f007 f8ec 	bl	34009e5c <HAL_UART_Init>
34002c84:	b108      	cbz	r0, 34002c8a <MX_USART1_UART_Init+0x2e>
  {
    Error_Handler();
34002c86:	f7ff fd43 	bl	34002710 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
34002c8a:	2100      	movs	r1, #0
34002c8c:	480a      	ldr	r0, [pc, #40]	@ (34002cb8 <MX_USART1_UART_Init+0x5c>)
34002c8e:	f007 f952 	bl	34009f36 <HAL_UARTEx_SetTxFifoThreshold>
34002c92:	b108      	cbz	r0, 34002c98 <MX_USART1_UART_Init+0x3c>
  {
    Error_Handler();
34002c94:	f7ff fd3c 	bl	34002710 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
34002c98:	2100      	movs	r1, #0
34002c9a:	4807      	ldr	r0, [pc, #28]	@ (34002cb8 <MX_USART1_UART_Init+0x5c>)
34002c9c:	f007 f96b 	bl	34009f76 <HAL_UARTEx_SetRxFifoThreshold>
34002ca0:	b108      	cbz	r0, 34002ca6 <MX_USART1_UART_Init+0x4a>
  {
    Error_Handler();
34002ca2:	f7ff fd35 	bl	34002710 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
34002ca6:	4804      	ldr	r0, [pc, #16]	@ (34002cb8 <MX_USART1_UART_Init+0x5c>)
34002ca8:	f007 f92a 	bl	34009f00 <HAL_UARTEx_DisableFifoMode>
34002cac:	b118      	cbz	r0, 34002cb6 <MX_USART1_UART_Init+0x5a>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
34002cae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
34002cb2:	f7ff bd2d 	b.w	34002710 <Error_Handler>
}
34002cb6:	bd08      	pop	{r3, pc}
34002cb8:	34014228 	.word	0x34014228
34002cbc:	52001000 	.word	0x52001000

34002cc0 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
34002cc0:	b510      	push	{r4, lr}
34002cc2:	4604      	mov	r4, r0
34002cc4:	b0ec      	sub	sp, #432	@ 0x1b0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
34002cc6:	2214      	movs	r2, #20
34002cc8:	2100      	movs	r1, #0
34002cca:	a803      	add	r0, sp, #12
34002ccc:	f00a fe22 	bl	3400d914 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34002cd0:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34002cd4:	2100      	movs	r1, #0
34002cd6:	a808      	add	r0, sp, #32
34002cd8:	f00a fe1c 	bl	3400d914 <memset>
  if(uartHandle->Instance==USART1)
34002cdc:	6822      	ldr	r2, [r4, #0]
34002cde:	4b16      	ldr	r3, [pc, #88]	@ (34002d38 <HAL_UART_MspInit+0x78>)
34002ce0:	429a      	cmp	r2, r3
34002ce2:	d127      	bne.n	34002d34 <HAL_UART_MspInit+0x74>

  /* USER CODE END USART1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
34002ce4:	f44f 7380 	mov.w	r3, #256	@ 0x100
34002ce8:	2200      	movs	r2, #0
34002cea:	e9cd 2308 	strd	r2, r3, [sp, #32]
    PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_HSI;
34002cee:	4b13      	ldr	r3, [pc, #76]	@ (34002d3c <HAL_UART_MspInit+0x7c>)
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34002cf0:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_HSI;
34002cf2:	935c      	str	r3, [sp, #368]	@ 0x170
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34002cf4:	f003 fbb6 	bl	34006464 <HAL_RCCEx_PeriphCLKConfig>
34002cf8:	b108      	cbz	r0, 34002cfe <HAL_UART_MspInit+0x3e>
    {
      Error_Handler();
34002cfa:	f7ff fd09 	bl	34002710 <Error_Handler>
  WRITE_REG(RCC->APB2ENSR, Periphs);
34002cfe:	2210      	movs	r2, #16
34002d00:	4b0f      	ldr	r3, [pc, #60]	@ (34002d40 <HAL_UART_MspInit+0x80>)
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
34002d02:	4810      	ldr	r0, [pc, #64]	@ (34002d44 <HAL_UART_MspInit+0x84>)
34002d04:	f8c3 2a6c 	str.w	r2, [r3, #2668]	@ 0xa6c
  tmpreg = READ_REG(RCC->APB2ENR);
34002d08:	f8d3 126c 	ldr.w	r1, [r3, #620]	@ 0x26c
34002d0c:	9102      	str	r1, [sp, #8]
  (void)tmpreg;
34002d0e:	9902      	ldr	r1, [sp, #8]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002d10:	f8c3 2a5c 	str.w	r2, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34002d14:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34002d18:	2260      	movs	r2, #96	@ 0x60
34002d1a:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34002d1c:	9b01      	ldr	r3, [sp, #4]
34002d1e:	2302      	movs	r3, #2
34002d20:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34002d24:	2300      	movs	r3, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34002d26:	e9cd 3305 	strd	r3, r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
34002d2a:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
34002d2c:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
34002d2e:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
34002d30:	f002 f8e0 	bl	34004ef4 <HAL_GPIO_Init>

  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
34002d34:	b06c      	add	sp, #432	@ 0x1b0
34002d36:	bd10      	pop	{r4, pc}
34002d38:	52001000 	.word	0x52001000
34002d3c:	07060030 	.word	0x07060030
34002d40:	56028000 	.word	0x56028000
34002d44:	56021000 	.word	0x56021000

34002d48 <LL_AHB5_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34002d48:	4b04      	ldr	r3, [pc, #16]	@ (34002d5c <LL_AHB5_GRP1_EnableClock+0x14>)
{
34002d4a:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34002d4c:	f8c3 0a60 	str.w	r0, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34002d50:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34002d54:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34002d56:	9b01      	ldr	r3, [sp, #4]
}
34002d58:	b002      	add	sp, #8
34002d5a:	4770      	bx	lr
34002d5c:	56028000 	.word	0x56028000

34002d60 <MX_XSPI1_Init>:
XSPI_HandleTypeDef hxspi1;
XSPI_HandleTypeDef hxspi2;

/* XSPI1 init function */
void MX_XSPI1_Init(void)
{
34002d60:	b510      	push	{r4, lr}
  /* USER CODE BEGIN XSPI1_Init 0 */

  /* USER CODE END XSPI1_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
  XSPI_HyperbusCfgTypeDef sHyperBusCfg = {0};
34002d62:	2210      	movs	r2, #16
  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34002d64:	2400      	movs	r4, #0
{
34002d66:	b088      	sub	sp, #32
  XSPI_HyperbusCfgTypeDef sHyperBusCfg = {0};
34002d68:	4621      	mov	r1, r4
34002d6a:	eb0d 0002 	add.w	r0, sp, r2
  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34002d6e:	e9cd 4401 	strd	r4, r4, [sp, #4]
34002d72:	9403      	str	r4, [sp, #12]
  XSPI_HyperbusCfgTypeDef sHyperBusCfg = {0};
34002d74:	f00a fdce 	bl	3400d914 <memset>

  /* USER CODE BEGIN XSPI1_Init 1 */

  /* USER CODE END XSPI1_Init 1 */
  hxspi1.Instance = XSPI1;
  hxspi1.Init.FifoThresholdByte = 4;
34002d78:	2304      	movs	r3, #4
  hxspi1.Instance = XSPI1;
34002d7a:	481e      	ldr	r0, [pc, #120]	@ (34002df4 <MX_XSPI1_Init+0x94>)
  hxspi1.Init.FifoThresholdByte = 4;
34002d7c:	491e      	ldr	r1, [pc, #120]	@ (34002df8 <MX_XSPI1_Init+0x98>)
  hxspi1.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
  hxspi1.Init.MemoryType = HAL_XSPI_MEMTYPE_HYPERBUS;
  hxspi1.Init.MemorySize = HAL_XSPI_SIZE_256MB;
34002d7e:	f04f 6c80 	mov.w	ip, #67108864	@ 0x4000000
  hxspi1.Init.FifoThresholdByte = 4;
34002d82:	e9c0 1300 	strd	r1, r3, [r0]
  hxspi1.Init.MemorySize = HAL_XSPI_SIZE_256MB;
34002d86:	2318      	movs	r3, #24
34002d88:	e9c0 c303 	strd	ip, r3, [r0, #12]
  hxspi1.Init.ChipSelectHighTimeCycle = 2;
34002d8c:	2302      	movs	r3, #2
  hxspi1.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
34002d8e:	e9c0 3405 	strd	r3, r4, [r0, #20]
  hxspi1.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
  hxspi1.Init.WrapSize = HAL_XSPI_WRAP_32_BYTES;
34002d92:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
  hxspi1.Init.ClockPrescaler = 1 - 1;
  hxspi1.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
  hxspi1.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34002d96:	e9c0 440a 	strd	r4, r4, [r0, #40]	@ 0x28
  hxspi1.Init.ClockPrescaler = 1 - 1;
34002d9a:	e9c0 3408 	strd	r3, r4, [r0, #32]
  hxspi1.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
  hxspi1.Init.MaxTran = 0;
34002d9e:	e9c0 440c 	strd	r4, r4, [r0, #48]	@ 0x30
  hxspi1.Init.Refresh = 0;
  hxspi1.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
34002da2:	e9c0 440e 	strd	r4, r4, [r0, #56]	@ 0x38
  hxspi1.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
34002da6:	6084      	str	r4, [r0, #8]
  hxspi1.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
34002da8:	61c4      	str	r4, [r0, #28]
  if (HAL_XSPI_Init(&hxspi1) != HAL_OK)
34002daa:	f007 f92b 	bl	3400a004 <HAL_XSPI_Init>
34002dae:	b108      	cbz	r0, 34002db4 <MX_XSPI1_Init+0x54>
  {
    Error_Handler();
34002db0:	f7ff fcae 	bl	34002710 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34002db4:	2310      	movs	r3, #16
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_1;
34002db6:	e9cd 3401 	strd	r3, r4, [sp, #4]
  sXspiManagerCfg.Req2AckTime = 1;
34002dba:	2301      	movs	r3, #1
  if (HAL_XSPIM_Config(&hxspi1, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002dbc:	f241 3288 	movw	r2, #5000	@ 0x1388
34002dc0:	480c      	ldr	r0, [pc, #48]	@ (34002df4 <MX_XSPI1_Init+0x94>)
34002dc2:	a901      	add	r1, sp, #4
  sXspiManagerCfg.Req2AckTime = 1;
34002dc4:	9303      	str	r3, [sp, #12]
  if (HAL_XSPIM_Config(&hxspi1, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002dc6:	f007 f9f1 	bl	3400a1ac <HAL_XSPIM_Config>
34002dca:	b108      	cbz	r0, 34002dd0 <MX_XSPI1_Init+0x70>
  {
    Error_Handler();
34002dcc:	f7ff fca0 	bl	34002710 <Error_Handler>
  }
  sHyperBusCfg.RWRecoveryTimeCycle = 7;
34002dd0:	2307      	movs	r3, #7
  sHyperBusCfg.AccessTimeCycle = 7;
  sHyperBusCfg.WriteZeroLatency = HAL_XSPI_LATENCY_ON_WRITE;
  sHyperBusCfg.LatencyMode = HAL_XSPI_FIXED_LATENCY;
34002dd2:	2200      	movs	r2, #0
  sHyperBusCfg.AccessTimeCycle = 7;
34002dd4:	e9cd 3304 	strd	r3, r3, [sp, #16]
  sHyperBusCfg.LatencyMode = HAL_XSPI_FIXED_LATENCY;
34002dd8:	2301      	movs	r3, #1
  if (HAL_XSPI_HyperbusCfg(&hxspi1, &sHyperBusCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002dda:	4806      	ldr	r0, [pc, #24]	@ (34002df4 <MX_XSPI1_Init+0x94>)
  sHyperBusCfg.LatencyMode = HAL_XSPI_FIXED_LATENCY;
34002ddc:	e9cd 2306 	strd	r2, r3, [sp, #24]
  if (HAL_XSPI_HyperbusCfg(&hxspi1, &sHyperBusCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002de0:	a904      	add	r1, sp, #16
34002de2:	f241 3288 	movw	r2, #5000	@ 0x1388
34002de6:	f007 f9b9 	bl	3400a15c <HAL_XSPI_HyperbusCfg>
34002dea:	b108      	cbz	r0, 34002df0 <MX_XSPI1_Init+0x90>
  {
    Error_Handler();
34002dec:	f7ff fc90 	bl	34002710 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI1_Init 2 */

  /* USER CODE END XSPI1_Init 2 */

}
34002df0:	b008      	add	sp, #32
34002df2:	bd10      	pop	{r4, pc}
34002df4:	34014324 	.word	0x34014324
34002df8:	58025000 	.word	0x58025000

34002dfc <MX_XSPI2_Init>:
/* XSPI2 init function */
void MX_XSPI2_Init(void)
{
34002dfc:	b51f      	push	{r0, r1, r2, r3, r4, lr}

  /* USER CODE BEGIN XSPI2_Init 1 */

  /* USER CODE END XSPI2_Init 1 */
  hxspi2.Instance = XSPI2;
  hxspi2.Init.FifoThresholdByte = 4;
34002dfe:	2204      	movs	r2, #4
  hxspi2.Instance = XSPI2;
34002e00:	4815      	ldr	r0, [pc, #84]	@ (34002e58 <MX_XSPI2_Init+0x5c>)
  hxspi2.Init.FifoThresholdByte = 4;
34002e02:	4916      	ldr	r1, [pc, #88]	@ (34002e5c <MX_XSPI2_Init+0x60>)
  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34002e04:	2300      	movs	r3, #0
  hxspi2.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
  hxspi2.Init.MemoryType = HAL_XSPI_MEMTYPE_MICRON;
  hxspi2.Init.MemorySize = HAL_XSPI_SIZE_256MB;
  hxspi2.Init.ChipSelectHighTimeCycle = 1;
34002e06:	2401      	movs	r4, #1
  hxspi2.Init.FifoThresholdByte = 4;
34002e08:	e9c0 1200 	strd	r1, r2, [r0]
  hxspi2.Init.ChipSelectHighTimeCycle = 1;
34002e0c:	2218      	movs	r2, #24
  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34002e0e:	e9cd 3301 	strd	r3, r3, [sp, #4]
  hxspi2.Init.MemoryType = HAL_XSPI_MEMTYPE_MICRON;
34002e12:	e9c0 3302 	strd	r3, r3, [r0, #8]
  hxspi2.Init.ChipSelectHighTimeCycle = 1;
34002e16:	e9c0 2404 	strd	r2, r4, [r0, #16]
  hxspi2.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
  hxspi2.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
34002e1a:	e9c0 3306 	strd	r3, r3, [r0, #24]
  hxspi2.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
  hxspi2.Init.ClockPrescaler = 0;
34002e1e:	e9c0 3308 	strd	r3, r3, [r0, #32]
  hxspi2.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
  hxspi2.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34002e22:	e9c0 330a 	strd	r3, r3, [r0, #40]	@ 0x28
  hxspi2.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
  hxspi2.Init.MaxTran = 0;
34002e26:	e9c0 330c 	strd	r3, r3, [r0, #48]	@ 0x30
  hxspi2.Init.Refresh = 0;
  hxspi2.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
34002e2a:	e9c0 330e 	strd	r3, r3, [r0, #56]	@ 0x38
  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34002e2e:	9303      	str	r3, [sp, #12]
  if (HAL_XSPI_Init(&hxspi2) != HAL_OK)
34002e30:	f007 f8e8 	bl	3400a004 <HAL_XSPI_Init>
34002e34:	b108      	cbz	r0, 34002e3a <MX_XSPI2_Init+0x3e>
  {
    Error_Handler();
34002e36:	f7ff fc6b 	bl	34002710 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34002e3a:	2310      	movs	r3, #16
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_2;
  sXspiManagerCfg.Req2AckTime = 1;
  if (HAL_XSPIM_Config(&hxspi2, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002e3c:	f241 3288 	movw	r2, #5000	@ 0x1388
34002e40:	4805      	ldr	r0, [pc, #20]	@ (34002e58 <MX_XSPI2_Init+0x5c>)
34002e42:	a901      	add	r1, sp, #4
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_2;
34002e44:	e9cd 3401 	strd	r3, r4, [sp, #4]
  sXspiManagerCfg.Req2AckTime = 1;
34002e48:	9403      	str	r4, [sp, #12]
  if (HAL_XSPIM_Config(&hxspi2, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002e4a:	f007 f9af 	bl	3400a1ac <HAL_XSPIM_Config>
34002e4e:	b108      	cbz	r0, 34002e54 <MX_XSPI2_Init+0x58>
  {
    Error_Handler();
34002e50:	f7ff fc5e 	bl	34002710 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI2_Init 2 */

  /* USER CODE END XSPI2_Init 2 */

}
34002e54:	b004      	add	sp, #16
34002e56:	bd10      	pop	{r4, pc}
34002e58:	340142c0 	.word	0x340142c0
34002e5c:	5802a000 	.word	0x5802a000

34002e60 <HAL_XSPI_MspInit>:

static uint32_t HAL_RCC_XSPIM_CLK_ENABLED=0;

void HAL_XSPI_MspInit(XSPI_HandleTypeDef* xspiHandle)
{
34002e60:	b5f0      	push	{r4, r5, r6, r7, lr}
34002e62:	4604      	mov	r4, r0
34002e64:	b0ed      	sub	sp, #436	@ 0x1b4

  GPIO_InitTypeDef GPIO_InitStruct = {0};
34002e66:	2214      	movs	r2, #20
34002e68:	2100      	movs	r1, #0
34002e6a:	a803      	add	r0, sp, #12
34002e6c:	f00a fd52 	bl	3400d914 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34002e70:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34002e74:	2100      	movs	r1, #0
34002e76:	a808      	add	r0, sp, #32
34002e78:	f00a fd4c 	bl	3400d914 <memset>
  if(xspiHandle->Instance==XSPI1)
34002e7c:	6823      	ldr	r3, [r4, #0]
34002e7e:	4a3e      	ldr	r2, [pc, #248]	@ (34002f78 <HAL_XSPI_MspInit+0x118>)
34002e80:	4293      	cmp	r3, r2
34002e82:	d144      	bne.n	34002f0e <HAL_XSPI_MspInit+0xae>

  /* USER CODE END XSPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI1;
34002e84:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34002e88:	2200      	movs	r2, #0
34002e8a:	e9cd 2308 	strd	r2, r3, [sp, #32]
    PeriphClkInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34002e8e:	4b3b      	ldr	r3, [pc, #236]	@ (34002f7c <HAL_XSPI_MspInit+0x11c>)
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34002e90:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34002e92:	9333      	str	r3, [sp, #204]	@ 0xcc
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34002e94:	f003 fae6 	bl	34006464 <HAL_RCCEx_PeriphCLKConfig>
34002e98:	b108      	cbz	r0, 34002e9e <HAL_XSPI_MspInit+0x3e>
    {
      Error_Handler();
34002e9a:	f7ff fc39 	bl	34002710 <Error_Handler>
    }

    /* XSPI1 clock enable */
    HAL_RCC_XSPIM_CLK_ENABLED++;
34002e9e:	4a38      	ldr	r2, [pc, #224]	@ (34002f80 <HAL_XSPI_MspInit+0x120>)
34002ea0:	6813      	ldr	r3, [r2, #0]
34002ea2:	3301      	adds	r3, #1
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
34002ea4:	2b01      	cmp	r3, #1
    HAL_RCC_XSPIM_CLK_ENABLED++;
34002ea6:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
34002ea8:	d103      	bne.n	34002eb2 <HAL_XSPI_MspInit+0x52>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34002eaa:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34002eae:	f7ff ff4b 	bl	34002d48 <LL_AHB5_GRP1_EnableClock>
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002eb2:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
    }
    __HAL_RCC_XSPI1_CLK_ENABLE();
34002eb6:	2020      	movs	r0, #32
34002eb8:	f7ff ff46 	bl	34002d48 <LL_AHB5_GRP1_EnableClock>
34002ebc:	4b31      	ldr	r3, [pc, #196]	@ (34002f84 <HAL_XSPI_MspInit+0x124>)
    PO0     ------> XSPIM_P1_NCS1
    PO4     ------> XSPIM_P1_CLK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_0|GPIO_PIN_4
                          |GPIO_PIN_1|GPIO_PIN_5|GPIO_PIN_3|GPIO_PIN_2;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34002ebe:	2702      	movs	r7, #2
34002ec0:	f8c3 2a5c 	str.w	r2, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34002ec4:	f8d3 225c 	ldr.w	r2, [r3, #604]	@ 0x25c
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002ec8:	2600      	movs	r6, #0
34002eca:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
34002ecc:	9a01      	ldr	r2, [sp, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002ece:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34002ed2:	f8c3 2a5c 	str.w	r2, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34002ed6:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34002eda:	2503      	movs	r5, #3
34002edc:	9300      	str	r3, [sp, #0]
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
34002ede:	2409      	movs	r4, #9
  (void)tmpreg;
34002ee0:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34002ee2:	23ff      	movs	r3, #255	@ 0xff
    HAL_GPIO_Init(GPIOP, &GPIO_InitStruct);
34002ee4:	4828      	ldr	r0, [pc, #160]	@ (34002f88 <HAL_XSPI_MspInit+0x128>)
34002ee6:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34002ee8:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002eec:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
34002ef0:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOP, &GPIO_InitStruct);
34002ef2:	f001 ffff 	bl	34004ef4 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_2|GPIO_PIN_0|GPIO_PIN_4;
34002ef6:	2335      	movs	r3, #53	@ 0x35
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002ef8:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34002efc:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
    HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
34002f00:	4822      	ldr	r0, [pc, #136]	@ (34002f8c <HAL_XSPI_MspInit+0x12c>)
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
34002f02:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
34002f04:	a903      	add	r1, sp, #12
                          |GPIO_PIN_2|GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P2;
    HAL_GPIO_Init(GPION, &GPIO_InitStruct);
34002f06:	f001 fff5 	bl	34004ef4 <HAL_GPIO_Init>

  /* USER CODE BEGIN XSPI2_MspInit 1 */

  /* USER CODE END XSPI2_MspInit 1 */
  }
}
34002f0a:	b06d      	add	sp, #436	@ 0x1b4
34002f0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(xspiHandle->Instance==XSPI2)
34002f0e:	4a20      	ldr	r2, [pc, #128]	@ (34002f90 <HAL_XSPI_MspInit+0x130>)
34002f10:	4293      	cmp	r3, r2
34002f12:	d1fa      	bne.n	34002f0a <HAL_XSPI_MspInit+0xaa>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI2;
34002f14:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
34002f18:	2200      	movs	r2, #0
34002f1a:	e9cd 2308 	strd	r2, r3, [sp, #32]
    PeriphClkInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34002f1e:	4b1d      	ldr	r3, [pc, #116]	@ (34002f94 <HAL_XSPI_MspInit+0x134>)
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34002f20:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34002f22:	9334      	str	r3, [sp, #208]	@ 0xd0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34002f24:	f003 fa9e 	bl	34006464 <HAL_RCCEx_PeriphCLKConfig>
34002f28:	b108      	cbz	r0, 34002f2e <HAL_XSPI_MspInit+0xce>
      Error_Handler();
34002f2a:	f7ff fbf1 	bl	34002710 <Error_Handler>
    HAL_RCC_XSPIM_CLK_ENABLED++;
34002f2e:	4a14      	ldr	r2, [pc, #80]	@ (34002f80 <HAL_XSPI_MspInit+0x120>)
34002f30:	6813      	ldr	r3, [r2, #0]
34002f32:	3301      	adds	r3, #1
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
34002f34:	2b01      	cmp	r3, #1
    HAL_RCC_XSPIM_CLK_ENABLED++;
34002f36:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
34002f38:	d103      	bne.n	34002f42 <HAL_XSPI_MspInit+0xe2>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34002f3a:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34002f3e:	f7ff ff03 	bl	34002d48 <LL_AHB5_GRP1_EnableClock>
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002f42:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
    __HAL_RCC_XSPI2_CLK_ENABLE();
34002f46:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34002f4a:	f7ff fefd 	bl	34002d48 <LL_AHB5_GRP1_EnableClock>
34002f4e:	4b0d      	ldr	r3, [pc, #52]	@ (34002f84 <HAL_XSPI_MspInit+0x124>)
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002f50:	2100      	movs	r1, #0
34002f52:	f8c3 2a5c 	str.w	r2, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34002f56:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34002f5a:	f640 727f 	movw	r2, #3967	@ 0xf7f
34002f5e:	9302      	str	r3, [sp, #8]
  (void)tmpreg;
34002f60:	9b02      	ldr	r3, [sp, #8]
34002f62:	2302      	movs	r3, #2
34002f64:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002f68:	2303      	movs	r3, #3
34002f6a:	e9cd 1305 	strd	r1, r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P2;
34002f6e:	2309      	movs	r3, #9
    HAL_GPIO_Init(GPION, &GPIO_InitStruct);
34002f70:	4809      	ldr	r0, [pc, #36]	@ (34002f98 <HAL_XSPI_MspInit+0x138>)
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P2;
34002f72:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPION, &GPIO_InitStruct);
34002f74:	a903      	add	r1, sp, #12
34002f76:	e7c6      	b.n	34002f06 <HAL_XSPI_MspInit+0xa6>
34002f78:	58025000 	.word	0x58025000
34002f7c:	03000014 	.word	0x03000014
34002f80:	340142bc 	.word	0x340142bc
34002f84:	56028000 	.word	0x56028000
34002f88:	56023c00 	.word	0x56023c00
34002f8c:	56023800 	.word	0x56023800
34002f90:	5802a000 	.word	0x5802a000
34002f94:	03000414 	.word	0x03000414
34002f98:	56023400 	.word	0x56023400

34002f9c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34002f9c:	480f      	ldr	r0, [pc, #60]	@ (34002fdc <LoopForever+0x4>)
  msr   MSPLIM, r0
34002f9e:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34002fa2:	480f      	ldr	r0, [pc, #60]	@ (34002fe0 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34002fa4:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34002fa6:	f7ff fd0d 	bl	340029c4 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34002faa:	480e      	ldr	r0, [pc, #56]	@ (34002fe4 <LoopForever+0xc>)
  ldr r1, =_edata
34002fac:	490e      	ldr	r1, [pc, #56]	@ (34002fe8 <LoopForever+0x10>)
  ldr r2, =_sidata
34002fae:	4a0f      	ldr	r2, [pc, #60]	@ (34002fec <LoopForever+0x14>)
  movs r3, #0
34002fb0:	2300      	movs	r3, #0
  b LoopCopyDataInit
34002fb2:	e002      	b.n	34002fba <LoopCopyDataInit>

34002fb4 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34002fb4:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34002fb6:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34002fb8:	3304      	adds	r3, #4

34002fba <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34002fba:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34002fbc:	428c      	cmp	r4, r1
  bcc CopyDataInit
34002fbe:	d3f9      	bcc.n	34002fb4 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34002fc0:	4a0b      	ldr	r2, [pc, #44]	@ (34002ff0 <LoopForever+0x18>)
  ldr r4, =_ebss
34002fc2:	4c0c      	ldr	r4, [pc, #48]	@ (34002ff4 <LoopForever+0x1c>)
  movs r3, #0
34002fc4:	2300      	movs	r3, #0
  b LoopFillZerobss
34002fc6:	e001      	b.n	34002fcc <LoopFillZerobss>

34002fc8 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34002fc8:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34002fca:	3204      	adds	r2, #4

34002fcc <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34002fcc:	42a2      	cmp	r2, r4
  bcc FillZerobss
34002fce:	d3fb      	bcc.n	34002fc8 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34002fd0:	f00a fd04 	bl	3400d9dc <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34002fd4:	f7ff f952 	bl	3400227c <main>

34002fd8 <LoopForever>:

LoopForever:
  b LoopForever
34002fd8:	e7fe      	b.n	34002fd8 <LoopForever>
34002fda:	0000      	.short	0x0000
  ldr   r0, =_sstack
34002fdc:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
34002fe0:	34200000 	.word	0x34200000
  ldr r0, =_sdata
34002fe4:	34013b0c 	.word	0x34013b0c
  ldr r1, =_edata
34002fe8:	34013c48 	.word	0x34013c48
  ldr r2, =_sidata
34002fec:	34013b0c 	.word	0x34013b0c
  ldr r2, =_sbss
34002ff0:	34013c80 	.word	0x34013c80
  ldr r4, =_ebss
34002ff4:	340d05c8 	.word	0x340d05c8

34002ff8 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34002ff8:	e7fe      	b.n	34002ff8 <ADC1_2_IRQHandler>
	...

34002ffc <bsp_i2c2_init>:
extern I2C_HandleTypeDef hi2c2;

static uint8_t bsp_i2c2_init_counter = 0;

int32_t bsp_i2c2_init(void)
{
34002ffc:	b508      	push	{r3, lr}
    if (bsp_i2c2_init_counter == 0)
34002ffe:	4b04      	ldr	r3, [pc, #16]	@ (34003010 <bsp_i2c2_init+0x14>)
34003000:	781a      	ldrb	r2, [r3, #0]
34003002:	b91a      	cbnz	r2, 3400300c <bsp_i2c2_init+0x10>
    {
        bsp_i2c2_init_counter++;
34003004:	2201      	movs	r2, #1
34003006:	701a      	strb	r2, [r3, #0]

        MX_I2C2_Init();
34003008:	f7fe ff88 	bl	34001f1c <MX_I2C2_Init>
    }

    return 0;
}
3400300c:	2000      	movs	r0, #0
3400300e:	bd08      	pop	{r3, pc}
34003010:	34014388 	.word	0x34014388

34003014 <bsp_i2c2_deinit>:

int32_t bsp_i2c2_deinit(void)
{
34003014:	b508      	push	{r3, lr}
    if (bsp_i2c2_init_counter == 0)
34003016:	4a06      	ldr	r2, [pc, #24]	@ (34003030 <bsp_i2c2_deinit+0x1c>)
34003018:	7813      	ldrb	r3, [r2, #0]
3400301a:	b133      	cbz	r3, 3400302a <bsp_i2c2_deinit+0x16>
    {
        return 0;
    }

    bsp_i2c2_init_counter--;
3400301c:	3b01      	subs	r3, #1
3400301e:	b2db      	uxtb	r3, r3
34003020:	7013      	strb	r3, [r2, #0]
    if (bsp_i2c2_init_counter == 0)
34003022:	b913      	cbnz	r3, 3400302a <bsp_i2c2_deinit+0x16>
    {
        HAL_I2C_DeInit(&hi2c2);
34003024:	4803      	ldr	r0, [pc, #12]	@ (34003034 <bsp_i2c2_deinit+0x20>)
34003026:	f002 fab9 	bl	3400559c <HAL_I2C_DeInit>
    }

    return 0;
}
3400302a:	2000      	movs	r0, #0
3400302c:	bd08      	pop	{r3, pc}
3400302e:	bf00      	nop
34003030:	34014388 	.word	0x34014388
34003034:	34014084 	.word	0x34014084

34003038 <bsp_i2c2_write_reg16>:

int32_t bsp_i2c2_write_reg16(uint16_t address, uint16_t reg, uint8_t *data, uint16_t length)
{
34003038:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (HAL_I2C_Mem_Write(&hi2c2, address, reg, I2C_MEMADD_SIZE_16BIT, data, length, 1000) != HAL_OK)
3400303a:	f44f 747a 	mov.w	r4, #1000	@ 0x3e8
3400303e:	9200      	str	r2, [sp, #0]
34003040:	e9cd 3401 	strd	r3, r4, [sp, #4]
34003044:	460a      	mov	r2, r1
34003046:	2302      	movs	r3, #2
34003048:	4601      	mov	r1, r0
3400304a:	4804      	ldr	r0, [pc, #16]	@ (3400305c <bsp_i2c2_write_reg16+0x24>)
3400304c:	f002 fac0 	bl	340055d0 <HAL_I2C_Mem_Write>
34003050:	3800      	subs	r0, #0
34003052:	bf18      	it	ne
34003054:	2001      	movne	r0, #1
    {
        return -1;
    }

    return 0;
}
34003056:	4240      	negs	r0, r0
34003058:	b004      	add	sp, #16
3400305a:	bd10      	pop	{r4, pc}
3400305c:	34014084 	.word	0x34014084

34003060 <bsp_i2c2_read_reg16>:

int32_t bsp_i2c2_read_reg16(uint16_t address, uint16_t reg, uint8_t *data, uint16_t length)
{
34003060:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (HAL_I2C_Mem_Read(&hi2c2, address, reg, I2C_MEMADD_SIZE_16BIT, data, length, 1000) != HAL_OK)
34003062:	f44f 747a 	mov.w	r4, #1000	@ 0x3e8
34003066:	9200      	str	r2, [sp, #0]
34003068:	e9cd 3401 	strd	r3, r4, [sp, #4]
3400306c:	460a      	mov	r2, r1
3400306e:	2302      	movs	r3, #2
34003070:	4601      	mov	r1, r0
34003072:	4804      	ldr	r0, [pc, #16]	@ (34003084 <bsp_i2c2_read_reg16+0x24>)
34003074:	f002 fb86 	bl	34005784 <HAL_I2C_Mem_Read>
34003078:	3800      	subs	r0, #0
3400307a:	bf18      	it	ne
3400307c:	2001      	movne	r0, #1
    {
        return -1;
    }

    return 0;
}
3400307e:	4240      	negs	r0, r0
34003080:	b004      	add	sp, #16
34003082:	bd10      	pop	{r4, pc}
34003084:	34014084 	.word	0x34014084

34003088 <bsp_bus_get_tick>:

int32_t bsp_bus_get_tick(void)
{
    return (int32_t)HAL_GetTick();
34003088:	f000 bb0e 	b.w	340036a8 <HAL_GetTick>

3400308c <bsp_lcd_get_pixel>:

    return 0;
}

static int32_t bsp_lcd_get_pixel(uint32_t instance, uint32_t x_pos, uint32_t y_pos, uint32_t *color)
{
3400308c:	b570      	push	{r4, r5, r6, lr}
    if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
3400308e:	2634      	movs	r6, #52	@ 0x34
34003090:	4d0d      	ldr	r5, [pc, #52]	@ (340030c8 <bsp_lcd_get_pixel+0x3c>)
34003092:	480e      	ldr	r0, [pc, #56]	@ (340030cc <bsp_lcd_get_pixel+0x40>)
34003094:	68ac      	ldr	r4, [r5, #8]
    {
        *color = *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (4 * ((bsp_lcd.x_size * y_pos) + x_pos)));
34003096:	682d      	ldr	r5, [r5, #0]
    if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34003098:	fb06 0004 	mla	r0, r6, r4, r0
3400309c:	6c84      	ldr	r4, [r0, #72]	@ 0x48
        *color = *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (4 * ((bsp_lcd.x_size * y_pos) + x_pos)));
3400309e:	fb05 1102 	mla	r1, r5, r2, r1
340030a2:	6dc0      	ldr	r0, [r0, #92]	@ 0x5c
    if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
340030a4:	b924      	cbnz	r4, 340030b0 <bsp_lcd_get_pixel+0x24>
        *color = *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (4 * ((bsp_lcd.x_size * y_pos) + x_pos)));
340030a6:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
    {
        *color = *(__IO uint16_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (2 * ((bsp_lcd.x_size * y_pos) + x_pos)));
    }

    return 0;
}
340030aa:	2000      	movs	r0, #0
        *color = *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (4 * ((bsp_lcd.x_size * y_pos) + x_pos)));
340030ac:	601a      	str	r2, [r3, #0]
}
340030ae:	bd70      	pop	{r4, r5, r6, pc}
    else if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
340030b0:	2c06      	cmp	r4, #6
        *color = *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (3 * ((bsp_lcd.x_size * y_pos) + x_pos)));
340030b2:	bf05      	ittet	eq
340030b4:	eb01 0141 	addeq.w	r1, r1, r1, lsl #1
340030b8:	580a      	ldreq	r2, [r1, r0]
        *color = *(__IO uint16_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (2 * ((bsp_lcd.x_size * y_pos) + x_pos)));
340030ba:	f830 2011 	ldrhne.w	r2, [r0, r1, lsl #1]
        *color = CONVERTARGB88882RGB888(*color);
340030be:	f022 427f 	biceq.w	r2, r2, #4278190080	@ 0xff000000
        *color = *(__IO uint16_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (2 * ((bsp_lcd.x_size * y_pos) + x_pos)));
340030c2:	bf18      	it	ne
340030c4:	b292      	uxthne	r2, r2
340030c6:	e7f0      	b.n	340030aa <bsp_lcd_get_pixel+0x1e>
340030c8:	3401438c 	.word	0x3401438c
340030cc:	340140d8 	.word	0x340140d8

340030d0 <bsp_lcd_set_pixel>:

static int32_t bsp_lcd_set_pixel(uint32_t instance, uint32_t x_pos, uint32_t y_pos, uint32_t color)
{
340030d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
340030d2:	2734      	movs	r7, #52	@ 0x34
340030d4:	4c1d      	ldr	r4, [pc, #116]	@ (3400314c <bsp_lcd_set_pixel+0x7c>)
340030d6:	4e1e      	ldr	r6, [pc, #120]	@ (34003150 <bsp_lcd_set_pixel+0x80>)
340030d8:	68a0      	ldr	r0, [r4, #8]
340030da:	fb07 6000 	mla	r0, r7, r0, r6
340030de:	f8d0 c048 	ldr.w	ip, [r0, #72]	@ 0x48
    {
        *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (4 * ((bsp_lcd.x_size * y_pos) + x_pos))) = color;
340030e2:	6dc5      	ldr	r5, [r0, #92]	@ 0x5c
340030e4:	6820      	ldr	r0, [r4, #0]
340030e6:	fb00 1002 	mla	r0, r0, r2, r1
    if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
340030ea:	f1bc 0f00 	cmp.w	ip, #0
340030ee:	d103      	bne.n	340030f8 <bsp_lcd_set_pixel+0x28>
        *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (4 * ((bsp_lcd.x_size * y_pos) + x_pos))) = color;
340030f0:	f845 3020 	str.w	r3, [r5, r0, lsl #2]
    {
        *(__IO uint16_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (2 * ((bsp_lcd.x_size * y_pos) + x_pos))) = (uint16_t)color;
    }

    return 0;
}
340030f4:	2000      	movs	r0, #0
340030f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
340030f8:	f1bc 0f06 	cmp.w	ip, #6
340030fc:	d122      	bne.n	34003144 <bsp_lcd_set_pixel+0x74>
        *(__IO uint8_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + ((3 * ((bsp_lcd.x_size * y_pos) + x_pos)) - 3)) = (uint8_t)color;
340030fe:	fa5f fc83 	uxtb.w	ip, r3
34003102:	eb00 0040 	add.w	r0, r0, r0, lsl #1
34003106:	3d03      	subs	r5, #3
34003108:	f800 c005 	strb.w	ip, [r0, r5]
        *(__IO uint8_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + ((3 * ((bsp_lcd.x_size * y_pos) + x_pos)) - 2)) = (uint8_t)(color >> 8);
3400310c:	68a5      	ldr	r5, [r4, #8]
3400310e:	6820      	ldr	r0, [r4, #0]
34003110:	fb07 6505 	mla	r5, r7, r5, r6
34003114:	fb00 1002 	mla	r0, r0, r2, r1
34003118:	6ded      	ldr	r5, [r5, #92]	@ 0x5c
3400311a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
3400311e:	f3c3 2c07 	ubfx	ip, r3, #8, #8
34003122:	3d02      	subs	r5, #2
34003124:	f800 c005 	strb.w	ip, [r0, r5]
        *(__IO uint8_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + ((3 * ((bsp_lcd.x_size * y_pos) + x_pos)) - 1)) = (uint8_t)(color >> 16);
34003128:	6820      	ldr	r0, [r4, #0]
3400312a:	f3c3 4307 	ubfx	r3, r3, #16, #8
3400312e:	fb00 1202 	mla	r2, r0, r2, r1
34003132:	68a1      	ldr	r1, [r4, #8]
34003134:	eb02 0242 	add.w	r2, r2, r2, lsl #1
34003138:	fb07 6601 	mla	r6, r7, r1, r6
3400313c:	6df1      	ldr	r1, [r6, #92]	@ 0x5c
3400313e:	3901      	subs	r1, #1
34003140:	5453      	strb	r3, [r2, r1]
34003142:	e7d7      	b.n	340030f4 <bsp_lcd_set_pixel+0x24>
        *(__IO uint16_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (2 * ((bsp_lcd.x_size * y_pos) + x_pos))) = (uint16_t)color;
34003144:	b29b      	uxth	r3, r3
34003146:	f825 3010 	strh.w	r3, [r5, r0, lsl #1]
3400314a:	e7d3      	b.n	340030f4 <bsp_lcd_set_pixel+0x24>
3400314c:	3401438c 	.word	0x3401438c
34003150:	340140d8 	.word	0x340140d8

34003154 <bsp_lcd_get_x_size>:

static int32_t bsp_lcd_get_x_size(uint32_t instance, uint32_t *x_size)
{
    *x_size = bsp_lcd.x_size;
34003154:	4b02      	ldr	r3, [pc, #8]	@ (34003160 <bsp_lcd_get_x_size+0xc>)

    return 0;
}
34003156:	2000      	movs	r0, #0
    *x_size = bsp_lcd.x_size;
34003158:	681b      	ldr	r3, [r3, #0]
3400315a:	600b      	str	r3, [r1, #0]
}
3400315c:	4770      	bx	lr
3400315e:	bf00      	nop
34003160:	3401438c 	.word	0x3401438c

34003164 <bsp_lcd_get_y_size>:

static int32_t bsp_lcd_get_y_size(uint32_t instance, uint32_t *y_size)
{
    *y_size = bsp_lcd.y_size;
34003164:	4b02      	ldr	r3, [pc, #8]	@ (34003170 <bsp_lcd_get_y_size+0xc>)

    return 0;
}
34003166:	2000      	movs	r0, #0
    *y_size = bsp_lcd.y_size;
34003168:	685b      	ldr	r3, [r3, #4]
3400316a:	600b      	str	r3, [r1, #0]
}
3400316c:	4770      	bx	lr
3400316e:	bf00      	nop
34003170:	3401438c 	.word	0x3401438c

34003174 <bsp_lcd_set_layer>:
    LTDC_LayerCfgTypeDef *layer_cfg;

    layer_cfg = &hltdc.LayerCfg[layer_index];

    bsp_lcd.active_layer = layer_index;
    bsp_lcd.x_size = layer_cfg->ImageWidth;
34003174:	2034      	movs	r0, #52	@ 0x34
    bsp_lcd.active_layer = layer_index;
34003176:	4b0f      	ldr	r3, [pc, #60]	@ (340031b4 <bsp_lcd_set_layer+0x40>)
    bsp_lcd.x_size = layer_cfg->ImageWidth;
34003178:	4a0f      	ldr	r2, [pc, #60]	@ (340031b8 <bsp_lcd_set_layer+0x44>)
    bsp_lcd.active_layer = layer_index;
3400317a:	6099      	str	r1, [r3, #8]
    bsp_lcd.x_size = layer_cfg->ImageWidth;
3400317c:	fb00 2101 	mla	r1, r0, r1, r2
34003180:	6e0a      	ldr	r2, [r1, #96]	@ 0x60
34003182:	601a      	str	r2, [r3, #0]
    bsp_lcd.y_size = layer_cfg->ImageHeight;
34003184:	6e4a      	ldr	r2, [r1, #100]	@ 0x64
34003186:	605a      	str	r2, [r3, #4]
    if (layer_cfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
34003188:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
3400318a:	2a04      	cmp	r2, #4
3400318c:	d00b      	beq.n	340031a6 <bsp_lcd_set_layer+0x32>
    {
        bsp_lcd.bpp_factor = 2;
        bsp_lcd.pixel_format = LCD_PIXEL_FORMAT_RGB565;
    }
    else if (layer_cfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444)
3400318e:	2a08      	cmp	r2, #8
34003190:	d00c      	beq.n	340031ac <bsp_lcd_set_layer+0x38>
    {
        bsp_lcd.bpp_factor = 2;
        bsp_lcd.pixel_format = LCD_PIXEL_FORMAT_ARGB4444;
    }
    else if (layer_cfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34003192:	2a06      	cmp	r2, #6
34003194:	bf0b      	itete	eq
34003196:	2203      	moveq	r2, #3
34003198:	2204      	movne	r2, #4
3400319a:	2101      	moveq	r1, #1
3400319c:	2100      	movne	r1, #0
        bsp_lcd.bpp_factor = 4;
        bsp_lcd.pixel_format = LCD_PIXEL_FORMAT_ARGB8888;
    }

    return 0;
}
3400319e:	2000      	movs	r0, #0
        bsp_lcd.pixel_format = LCD_PIXEL_FORMAT_RGB565;
340031a0:	e9c3 1203 	strd	r1, r2, [r3, #12]
}
340031a4:	4770      	bx	lr
340031a6:	2202      	movs	r2, #2
340031a8:	4611      	mov	r1, r2
340031aa:	e7f8      	b.n	3400319e <bsp_lcd_set_layer+0x2a>
340031ac:	2202      	movs	r2, #2
340031ae:	2104      	movs	r1, #4
340031b0:	e7f5      	b.n	3400319e <bsp_lcd_set_layer+0x2a>
340031b2:	bf00      	nop
340031b4:	3401438c 	.word	0x3401438c
340031b8:	340140d8 	.word	0x340140d8

340031bc <bsp_lcd_get_format>:

static int32_t bsp_lcd_get_format(uint32_t instance, uint32_t *pixel_format)
{
    *pixel_format =  bsp_lcd.pixel_format;
340031bc:	4b02      	ldr	r3, [pc, #8]	@ (340031c8 <bsp_lcd_get_format+0xc>)

    return 0;
}
340031be:	2000      	movs	r0, #0
    *pixel_format =  bsp_lcd.pixel_format;
340031c0:	68db      	ldr	r3, [r3, #12]
340031c2:	600b      	str	r3, [r1, #0]
}
340031c4:	4770      	bx	lr
340031c6:	bf00      	nop
340031c8:	3401438c 	.word	0x3401438c

340031cc <bsp_lcd_fill_buffer>:
        }
    }
}

static void bsp_lcd_fill_buffer(uint32_t *destination, uint32_t x_size, uint32_t y_size, uint32_t offset, uint32_t color)
{
340031cc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
340031d0:	4690      	mov	r8, r2
    uint32_t output_color_mode;
    uint32_t input_color;

    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
340031d2:	4a30      	ldr	r2, [pc, #192]	@ (34003294 <bsp_lcd_fill_buffer+0xc8>)
{
340031d4:	460f      	mov	r7, r1
    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
340031d6:	68d1      	ldr	r1, [r2, #12]
{
340031d8:	4606      	mov	r6, r0
    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
340031da:	2902      	cmp	r1, #2
{
340031dc:	9c08      	ldr	r4, [sp, #32]
    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
340031de:	d135      	bne.n	3400324c <bsp_lcd_fill_buffer+0x80>
    {
        output_color_mode = DMA2D_OUTPUT_RGB565;
        input_color = CONVERTRGB5652ARGB8888(color);
340031e0:	f240 1c03 	movw	ip, #259	@ 0x103
340031e4:	f240 200f 	movw	r0, #527	@ 0x20f
340031e8:	f3c4 1545 	ubfx	r5, r4, #5, #6
340031ec:	f3c4 22c4 	ubfx	r2, r4, #11, #5
340031f0:	fb0c f505 	mul.w	r5, ip, r5
340031f4:	4342      	muls	r2, r0
340031f6:	f004 041f 	and.w	r4, r4, #31
340031fa:	4344      	muls	r4, r0
340031fc:	3521      	adds	r5, #33	@ 0x21
340031fe:	3217      	adds	r2, #23
34003200:	09ad      	lsrs	r5, r5, #6
34003202:	0992      	lsrs	r2, r2, #6
34003204:	022d      	lsls	r5, r5, #8
34003206:	3417      	adds	r4, #23
34003208:	ea45 4502 	orr.w	r5, r5, r2, lsl #16
3400320c:	ea45 1594 	orr.w	r5, r5, r4, lsr #6
34003210:	f045 447f 	orr.w	r4, r5, #4278190080	@ 0xff000000
        output_color_mode = DMA2D_OUTPUT_ARGB8888;
        input_color = color;
    }

    hdma2d.Instance = DMA2D;
    hdma2d.Init.Mode = DMA2D_R2M;
34003214:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
    hdma2d.Instance = DMA2D;
34003218:	4d1f      	ldr	r5, [pc, #124]	@ (34003298 <bsp_lcd_fill_buffer+0xcc>)
    hdma2d.Init.Mode = DMA2D_R2M;
3400321a:	4820      	ldr	r0, [pc, #128]	@ (3400329c <bsp_lcd_fill_buffer+0xd0>)
    hdma2d.Init.ColorMode = output_color_mode;
    hdma2d.Init.OutputOffset = offset;
3400321c:	e9c5 1302 	strd	r1, r3, [r5, #8]
    hdma2d.Init.Mode = DMA2D_R2M;
34003220:	e9c5 0200 	strd	r0, r2, [r5]
    if (HAL_DMA2D_Init(&hdma2d) == HAL_OK)
34003224:	4628      	mov	r0, r5
34003226:	f001 fd32 	bl	34004c8e <HAL_DMA2D_Init>
3400322a:	bb78      	cbnz	r0, 3400328c <bsp_lcd_fill_buffer+0xc0>
    {
        if (HAL_DMA2D_Start(&hdma2d, input_color, (uint32_t)destination, x_size, y_size) == HAL_OK)
3400322c:	463b      	mov	r3, r7
3400322e:	4632      	mov	r2, r6
34003230:	4621      	mov	r1, r4
34003232:	4628      	mov	r0, r5
34003234:	f8cd 8000 	str.w	r8, [sp]
34003238:	f001 fd66 	bl	34004d08 <HAL_DMA2D_Start>
3400323c:	bb30      	cbnz	r0, 3400328c <bsp_lcd_fill_buffer+0xc0>
        {
            HAL_DMA2D_PollForTransfer(&hdma2d, 50);
3400323e:	2132      	movs	r1, #50	@ 0x32
34003240:	4628      	mov	r0, r5
        }
    }
}
34003242:	b002      	add	sp, #8
34003244:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            HAL_DMA2D_PollForTransfer(&hdma2d, 50);
34003248:	f001 bd78 	b.w	34004d3c <HAL_DMA2D_PollForTransfer>
    else if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_ARGB4444)
3400324c:	2904      	cmp	r1, #4
3400324e:	d117      	bne.n	34003280 <bsp_lcd_fill_buffer+0xb4>
        input_color = CONVERTARGB44442ARGB8888(color);
34003250:	f3c4 3203 	ubfx	r2, r4, #12, #4
34003254:	eb02 1002 	add.w	r0, r2, r2, lsl #4
34003258:	f3c4 2203 	ubfx	r2, r4, #8, #4
3400325c:	eb02 1202 	add.w	r2, r2, r2, lsl #4
34003260:	0412      	lsls	r2, r2, #16
34003262:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
34003266:	f004 000f 	and.w	r0, r4, #15
3400326a:	eb00 1000 	add.w	r0, r0, r0, lsl #4
3400326e:	4302      	orrs	r2, r0
34003270:	f3c4 1003 	ubfx	r0, r4, #4, #4
34003274:	f004 04f0 	and.w	r4, r4, #240	@ 0xf0
34003278:	4404      	add	r4, r0
3400327a:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
3400327e:	e7c9      	b.n	34003214 <bsp_lcd_fill_buffer+0x48>
    else if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB888)
34003280:	2901      	cmp	r1, #1
        output_color_mode = DMA2D_OUTPUT_ARGB8888;
34003282:	bf14      	ite	ne
34003284:	2100      	movne	r1, #0
        input_color = CONVERTRGB8882ARGB8888(color);
34003286:	f044 447f 	orreq.w	r4, r4, #4278190080	@ 0xff000000
3400328a:	e7c3      	b.n	34003214 <bsp_lcd_fill_buffer+0x48>
}
3400328c:	b002      	add	sp, #8
3400328e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34003292:	bf00      	nop
34003294:	3401438c 	.word	0x3401438c
34003298:	3401401c 	.word	0x3401401c
3400329c:	58021000 	.word	0x58021000

340032a0 <bsp_lcd_fill_rect>:
{
340032a0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340032a2:	4d0c      	ldr	r5, [pc, #48]	@ (340032d4 <bsp_lcd_fill_rect+0x34>)
{
340032a4:	460c      	mov	r4, r1
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340032a6:	692e      	ldr	r6, [r5, #16]
340032a8:	68a8      	ldr	r0, [r5, #8]
{
340032aa:	4619      	mov	r1, r3
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340032ac:	682b      	ldr	r3, [r5, #0]
340032ae:	2534      	movs	r5, #52	@ 0x34
340032b0:	fb02 4403 	mla	r4, r2, r3, r4
340032b4:	4a08      	ldr	r2, [pc, #32]	@ (340032d8 <bsp_lcd_fill_rect+0x38>)
    bsp_lcd_fill_buffer((uint32_t *)address, width, height, bsp_lcd.x_size - width, color);
340032b6:	1a5b      	subs	r3, r3, r1
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340032b8:	fb05 2200 	mla	r2, r5, r0, r2
340032bc:	6dd0      	ldr	r0, [r2, #92]	@ 0x5c
    bsp_lcd_fill_buffer((uint32_t *)address, width, height, bsp_lcd.x_size - width, color);
340032be:	9a07      	ldr	r2, [sp, #28]
340032c0:	fb06 0004 	mla	r0, r6, r4, r0
340032c4:	9200      	str	r2, [sp, #0]
340032c6:	9a06      	ldr	r2, [sp, #24]
340032c8:	f7ff ff80 	bl	340031cc <bsp_lcd_fill_buffer>
}
340032cc:	2000      	movs	r0, #0
340032ce:	b002      	add	sp, #8
340032d0:	bd70      	pop	{r4, r5, r6, pc}
340032d2:	bf00      	nop
340032d4:	3401438c 	.word	0x3401438c
340032d8:	340140d8 	.word	0x340140d8

340032dc <bsp_lcd_draw_v_line>:
{
340032dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340032de:	4d0c      	ldr	r5, [pc, #48]	@ (34003310 <bsp_lcd_draw_v_line+0x34>)
{
340032e0:	4614      	mov	r4, r2
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340032e2:	692e      	ldr	r6, [r5, #16]
340032e4:	68a8      	ldr	r0, [r5, #8]
{
340032e6:	461a      	mov	r2, r3
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340032e8:	682b      	ldr	r3, [r5, #0]
340032ea:	2534      	movs	r5, #52	@ 0x34
340032ec:	fb04 1403 	mla	r4, r4, r3, r1
340032f0:	4908      	ldr	r1, [pc, #32]	@ (34003314 <bsp_lcd_draw_v_line+0x38>)
    bsp_lcd_fill_buffer((uint32_t *)address, 1, length, bsp_lcd.x_size - 1, color);
340032f2:	3b01      	subs	r3, #1
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340032f4:	fb05 1100 	mla	r1, r5, r0, r1
340032f8:	6dc8      	ldr	r0, [r1, #92]	@ 0x5c
    bsp_lcd_fill_buffer((uint32_t *)address, 1, length, bsp_lcd.x_size - 1, color);
340032fa:	9906      	ldr	r1, [sp, #24]
340032fc:	fb06 0004 	mla	r0, r6, r4, r0
34003300:	9100      	str	r1, [sp, #0]
34003302:	2101      	movs	r1, #1
34003304:	f7ff ff62 	bl	340031cc <bsp_lcd_fill_buffer>
}
34003308:	2000      	movs	r0, #0
3400330a:	b002      	add	sp, #8
3400330c:	bd70      	pop	{r4, r5, r6, pc}
3400330e:	bf00      	nop
34003310:	3401438c 	.word	0x3401438c
34003314:	340140d8 	.word	0x340140d8

34003318 <bsp_lcd_draw_h_line>:
{
34003318:	b537      	push	{r0, r1, r2, r4, r5, lr}
3400331a:	460c      	mov	r4, r1
3400331c:	4619      	mov	r1, r3
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
3400331e:	4b0b      	ldr	r3, [pc, #44]	@ (3400334c <bsp_lcd_draw_h_line+0x34>)
34003320:	6818      	ldr	r0, [r3, #0]
34003322:	691d      	ldr	r5, [r3, #16]
34003324:	fb00 4402 	mla	r4, r0, r2, r4
34003328:	2034      	movs	r0, #52	@ 0x34
3400332a:	689a      	ldr	r2, [r3, #8]
3400332c:	4b08      	ldr	r3, [pc, #32]	@ (34003350 <bsp_lcd_draw_h_line+0x38>)
3400332e:	fb00 3302 	mla	r3, r0, r2, r3
34003332:	6dd8      	ldr	r0, [r3, #92]	@ 0x5c
    bsp_lcd_fill_buffer((uint32_t *)address, length, 1, 0, color);
34003334:	9b06      	ldr	r3, [sp, #24]
34003336:	fb05 0004 	mla	r0, r5, r4, r0
3400333a:	9300      	str	r3, [sp, #0]
3400333c:	2201      	movs	r2, #1
3400333e:	2300      	movs	r3, #0
34003340:	f7ff ff44 	bl	340031cc <bsp_lcd_fill_buffer>
}
34003344:	2000      	movs	r0, #0
34003346:	b003      	add	sp, #12
34003348:	bd30      	pop	{r4, r5, pc}
3400334a:	bf00      	nop
3400334c:	3401438c 	.word	0x3401438c
34003350:	340140d8 	.word	0x340140d8

34003354 <bsp_lcd_convert_line_to_rgb>:
{
34003354:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34003356:	4617      	mov	r7, r2
    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
34003358:	4a19      	ldr	r2, [pc, #100]	@ (340033c0 <bsp_lcd_convert_line_to_rgb+0x6c>)
{
3400335a:	460e      	mov	r6, r1
3400335c:	68d4      	ldr	r4, [r2, #12]
    hdma2d.Init.Mode = DMA2D_M2M_PFC;
3400335e:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
34003362:	3c01      	subs	r4, #1
34003364:	2c03      	cmp	r4, #3
    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
34003366:	bf8c      	ite	hi
34003368:	2200      	movhi	r2, #0
3400336a:	4a16      	ldrls	r2, [pc, #88]	@ (340033c4 <bsp_lcd_convert_line_to_rgb+0x70>)
{
3400336c:	4605      	mov	r5, r0
3400336e:	bf98      	it	ls
34003370:	5d12      	ldrbls	r2, [r2, r4]
    hdma2d.Init.Mode = DMA2D_M2M_PFC;
34003372:	4815      	ldr	r0, [pc, #84]	@ (340033c8 <bsp_lcd_convert_line_to_rgb+0x74>)
    hdma2d.Instance = DMA2D;
34003374:	4c15      	ldr	r4, [pc, #84]	@ (340033cc <bsp_lcd_convert_line_to_rgb+0x78>)
    hdma2d.Init.Mode = DMA2D_M2M_PFC;
34003376:	e9c4 0100 	strd	r0, r1, [r4]
    hdma2d.Init.ColorMode = output_color_mode;
3400337a:	60a2      	str	r2, [r4, #8]
    hdma2d.LayerCfg[DMA2D_FOREGROUND_LAYER].InputAlpha = 0xFF;
3400337c:	21ff      	movs	r1, #255	@ 0xff
    hdma2d.Init.OutputOffset = 0;
3400337e:	2200      	movs	r2, #0
    if (HAL_DMA2D_Init(&hdma2d) == HAL_OK)
34003380:	4620      	mov	r0, r4
    hdma2d.LayerCfg[DMA2D_FOREGROUND_LAYER].InputOffset = 0;
34003382:	e9c4 2311 	strd	r2, r3, [r4, #68]	@ 0x44
    hdma2d.Init.OutputOffset = 0;
34003386:	60e2      	str	r2, [r4, #12]
    hdma2d.LayerCfg[DMA2D_FOREGROUND_LAYER].AlphaMode = DMA2D_NO_MODIF_ALPHA;
34003388:	64e2      	str	r2, [r4, #76]	@ 0x4c
    hdma2d.LayerCfg[DMA2D_FOREGROUND_LAYER].InputAlpha = 0xFF;
3400338a:	6521      	str	r1, [r4, #80]	@ 0x50
    if (HAL_DMA2D_Init(&hdma2d) == HAL_OK)
3400338c:	f001 fc7f 	bl	34004c8e <HAL_DMA2D_Init>
34003390:	b9a0      	cbnz	r0, 340033bc <bsp_lcd_convert_line_to_rgb+0x68>
        if (HAL_DMA2D_ConfigLayer(&hdma2d, DMA2D_FOREGROUND_LAYER) == HAL_OK)
34003392:	2101      	movs	r1, #1
34003394:	4620      	mov	r0, r4
34003396:	f001 fd4f 	bl	34004e38 <HAL_DMA2D_ConfigLayer>
3400339a:	b978      	cbnz	r0, 340033bc <bsp_lcd_convert_line_to_rgb+0x68>
            if (HAL_DMA2D_Start(&hdma2d, (uint32_t)source, (uint32_t)destination, x_size, DMA2D_FOREGROUND_LAYER) == HAL_OK)
3400339c:	2301      	movs	r3, #1
3400339e:	4632      	mov	r2, r6
340033a0:	9300      	str	r3, [sp, #0]
340033a2:	4629      	mov	r1, r5
340033a4:	463b      	mov	r3, r7
340033a6:	4620      	mov	r0, r4
340033a8:	f001 fcae 	bl	34004d08 <HAL_DMA2D_Start>
340033ac:	b930      	cbnz	r0, 340033bc <bsp_lcd_convert_line_to_rgb+0x68>
                HAL_DMA2D_PollForTransfer(&hdma2d, 50);
340033ae:	2132      	movs	r1, #50	@ 0x32
340033b0:	4620      	mov	r0, r4
}
340033b2:	b003      	add	sp, #12
340033b4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                HAL_DMA2D_PollForTransfer(&hdma2d, 50);
340033b8:	f001 bcc0 	b.w	34004d3c <HAL_DMA2D_PollForTransfer>
}
340033bc:	b003      	add	sp, #12
340033be:	bdf0      	pop	{r4, r5, r6, r7, pc}
340033c0:	3401438c 	.word	0x3401438c
340033c4:	34010388 	.word	0x34010388
340033c8:	58021000 	.word	0x58021000
340033cc:	3401401c 	.word	0x3401401c

340033d0 <bsp_lcd_fill_rgb_rect>:
{
340033d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
340033d4:	4e28      	ldr	r6, [pc, #160]	@ (34003478 <bsp_lcd_fill_rgb_rect+0xa8>)
{
340033d6:	461c      	mov	r4, r3
340033d8:	68f3      	ldr	r3, [r6, #12]
340033da:	4615      	mov	r5, r2
340033dc:	3b01      	subs	r3, #1
340033de:	2b03      	cmp	r3, #3
340033e0:	4688      	mov	r8, r1
    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
340033e2:	bf88      	it	hi
340033e4:	2300      	movhi	r3, #0
        address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * (y_pos + i)) + x_pos));
340033e6:	f04f 0a34 	mov.w	sl, #52	@ 0x34
340033ea:	bf98      	it	ls
340033ec:	4a23      	ldrls	r2, [pc, #140]	@ (3400347c <bsp_lcd_fill_rgb_rect+0xac>)
340033ee:	9f0d      	ldr	r7, [sp, #52]	@ 0x34
340033f0:	bf98      	it	ls
340033f2:	5cd3      	ldrbls	r3, [r2, r3]
340033f4:	f8df 9088 	ldr.w	r9, [pc, #136]	@ 34003480 <bsp_lcd_fill_rgb_rect+0xb0>
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340033f8:	f8df b088 	ldr.w	fp, [pc, #136]	@ 34003484 <bsp_lcd_fill_rgb_rect+0xb4>
340033fc:	442f      	add	r7, r5
    for (i = 0; i < height; i++)
340033fe:	42bd      	cmp	r5, r7
34003400:	d103      	bne.n	3400340a <bsp_lcd_fill_rgb_rect+0x3a>
}
34003402:	2000      	movs	r0, #0
34003404:	b003      	add	sp, #12
34003406:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * (y_pos + i)) + x_pos));
3400340a:	68b1      	ldr	r1, [r6, #8]
3400340c:	6830      	ldr	r0, [r6, #0]
3400340e:	fb0a 9101 	mla	r1, sl, r1, r9
34003412:	fb05 8c00 	mla	ip, r5, r0, r8
34003416:	6932      	ldr	r2, [r6, #16]
34003418:	6dc9      	ldr	r1, [r1, #92]	@ 0x5c
3400341a:	fb02 110c 	mla	r1, r2, ip, r1
        SCB_CleanDCache_by_Addr((uint32_t *)data, bsp_lcd.bpp_factor * bsp_lcd.x_size);
3400341e:	4342      	muls	r2, r0
    if ( dsize > 0 ) {
34003420:	2a00      	cmp	r2, #0
34003422:	dd1d      	ble.n	34003460 <bsp_lcd_fill_rgb_rect+0x90>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34003424:	f004 001f 	and.w	r0, r4, #31
34003428:	4410      	add	r0, r2
  __ASM volatile ("dsb 0xF":::"memory");
3400342a:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
3400342e:	43e2      	mvns	r2, r4
34003430:	eb04 0e00 	add.w	lr, r4, r0
34003434:	4472      	add	r2, lr
34003436:	3820      	subs	r0, #32
34003438:	0952      	lsrs	r2, r2, #5
3400343a:	3020      	adds	r0, #32
3400343c:	f102 0e01 	add.w	lr, r2, #1
34003440:	bfd8      	it	le
34003442:	f04f 0e01 	movle.w	lr, #1
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
34003446:	46a4      	mov	ip, r4
34003448:	f04e e001 	dls	lr, lr
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
3400344c:	f8cb c268 	str.w	ip, [fp, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
34003450:	f10c 0c20 	add.w	ip, ip, #32
      } while ( op_size > 0 );
34003454:	f00f c007 	le	lr, 3400344c <bsp_lcd_fill_rgb_rect+0x7c>
34003458:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3400345c:	f3bf 8f6f 	isb	sy
        bsp_lcd_convert_line_to_rgb((uint32_t *)data, (uint32_t *)address, width, input_color_mode);
34003460:	4620      	mov	r0, r4
34003462:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
34003464:	9301      	str	r3, [sp, #4]
34003466:	f7ff ff75 	bl	34003354 <bsp_lcd_convert_line_to_rgb>
        data += bsp_lcd.bpp_factor * width;
3400346a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
3400346c:	6932      	ldr	r2, [r6, #16]
3400346e:	3501      	adds	r5, #1
34003470:	fb02 4403 	mla	r4, r2, r3, r4
    for (i = 0; i < height; i++)
34003474:	9b01      	ldr	r3, [sp, #4]
34003476:	e7c2      	b.n	340033fe <bsp_lcd_fill_rgb_rect+0x2e>
34003478:	3401438c 	.word	0x3401438c
3400347c:	34010388 	.word	0x34010388
34003480:	340140d8 	.word	0x340140d8
34003484:	e000ed00 	.word	0xe000ed00

34003488 <bsp_lcd_draw_bitmap>:
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
34003488:	f04f 0c34 	mov.w	ip, #52	@ 0x34
{
3400348c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
34003490:	4f1f      	ldr	r7, [pc, #124]	@ (34003510 <bsp_lcd_draw_bitmap+0x88>)
    bit_pixel = (uint32_t)bitmap[28] + ((uint32_t)bitmap[29] << 8);
34003492:	8b9d      	ldrh	r5, [r3, #28]
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
34003494:	683c      	ldr	r4, [r7, #0]
34003496:	68be      	ldr	r6, [r7, #8]
34003498:	fb04 1102 	mla	r1, r4, r2, r1
3400349c:	4a1d      	ldr	r2, [pc, #116]	@ (34003514 <bsp_lcd_draw_bitmap+0x8c>)
3400349e:	693c      	ldr	r4, [r7, #16]
340034a0:	fb0c 2206 	mla	r2, ip, r6, r2
340034a4:	6dd6      	ldr	r6, [r2, #92]	@ 0x5c
    if ((bit_pixel / 8) == 4)
340034a6:	f1a5 0220 	sub.w	r2, r5, #32
340034aa:	2a07      	cmp	r2, #7
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340034ac:	fb04 6601 	mla	r6, r4, r1, r6
    index = (uint32_t)bitmap[10] + ((uint32_t)bitmap[11] << 8) + ((uint32_t)bitmap[12] << 16) + ((uint32_t)bitmap[13] << 24);
340034b0:	f8d3 000a 	ldr.w	r0, [r3, #10]
    width = (uint32_t)bitmap[18] + ((uint32_t)bitmap[19] << 8) + ((uint32_t)bitmap[20] << 16) + ((uint32_t)bitmap[21] << 24);
340034b4:	f8d3 a012 	ldr.w	sl, [r3, #18]
    height = (uint32_t)bitmap[22] + ((uint32_t)bitmap[23] << 8) + ((uint32_t)bitmap[24] << 16) + ((uint32_t)bitmap[25] << 24);
340034b8:	f8d3 9016 	ldr.w	r9, [r3, #22]
    if ((bit_pixel / 8) == 4)
340034bc:	d917      	bls.n	340034ee <bsp_lcd_draw_bitmap+0x66>
    else if ((bit_pixel / 8) == 2)
340034be:	f1a5 0210 	sub.w	r2, r5, #16
        input_color_mode = DMA2D_INPUT_RGB565;
340034c2:	2a07      	cmp	r2, #7
340034c4:	bf8c      	ite	hi
340034c6:	f04f 0b01 	movhi.w	fp, #1
340034ca:	f04f 0b02 	movls.w	fp, #2
    for(index=0; index < height; index++)
340034ce:	f04f 0800 	mov.w	r8, #0
    bitmap += index + (width * (height - 1) * (bit_pixel / 8));
340034d2:	08ed      	lsrs	r5, r5, #3
340034d4:	fb0a f505 	mul.w	r5, sl, r5
340034d8:	f109 32ff 	add.w	r2, r9, #4294967295
340034dc:	fb05 0002 	mla	r0, r5, r2, r0
        bitmap -= width * (bit_pixel / 8);
340034e0:	426d      	negs	r5, r5
    bitmap += index + (width * (height - 1) * (bit_pixel / 8));
340034e2:	181c      	adds	r4, r3, r0
    for(index=0; index < height; index++)
340034e4:	45c8      	cmp	r8, r9
340034e6:	d105      	bne.n	340034f4 <bsp_lcd_draw_bitmap+0x6c>
}
340034e8:	2000      	movs	r0, #0
340034ea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        input_color_mode = DMA2D_INPUT_ARGB8888;
340034ee:	f04f 0b00 	mov.w	fp, #0
340034f2:	e7ec      	b.n	340034ce <bsp_lcd_draw_bitmap+0x46>
        bsp_lcd_convert_line_to_rgb((uint32_t *)bitmap, (uint32_t *)address, width, input_color_mode);
340034f4:	4631      	mov	r1, r6
340034f6:	465b      	mov	r3, fp
340034f8:	4620      	mov	r0, r4
340034fa:	4652      	mov	r2, sl
340034fc:	f7ff ff2a 	bl	34003354 <bsp_lcd_convert_line_to_rgb>
        address += (bsp_lcd.bpp_factor * bsp_lcd.x_size);
34003500:	693b      	ldr	r3, [r7, #16]
34003502:	6839      	ldr	r1, [r7, #0]
        bitmap -= width * (bit_pixel / 8);
34003504:	442c      	add	r4, r5
        address += (bsp_lcd.bpp_factor * bsp_lcd.x_size);
34003506:	fb01 6603 	mla	r6, r1, r3, r6
    for(index=0; index < height; index++)
3400350a:	f108 0801 	add.w	r8, r8, #1
3400350e:	e7e9      	b.n	340034e4 <bsp_lcd_draw_bitmap+0x5c>
34003510:	3401438c 	.word	0x3401438c
34003514:	340140d8 	.word	0x340140d8

34003518 <bsp_lcd_config_layer>:
{
34003518:	b570      	push	{r4, r5, r6, lr}
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
3400351a:	26ff      	movs	r6, #255	@ 0xff
{
3400351c:	460c      	mov	r4, r1
3400351e:	b08e      	sub	sp, #56	@ 0x38
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
34003520:	2224      	movs	r2, #36	@ 0x24
34003522:	2100      	movs	r1, #0
{
34003524:	4605      	mov	r5, r0
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
34003526:	a805      	add	r0, sp, #20
34003528:	f00a f9f4 	bl	3400d914 <memset>
3400352c:	f44f 6ec0 	mov.w	lr, #1536	@ 0x600
34003530:	9606      	str	r6, [sp, #24]
34003532:	2607      	movs	r6, #7
        .WindowY0 = layer_config->y0,
34003534:	68a2      	ldr	r2, [r4, #8]
        .WindowY1 = layer_config->y1,
34003536:	68e3      	ldr	r3, [r4, #12]
        .WindowX0 = layer_config->x0,
34003538:	6820      	ldr	r0, [r4, #0]
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
3400353a:	9304      	str	r3, [sp, #16]
        .ImageHeight = layer_config->y1 - layer_config->y0,
3400353c:	1a9b      	subs	r3, r3, r2
        .WindowX1 = layer_config->x1,
3400353e:	6861      	ldr	r1, [r4, #4]
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
34003540:	930c      	str	r3, [sp, #48]	@ 0x30
    if (layer_config->pixel_format == LCD_PIXEL_FORMAT_RGB565)
34003542:	6923      	ldr	r3, [r4, #16]
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
34003544:	e9cd e608 	strd	lr, r6, [sp, #32]
34003548:	6966      	ldr	r6, [r4, #20]
3400354a:	9102      	str	r1, [sp, #8]
    if (layer_config->pixel_format == LCD_PIXEL_FORMAT_RGB565)
3400354c:	2b02      	cmp	r3, #2
        .ImageWidth = layer_config->x1 - layer_config->x0,
3400354e:	eba1 0100 	sub.w	r1, r1, r0
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
34003552:	9001      	str	r0, [sp, #4]
34003554:	9203      	str	r2, [sp, #12]
34003556:	960a      	str	r6, [sp, #40]	@ 0x28
34003558:	910b      	str	r1, [sp, #44]	@ 0x2c
    if (layer_config->pixel_format == LCD_PIXEL_FORMAT_RGB565)
3400355a:	d10a      	bne.n	34003572 <bsp_lcd_config_layer+0x5a>
        ltdc_layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
3400355c:	2304      	movs	r3, #4
        ltdc_layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
3400355e:	9305      	str	r3, [sp, #20]
    HAL_LTDC_ConfigLayer(&hltdc, &ltdc_layer_cfg, layer_id);
34003560:	1e6b      	subs	r3, r5, #1
34003562:	425a      	negs	r2, r3
34003564:	415a      	adcs	r2, r3
34003566:	a901      	add	r1, sp, #4
34003568:	4806      	ldr	r0, [pc, #24]	@ (34003584 <bsp_lcd_config_layer+0x6c>)
3400356a:	f002 fd09 	bl	34005f80 <HAL_LTDC_ConfigLayer>
}
3400356e:	b00e      	add	sp, #56	@ 0x38
34003570:	bd70      	pop	{r4, r5, r6, pc}
    else if (layer_config->pixel_format == LCD_PIXEL_FORMAT_ARGB4444)
34003572:	2b04      	cmp	r3, #4
34003574:	d101      	bne.n	3400357a <bsp_lcd_config_layer+0x62>
        ltdc_layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
34003576:	2308      	movs	r3, #8
34003578:	e7f1      	b.n	3400355e <bsp_lcd_config_layer+0x46>
    else if (layer_config->pixel_format == LCD_PIXEL_FORMAT_ARGB8888)
3400357a:	2b00      	cmp	r3, #0
3400357c:	d0f0      	beq.n	34003560 <bsp_lcd_config_layer+0x48>
        ltdc_layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
3400357e:	2306      	movs	r3, #6
34003580:	e7ed      	b.n	3400355e <bsp_lcd_config_layer+0x46>
34003582:	bf00      	nop
34003584:	340140d8 	.word	0x340140d8

34003588 <bsp_lcd_init_ex>:
{
34003588:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (pixel_format == LCD_PIXEL_FORMAT_RGB565)
3400358c:	2802      	cmp	r0, #2
{
3400358e:	4604      	mov	r4, r0
34003590:	4688      	mov	r8, r1
34003592:	4617      	mov	r7, r2
34003594:	4603      	mov	r3, r0
34003596:	b086      	sub	sp, #24
    if (pixel_format == LCD_PIXEL_FORMAT_RGB565)
34003598:	d005      	beq.n	340035a6 <bsp_lcd_init_ex+0x1e>
    else if (pixel_format == LCD_PIXEL_FORMAT_RGB888)
3400359a:	2801      	cmp	r0, #1
3400359c:	d021      	beq.n	340035e2 <bsp_lcd_init_ex+0x5a>
    else if (pixel_format == LCD_PIXEL_FORMAT_ARGB4444)
3400359e:	2804      	cmp	r0, #4
340035a0:	bf0c      	ite	eq
340035a2:	2302      	moveq	r3, #2
340035a4:	2304      	movne	r3, #4
    layer_cfg.x0 = 0;
340035a6:	2600      	movs	r6, #0
        bsp_lcd.bpp_factor = 2;
340035a8:	4d0f      	ldr	r5, [pc, #60]	@ (340035e8 <bsp_lcd_init_ex+0x60>)
    bsp_lcd.pixel_format = pixel_format;
340035aa:	e9c5 4303 	strd	r4, r3, [r5, #12]
    bsp_lcd.y_size = height;
340035ae:	e9c5 8700 	strd	r8, r7, [r5]
    MX_DMA2D_Init();
340035b2:	f7fe fbff 	bl	34001db4 <MX_DMA2D_Init>
    MX_LTDC_Init();
340035b6:	f7fe fd4d 	bl	34002054 <MX_LTDC_Init>
    layer_cfg.address = (uint32_t)lcd_framebuffer;
340035ba:	4b0c      	ldr	r3, [pc, #48]	@ (340035ec <bsp_lcd_init_ex+0x64>)
    bsp_lcd_config_layer(0, &layer_cfg);
340035bc:	4669      	mov	r1, sp
340035be:	4630      	mov	r0, r6
    layer_cfg.x1 = width;
340035c0:	e9cd 8601 	strd	r8, r6, [sp, #4]
    layer_cfg.pixel_format = pixel_format;
340035c4:	e9cd 7403 	strd	r7, r4, [sp, #12]
    layer_cfg.x0 = 0;
340035c8:	9600      	str	r6, [sp, #0]
    layer_cfg.address = (uint32_t)lcd_framebuffer;
340035ca:	9305      	str	r3, [sp, #20]
    bsp_lcd_config_layer(0, &layer_cfg);
340035cc:	f7ff ffa4 	bl	34003518 <bsp_lcd_config_layer>
        HAL_GPIO_WritePin(BSP_LCD_BL_GPIO, BSP_LCD_BL_PIN, GPIO_PIN_SET);
340035d0:	2201      	movs	r2, #1
340035d2:	2108      	movs	r1, #8
340035d4:	4806      	ldr	r0, [pc, #24]	@ (340035f0 <bsp_lcd_init_ex+0x68>)
    bsp_lcd.active_layer = 0;
340035d6:	60ae      	str	r6, [r5, #8]
}
340035d8:	b006      	add	sp, #24
340035da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        HAL_GPIO_WritePin(BSP_LCD_BL_GPIO, BSP_LCD_BL_PIN, GPIO_PIN_SET);
340035de:	f001 be29 	b.w	34005234 <HAL_GPIO_WritePin>
340035e2:	2303      	movs	r3, #3
340035e4:	e7df      	b.n	340035a6 <bsp_lcd_init_ex+0x1e>
340035e6:	bf00      	nop
340035e8:	3401438c 	.word	0x3401438c
340035ec:	340143a0 	.word	0x340143a0
340035f0:	56020000 	.word	0x56020000

340035f4 <bsp_lcd_init>:
    bsp_lcd_init_ex(LCD_PIXEL_FORMAT_RGB565, BSP_LCD_WIDTH, BSP_LCD_HEIGHT);
340035f4:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
340035f8:	f44f 7148 	mov.w	r1, #800	@ 0x320
340035fc:	2002      	movs	r0, #2
340035fe:	f7ff bfc3 	b.w	34003588 <bsp_lcd_init_ex>
	...

34003604 <bsp_lcd_set_brightness>:
    if (brightness != 0)
34003604:	4602      	mov	r2, r0
34003606:	b100      	cbz	r0, 3400360a <bsp_lcd_set_brightness+0x6>
        HAL_GPIO_WritePin(BSP_LCD_BL_GPIO, BSP_LCD_BL_PIN, GPIO_PIN_SET);
34003608:	2201      	movs	r2, #1
        HAL_GPIO_WritePin(BSP_LCD_BL_GPIO, BSP_LCD_BL_PIN, GPIO_PIN_RESET);
3400360a:	2108      	movs	r1, #8
3400360c:	4801      	ldr	r0, [pc, #4]	@ (34003614 <bsp_lcd_set_brightness+0x10>)
3400360e:	f001 be11 	b.w	34005234 <HAL_GPIO_WritePin>
34003612:	bf00      	nop
34003614:	56020000 	.word	0x56020000

34003618 <bsp_lcd_get_ltdc_handle>:
}
34003618:	4800      	ldr	r0, [pc, #0]	@ (3400361c <bsp_lcd_get_ltdc_handle+0x4>)
3400361a:	4770      	bx	lr
3400361c:	340140d8 	.word	0x340140d8

34003620 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34003620:	b538      	push	{r3, r4, r5, lr}
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
34003622:	4b0f      	ldr	r3, [pc, #60]	@ (34003660 <HAL_InitTick+0x40>)
{
34003624:	4605      	mov	r5, r0
  if ((uint32_t)uwTickFreq == 0UL)
34003626:	781a      	ldrb	r2, [r3, #0]
34003628:	b90a      	cbnz	r2, 3400362e <HAL_InitTick+0xe>
  {
    return HAL_ERROR;
3400362a:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
3400362c:	bd38      	pop	{r3, r4, r5, pc}
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
3400362e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34003632:	fbb3 f3f2 	udiv	r3, r3, r2
34003636:	4a0b      	ldr	r2, [pc, #44]	@ (34003664 <HAL_InitTick+0x44>)
34003638:	6810      	ldr	r0, [r2, #0]
3400363a:	fbb0 f0f3 	udiv	r0, r0, r3
3400363e:	f000 f8d5 	bl	340037ec <HAL_SYSTICK_Config>
34003642:	4604      	mov	r4, r0
34003644:	2800      	cmp	r0, #0
34003646:	d1f0      	bne.n	3400362a <HAL_InitTick+0xa>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34003648:	2d0f      	cmp	r5, #15
3400364a:	d8ee      	bhi.n	3400362a <HAL_InitTick+0xa>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
3400364c:	4602      	mov	r2, r0
3400364e:	4629      	mov	r1, r5
34003650:	f04f 30ff 	mov.w	r0, #4294967295
34003654:	f000 f888 	bl	34003768 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
34003658:	4b03      	ldr	r3, [pc, #12]	@ (34003668 <HAL_InitTick+0x48>)
3400365a:	4620      	mov	r0, r4
3400365c:	601d      	str	r5, [r3, #0]
  return HAL_OK;
3400365e:	e7e5      	b.n	3400362c <HAL_InitTick+0xc>
34003660:	34013b1c 	.word	0x34013b1c
34003664:	34013b18 	.word	0x34013b18
34003668:	34013b20 	.word	0x34013b20

3400366c <HAL_Init>:
{
3400366c:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
3400366e:	2003      	movs	r0, #3
34003670:	f000 f868 	bl	34003744 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
34003674:	f7ff f9f2 	bl	34002a5c <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34003678:	200f      	movs	r0, #15
3400367a:	f7ff ffd1 	bl	34003620 <HAL_InitTick>
3400367e:	4604      	mov	r4, r0
34003680:	b918      	cbnz	r0, 3400368a <HAL_Init+0x1e>
  HAL_MspInit();
34003682:	f7ff f959 	bl	34002938 <HAL_MspInit>
}
34003686:	4620      	mov	r0, r4
34003688:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
3400368a:	2401      	movs	r4, #1
3400368c:	e7fb      	b.n	34003686 <HAL_Init+0x1a>
	...

34003690 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
34003690:	4a03      	ldr	r2, [pc, #12]	@ (340036a0 <HAL_IncTick+0x10>)
34003692:	4b04      	ldr	r3, [pc, #16]	@ (340036a4 <HAL_IncTick+0x14>)
34003694:	6811      	ldr	r1, [r2, #0]
34003696:	781b      	ldrb	r3, [r3, #0]
34003698:	440b      	add	r3, r1
3400369a:	6013      	str	r3, [r2, #0]
}
3400369c:	4770      	bx	lr
3400369e:	bf00      	nop
340036a0:	340cfba0 	.word	0x340cfba0
340036a4:	34013b1c 	.word	0x34013b1c

340036a8 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
340036a8:	4b01      	ldr	r3, [pc, #4]	@ (340036b0 <HAL_GetTick+0x8>)
340036aa:	6818      	ldr	r0, [r3, #0]
}
340036ac:	4770      	bx	lr
340036ae:	bf00      	nop
340036b0:	340cfba0 	.word	0x340cfba0

340036b4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
340036b4:	b538      	push	{r3, r4, r5, lr}
340036b6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
340036b8:	f7ff fff6 	bl	340036a8 <HAL_GetTick>
340036bc:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
340036be:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
340036c0:	bf1e      	ittt	ne
340036c2:	4b04      	ldrne	r3, [pc, #16]	@ (340036d4 <HAL_Delay+0x20>)
340036c4:	781b      	ldrbne	r3, [r3, #0]
340036c6:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
340036c8:	f7ff ffee 	bl	340036a8 <HAL_GetTick>
340036cc:	1b43      	subs	r3, r0, r5
340036ce:	42a3      	cmp	r3, r4
340036d0:	d3fa      	bcc.n	340036c8 <HAL_Delay+0x14>
  {
  }
}
340036d2:	bd38      	pop	{r3, r4, r5, pc}
340036d4:	34013b1c 	.word	0x34013b1c

340036d8 <HAL_CACHEAXI_Enable>:
  * @param  hcacheaxi Pointer to a CACHEAXI_HandleTypeDef structure that contains
  *                   the configuration information for the specified CACHEAXIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_Enable(CACHEAXI_HandleTypeDef *hcacheaxi)
{
340036d8:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tickstart;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
340036da:	4604      	mov	r4, r0
340036dc:	b1e8      	cbz	r0, 3400371a <HAL_CACHEAXI_Enable+0x42>

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));

  /* Check if ongoing full invalidation operation */
  if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
340036de:	6803      	ldr	r3, [r0, #0]
340036e0:	685b      	ldr	r3, [r3, #4]
340036e2:	07d9      	lsls	r1, r3, #31
340036e4:	d407      	bmi.n	340036f6 <HAL_CACHEAXI_Enable+0x1e>
  }

  if (status == HAL_OK)
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
340036e6:	2000      	movs	r0, #0
    /* Enable the selected CACHEAXI peripheral */
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
340036e8:	6822      	ldr	r2, [r4, #0]
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
340036ea:	60a0      	str	r0, [r4, #8]
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
340036ec:	6813      	ldr	r3, [r2, #0]
340036ee:	f043 0301 	orr.w	r3, r3, #1
340036f2:	6013      	str	r3, [r2, #0]
  }

  return status;
}
340036f4:	bd38      	pop	{r3, r4, r5, pc}
    tickstart = HAL_GetTick();
340036f6:	f7ff ffd7 	bl	340036a8 <HAL_GetTick>
340036fa:	4605      	mov	r5, r0
    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
340036fc:	6823      	ldr	r3, [r4, #0]
340036fe:	685b      	ldr	r3, [r3, #4]
34003700:	07db      	lsls	r3, r3, #31
34003702:	d5f0      	bpl.n	340036e6 <HAL_CACHEAXI_Enable+0xe>
      if ((HAL_GetTick() - tickstart) > CACHEAXI_ENABLE_TIMEOUT_VALUE)
34003704:	f7ff ffd0 	bl	340036a8 <HAL_GetTick>
34003708:	1b40      	subs	r0, r0, r5
3400370a:	2801      	cmp	r0, #1
3400370c:	d9f6      	bls.n	340036fc <HAL_CACHEAXI_Enable+0x24>
        if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) == 0U)
3400370e:	6823      	ldr	r3, [r4, #0]
34003710:	685b      	ldr	r3, [r3, #4]
34003712:	07da      	lsls	r2, r3, #31
34003714:	d4f2      	bmi.n	340036fc <HAL_CACHEAXI_Enable+0x24>
          hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
34003716:	2310      	movs	r3, #16
34003718:	60a3      	str	r3, [r4, #8]
    return HAL_ERROR;
3400371a:	2001      	movs	r0, #1
3400371c:	e7ea      	b.n	340036f4 <HAL_CACHEAXI_Enable+0x1c>

3400371e <HAL_CACHEAXI_Init>:
{
3400371e:	b510      	push	{r4, lr}
  if (hcacheaxi == NULL)
34003720:	4604      	mov	r4, r0
34003722:	b160      	cbz	r0, 3400373e <HAL_CACHEAXI_Init+0x20>
  if (hcacheaxi->State == HAL_CACHEAXI_STATE_RESET)
34003724:	7903      	ldrb	r3, [r0, #4]
34003726:	b90b      	cbnz	r3, 3400372c <HAL_CACHEAXI_Init+0xe>
    HAL_CACHEAXI_MspInit(hcacheaxi);
34003728:	f7fe fac8 	bl	34001cbc <HAL_CACHEAXI_MspInit>
  hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
3400372c:	2300      	movs	r3, #0
3400372e:	60a3      	str	r3, [r4, #8]
  hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
34003730:	2301      	movs	r3, #1
34003732:	7123      	strb	r3, [r4, #4]
  status = HAL_CACHEAXI_Enable(hcacheaxi);
34003734:	4620      	mov	r0, r4
}
34003736:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  status = HAL_CACHEAXI_Enable(hcacheaxi);
3400373a:	f7ff bfcd 	b.w	340036d8 <HAL_CACHEAXI_Enable>
}
3400373e:	2001      	movs	r0, #1
34003740:	bd10      	pop	{r4, pc}
	...

34003744 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34003744:	4907      	ldr	r1, [pc, #28]	@ (34003764 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34003746:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34003748:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
3400374a:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
3400374e:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
34003752:	0412      	lsls	r2, r2, #16
34003754:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34003756:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34003758:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
3400375c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
34003760:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
34003762:	4770      	bx	lr
34003764:	e000ed00 	.word	0xe000ed00

34003768 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
34003768:	b570      	push	{r4, r5, r6, lr}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
3400376a:	4c18      	ldr	r4, [pc, #96]	@ (340037cc <HAL_NVIC_SetPriority+0x64>)
3400376c:	68e3      	ldr	r3, [r4, #12]
3400376e:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34003772:	f1c3 0507 	rsb	r5, r3, #7
34003776:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34003778:	f103 0604 	add.w	r6, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
3400377c:	bf28      	it	cs
3400377e:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34003780:	2e06      	cmp	r6, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34003782:	f04f 36ff 	mov.w	r6, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34003786:	f1a3 0303 	sub.w	r3, r3, #3
3400378a:	bf98      	it	ls
3400378c:	2300      	movls	r3, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
3400378e:	fa06 f505 	lsl.w	r5, r6, r5
34003792:	ea21 0105 	bic.w	r1, r1, r5
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34003796:	409e      	lsls	r6, r3
  if ((int32_t)(IRQn) >= 0)
34003798:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
3400379a:	fa01 f103 	lsl.w	r1, r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
3400379e:	ea22 0206 	bic.w	r2, r2, r6
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340037a2:	bfb8      	it	lt
340037a4:	f000 000f 	andlt.w	r0, r0, #15
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
340037a8:	ea41 0302 	orr.w	r3, r1, r2
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340037ac:	bfa8      	it	ge
340037ae:	f100 4060 	addge.w	r0, r0, #3758096384	@ 0xe0000000
340037b2:	ea4f 1303 	mov.w	r3, r3, lsl #4
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340037b6:	bfb8      	it	lt
340037b8:	3804      	sublt	r0, #4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340037ba:	b2db      	uxtb	r3, r3
340037bc:	bfab      	itete	ge
340037be:	f500 4061 	addge.w	r0, r0, #57600	@ 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340037c2:	1824      	addlt	r4, r4, r0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340037c4:	f880 3300 	strbge.w	r3, [r0, #768]	@ 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340037c8:	7623      	strblt	r3, [r4, #24]
  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
340037ca:	bd70      	pop	{r4, r5, r6, pc}
340037cc:	e000ed00 	.word	0xe000ed00

340037d0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
340037d0:	2800      	cmp	r0, #0
340037d2:	db07      	blt.n	340037e4 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
340037d4:	2301      	movs	r3, #1
340037d6:	0941      	lsrs	r1, r0, #5
340037d8:	4a03      	ldr	r2, [pc, #12]	@ (340037e8 <HAL_NVIC_EnableIRQ+0x18>)
340037da:	f000 001f 	and.w	r0, r0, #31
340037de:	4083      	lsls	r3, r0
340037e0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
340037e4:	4770      	bx	lr
340037e6:	bf00      	nop
340037e8:	e000e100 	.word	0xe000e100

340037ec <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
340037ec:	3801      	subs	r0, #1
340037ee:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
340037f2:	d20b      	bcs.n	3400380c <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
340037f4:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340037f8:	21f0      	movs	r1, #240	@ 0xf0
340037fa:	4a05      	ldr	r2, [pc, #20]	@ (34003810 <HAL_SYSTICK_Config+0x24>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
340037fc:	6158      	str	r0, [r3, #20]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340037fe:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34003802:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34003804:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34003806:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34003808:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
3400380a:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
3400380c:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
3400380e:	4770      	bx	lr
34003810:	e000ed00 	.word	0xe000ed00

34003814 <DCMIPP_CSI_SetVCConfig>:
  * @param  hdcmipp         Pointer to DCMIPP handle
  * @param  Pipe            Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @param  VirtualChannel  Specifies the virtual channel, can be a value from @ref DCMIPP_Virtual_Channel
  */
static HAL_StatusTypeDef DCMIPP_CSI_SetVCConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t VirtualChannel)
{
34003814:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34003816:	4614      	mov	r4, r2
  uint32_t tickstart;

  /* Set Virtual Channel ID for the selected Pipe */
  if (Pipe == DCMIPP_PIPE0)
  {
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
34003818:	6803      	ldr	r3, [r0, #0]
  if (Pipe == DCMIPP_PIPE0)
3400381a:	bb71      	cbnz	r1, 3400387a <DCMIPP_CSI_SetVCConfig+0x66>
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
3400381c:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34003820:	f422 12c0 	bic.w	r2, r2, #1572864	@ 0x180000
34003824:	ea42 42c4 	orr.w	r2, r2, r4, lsl #19
34003828:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
    }
  }

  /* Enable the selected virtual channel */
  switch (VirtualChannel)
3400382c:	4b23      	ldr	r3, [pc, #140]	@ (340038bc <DCMIPP_CSI_SetVCConfig+0xa8>)
3400382e:	2c02      	cmp	r4, #2
    case DCMIPP_VIRTUAL_CHANNEL3:
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
      break;
    default:
      /* DCMIPP_VIRTUAL_CHANNEL0: */
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
34003830:	681a      	ldr	r2, [r3, #0]
  switch (VirtualChannel)
34003832:	d038      	beq.n	340038a6 <DCMIPP_CSI_SetVCConfig+0x92>
34003834:	2c03      	cmp	r4, #3
34003836:	d039      	beq.n	340038ac <DCMIPP_CSI_SetVCConfig+0x98>
34003838:	2c01      	cmp	r4, #1
3400383a:	d13a      	bne.n	340038b2 <DCMIPP_CSI_SetVCConfig+0x9e>
      SET_BIT(csi_instance->CR, CSI_CR_VC1START);
3400383c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
34003840:	601a      	str	r2, [r3, #0]
      break;
  }

  /* wait for the selected virtual channel active state */
  tickstart = HAL_GetTick();
34003842:	f7ff ff31 	bl	340036a8 <HAL_GetTick>
  {
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
    {
      return HAL_ERROR;
    }
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34003846:	f44f 3600 	mov.w	r6, #131072	@ 0x20000
  tickstart = HAL_GetTick();
3400384a:	4607      	mov	r7, r0
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
3400384c:	4d1b      	ldr	r5, [pc, #108]	@ (340038bc <DCMIPP_CSI_SetVCConfig+0xa8>)
3400384e:	40a6      	lsls	r6, r4
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
34003850:	f7ff ff2a 	bl	340036a8 <HAL_GetTick>
34003854:	1bc0      	subs	r0, r0, r7
34003856:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
3400385a:	d82d      	bhi.n	340038b8 <DCMIPP_CSI_SetVCConfig+0xa4>
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
3400385c:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
34003860:	ea36 0303 	bics.w	r3, r6, r3
34003864:	d1f4      	bne.n	34003850 <DCMIPP_CSI_SetVCConfig+0x3c>

  /* Enable the SOF and EOF interrupts for the selected virtual channel */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
34003866:	f44f 5388 	mov.w	r3, #4352	@ 0x1100
                             (DCMIPP_CSI_IT_SOF0 << VirtualChannel));
  return HAL_OK;
3400386a:	2000      	movs	r0, #0
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
3400386c:	f8d5 2080 	ldr.w	r2, [r5, #128]	@ 0x80
34003870:	40a3      	lsls	r3, r4
34003872:	4313      	orrs	r3, r2
34003874:	f8c5 3080 	str.w	r3, [r5, #128]	@ 0x80
}
34003878:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (Pipe == DCMIPP_PIPE1)
3400387a:	2901      	cmp	r1, #1
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
3400387c:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
  else if (Pipe == DCMIPP_PIPE1)
34003880:	d106      	bne.n	34003890 <DCMIPP_CSI_SetVCConfig+0x7c>
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
34003882:	f422 12c0 	bic.w	r2, r2, #1572864	@ 0x180000
34003886:	ea42 42c4 	orr.w	r2, r2, r4, lsl #19
3400388a:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
3400388e:	e7cd      	b.n	3400382c <DCMIPP_CSI_SetVCConfig+0x18>
    if ((hdcmipp->Instance->P1FSCR & DCMIPP_P1FSCR_PIPEDIFF) == DCMIPP_P1FSCR_PIPEDIFF)
34003890:	0352      	lsls	r2, r2, #13
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
34003892:	bf41      	itttt	mi
34003894:	f8d3 2c04 	ldrmi.w	r2, [r3, #3076]	@ 0xc04
34003898:	f422 12c0 	bicmi.w	r2, r2, #1572864	@ 0x180000
3400389c:	ea42 42c4 	orrmi.w	r2, r2, r4, lsl #19
340038a0:	f8c3 2c04 	strmi.w	r2, [r3, #3076]	@ 0xc04
340038a4:	e7c2      	b.n	3400382c <DCMIPP_CSI_SetVCConfig+0x18>
      SET_BIT(csi_instance->CR, CSI_CR_VC2START);
340038a6:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
340038aa:	e7c9      	b.n	34003840 <DCMIPP_CSI_SetVCConfig+0x2c>
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
340038ac:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
340038b0:	e7c6      	b.n	34003840 <DCMIPP_CSI_SetVCConfig+0x2c>
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
340038b2:	f042 0204 	orr.w	r2, r2, #4
340038b6:	e7c3      	b.n	34003840 <DCMIPP_CSI_SetVCConfig+0x2c>
      return HAL_ERROR;
340038b8:	2001      	movs	r0, #1
340038ba:	e7dd      	b.n	34003878 <DCMIPP_CSI_SetVCConfig+0x64>
340038bc:	58006000 	.word	0x58006000

340038c0 <DCMIPP_SetConfig.part.0>:
  else if (Pipe == DCMIPP_PIPE1)
340038c0:	2901      	cmp	r1, #1
static void DCMIPP_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t DstAddress, uint32_t CaptureMode)
340038c2:	b530      	push	{r4, r5, lr}
340038c4:	f04f 0502 	mov.w	r5, #2
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
340038c8:	6804      	ldr	r4, [r0, #0]
  else if (Pipe == DCMIPP_PIPE1)
340038ca:	d110      	bne.n	340038ee <DCMIPP_SetConfig.part.0+0x2e>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
340038cc:	7185      	strb	r5, [r0, #6]
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
340038ce:	f8d4 1900 	ldr.w	r1, [r4, #2304]	@ 0x900
340038d2:	430b      	orrs	r3, r1
340038d4:	f8c4 3900 	str.w	r3, [r4, #2304]	@ 0x900
    WRITE_REG(hdcmipp->Instance->P1PPM0AR1, DstAddress);
340038d8:	f8c4 29c4 	str.w	r2, [r4, #2500]	@ 0x9c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME  | DCMIPP_IT_PIPE1_OVR | DCMIPP_IT_PIPE1_VSYNC |
340038dc:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
340038e0:	f443 0306 	orr.w	r3, r3, #8781824	@ 0x860000
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
340038e4:	f043 0320 	orr.w	r3, r3, #32
340038e8:	f8c4 33f0 	str.w	r3, [r4, #1008]	@ 0x3f0
}
340038ec:	bd30      	pop	{r4, r5, pc}
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
340038ee:	4408      	add	r0, r1
340038f0:	7145      	strb	r5, [r0, #5]
    hdcmipp->Instance->P2FCTCR |= CaptureMode;
340038f2:	f8d4 1d00 	ldr.w	r1, [r4, #3328]	@ 0xd00
340038f6:	430b      	orrs	r3, r1
340038f8:	f8c4 3d00 	str.w	r3, [r4, #3328]	@ 0xd00
    WRITE_REG(hdcmipp->Instance->P2PPM0AR1, DstAddress);
340038fc:	f8c4 2dc4 	str.w	r2, [r4, #3524]	@ 0xdc4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
34003900:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
34003904:	f043 4306 	orr.w	r3, r3, #2248146944	@ 0x86000000
34003908:	e7ec      	b.n	340038e4 <DCMIPP_SetConfig.part.0+0x24>

3400390a <DCMIPP_SetConfig>:
{
3400390a:	b470      	push	{r4, r5, r6}
3400390c:	4615      	mov	r5, r2
3400390e:	461e      	mov	r6, r3
  if (Pipe == DCMIPP_PIPE0)
34003910:	b999      	cbnz	r1, 3400393a <DCMIPP_SetConfig+0x30>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34003912:	2302      	movs	r3, #2
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
34003914:	6801      	ldr	r1, [r0, #0]
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34003916:	7143      	strb	r3, [r0, #5]
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
34003918:	f8d1 2500 	ldr.w	r2, [r1, #1280]	@ 0x500
3400391c:	4332      	orrs	r2, r6
3400391e:	f8c1 2500 	str.w	r2, [r1, #1280]	@ 0x500
    WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
34003922:	f8c1 55c4 	str.w	r5, [r1, #1476]	@ 0x5c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
34003926:	f8d1 33f0 	ldr.w	r3, [r1, #1008]	@ 0x3f0
}
3400392a:	bc70      	pop	{r4, r5, r6}
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
3400392c:	f443 4306 	orr.w	r3, r3, #34304	@ 0x8600
34003930:	f043 0320 	orr.w	r3, r3, #32
34003934:	f8c1 33f0 	str.w	r3, [r1, #1008]	@ 0x3f0
}
34003938:	4770      	bx	lr
3400393a:	bc70      	pop	{r4, r5, r6}
3400393c:	f7ff bfc0 	b.w	340038c0 <DCMIPP_SetConfig.part.0>

34003940 <DCMIPP_EnableCapture.part.0>:
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34003940:	2302      	movs	r3, #2
34003942:	7183      	strb	r3, [r0, #6]
    SET_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEN);
34003944:	6803      	ldr	r3, [r0, #0]
34003946:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
3400394a:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400394e:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
    SET_BIT(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_CPTREQ);
34003952:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
34003956:	f042 0208 	orr.w	r2, r2, #8
3400395a:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
}
3400395e:	4770      	bx	lr

34003960 <DCMIPP_EnableCapture>:
  if (Pipe == DCMIPP_PIPE0)
34003960:	b969      	cbnz	r1, 3400397e <DCMIPP_EnableCapture+0x1e>
    SET_BIT(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_PIPEN);
34003962:	6803      	ldr	r3, [r0, #0]
34003964:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34003968:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400396c:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
    SET_BIT(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
34003970:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34003974:	f042 0208 	orr.w	r2, r2, #8
34003978:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
3400397c:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE1)
3400397e:	2901      	cmp	r1, #1
34003980:	d101      	bne.n	34003986 <DCMIPP_EnableCapture+0x26>
34003982:	f7ff bfdd 	b.w	34003940 <DCMIPP_EnableCapture.part.0>
    SET_BIT(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_PIPEN);
34003986:	6803      	ldr	r3, [r0, #0]
34003988:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
3400398c:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34003990:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    SET_BIT(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_CPTREQ);
34003994:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
34003998:	f042 0208 	orr.w	r2, r2, #8
3400399c:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
}
340039a0:	4770      	bx	lr
	...

340039a4 <DCMIPP_CSI_WritePHYReg.constprop.0>:
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340039a4:	4b18      	ldr	r3, [pc, #96]	@ (34003a08 <DCMIPP_CSI_WritePHYReg.constprop.0+0x64>)
static void DCMIPP_CSI_WritePHYReg(CSI_TypeDef *hcsi, uint32_t reg_msb, uint32_t reg_lsb, uint32_t val)
340039a6:	b510      	push	{r4, lr}
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340039a8:	695a      	ldr	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
340039aa:	b2c9      	uxtb	r1, r1
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340039ac:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
340039b0:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
340039b2:	691a      	ldr	r2, [r3, #16]
340039b4:	f042 0201 	orr.w	r2, r2, #1
340039b8:	611a      	str	r2, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340039ba:	695a      	ldr	r2, [r3, #20]
340039bc:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
340039c0:	615a      	str	r2, [r3, #20]
  CLEAR_REG(hcsi->PTCR0);
340039c2:	2200      	movs	r2, #0
340039c4:	611a      	str	r2, [r3, #16]
  CLEAR_REG(hcsi->PTCR1);
340039c6:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, reg_msb & 0xFFU);
340039c8:	695c      	ldr	r4, [r3, #20]
340039ca:	615c      	str	r4, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
340039cc:	691c      	ldr	r4, [r3, #16]
340039ce:	f044 0401 	orr.w	r4, r4, #1
340039d2:	611c      	str	r4, [r3, #16]
  CLEAR_REG(hcsi->PTCR0);
340039d4:	611a      	str	r2, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340039d6:	695c      	ldr	r4, [r3, #20]
340039d8:	f444 3480 	orr.w	r4, r4, #65536	@ 0x10000
340039dc:	615c      	str	r4, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
340039de:	691c      	ldr	r4, [r3, #16]
340039e0:	f044 0401 	orr.w	r4, r4, #1
340039e4:	611c      	str	r4, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM | (reg_lsb & 0xFFU));
340039e6:	695c      	ldr	r4, [r3, #20]
340039e8:	4304      	orrs	r4, r0
340039ea:	f444 3480 	orr.w	r4, r4, #65536	@ 0x10000
340039ee:	615c      	str	r4, [r3, #20]
  CLEAR_REG(hcsi->PTCR0);
340039f0:	611a      	str	r2, [r3, #16]
  CLEAR_REG(hcsi->PTCR1);
340039f2:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
340039f4:	6958      	ldr	r0, [r3, #20]
340039f6:	4301      	orrs	r1, r0
340039f8:	6159      	str	r1, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
340039fa:	6919      	ldr	r1, [r3, #16]
340039fc:	f041 0101 	orr.w	r1, r1, #1
34003a00:	6119      	str	r1, [r3, #16]
  CLEAR_REG(hcsi->PTCR0);
34003a02:	611a      	str	r2, [r3, #16]
}
34003a04:	bd10      	pop	{r4, pc}
34003a06:	bf00      	nop
34003a08:	58007000 	.word	0x58007000

34003a0c <HAL_DCMIPP_Init>:
{
34003a0c:	b510      	push	{r4, lr}
  if (hdcmipp == NULL)
34003a0e:	4604      	mov	r4, r0
34003a10:	b168      	cbz	r0, 34003a2e <HAL_DCMIPP_Init+0x22>
  if (hdcmipp->State == HAL_DCMIPP_STATE_RESET)
34003a12:	7903      	ldrb	r3, [r0, #4]
34003a14:	b90b      	cbnz	r3, 34003a1a <HAL_DCMIPP_Init+0xe>
    HAL_DCMIPP_MspInit(hdcmipp);
34003a16:	f008 fe41 	bl	3400c69c <HAL_DCMIPP_MspInit>
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34003a1a:	2303      	movs	r3, #3
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
34003a1c:	2000      	movs	r0, #0
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34003a1e:	7123      	strb	r3, [r4, #4]
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
34003a20:	2301      	movs	r3, #1
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
34003a22:	7160      	strb	r0, [r4, #5]
34003a24:	71a0      	strb	r0, [r4, #6]
34003a26:	71e0      	strb	r0, [r4, #7]
  hdcmipp->ErrorCode = HAL_DCMIPP_ERROR_NONE;
34003a28:	60a0      	str	r0, [r4, #8]
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
34003a2a:	7123      	strb	r3, [r4, #4]
}
34003a2c:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34003a2e:	2001      	movs	r0, #1
34003a30:	e7fc      	b.n	34003a2c <HAL_DCMIPP_Init+0x20>
	...

34003a34 <HAL_DCMIPP_CSI_SetConfig>:
{
34003a34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34003a38:	4604      	mov	r4, r0
34003a3a:	b0fe      	sub	sp, #504	@ 0x1f8
34003a3c:	460d      	mov	r5, r1
  const SNPS_FreqsTypeDef SNPS_Freqs[63] =
34003a3e:	f44f 72fc 	mov.w	r2, #504	@ 0x1f8
34003a42:	4668      	mov	r0, sp
34003a44:	493f      	ldr	r1, [pc, #252]	@ (34003b44 <HAL_DCMIPP_CSI_SetConfig+0x110>)
34003a46:	f009 fff8 	bl	3400da3a <memcpy>
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
34003a4a:	b91c      	cbnz	r4, 34003a54 <HAL_DCMIPP_CSI_SetConfig+0x20>
    return HAL_ERROR;
34003a4c:	2001      	movs	r0, #1
}
34003a4e:	b07e      	add	sp, #504	@ 0x1f8
34003a50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
34003a54:	2d00      	cmp	r5, #0
34003a56:	d0f9      	beq.n	34003a4c <HAL_DCMIPP_CSI_SetConfig+0x18>
  CLEAR_BIT(csi_instance->CR, CSI_CR_CSIEN);
34003a58:	4b3b      	ldr	r3, [pc, #236]	@ (34003b48 <HAL_DCMIPP_CSI_SetConfig+0x114>)
34003a5a:	681a      	ldr	r2, [r3, #0]
34003a5c:	f022 0201 	bic.w	r2, r2, #1
34003a60:	601a      	str	r2, [r3, #0]
  if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34003a62:	6869      	ldr	r1, [r5, #4]
34003a64:	2901      	cmp	r1, #1
34003a66:	d11a      	bne.n	34003a9e <HAL_DCMIPP_CSI_SetConfig+0x6a>
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL0MAP_Pos) | \
34003a68:	682a      	ldr	r2, [r5, #0]
34003a6a:	f442 1204 	orr.w	r2, r2, #2162688	@ 0x210000
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
34003a6e:	671a      	str	r2, [r3, #112]	@ 0x70
  SET_BIT(csi_instance->CR, CSI_CR_CSIEN);
34003a70:	681a      	ldr	r2, [r3, #0]
34003a72:	f042 0201 	orr.w	r2, r2, #1
34003a76:	601a      	str	r2, [r3, #0]
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO |  DCMIPP_CSI_IT_SYNCERR | \
34003a78:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34003a7c:	f042 42b0 	orr.w	r2, r2, #1476395008	@ 0x58000000
34003a80:	f442 1204 	orr.w	r2, r2, #2162688	@ 0x210000
34003a84:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34003a88:	682a      	ldr	r2, [r5, #0]
34003a8a:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0 | DCMIPP_CSI_IT_ESOTSYNCDL0 |
34003a8e:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34003a92:	d154      	bne.n	34003b3e <HAL_DCMIPP_CSI_SetConfig+0x10a>
    if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34003a94:	2901      	cmp	r1, #1
34003a96:	d108      	bne.n	34003aaa <HAL_DCMIPP_CSI_SetConfig+0x76>
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34003a98:	f042 021f 	orr.w	r2, r2, #31
34003a9c:	e007      	b.n	34003aae <HAL_DCMIPP_CSI_SetConfig+0x7a>
  else if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_INVERTED_DATA_LANES)
34003a9e:	2902      	cmp	r1, #2
34003aa0:	d1d4      	bne.n	34003a4c <HAL_DCMIPP_CSI_SetConfig+0x18>
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
34003aa2:	682a      	ldr	r2, [r5, #0]
34003aa4:	f442 1290 	orr.w	r2, r2, #1179648	@ 0x120000
34003aa8:	e7e1      	b.n	34003a6e <HAL_DCMIPP_CSI_SetConfig+0x3a>
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34003aaa:	f442 52f8 	orr.w	r2, r2, #7936	@ 0x1f00
  CLEAR_REG(csi_instance-> PCR);
34003aae:	2600      	movs	r6, #0
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34003ab0:	4c26      	ldr	r4, [pc, #152]	@ (34003b4c <HAL_DCMIPP_CSI_SetConfig+0x118>)
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34003ab2:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34003ab6:	6823      	ldr	r3, [r4, #0]
34003ab8:	4f23      	ldr	r7, [pc, #140]	@ (34003b48 <HAL_DCMIPP_CSI_SetConfig+0x114>)
34003aba:	f023 0302 	bic.w	r3, r3, #2
34003abe:	6023      	str	r3, [r4, #0]
  CLEAR_REG(csi_instance-> PCR);
34003ac0:	607e      	str	r6, [r7, #4]
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34003ac2:	6923      	ldr	r3, [r4, #16]
  HAL_Delay(1);
34003ac4:	2001      	movs	r0, #1
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34003ac6:	f043 0301 	orr.w	r3, r3, #1
34003aca:	6123      	str	r3, [r4, #16]
  HAL_Delay(1);
34003acc:	f7ff fdf2 	bl	340036b4 <HAL_Delay>
  CLEAR_REG(csi_instance->PTCR0);
34003ad0:	6126      	str	r6, [r4, #16]
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34003ad2:	f8d5 8008 	ldr.w	r8, [r5, #8]
34003ad6:	68a3      	ldr	r3, [r4, #8]
34003ad8:	f85d 2038 	ldr.w	r2, [sp, r8, lsl #3]
34003adc:	f423 43fe 	bic.w	r3, r3, #32512	@ 0x7f00
34003ae0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
34003ae4:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
34003ae8:	60a3      	str	r3, [r4, #8]
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34003aea:	2138      	movs	r1, #56	@ 0x38
34003aec:	2008      	movs	r0, #8
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34003aee:	0216      	lsls	r6, r2, #8
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34003af0:	f7ff ff58 	bl	340039a4 <DCMIPP_CSI_WritePHYReg.constprop.0>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe4, 0x11);
34003af4:	2111      	movs	r1, #17
34003af6:	20e4      	movs	r0, #228	@ 0xe4
34003af8:	f7ff ff54 	bl	340039a4 <DCMIPP_CSI_WritePHYReg.constprop.0>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34003afc:	eb0d 03c8 	add.w	r3, sp, r8, lsl #3
34003b00:	f8d3 8004 	ldr.w	r8, [r3, #4]
34003b04:	20e3      	movs	r0, #227	@ 0xe3
34003b06:	ea4f 2118 	mov.w	r1, r8, lsr #8
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34003b0a:	f446 3680 	orr.w	r6, r6, #65536	@ 0x10000
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34003b0e:	f7ff ff49 	bl	340039a4 <DCMIPP_CSI_WritePHYReg.constprop.0>
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34003b12:	f046 0628 	orr.w	r6, r6, #40	@ 0x28
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target & 0xFFU);
34003b16:	20e3      	movs	r0, #227	@ 0xe3
34003b18:	fa5f f188 	uxtb.w	r1, r8
34003b1c:	f7ff ff42 	bl	340039a4 <DCMIPP_CSI_WritePHYReg.constprop.0>
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34003b20:	60a6      	str	r6, [r4, #8]
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34003b22:	682b      	ldr	r3, [r5, #0]
  CLEAR_REG(csi_instance->PMCR);
34003b24:	2000      	movs	r0, #0
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34003b26:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34003b2a:	bf0c      	ite	eq
34003b2c:	2307      	moveq	r3, #7
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_DL1EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34003b2e:	230f      	movne	r3, #15
34003b30:	607b      	str	r3, [r7, #4]
  SET_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34003b32:	6823      	ldr	r3, [r4, #0]
34003b34:	f043 0302 	orr.w	r3, r3, #2
34003b38:	6023      	str	r3, [r4, #0]
  CLEAR_REG(csi_instance->PMCR);
34003b3a:	6060      	str	r0, [r4, #4]
  return HAL_OK;
34003b3c:	e787      	b.n	34003a4e <HAL_DCMIPP_CSI_SetConfig+0x1a>
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34003b3e:	f442 52f8 	orr.w	r2, r2, #7936	@ 0x1f00
34003b42:	e7a9      	b.n	34003a98 <HAL_DCMIPP_CSI_SetConfig+0x64>
34003b44:	3400f2b8 	.word	0x3400f2b8
34003b48:	58006000 	.word	0x58006000
34003b4c:	58007000 	.word	0x58007000

34003b50 <HAL_DCMIPP_CSI_PIPE_SetConfig>:
{
34003b50:	b530      	push	{r4, r5, lr}
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
34003b52:	b158      	cbz	r0, 34003b6c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x1c>
34003b54:	b152      	cbz	r2, 34003b6c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x1c>
  state = hdcmipp->State;
34003b56:	7903      	ldrb	r3, [r0, #4]
  if ((state == HAL_DCMIPP_STATE_INIT) || (state == HAL_DCMIPP_STATE_READY))
34003b58:	3b01      	subs	r3, #1
34003b5a:	2b01      	cmp	r3, #1
34003b5c:	d83f      	bhi.n	34003bde <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8e>
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34003b5e:	6814      	ldr	r4, [r2, #0]
34003b60:	f424 3380 	bic.w	r3, r4, #65536	@ 0x10000
34003b64:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34003b68:	d102      	bne.n	34003b70 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x20>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34003b6a:	b1f9      	cbz	r1, 34003bac <HAL_DCMIPP_CSI_PIPE_SetConfig+0x5c>
    return HAL_ERROR;
34003b6c:	2001      	movs	r0, #1
34003b6e:	e039      	b.n	34003be4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x94>
  uint32_t pxfscr_reg = 0;
34003b70:	2902      	cmp	r1, #2
34003b72:	bf14      	ite	ne
34003b74:	4623      	movne	r3, r4
34003b76:	2300      	moveq	r3, #0
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
34003b78:	6855      	ldr	r5, [r2, #4]
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34003b7a:	f5b4 3f80 	cmp.w	r4, #65536	@ 0x10000
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
34003b7e:	ea43 0305 	orr.w	r3, r3, r5
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34003b82:	6805      	ldr	r5, [r0, #0]
34003b84:	d002      	beq.n	34003b8c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x3c>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
34003b86:	f5b4 3f00 	cmp.w	r4, #131072	@ 0x20000
34003b8a:	d104      	bne.n	34003b96 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x46>
      if (Pipe != DCMIPP_PIPE2)
34003b8c:	2902      	cmp	r1, #2
34003b8e:	d02a      	beq.n	34003be6 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x96>
        pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDB << DCMIPP_P0FSCR_DTIDB_Pos);
34003b90:	6892      	ldr	r2, [r2, #8]
34003b92:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    if (Pipe == DCMIPP_PIPE0)
34003b96:	b169      	cbz	r1, 34003bb4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x64>
    else if (Pipe == DCMIPP_PIPE1)
34003b98:	2901      	cmp	r1, #1
34003b9a:	d124      	bne.n	34003be6 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x96>
      MODIFY_REG(hdcmipp->Instance->P1FSCR, (DCMIPP_P1FSCR_DTIDA | DCMIPP_P1FSCR_DTIDB |
34003b9c:	f8d5 1804 	ldr.w	r1, [r5, #2052]	@ 0x804
34003ba0:	4a15      	ldr	r2, [pc, #84]	@ (34003bf8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>)
34003ba2:	400a      	ands	r2, r1
34003ba4:	431a      	orrs	r2, r3
34003ba6:	f8c5 2804 	str.w	r2, [r5, #2052]	@ 0x804
34003baa:	e00b      	b.n	34003bc4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x74>
    if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
34003bac:	f5b4 3f40 	cmp.w	r4, #196608	@ 0x30000
34003bb0:	4623      	mov	r3, r4
34003bb2:	d1e1      	bne.n	34003b78 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x28>
      MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_DTMODE | DCMIPP_P0FSCR_DTIDA |
34003bb4:	6801      	ldr	r1, [r0, #0]
34003bb6:	4a10      	ldr	r2, [pc, #64]	@ (34003bf8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>)
34003bb8:	f8d1 4404 	ldr.w	r4, [r1, #1028]	@ 0x404
34003bbc:	4022      	ands	r2, r4
34003bbe:	431a      	orrs	r2, r3
34003bc0:	f8c1 2404 	str.w	r2, [r1, #1028]	@ 0x404
    CLEAR_BIT(hdcmipp->Instance->PRCR, DCMIPP_PRCR_ENABLE);
34003bc4:	6803      	ldr	r3, [r0, #0]
34003bc6:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34003bca:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34003bce:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    SET_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
34003bd2:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
34003bd6:	f042 0201 	orr.w	r2, r2, #1
34003bda:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
34003bde:	2302      	movs	r3, #2
34003be0:	7103      	strb	r3, [r0, #4]
  return HAL_OK;
34003be2:	2000      	movs	r0, #0
}
34003be4:	bd30      	pop	{r4, r5, pc}
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_DTIDA, pxfscr_reg);
34003be6:	f8d5 2c04 	ldr.w	r2, [r5, #3076]	@ 0xc04
34003bea:	f022 023f 	bic.w	r2, r2, #63	@ 0x3f
34003bee:	4313      	orrs	r3, r2
34003bf0:	f8c5 3c04 	str.w	r3, [r5, #3076]	@ 0xc04
34003bf4:	e7e6      	b.n	34003bc4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x74>
34003bf6:	bf00      	nop
34003bf8:	fffcc0c0 	.word	0xfffcc0c0

34003bfc <HAL_DCMIPP_CSI_SetVCConfig>:
  if (hdcmipp == NULL)
34003bfc:	b1f0      	cbz	r0, 34003c3c <HAL_DCMIPP_CSI_SetVCConfig+0x40>
  switch (VirtualChannel)
34003bfe:	2903      	cmp	r1, #3
34003c00:	d808      	bhi.n	34003c14 <HAL_DCMIPP_CSI_SetVCConfig+0x18>
34003c02:	e8df f001 	tbb	[pc, r1]
34003c06:	0902      	.short	0x0902
34003c08:	150f      	.short	0x150f
      WRITE_REG(csi_instance->VC0CFGR1, (DataTypeFormat << CSI_VC0CFGR1_CDTFT_Pos) | CSI_VC0CFGR1_ALLDT);
34003c0a:	4b0d      	ldr	r3, [pc, #52]	@ (34003c40 <HAL_DCMIPP_CSI_SetVCConfig+0x44>)
34003c0c:	0212      	lsls	r2, r2, #8
34003c0e:	f042 0201 	orr.w	r2, r2, #1
34003c12:	611a      	str	r2, [r3, #16]
  return HAL_OK;
34003c14:	2000      	movs	r0, #0
34003c16:	4770      	bx	lr
      WRITE_REG(csi_instance->VC1CFGR1, (DataTypeFormat << CSI_VC1CFGR1_CDTFT_Pos) | CSI_VC1CFGR1_ALLDT);
34003c18:	4b09      	ldr	r3, [pc, #36]	@ (34003c40 <HAL_DCMIPP_CSI_SetVCConfig+0x44>)
34003c1a:	0212      	lsls	r2, r2, #8
34003c1c:	f042 0201 	orr.w	r2, r2, #1
34003c20:	621a      	str	r2, [r3, #32]
      break;
34003c22:	e7f7      	b.n	34003c14 <HAL_DCMIPP_CSI_SetVCConfig+0x18>
      WRITE_REG(csi_instance->VC2CFGR1, (DataTypeFormat << CSI_VC2CFGR1_CDTFT_Pos) | CSI_VC2CFGR1_ALLDT);
34003c24:	4b06      	ldr	r3, [pc, #24]	@ (34003c40 <HAL_DCMIPP_CSI_SetVCConfig+0x44>)
34003c26:	0212      	lsls	r2, r2, #8
34003c28:	f042 0201 	orr.w	r2, r2, #1
34003c2c:	631a      	str	r2, [r3, #48]	@ 0x30
      break;
34003c2e:	e7f1      	b.n	34003c14 <HAL_DCMIPP_CSI_SetVCConfig+0x18>
      WRITE_REG(csi_instance->VC3CFGR1, (DataTypeFormat << CSI_VC3CFGR1_CDTFT_Pos) | CSI_VC3CFGR1_ALLDT);
34003c30:	4b03      	ldr	r3, [pc, #12]	@ (34003c40 <HAL_DCMIPP_CSI_SetVCConfig+0x44>)
34003c32:	0212      	lsls	r2, r2, #8
34003c34:	f042 0201 	orr.w	r2, r2, #1
34003c38:	641a      	str	r2, [r3, #64]	@ 0x40
      break;
34003c3a:	e7eb      	b.n	34003c14 <HAL_DCMIPP_CSI_SetVCConfig+0x18>
    return HAL_ERROR;
34003c3c:	2001      	movs	r0, #1
}
34003c3e:	4770      	bx	lr
34003c40:	58006000 	.word	0x58006000

34003c44 <HAL_DCMIPP_PIPE_SetConfig>:
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
34003c44:	4603      	mov	r3, r0
{
34003c46:	b5f0      	push	{r4, r5, r6, r7, lr}
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
34003c48:	2800      	cmp	r0, #0
34003c4a:	d05f      	beq.n	34003d0c <HAL_DCMIPP_PIPE_SetConfig+0xc8>
34003c4c:	2a00      	cmp	r2, #0
34003c4e:	d05d      	beq.n	34003d0c <HAL_DCMIPP_PIPE_SetConfig+0xc8>
  if ((Pipe == DCMIPP_PIPE2) && ((pPipeConfig->PixelPackerFormat) > DCMIPP_PIXEL_PACKER_FORMAT_YUV422_1))
34003c50:	2902      	cmp	r1, #2
34003c52:	d102      	bne.n	34003c5a <HAL_DCMIPP_PIPE_SetConfig+0x16>
34003c54:	6890      	ldr	r0, [r2, #8]
34003c56:	2806      	cmp	r0, #6
34003c58:	d858      	bhi.n	34003d0c <HAL_DCMIPP_PIPE_SetConfig+0xc8>
  pipe_state = hdcmipp->PipeState[Pipe];
34003c5a:	185c      	adds	r4, r3, r1
34003c5c:	7960      	ldrb	r0, [r4, #5]
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34003c5e:	791d      	ldrb	r5, [r3, #4]
  pipe_state = hdcmipp->PipeState[Pipe];
34003c60:	b2c0      	uxtb	r0, r0
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34003c62:	2d02      	cmp	r5, #2
34003c64:	b2ee      	uxtb	r6, r5
34003c66:	d151      	bne.n	34003d0c <HAL_DCMIPP_PIPE_SetConfig+0xc8>
    if ((pipe_state == HAL_DCMIPP_PIPE_STATE_RESET) || (pipe_state == HAL_DCMIPP_PIPE_STATE_ERROR))
34003c68:	f010 00fb 	ands.w	r0, r0, #251	@ 0xfb
34003c6c:	d14e      	bne.n	34003d0c <HAL_DCMIPP_PIPE_SetConfig+0xc8>
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34003c6e:	7166      	strb	r6, [r4, #5]
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
34003c70:	681b      	ldr	r3, [r3, #0]
34003c72:	6817      	ldr	r7, [r2, #0]
  if (Pipe == DCMIPP_PIPE0)
34003c74:	b949      	cbnz	r1, 34003c8a <HAL_DCMIPP_PIPE_SetConfig+0x46>
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
34003c76:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34003c7a:	f022 0203 	bic.w	r2, r2, #3
34003c7e:	433a      	orrs	r2, r7
34003c80:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_READY;
34003c84:	2301      	movs	r3, #1
34003c86:	7163      	strb	r3, [r4, #5]
}
34003c88:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (Pipe == DCMIPP_PIPE1)
34003c8a:	2901      	cmp	r1, #1
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
34003c8c:	e9d2 5601 	ldrd	r5, r6, [r2, #4]
  else if (Pipe == DCMIPP_PIPE1)
34003c90:	d126      	bne.n	34003ce0 <HAL_DCMIPP_PIPE_SetConfig+0x9c>
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
34003c92:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
34003c96:	491e      	ldr	r1, [pc, #120]	@ (34003d10 <HAL_DCMIPP_PIPE_SetConfig+0xcc>)
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
34003c98:	f022 0203 	bic.w	r2, r2, #3
34003c9c:	433a      	orrs	r2, r7
34003c9e:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
34003ca2:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
34003ca6:	f022 020f 	bic.w	r2, r2, #15
34003caa:	4332      	orrs	r2, r6
34003cac:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
34003cb0:	f8d3 29cc 	ldr.w	r2, [r3, #2508]	@ 0x9cc
34003cb4:	400a      	ands	r2, r1
34003cb6:	432a      	orrs	r2, r5
34003cb8:	f8c3 29cc 	str.w	r2, [r3, #2508]	@ 0x9cc
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
34003cbc:	1ff2      	subs	r2, r6, #7
34003cbe:	2a01      	cmp	r2, #1
34003cc0:	d806      	bhi.n	34003cd0 <HAL_DCMIPP_PIPE_SetConfig+0x8c>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
34003cc2:	f8d3 29dc 	ldr.w	r2, [r3, #2524]	@ 0x9dc
34003cc6:	400a      	ands	r2, r1
34003cc8:	432a      	orrs	r2, r5
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
34003cca:	f8c3 29dc 	str.w	r2, [r3, #2524]	@ 0x9dc
34003cce:	e7d9      	b.n	34003c84 <HAL_DCMIPP_PIPE_SetConfig+0x40>
    else if (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_3)
34003cd0:	2e09      	cmp	r6, #9
34003cd2:	d1d7      	bne.n	34003c84 <HAL_DCMIPP_PIPE_SetConfig+0x40>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
34003cd4:	f8d3 29dc 	ldr.w	r2, [r3, #2524]	@ 0x9dc
34003cd8:	400a      	ands	r2, r1
34003cda:	ea42 0255 	orr.w	r2, r2, r5, lsr #1
34003cde:	e7f4      	b.n	34003cca <HAL_DCMIPP_PIPE_SetConfig+0x86>
    MODIFY_REG(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_FRATE, pPipeConfig->FrameRate);
34003ce0:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
34003ce4:	f022 0203 	bic.w	r2, r2, #3
34003ce8:	433a      	orrs	r2, r7
34003cea:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
34003cee:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
34003cf2:	f022 020f 	bic.w	r2, r2, #15
34003cf6:	4332      	orrs	r2, r6
34003cf8:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
34003cfc:	f8d3 2dcc 	ldr.w	r2, [r3, #3532]	@ 0xdcc
34003d00:	f36f 020e 	bfc	r2, #0, #15
34003d04:	432a      	orrs	r2, r5
34003d06:	f8c3 2dcc 	str.w	r2, [r3, #3532]	@ 0xdcc
34003d0a:	e7bb      	b.n	34003c84 <HAL_DCMIPP_PIPE_SetConfig+0x40>
    return HAL_ERROR;
34003d0c:	2001      	movs	r0, #1
34003d0e:	e7bb      	b.n	34003c88 <HAL_DCMIPP_PIPE_SetConfig+0x44>
34003d10:	ffff8000 	.word	0xffff8000

34003d14 <HAL_DCMIPP_CSI_PIPE_Start>:
{
34003d14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34003d16:	460e      	mov	r6, r1
34003d18:	461f      	mov	r7, r3
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
34003d1a:	4604      	mov	r4, r0
34003d1c:	b910      	cbnz	r0, 34003d24 <HAL_DCMIPP_CSI_PIPE_Start+0x10>
    return HAL_ERROR;
34003d1e:	2501      	movs	r5, #1
}
34003d20:	4628      	mov	r0, r5
34003d22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
34003d24:	071d      	lsls	r5, r3, #28
34003d26:	d1fa      	bne.n	34003d1e <HAL_DCMIPP_CSI_PIPE_Start+0xa>
  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
34003d28:	6803      	ldr	r3, [r0, #0]
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
34003d2a:	1845      	adds	r5, r0, r1
  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
34003d2c:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
34003d30:	796d      	ldrb	r5, [r5, #5]
34003d32:	2d01      	cmp	r5, #1
34003d34:	d1f3      	bne.n	34003d1e <HAL_DCMIPP_CSI_PIPE_Start+0xa>
34003d36:	07db      	lsls	r3, r3, #31
34003d38:	d5f1      	bpl.n	34003d1e <HAL_DCMIPP_CSI_PIPE_Start+0xa>
  if (DCMIPP_CSI_SetVCConfig(hdcmipp, Pipe, VirtualChannel) != HAL_OK)
34003d3a:	f7ff fd6b 	bl	34003814 <DCMIPP_CSI_SetVCConfig>
34003d3e:	4605      	mov	r5, r0
34003d40:	2800      	cmp	r0, #0
34003d42:	d1ec      	bne.n	34003d1e <HAL_DCMIPP_CSI_PIPE_Start+0xa>
  DCMIPP_SetConfig(hdcmipp, Pipe, DstAddress, CaptureMode);
34003d44:	4631      	mov	r1, r6
34003d46:	4620      	mov	r0, r4
34003d48:	463a      	mov	r2, r7
34003d4a:	9b06      	ldr	r3, [sp, #24]
34003d4c:	f7ff fddd 	bl	3400390a <DCMIPP_SetConfig>
  DCMIPP_EnableCapture(hdcmipp, Pipe);
34003d50:	4631      	mov	r1, r6
34003d52:	4620      	mov	r0, r4
34003d54:	f7ff fe04 	bl	34003960 <DCMIPP_EnableCapture>
  return HAL_OK;
34003d58:	e7e2      	b.n	34003d20 <HAL_DCMIPP_CSI_PIPE_Start+0xc>

34003d5a <HAL_DCMIPP_PIPE_LineEventCallback>:
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
34003d5a:	4770      	bx	lr

34003d5c <HAL_DCMIPP_PIPE_LimitEventCallback>:
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
34003d5c:	4770      	bx	lr

34003d5e <HAL_DCMIPP_PIPE_ErrorCallback>:
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
34003d5e:	4770      	bx	lr

34003d60 <HAL_DCMIPP_ErrorCallback>:
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
34003d60:	4770      	bx	lr

34003d62 <HAL_DCMIPP_IRQHandler>:
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34003d62:	6803      	ldr	r3, [r0, #0]
{
34003d64:	b570      	push	{r4, r5, r6, lr}
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34003d66:	f8d3 63f8 	ldr.w	r6, [r3, #1016]	@ 0x3f8
{
34003d6a:	4604      	mov	r4, r0
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34003d6c:	0472      	lsls	r2, r6, #17
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
34003d6e:	f8d3 53f0 	ldr.w	r5, [r3, #1008]	@ 0x3f0
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34003d72:	d512      	bpl.n	34003d9a <HAL_DCMIPP_IRQHandler+0x38>
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
34003d74:	0469      	lsls	r1, r5, #17
34003d76:	d510      	bpl.n	34003d9a <HAL_DCMIPP_IRQHandler+0x38>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34003d78:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
34003d7c:	2100      	movs	r1, #0
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34003d7e:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34003d82:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
34003d86:	6882      	ldr	r2, [r0, #8]
34003d88:	f042 0204 	orr.w	r2, r2, #4
34003d8c:	6082      	str	r2, [r0, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
34003d8e:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34003d92:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
34003d96:	f7ff ffe1 	bl	34003d5c <HAL_DCMIPP_PIPE_LimitEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
34003d9a:	0572      	lsls	r2, r6, #21
34003d9c:	d50a      	bpl.n	34003db4 <HAL_DCMIPP_IRQHandler+0x52>
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
34003d9e:	056b      	lsls	r3, r5, #21
34003da0:	d508      	bpl.n	34003db4 <HAL_DCMIPP_IRQHandler+0x52>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
34003da2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34003da6:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
34003da8:	2100      	movs	r1, #0
34003daa:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
34003dac:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
34003db0:	f007 f910 	bl	3400afd4 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
34003db4:	05b0      	lsls	r0, r6, #22
34003db6:	d516      	bpl.n	34003de6 <HAL_DCMIPP_IRQHandler+0x84>
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
34003db8:	05a9      	lsls	r1, r5, #22
34003dba:	d514      	bpl.n	34003de6 <HAL_DCMIPP_IRQHandler+0x84>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34003dbc:	6823      	ldr	r3, [r4, #0]
34003dbe:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34003dc2:	0752      	lsls	r2, r2, #29
34003dc4:	d507      	bpl.n	34003dd6 <HAL_DCMIPP_IRQHandler+0x74>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
34003dc6:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34003dca:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
34003dce:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
34003dd2:	2201      	movs	r2, #1
34003dd4:	7162      	strb	r2, [r4, #5]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34003dd6:	f44f 7200 	mov.w	r2, #512	@ 0x200
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
34003dda:	2100      	movs	r1, #0
34003ddc:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34003dde:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
34003de2:	f007 f909 	bl	3400aff8 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
34003de6:	05f3      	lsls	r3, r6, #23
34003de8:	d50a      	bpl.n	34003e00 <HAL_DCMIPP_IRQHandler+0x9e>
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
34003dea:	05e8      	lsls	r0, r5, #23
34003dec:	d508      	bpl.n	34003e00 <HAL_DCMIPP_IRQHandler+0x9e>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
34003dee:	f44f 7280 	mov.w	r2, #256	@ 0x100
34003df2:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34003df4:	2100      	movs	r1, #0
34003df6:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
34003df8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34003dfc:	f7ff ffad 	bl	34003d5a <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
34003e00:	0431      	lsls	r1, r6, #16
34003e02:	d516      	bpl.n	34003e32 <HAL_DCMIPP_IRQHandler+0xd0>
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
34003e04:	042a      	lsls	r2, r5, #16
34003e06:	d514      	bpl.n	34003e32 <HAL_DCMIPP_IRQHandler+0xd0>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34003e08:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34003e0a:	2100      	movs	r1, #0
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34003e0c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34003e10:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34003e12:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34003e16:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
34003e1a:	68a2      	ldr	r2, [r4, #8]
34003e1c:	f042 0208 	orr.w	r2, r2, #8
34003e20:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
34003e22:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34003e26:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
34003e2a:	2304      	movs	r3, #4
34003e2c:	7163      	strb	r3, [r4, #5]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34003e2e:	f7ff ff96 	bl	34003d5e <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34003e32:	03f3      	lsls	r3, r6, #15
34003e34:	d50a      	bpl.n	34003e4c <HAL_DCMIPP_IRQHandler+0xea>
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34003e36:	03e8      	lsls	r0, r5, #15
34003e38:	d508      	bpl.n	34003e4c <HAL_DCMIPP_IRQHandler+0xea>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
34003e3a:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34003e3e:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
34003e40:	2101      	movs	r1, #1
34003e42:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
34003e44:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
34003e48:	f7ff ff87 	bl	34003d5a <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
34003e4c:	0371      	lsls	r1, r6, #13
34003e4e:	d50a      	bpl.n	34003e66 <HAL_DCMIPP_IRQHandler+0x104>
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
34003e50:	036a      	lsls	r2, r5, #13
34003e52:	d508      	bpl.n	34003e66 <HAL_DCMIPP_IRQHandler+0x104>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
34003e54:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34003e58:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34003e5a:	2101      	movs	r1, #1
34003e5c:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
34003e5e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34003e62:	f007 f8b7 	bl	3400afd4 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
34003e66:	03b3      	lsls	r3, r6, #14
34003e68:	d516      	bpl.n	34003e98 <HAL_DCMIPP_IRQHandler+0x136>
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
34003e6a:	03a8      	lsls	r0, r5, #14
34003e6c:	d514      	bpl.n	34003e98 <HAL_DCMIPP_IRQHandler+0x136>
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34003e6e:	6823      	ldr	r3, [r4, #0]
34003e70:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
34003e74:	0751      	lsls	r1, r2, #29
34003e76:	d507      	bpl.n	34003e88 <HAL_DCMIPP_IRQHandler+0x126>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
34003e78:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34003e7c:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
34003e80:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
34003e84:	2201      	movs	r2, #1
34003e86:	71a2      	strb	r2, [r4, #6]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
34003e88:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34003e8c:	2101      	movs	r1, #1
34003e8e:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
34003e90:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34003e94:	f007 f8b0 	bl	3400aff8 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
34003e98:	0232      	lsls	r2, r6, #8
34003e9a:	d516      	bpl.n	34003eca <HAL_DCMIPP_IRQHandler+0x168>
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
34003e9c:	022b      	lsls	r3, r5, #8
34003e9e:	d514      	bpl.n	34003eca <HAL_DCMIPP_IRQHandler+0x168>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34003ea0:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34003ea2:	2101      	movs	r1, #1
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34003ea4:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34003ea8:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34003eaa:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
34003eae:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
34003eb2:	68a2      	ldr	r2, [r4, #8]
34003eb4:	f042 0210 	orr.w	r2, r2, #16
34003eb8:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
34003eba:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
34003ebe:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
34003ec2:	2304      	movs	r3, #4
34003ec4:	71a3      	strb	r3, [r4, #6]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34003ec6:	f7ff ff4a 	bl	34003d5e <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
34003eca:	01f0      	lsls	r0, r6, #7
34003ecc:	d50a      	bpl.n	34003ee4 <HAL_DCMIPP_IRQHandler+0x182>
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
34003ece:	01e9      	lsls	r1, r5, #7
34003ed0:	d508      	bpl.n	34003ee4 <HAL_DCMIPP_IRQHandler+0x182>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
34003ed2:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34003ed6:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
34003ed8:	2102      	movs	r1, #2
34003eda:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
34003edc:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
34003ee0:	f7ff ff3b 	bl	34003d5a <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
34003ee4:	0172      	lsls	r2, r6, #5
34003ee6:	d50a      	bpl.n	34003efe <HAL_DCMIPP_IRQHandler+0x19c>
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
34003ee8:	016b      	lsls	r3, r5, #5
34003eea:	d508      	bpl.n	34003efe <HAL_DCMIPP_IRQHandler+0x19c>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
34003eec:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34003ef0:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
34003ef2:	2102      	movs	r1, #2
34003ef4:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
34003ef6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
34003efa:	f007 f86b 	bl	3400afd4 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
34003efe:	01b0      	lsls	r0, r6, #6
34003f00:	d516      	bpl.n	34003f30 <HAL_DCMIPP_IRQHandler+0x1ce>
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
34003f02:	01a9      	lsls	r1, r5, #6
34003f04:	d514      	bpl.n	34003f30 <HAL_DCMIPP_IRQHandler+0x1ce>
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34003f06:	6823      	ldr	r3, [r4, #0]
34003f08:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
34003f0c:	0752      	lsls	r2, r2, #29
34003f0e:	d507      	bpl.n	34003f20 <HAL_DCMIPP_IRQHandler+0x1be>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
34003f10:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34003f14:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
34003f18:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
34003f1c:	2201      	movs	r2, #1
34003f1e:	71e2      	strb	r2, [r4, #7]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
34003f20:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34003f24:	2102      	movs	r1, #2
34003f26:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
34003f28:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34003f2c:	f007 f864 	bl	3400aff8 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
34003f30:	2e00      	cmp	r6, #0
34003f32:	da16      	bge.n	34003f62 <HAL_DCMIPP_IRQHandler+0x200>
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
34003f34:	2d00      	cmp	r5, #0
34003f36:	da14      	bge.n	34003f62 <HAL_DCMIPP_IRQHandler+0x200>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34003f38:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34003f3a:	2102      	movs	r1, #2
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34003f3c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34003f40:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34003f42:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34003f46:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
34003f4a:	68a2      	ldr	r2, [r4, #8]
34003f4c:	f042 0220 	orr.w	r2, r2, #32
34003f50:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
34003f52:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34003f56:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
34003f5a:	2304      	movs	r3, #4
34003f5c:	71e3      	strb	r3, [r4, #7]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34003f5e:	f7ff fefe 	bl	34003d5e <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
34003f62:	0670      	lsls	r0, r6, #25
34003f64:	d514      	bpl.n	34003f90 <HAL_DCMIPP_IRQHandler+0x22e>
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
34003f66:	0669      	lsls	r1, r5, #25
34003f68:	d512      	bpl.n	34003f90 <HAL_DCMIPP_IRQHandler+0x22e>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34003f6a:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34003f6c:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34003f6e:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34003f72:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34003f76:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
34003f7a:	68a2      	ldr	r2, [r4, #8]
34003f7c:	f042 0202 	orr.w	r2, r2, #2
34003f80:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
34003f82:	2240      	movs	r2, #64	@ 0x40
34003f84:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34003f88:	2304      	movs	r3, #4
34003f8a:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34003f8c:	f7ff fee8 	bl	34003d60 <HAL_DCMIPP_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
34003f90:	06b2      	lsls	r2, r6, #26
34003f92:	d514      	bpl.n	34003fbe <HAL_DCMIPP_IRQHandler+0x25c>
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
34003f94:	06ab      	lsls	r3, r5, #26
34003f96:	d512      	bpl.n	34003fbe <HAL_DCMIPP_IRQHandler+0x25c>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
34003f98:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34003f9a:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
34003f9c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34003fa0:	f022 0220 	bic.w	r2, r2, #32
34003fa4:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
34003fa8:	68a2      	ldr	r2, [r4, #8]
34003faa:	f042 0201 	orr.w	r2, r2, #1
34003fae:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
34003fb0:	2220      	movs	r2, #32
34003fb2:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34003fb6:	2304      	movs	r3, #4
34003fb8:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34003fba:	f7ff fed1 	bl	34003d60 <HAL_DCMIPP_ErrorCallback>
}
34003fbe:	bd70      	pop	{r4, r5, r6, pc}

34003fc0 <HAL_DCMIPP_PIPE_SetCropConfig>:
{
34003fc0:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
34003fc2:	2800      	cmp	r0, #0
34003fc4:	d05b      	beq.n	3400407e <HAL_DCMIPP_PIPE_SetCropConfig+0xbe>
34003fc6:	2a00      	cmp	r2, #0
34003fc8:	d059      	beq.n	3400407e <HAL_DCMIPP_PIPE_SetCropConfig+0xbe>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34003fca:	7903      	ldrb	r3, [r0, #4]
34003fcc:	2b02      	cmp	r3, #2
34003fce:	d156      	bne.n	3400407e <HAL_DCMIPP_PIPE_SetCropConfig+0xbe>
    if (Pipe == DCMIPP_PIPE0)
34003fd0:	bb09      	cbnz	r1, 34004016 <HAL_DCMIPP_PIPE_SetCropConfig+0x56>
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34003fd2:	6801      	ldr	r1, [r0, #0]
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34003fd4:	4b2b      	ldr	r3, [pc, #172]	@ (34004084 <HAL_DCMIPP_PIPE_SetCropConfig+0xc4>)
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34003fd6:	f8d1 0104 	ldr.w	r0, [r1, #260]	@ 0x104
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34003fda:	4003      	ands	r3, r0
34003fdc:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34003fe0:	d04d      	beq.n	3400407e <HAL_DCMIPP_PIPE_SetCropConfig+0xbe>
        MODIFY_REG(hdcmipp->Instance->P0SCSTR, DCMIPP_P0SCSTR_HSTART | DCMIPP_P0SCSTR_VSTART,
34003fe2:	e9d2 4300 	ldrd	r4, r3, [r2]
34003fe6:	f8d1 0504 	ldr.w	r0, [r1, #1284]	@ 0x504
34003fea:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
34003fee:	f000 20f0 	and.w	r0, r0, #4026593280	@ 0xf000f000
34003ff2:	4303      	orrs	r3, r0
34003ff4:	f8c1 3504 	str.w	r3, [r1, #1284]	@ 0x504
        MODIFY_REG(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_HSIZE | DCMIPP_P0SCSZR_VSIZE | DCMIPP_P0SCSZR_POSNEG,
34003ff8:	e9d2 3403 	ldrd	r3, r4, [r2, #12]
34003ffc:	6892      	ldr	r2, [r2, #8]
34003ffe:	4323      	orrs	r3, r4
34004000:	f8d1 0508 	ldr.w	r0, [r1, #1288]	@ 0x508
34004004:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
34004008:	4a1f      	ldr	r2, [pc, #124]	@ (34004088 <HAL_DCMIPP_PIPE_SetCropConfig+0xc8>)
3400400a:	4002      	ands	r2, r0
3400400c:	4313      	orrs	r3, r2
3400400e:	f8c1 3508 	str.w	r3, [r1, #1288]	@ 0x508
  return HAL_OK;
34004012:	2000      	movs	r0, #0
}
34004014:	bd10      	pop	{r4, pc}
    else if (Pipe == DCMIPP_PIPE1)
34004016:	2901      	cmp	r1, #1
34004018:	d117      	bne.n	3400404a <HAL_DCMIPP_PIPE_SetCropConfig+0x8a>
      MODIFY_REG(hdcmipp->Instance->P1CRSTR, DCMIPP_P1CRSTR_HSTART | DCMIPP_P1CRSTR_VSTART,
3400401a:	e9d2 4300 	ldrd	r4, r3, [r2]
3400401e:	6801      	ldr	r1, [r0, #0]
34004020:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
34004024:	f8d1 0904 	ldr.w	r0, [r1, #2308]	@ 0x904
34004028:	f000 20f0 	and.w	r0, r0, #4026593280	@ 0xf000f000
3400402c:	4303      	orrs	r3, r0
3400402e:	f8c1 3904 	str.w	r3, [r1, #2308]	@ 0x904
      MODIFY_REG(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_HSIZE | DCMIPP_P1CRSZR_VSIZE,
34004032:	f8d1 0908 	ldr.w	r0, [r1, #2312]	@ 0x908
34004036:	e9d2 4302 	ldrd	r4, r3, [r2, #8]
3400403a:	f000 22f0 	and.w	r2, r0, #4026593280	@ 0xf000f000
3400403e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
34004042:	4313      	orrs	r3, r2
34004044:	f8c1 3908 	str.w	r3, [r1, #2312]	@ 0x908
34004048:	e7e3      	b.n	34004012 <HAL_DCMIPP_PIPE_SetCropConfig+0x52>
    else if (Pipe == DCMIPP_PIPE2)
3400404a:	2902      	cmp	r1, #2
3400404c:	d117      	bne.n	3400407e <HAL_DCMIPP_PIPE_SetCropConfig+0xbe>
      MODIFY_REG(hdcmipp->Instance->P2CRSTR, DCMIPP_P2CRSTR_HSTART | DCMIPP_P2CRSTR_VSTART,
3400404e:	e9d2 4300 	ldrd	r4, r3, [r2]
34004052:	6801      	ldr	r1, [r0, #0]
34004054:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
34004058:	f8d1 0d04 	ldr.w	r0, [r1, #3332]	@ 0xd04
3400405c:	f000 20f0 	and.w	r0, r0, #4026593280	@ 0xf000f000
34004060:	4303      	orrs	r3, r0
34004062:	f8c1 3d04 	str.w	r3, [r1, #3332]	@ 0xd04
      MODIFY_REG(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_HSIZE | DCMIPP_P2CRSZR_VSIZE,
34004066:	f8d1 0d08 	ldr.w	r0, [r1, #3336]	@ 0xd08
3400406a:	e9d2 4302 	ldrd	r4, r3, [r2, #8]
3400406e:	f000 22f0 	and.w	r2, r0, #4026593280	@ 0xf000f000
34004072:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
34004076:	4313      	orrs	r3, r2
34004078:	f8c1 3d08 	str.w	r3, [r1, #3336]	@ 0xd08
3400407c:	e7c9      	b.n	34004012 <HAL_DCMIPP_PIPE_SetCropConfig+0x52>
    return HAL_ERROR;
3400407e:	2001      	movs	r0, #1
34004080:	e7c8      	b.n	34004014 <HAL_DCMIPP_PIPE_SetCropConfig+0x54>
34004082:	bf00      	nop
34004084:	00ff4000 	.word	0x00ff4000
34004088:	b000f000 	.word	0xb000f000

3400408c <HAL_DCMIPP_PIPE_EnableCrop>:
  if (hdcmipp == NULL)
3400408c:	b368      	cbz	r0, 340040ea <HAL_DCMIPP_PIPE_EnableCrop+0x5e>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
3400408e:	7903      	ldrb	r3, [r0, #4]
34004090:	2b02      	cmp	r3, #2
34004092:	d12a      	bne.n	340040ea <HAL_DCMIPP_PIPE_EnableCrop+0x5e>
    if (Pipe == DCMIPP_PIPE0)
34004094:	b979      	cbnz	r1, 340040b6 <HAL_DCMIPP_PIPE_EnableCrop+0x2a>
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34004096:	6803      	ldr	r3, [r0, #0]
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34004098:	4a15      	ldr	r2, [pc, #84]	@ (340040f0 <HAL_DCMIPP_PIPE_EnableCrop+0x64>)
      tmp = READ_REG(hdcmipp->Instance->PRCR);
3400409a:	f8d3 1104 	ldr.w	r1, [r3, #260]	@ 0x104
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
3400409e:	400a      	ands	r2, r1
340040a0:	f5b2 4f80 	cmp.w	r2, #16384	@ 0x4000
340040a4:	d021      	beq.n	340040ea <HAL_DCMIPP_PIPE_EnableCrop+0x5e>
        SET_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
340040a6:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
340040aa:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
340040ae:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
  return HAL_OK;
340040b2:	2000      	movs	r0, #0
340040b4:	4770      	bx	lr
    else if (Pipe == DCMIPP_PIPE1)
340040b6:	2901      	cmp	r1, #1
340040b8:	d10d      	bne.n	340040d6 <HAL_DCMIPP_PIPE_EnableCrop+0x4a>
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
340040ba:	6803      	ldr	r3, [r0, #0]
    return HAL_ERROR;
340040bc:	4608      	mov	r0, r1
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
340040be:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
340040c2:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
340040c6:	d011      	beq.n	340040ec <HAL_DCMIPP_PIPE_EnableCrop+0x60>
        SET_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
340040c8:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
340040cc:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
340040d0:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
340040d4:	e7ed      	b.n	340040b2 <HAL_DCMIPP_PIPE_EnableCrop+0x26>
    else if (Pipe == DCMIPP_PIPE2)
340040d6:	2902      	cmp	r1, #2
340040d8:	d107      	bne.n	340040ea <HAL_DCMIPP_PIPE_EnableCrop+0x5e>
      SET_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
340040da:	6802      	ldr	r2, [r0, #0]
340040dc:	f8d2 3d08 	ldr.w	r3, [r2, #3336]	@ 0xd08
340040e0:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
340040e4:	f8c2 3d08 	str.w	r3, [r2, #3336]	@ 0xd08
340040e8:	e7e3      	b.n	340040b2 <HAL_DCMIPP_PIPE_EnableCrop+0x26>
    return HAL_ERROR;
340040ea:	2001      	movs	r0, #1
}
340040ec:	4770      	bx	lr
340040ee:	bf00      	nop
340040f0:	00ff4000 	.word	0x00ff4000

340040f4 <HAL_DCMIPP_PIPE_DisableCrop>:
  if (hdcmipp == NULL)
340040f4:	b1e8      	cbz	r0, 34004132 <HAL_DCMIPP_PIPE_DisableCrop+0x3e>
  if (Pipe == DCMIPP_PIPE0)
340040f6:	b941      	cbnz	r1, 3400410a <HAL_DCMIPP_PIPE_DisableCrop+0x16>
    CLEAR_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
340040f8:	6802      	ldr	r2, [r0, #0]
340040fa:	f8d2 3508 	ldr.w	r3, [r2, #1288]	@ 0x508
340040fe:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34004102:	f8c2 3508 	str.w	r3, [r2, #1288]	@ 0x508
  return HAL_OK;
34004106:	2000      	movs	r0, #0
34004108:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE1)
3400410a:	2901      	cmp	r1, #1
3400410c:	d107      	bne.n	3400411e <HAL_DCMIPP_PIPE_DisableCrop+0x2a>
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
3400410e:	6802      	ldr	r2, [r0, #0]
34004110:	f8d2 3908 	ldr.w	r3, [r2, #2312]	@ 0x908
34004114:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34004118:	f8c2 3908 	str.w	r3, [r2, #2312]	@ 0x908
3400411c:	e7f3      	b.n	34004106 <HAL_DCMIPP_PIPE_DisableCrop+0x12>
  else if (Pipe == DCMIPP_PIPE2)
3400411e:	2902      	cmp	r1, #2
34004120:	d107      	bne.n	34004132 <HAL_DCMIPP_PIPE_DisableCrop+0x3e>
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34004122:	6802      	ldr	r2, [r0, #0]
34004124:	f8d2 3d08 	ldr.w	r3, [r2, #3336]	@ 0xd08
34004128:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400412c:	f8c2 3d08 	str.w	r3, [r2, #3336]	@ 0xd08
34004130:	e7e9      	b.n	34004106 <HAL_DCMIPP_PIPE_DisableCrop+0x12>
    return HAL_ERROR;
34004132:	2001      	movs	r0, #1
}
34004134:	4770      	bx	lr

34004136 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>:
  if ((hdcmipp == NULL) || (pDecConfig == NULL))
34004136:	b190      	cbz	r0, 3400415e <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x28>
34004138:	b18a      	cbz	r2, 3400415e <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x28>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
3400413a:	7903      	ldrb	r3, [r0, #4]
3400413c:	2b02      	cmp	r3, #2
3400413e:	d10e      	bne.n	3400415e <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x28>
    if (Pipe == DCMIPP_PIPE1)
34004140:	2901      	cmp	r1, #1
34004142:	d10c      	bne.n	3400415e <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x28>
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
34004144:	e9d2 3200 	ldrd	r3, r2, [r2]
34004148:	6800      	ldr	r0, [r0, #0]
3400414a:	4313      	orrs	r3, r2
3400414c:	f8d0 1830 	ldr.w	r1, [r0, #2096]	@ 0x830
34004150:	f021 021e 	bic.w	r2, r1, #30
34004154:	4313      	orrs	r3, r2
34004156:	f8c0 3830 	str.w	r3, [r0, #2096]	@ 0x830
  return HAL_OK;
3400415a:	2000      	movs	r0, #0
3400415c:	4770      	bx	lr
    return HAL_ERROR;
3400415e:	2001      	movs	r0, #1
}
34004160:	4770      	bx	lr

34004162 <HAL_DCMIPP_PIPE_EnableISPDecimation>:
  if (hdcmipp == NULL)
34004162:	b150      	cbz	r0, 3400417a <HAL_DCMIPP_PIPE_EnableISPDecimation+0x18>
  if (Pipe == DCMIPP_PIPE1)
34004164:	2901      	cmp	r1, #1
34004166:	d108      	bne.n	3400417a <HAL_DCMIPP_PIPE_EnableISPDecimation+0x18>
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
34004168:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400416a:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
3400416c:	f8d2 3830 	ldr.w	r3, [r2, #2096]	@ 0x830
34004170:	f043 0301 	orr.w	r3, r3, #1
34004174:	f8c2 3830 	str.w	r3, [r2, #2096]	@ 0x830
  return HAL_OK;
34004178:	4770      	bx	lr
    return HAL_ERROR;
3400417a:	2001      	movs	r0, #1
}
3400417c:	4770      	bx	lr

3400417e <HAL_DCMIPP_PIPE_SetDecimationConfig>:
  if (hdcmipp == NULL)
3400417e:	b1f8      	cbz	r0, 340041c0 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x42>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34004180:	7903      	ldrb	r3, [r0, #4]
34004182:	2b02      	cmp	r3, #2
34004184:	d11c      	bne.n	340041c0 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x42>
    if (Pipe == DCMIPP_PIPE1)
34004186:	2901      	cmp	r1, #1
34004188:	d10c      	bne.n	340041a4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x26>
      MODIFY_REG(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_VDEC | DCMIPP_P1DCCR_HDEC,
3400418a:	e9d2 3200 	ldrd	r3, r2, [r2]
3400418e:	6800      	ldr	r0, [r0, #0]
34004190:	4313      	orrs	r3, r2
34004192:	f8d0 190c 	ldr.w	r1, [r0, #2316]	@ 0x90c
34004196:	f021 021e 	bic.w	r2, r1, #30
3400419a:	4313      	orrs	r3, r2
3400419c:	f8c0 390c 	str.w	r3, [r0, #2316]	@ 0x90c
  return HAL_OK;
340041a0:	2000      	movs	r0, #0
340041a2:	4770      	bx	lr
    else if (Pipe == DCMIPP_PIPE2)
340041a4:	2902      	cmp	r1, #2
340041a6:	d10b      	bne.n	340041c0 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x42>
      MODIFY_REG(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_VDEC | DCMIPP_P2DCCR_HDEC,
340041a8:	e9d2 3200 	ldrd	r3, r2, [r2]
340041ac:	6800      	ldr	r0, [r0, #0]
340041ae:	4313      	orrs	r3, r2
340041b0:	f8d0 1d0c 	ldr.w	r1, [r0, #3340]	@ 0xd0c
340041b4:	f021 021e 	bic.w	r2, r1, #30
340041b8:	4313      	orrs	r3, r2
340041ba:	f8c0 3d0c 	str.w	r3, [r0, #3340]	@ 0xd0c
340041be:	e7ef      	b.n	340041a0 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x22>
    return HAL_ERROR;
340041c0:	2001      	movs	r0, #1
}
340041c2:	4770      	bx	lr

340041c4 <HAL_DCMIPP_PIPE_EnableDecimation>:
  if (hdcmipp == NULL)
340041c4:	b1a0      	cbz	r0, 340041f0 <HAL_DCMIPP_PIPE_EnableDecimation+0x2c>
  if (Pipe == DCMIPP_PIPE1)
340041c6:	2901      	cmp	r1, #1
340041c8:	d108      	bne.n	340041dc <HAL_DCMIPP_PIPE_EnableDecimation+0x18>
    SET_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
340041ca:	6802      	ldr	r2, [r0, #0]
340041cc:	f8d2 390c 	ldr.w	r3, [r2, #2316]	@ 0x90c
340041d0:	f043 0301 	orr.w	r3, r3, #1
340041d4:	f8c2 390c 	str.w	r3, [r2, #2316]	@ 0x90c
  return HAL_OK;
340041d8:	2000      	movs	r0, #0
340041da:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE2)
340041dc:	2902      	cmp	r1, #2
340041de:	d107      	bne.n	340041f0 <HAL_DCMIPP_PIPE_EnableDecimation+0x2c>
    SET_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
340041e0:	6802      	ldr	r2, [r0, #0]
340041e2:	f8d2 3d0c 	ldr.w	r3, [r2, #3340]	@ 0xd0c
340041e6:	f043 0301 	orr.w	r3, r3, #1
340041ea:	f8c2 3d0c 	str.w	r3, [r2, #3340]	@ 0xd0c
340041ee:	e7f3      	b.n	340041d8 <HAL_DCMIPP_PIPE_EnableDecimation+0x14>
    return HAL_ERROR;
340041f0:	2001      	movs	r0, #1
}
340041f2:	4770      	bx	lr

340041f4 <HAL_DCMIPP_PIPE_DisableDecimation>:
  if (hdcmipp == NULL)
340041f4:	b1a0      	cbz	r0, 34004220 <HAL_DCMIPP_PIPE_DisableDecimation+0x2c>
  if (Pipe == DCMIPP_PIPE1)
340041f6:	2901      	cmp	r1, #1
340041f8:	d108      	bne.n	3400420c <HAL_DCMIPP_PIPE_DisableDecimation+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
340041fa:	6802      	ldr	r2, [r0, #0]
340041fc:	f8d2 390c 	ldr.w	r3, [r2, #2316]	@ 0x90c
34004200:	f023 0301 	bic.w	r3, r3, #1
34004204:	f8c2 390c 	str.w	r3, [r2, #2316]	@ 0x90c
  return HAL_OK;
34004208:	2000      	movs	r0, #0
3400420a:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE2)
3400420c:	2902      	cmp	r1, #2
3400420e:	d107      	bne.n	34004220 <HAL_DCMIPP_PIPE_DisableDecimation+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
34004210:	6802      	ldr	r2, [r0, #0]
34004212:	f8d2 3d0c 	ldr.w	r3, [r2, #3340]	@ 0xd0c
34004216:	f023 0301 	bic.w	r3, r3, #1
3400421a:	f8c2 3d0c 	str.w	r3, [r2, #3340]	@ 0xd0c
3400421e:	e7f3      	b.n	34004208 <HAL_DCMIPP_PIPE_DisableDecimation+0x14>
    return HAL_ERROR;
34004220:	2001      	movs	r0, #1
}
34004222:	4770      	bx	lr

34004224 <HAL_DCMIPP_PIPE_SetDownsizeConfig>:
{
34004224:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
34004226:	2800      	cmp	r0, #0
34004228:	d045      	beq.n	340042b6 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x92>
3400422a:	2a00      	cmp	r2, #0
3400422c:	d043      	beq.n	340042b6 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x92>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
3400422e:	7903      	ldrb	r3, [r0, #4]
34004230:	2b02      	cmp	r3, #2
34004232:	d140      	bne.n	340042b6 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x92>
    if (Pipe == DCMIPP_PIPE1)
34004234:	2901      	cmp	r1, #1
34004236:	d11e      	bne.n	34004276 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x52>
      MODIFY_REG(hdcmipp->Instance->P1DSCR, (DCMIPP_P1DSCR_HDIV | DCMIPP_P1DSCR_VDIV),
34004238:	e9d2 4104 	ldrd	r4, r1, [r2, #16]
3400423c:	6803      	ldr	r3, [r0, #0]
3400423e:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
34004242:	f8d3 0910 	ldr.w	r0, [r3, #2320]	@ 0x910
34004246:	f000 20fc 	and.w	r0, r0, #4227922944	@ 0xfc00fc00
3400424a:	4301      	orrs	r1, r0
3400424c:	f8c3 1910 	str.w	r1, [r3, #2320]	@ 0x910
      WRITE_REG(hdcmipp->Instance->P1DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P1DSRTIOR_HRATIO_Pos) | \
34004250:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
34004254:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
34004258:	f8c3 1914 	str.w	r1, [r3, #2324]	@ 0x914
      MODIFY_REG(hdcmipp->Instance->P1DSSZR, DCMIPP_P1DSSZR_HSIZE | DCMIPP_P1DSSZR_VSIZE,
3400425c:	f8d3 1918 	ldr.w	r1, [r3, #2328]	@ 0x918
34004260:	e9d2 0200 	ldrd	r0, r2, [r2]
34004264:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34004268:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3400426c:	430a      	orrs	r2, r1
3400426e:	f8c3 2918 	str.w	r2, [r3, #2328]	@ 0x918
  return HAL_OK;
34004272:	2000      	movs	r0, #0
}
34004274:	bd10      	pop	{r4, pc}
    else if (Pipe == DCMIPP_PIPE2)
34004276:	2902      	cmp	r1, #2
34004278:	d11d      	bne.n	340042b6 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x92>
      MODIFY_REG(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_HDIV | DCMIPP_P2DSCR_VDIV,
3400427a:	e9d2 4104 	ldrd	r4, r1, [r2, #16]
3400427e:	6803      	ldr	r3, [r0, #0]
34004280:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
34004284:	f8d3 0d10 	ldr.w	r0, [r3, #3344]	@ 0xd10
34004288:	f000 20fc 	and.w	r0, r0, #4227922944	@ 0xfc00fc00
3400428c:	4301      	orrs	r1, r0
3400428e:	f8c3 1d10 	str.w	r1, [r3, #3344]	@ 0xd10
      WRITE_REG(hdcmipp->Instance->P2DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P2DSRTIOR_HRATIO_Pos) | \
34004292:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
34004296:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
3400429a:	f8c3 1d14 	str.w	r1, [r3, #3348]	@ 0xd14
      MODIFY_REG(hdcmipp->Instance->P2DSSZR, DCMIPP_P2DSSZR_HSIZE | DCMIPP_P2DSSZR_VSIZE,
3400429e:	f8d3 1d18 	ldr.w	r1, [r3, #3352]	@ 0xd18
340042a2:	e9d2 0200 	ldrd	r0, r2, [r2]
340042a6:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
340042aa:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340042ae:	430a      	orrs	r2, r1
340042b0:	f8c3 2d18 	str.w	r2, [r3, #3352]	@ 0xd18
340042b4:	e7dd      	b.n	34004272 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x4e>
    return HAL_ERROR;
340042b6:	2001      	movs	r0, #1
340042b8:	e7dc      	b.n	34004274 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x50>

340042ba <HAL_DCMIPP_PIPE_EnableDownsize>:
  if (hdcmipp == NULL)
340042ba:	b1a0      	cbz	r0, 340042e6 <HAL_DCMIPP_PIPE_EnableDownsize+0x2c>
  if (Pipe == DCMIPP_PIPE1)
340042bc:	2901      	cmp	r1, #1
340042be:	d108      	bne.n	340042d2 <HAL_DCMIPP_PIPE_EnableDownsize+0x18>
    SET_BIT(hdcmipp->Instance->P1DSCR, DCMIPP_P1DSCR_ENABLE);
340042c0:	6802      	ldr	r2, [r0, #0]
340042c2:	f8d2 3910 	ldr.w	r3, [r2, #2320]	@ 0x910
340042c6:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
340042ca:	f8c2 3910 	str.w	r3, [r2, #2320]	@ 0x910
  return HAL_OK;
340042ce:	2000      	movs	r0, #0
340042d0:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE2)
340042d2:	2902      	cmp	r1, #2
340042d4:	d107      	bne.n	340042e6 <HAL_DCMIPP_PIPE_EnableDownsize+0x2c>
    SET_BIT(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_ENABLE);
340042d6:	6802      	ldr	r2, [r0, #0]
340042d8:	f8d2 3d10 	ldr.w	r3, [r2, #3344]	@ 0xd10
340042dc:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
340042e0:	f8c2 3d10 	str.w	r3, [r2, #3344]	@ 0xd10
340042e4:	e7f3      	b.n	340042ce <HAL_DCMIPP_PIPE_EnableDownsize+0x14>
    return HAL_ERROR;
340042e6:	2001      	movs	r0, #1
}
340042e8:	4770      	bx	lr

340042ea <HAL_DCMIPP_PIPE_EnableGammaConversion>:
  if (hdcmipp == NULL)
340042ea:	b1a0      	cbz	r0, 34004316 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x2c>
  if (Pipe == DCMIPP_PIPE1)
340042ec:	2901      	cmp	r1, #1
340042ee:	d108      	bne.n	34004302 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x18>
    SET_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
340042f0:	6802      	ldr	r2, [r0, #0]
340042f2:	f8d2 3970 	ldr.w	r3, [r2, #2416]	@ 0x970
340042f6:	f043 0301 	orr.w	r3, r3, #1
340042fa:	f8c2 3970 	str.w	r3, [r2, #2416]	@ 0x970
  return HAL_OK;
340042fe:	2000      	movs	r0, #0
34004300:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE2)
34004302:	2902      	cmp	r1, #2
34004304:	d107      	bne.n	34004316 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x2c>
    SET_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34004306:	6802      	ldr	r2, [r0, #0]
34004308:	f8d2 3d70 	ldr.w	r3, [r2, #3440]	@ 0xd70
3400430c:	f043 0301 	orr.w	r3, r3, #1
34004310:	f8c2 3d70 	str.w	r3, [r2, #3440]	@ 0xd70
34004314:	e7f3      	b.n	340042fe <HAL_DCMIPP_PIPE_EnableGammaConversion+0x14>
    return HAL_ERROR;
34004316:	2001      	movs	r0, #1
}
34004318:	4770      	bx	lr

3400431a <HAL_DCMIPP_PIPE_DisableGammaConversion>:
  if (hdcmipp == NULL)
3400431a:	b1a0      	cbz	r0, 34004346 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x2c>
  if (Pipe == DCMIPP_PIPE1)
3400431c:	2901      	cmp	r1, #1
3400431e:	d108      	bne.n	34004332 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
34004320:	6802      	ldr	r2, [r0, #0]
34004322:	f8d2 3970 	ldr.w	r3, [r2, #2416]	@ 0x970
34004326:	f023 0301 	bic.w	r3, r3, #1
3400432a:	f8c2 3970 	str.w	r3, [r2, #2416]	@ 0x970
  return HAL_OK;
3400432e:	2000      	movs	r0, #0
34004330:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE2)
34004332:	2902      	cmp	r1, #2
34004334:	d107      	bne.n	34004346 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34004336:	6802      	ldr	r2, [r0, #0]
34004338:	f8d2 3d70 	ldr.w	r3, [r2, #3440]	@ 0xd70
3400433c:	f023 0301 	bic.w	r3, r3, #1
34004340:	f8c2 3d70 	str.w	r3, [r2, #3440]	@ 0xd70
34004344:	e7f3      	b.n	3400432e <HAL_DCMIPP_PIPE_DisableGammaConversion+0x14>
    return HAL_ERROR;
34004346:	2001      	movs	r0, #1
}
34004348:	4770      	bx	lr

3400434a <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>:
  if (Pipe == DCMIPP_PIPE1)
3400434a:	2901      	cmp	r1, #1
3400434c:	d105      	bne.n	3400435a <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x10>
    return ((READ_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE) == DCMIPP_P1GMCR_ENABLE) ? 1U : 0U);
3400434e:	6803      	ldr	r3, [r0, #0]
34004350:	f8d3 0970 	ldr.w	r0, [r3, #2416]	@ 0x970
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
34004354:	f000 0001 	and.w	r0, r0, #1
34004358:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE2)
3400435a:	2902      	cmp	r1, #2
3400435c:	d103      	bne.n	34004366 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x1c>
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
3400435e:	6803      	ldr	r3, [r0, #0]
34004360:	f8d3 0d70 	ldr.w	r0, [r3, #3440]	@ 0xd70
34004364:	e7f6      	b.n	34004354 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0xa>
    return 0;
34004366:	2000      	movs	r0, #0
}
34004368:	4770      	bx	lr
	...

3400436c <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>:
{
3400436c:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
3400436e:	b1c8      	cbz	r0, 340043a4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x38>
34004370:	b1c2      	cbz	r2, 340043a4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x38>
  if (Pipe == DCMIPP_PIPE1)
34004372:	2901      	cmp	r1, #1
34004374:	d116      	bne.n	340043a4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x38>
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
34004376:	e9d2 4303 	ldrd	r4, r3, [r2, #12]
3400437a:	071b      	lsls	r3, r3, #28
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
3400437c:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
34004380:	6894      	ldr	r4, [r2, #8]
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
34004382:	6801      	ldr	r1, [r0, #0]
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
34004384:	4323      	orrs	r3, r4
                  (pRawBayer2RGBConfig->VLineStrength << DCMIPP_P1DMCR_LINEV_Pos)   | \
34004386:	6814      	ldr	r4, [r2, #0]
                  (pRawBayer2RGBConfig->HLineStrength << DCMIPP_P1DMCR_LINEH_Pos));
34004388:	6852      	ldr	r2, [r2, #4]
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
3400438a:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
3400438e:	f8d1 0870 	ldr.w	r0, [r1, #2160]	@ 0x870
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
34004392:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
34004396:	4a04      	ldr	r2, [pc, #16]	@ (340043a8 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x3c>)
34004398:	4002      	ands	r2, r0
  return HAL_OK;
3400439a:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
3400439c:	4313      	orrs	r3, r2
3400439e:	f8c1 3870 	str.w	r3, [r1, #2160]	@ 0x870
}
340043a2:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
340043a4:	2001      	movs	r0, #1
340043a6:	e7fc      	b.n	340043a2 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x36>
340043a8:	8888fff9 	.word	0x8888fff9

340043ac <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>:
  if (hdcmipp == NULL)
340043ac:	b150      	cbz	r0, 340043c4 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x18>
  if (Pipe == DCMIPP_PIPE1)
340043ae:	2901      	cmp	r1, #1
340043b0:	d108      	bne.n	340043c4 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x18>
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
340043b2:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340043b4:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
340043b6:	f8d2 3870 	ldr.w	r3, [r2, #2160]	@ 0x870
340043ba:	f043 0301 	orr.w	r3, r3, #1
340043be:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  return HAL_OK;
340043c2:	4770      	bx	lr
    return HAL_ERROR;
340043c4:	2001      	movs	r0, #1
}
340043c6:	4770      	bx	lr

340043c8 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>:
  if (hdcmipp == NULL)
340043c8:	b150      	cbz	r0, 340043e0 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x18>
  if (Pipe == DCMIPP_PIPE1)
340043ca:	2901      	cmp	r1, #1
340043cc:	d108      	bne.n	340043e0 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
340043ce:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340043d0:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
340043d2:	f8d2 3870 	ldr.w	r3, [r2, #2160]	@ 0x870
340043d6:	f023 0301 	bic.w	r3, r3, #1
340043da:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  return HAL_OK;
340043de:	4770      	bx	lr
    return HAL_ERROR;
340043e0:	2001      	movs	r0, #1
}
340043e2:	4770      	bx	lr

340043e4 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>:
  if (hdcmipp == NULL)
340043e4:	b178      	cbz	r0, 34004406 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x22>
  if (Pipe == DCMIPP_PIPE1)
340043e6:	2901      	cmp	r1, #1
340043e8:	d10d      	bne.n	34004406 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x22>
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
340043ea:	6800      	ldr	r0, [r0, #0]
    p1srcr_reg = ((NbFirstLines << DCMIPP_P1SRCR_FIRSTLINEDEL_Pos) | (NbLastLines << DCMIPP_P1SRCR_LASTLINE_Pos));
340043ec:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
340043f0:	f8d0 1820 	ldr.w	r1, [r0, #2080]	@ 0x820
340043f4:	f421 42ff 	bic.w	r2, r1, #32640	@ 0x7f80
340043f8:	f022 027f 	bic.w	r2, r2, #127	@ 0x7f
340043fc:	4313      	orrs	r3, r2
340043fe:	f8c0 3820 	str.w	r3, [r0, #2080]	@ 0x820
  return HAL_OK;
34004402:	2000      	movs	r0, #0
34004404:	4770      	bx	lr
    return HAL_ERROR;
34004406:	2001      	movs	r0, #1
}
34004408:	4770      	bx	lr

3400440a <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>:
  if (hdcmipp == NULL)
3400440a:	b150      	cbz	r0, 34004422 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x18>
  if (Pipe == DCMIPP_PIPE1)
3400440c:	2901      	cmp	r1, #1
3400440e:	d108      	bne.n	34004422 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x18>
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
34004410:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34004412:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
34004414:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
34004418:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400441c:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
34004420:	4770      	bx	lr
    return HAL_ERROR;
34004422:	2001      	movs	r0, #1
}
34004424:	4770      	bx	lr

34004426 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>:
  if (hdcmipp == NULL)
34004426:	b150      	cbz	r0, 3400443e <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x18>
  if (Pipe == DCMIPP_PIPE1)
34004428:	2901      	cmp	r1, #1
3400442a:	d108      	bne.n	3400443e <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
3400442c:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400442e:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
34004430:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
34004434:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34004438:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
3400443c:	4770      	bx	lr
    return HAL_ERROR;
3400443e:	2001      	movs	r0, #1
}
34004440:	4770      	bx	lr

34004442 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>:
  if (hdcmipp == NULL)
34004442:	b160      	cbz	r0, 3400445e <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x1c>
  if (Pipe == DCMIPP_PIPE1)
34004444:	2901      	cmp	r1, #1
34004446:	d10a      	bne.n	3400445e <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x1c>
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
34004448:	6801      	ldr	r1, [r0, #0]
  return HAL_OK;
3400444a:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
3400444c:	f8d1 3824 	ldr.w	r3, [r1, #2084]	@ 0x824
34004450:	f023 030e 	bic.w	r3, r3, #14
34004454:	ea43 0242 	orr.w	r2, r3, r2, lsl #1
34004458:	f8c1 2824 	str.w	r2, [r1, #2084]	@ 0x824
  return HAL_OK;
3400445c:	4770      	bx	lr
    return HAL_ERROR;
3400445e:	2001      	movs	r0, #1
}
34004460:	4770      	bx	lr

34004462 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>:
  if (hdcmipp == NULL)
34004462:	b150      	cbz	r0, 3400447a <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x18>
  if (Pipe == DCMIPP_PIPE1)
34004464:	2901      	cmp	r1, #1
34004466:	d108      	bne.n	3400447a <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x18>
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34004468:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400446a:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
3400446c:	f8d2 3824 	ldr.w	r3, [r2, #2084]	@ 0x824
34004470:	f043 0301 	orr.w	r3, r3, #1
34004474:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  return HAL_OK;
34004478:	4770      	bx	lr
    return HAL_ERROR;
3400447a:	2001      	movs	r0, #1
}
3400447c:	4770      	bx	lr

3400447e <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>:
  if (hdcmipp == NULL)
3400447e:	b150      	cbz	r0, 34004496 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x18>
  if (Pipe == DCMIPP_PIPE1)
34004480:	2901      	cmp	r1, #1
34004482:	d108      	bne.n	34004496 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34004484:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34004486:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34004488:	f8d2 3824 	ldr.w	r3, [r2, #2084]	@ 0x824
3400448c:	f023 0301 	bic.w	r3, r3, #1
34004490:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  return HAL_OK;
34004494:	4770      	bx	lr
    return HAL_ERROR;
34004496:	2001      	movs	r0, #1
}
34004498:	4770      	bx	lr

3400449a <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>:
  return (((READ_REG(hdcmipp->Instance->P1BPRCR)) & DCMIPP_P1BPRCR_STRENGTH) >> DCMIPP_P1BPRCR_STRENGTH_Pos);
3400449a:	6803      	ldr	r3, [r0, #0]
3400449c:	f8d3 0824 	ldr.w	r0, [r3, #2084]	@ 0x824
}
340044a0:	f3c0 0042 	ubfx	r0, r0, #1, #3
340044a4:	4770      	bx	lr

340044a6 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>:
  if (Pipe == DCMIPP_PIPE1)
340044a6:	2901      	cmp	r1, #1
    return ((READ_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE) == DCMIPP_P1BPRCR_ENABLE) ? 1U : 0U);
340044a8:	bf03      	ittte	eq
340044aa:	6803      	ldreq	r3, [r0, #0]
340044ac:	f8d3 0824 	ldreq.w	r0, [r3, #2084]	@ 0x824
340044b0:	f000 0001 	andeq.w	r0, r0, #1
    return 0;
340044b4:	2000      	movne	r0, #0
}
340044b6:	4770      	bx	lr

340044b8 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>:
  if ((hdcmipp == NULL) || (pCounter == NULL))
340044b8:	b158      	cbz	r0, 340044d2 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x1a>
340044ba:	b152      	cbz	r2, 340044d2 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x1a>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
340044bc:	7903      	ldrb	r3, [r0, #4]
340044be:	2b02      	cmp	r3, #2
340044c0:	d107      	bne.n	340044d2 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x1a>
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
340044c2:	6803      	ldr	r3, [r0, #0]
  return HAL_OK;
340044c4:	2000      	movs	r0, #0
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
340044c6:	f8d3 3828 	ldr.w	r3, [r3, #2088]	@ 0x828
340044ca:	f3c3 030b 	ubfx	r3, r3, #0, #12
340044ce:	6013      	str	r3, [r2, #0]
  return HAL_OK;
340044d0:	4770      	bx	lr
    return HAL_ERROR;
340044d2:	2001      	movs	r0, #1
}
340044d4:	4770      	bx	lr
	...

340044d8 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>:
{
340044d8:	b570      	push	{r4, r5, r6, lr}
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
340044da:	2800      	cmp	r0, #0
340044dc:	f000 80a8 	beq.w	34004630 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x158>
340044e0:	2a00      	cmp	r2, #0
340044e2:	f000 80a5 	beq.w	34004630 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x158>
  if (Pipe == DCMIPP_PIPE1)
340044e6:	2901      	cmp	r1, #1
340044e8:	f040 80a2 	bne.w	34004630 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x158>
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
340044ec:	6803      	ldr	r3, [r0, #0]
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
340044ee:	7814      	ldrb	r4, [r2, #0]
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
340044f0:	f8d3 0880 	ldr.w	r0, [r3, #2176]	@ 0x880
                 ((uint32_t)pColorConversionConfig->OutputSamplesType);
340044f4:	7851      	ldrb	r1, [r2, #1]
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
340044f6:	f020 0006 	bic.w	r0, r0, #6
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
340044fa:	ea41 0184 	orr.w	r1, r1, r4, lsl #2
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
340044fe:	4301      	orrs	r1, r0
34004500:	f8c3 1880 	str.w	r1, [r3, #2176]	@ 0x880
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
34004504:	f9b2 1002 	ldrsh.w	r1, [r2, #2]
34004508:	b28c      	uxth	r4, r1
3400450a:	f3c1 000a 	ubfx	r0, r1, #0, #11
3400450e:	2900      	cmp	r1, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
34004510:	f9b2 1004 	ldrsh.w	r1, [r2, #4]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
34004514:	bfb8      	it	lt
34004516:	4604      	movlt	r4, r0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
34004518:	f3c1 050a 	ubfx	r5, r1, #0, #11
3400451c:	2900      	cmp	r1, #0
3400451e:	b288      	uxth	r0, r1
34004520:	bfb8      	it	lt
34004522:	4628      	movlt	r0, r5
    MODIFY_REG(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR | DCMIPP_P1CCRR1_RG,
34004524:	f8d3 1884 	ldr.w	r1, [r3, #2180]	@ 0x884
34004528:	f001 21f8 	and.w	r1, r1, #4160813056	@ 0xf800f800
3400452c:	4321      	orrs	r1, r4
3400452e:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
34004532:	f8c3 1884 	str.w	r1, [r3, #2180]	@ 0x884
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
34004536:	f9b2 1006 	ldrsh.w	r1, [r2, #6]
3400453a:	b28d      	uxth	r5, r1
3400453c:	f3c1 000a 	ubfx	r0, r1, #0, #11
34004540:	2900      	cmp	r1, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
34004542:	f9b2 1008 	ldrsh.w	r1, [r2, #8]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
34004546:	bfb8      	it	lt
34004548:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
3400454a:	f3c1 0009 	ubfx	r0, r1, #0, #10
3400454e:	2900      	cmp	r1, #0
34004550:	b28c      	uxth	r4, r1
34004552:	bfb8      	it	lt
34004554:	4604      	movlt	r4, r0
    MODIFY_REG(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB | DCMIPP_P1CCRR2_RA,
34004556:	f8d3 1888 	ldr.w	r1, [r3, #2184]	@ 0x888
3400455a:	4836      	ldr	r0, [pc, #216]	@ (34004634 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x15c>)
3400455c:	4001      	ands	r1, r0
3400455e:	4329      	orrs	r1, r5
34004560:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
34004564:	f8c3 1888 	str.w	r1, [r3, #2184]	@ 0x888
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
34004568:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
3400456c:	b28d      	uxth	r5, r1
3400456e:	f3c1 040a 	ubfx	r4, r1, #0, #11
34004572:	2900      	cmp	r1, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
34004574:	f9b2 100a 	ldrsh.w	r1, [r2, #10]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
34004578:	bfb8      	it	lt
3400457a:	4625      	movlt	r5, r4
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
3400457c:	f3c1 060a 	ubfx	r6, r1, #0, #11
34004580:	2900      	cmp	r1, #0
34004582:	b28c      	uxth	r4, r1
34004584:	bfb8      	it	lt
34004586:	4634      	movlt	r4, r6
    MODIFY_REG(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR | DCMIPP_P1CCGR1_GG,
34004588:	f8d3 188c 	ldr.w	r1, [r3, #2188]	@ 0x88c
3400458c:	f001 21f8 	and.w	r1, r1, #4160813056	@ 0xf800f800
34004590:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
34004594:	4321      	orrs	r1, r4
34004596:	f8c3 188c 	str.w	r1, [r3, #2188]	@ 0x88c
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
3400459a:	f9b2 100e 	ldrsh.w	r1, [r2, #14]
3400459e:	b28d      	uxth	r5, r1
340045a0:	f3c1 040a 	ubfx	r4, r1, #0, #11
340045a4:	2900      	cmp	r1, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
340045a6:	f9b2 1010 	ldrsh.w	r1, [r2, #16]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
340045aa:	bfb8      	it	lt
340045ac:	4625      	movlt	r5, r4
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
340045ae:	f3c1 0609 	ubfx	r6, r1, #0, #10
340045b2:	2900      	cmp	r1, #0
340045b4:	b28c      	uxth	r4, r1
340045b6:	bfb8      	it	lt
340045b8:	4634      	movlt	r4, r6
    MODIFY_REG(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB | DCMIPP_P1CCGR2_GA,
340045ba:	f8d3 1890 	ldr.w	r1, [r3, #2192]	@ 0x890
340045be:	4001      	ands	r1, r0
340045c0:	4329      	orrs	r1, r5
340045c2:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
340045c6:	f8c3 1890 	str.w	r1, [r3, #2192]	@ 0x890
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
340045ca:	f9b2 1012 	ldrsh.w	r1, [r2, #18]
340045ce:	b28d      	uxth	r5, r1
340045d0:	f3c1 040a 	ubfx	r4, r1, #0, #11
340045d4:	2900      	cmp	r1, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
340045d6:	f9b2 1014 	ldrsh.w	r1, [r2, #20]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
340045da:	bfb8      	it	lt
340045dc:	4625      	movlt	r5, r4
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
340045de:	f3c1 060a 	ubfx	r6, r1, #0, #11
340045e2:	2900      	cmp	r1, #0
340045e4:	b28c      	uxth	r4, r1
340045e6:	bfb8      	it	lt
340045e8:	4634      	movlt	r4, r6
    MODIFY_REG(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR | DCMIPP_P1CCBR1_BG,
340045ea:	f8d3 1894 	ldr.w	r1, [r3, #2196]	@ 0x894
340045ee:	f001 21f8 	and.w	r1, r1, #4160813056	@ 0xf800f800
340045f2:	4329      	orrs	r1, r5
340045f4:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
340045f8:	f8c3 1894 	str.w	r1, [r3, #2196]	@ 0x894
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
340045fc:	f9b2 1016 	ldrsh.w	r1, [r2, #22]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
34004600:	f9b2 2018 	ldrsh.w	r2, [r2, #24]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
34004604:	f3c1 050a 	ubfx	r5, r1, #0, #11
34004608:	2900      	cmp	r1, #0
3400460a:	b28c      	uxth	r4, r1
3400460c:	bfb8      	it	lt
3400460e:	462c      	movlt	r4, r5
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
34004610:	f3c2 0509 	ubfx	r5, r2, #0, #10
34004614:	2a00      	cmp	r2, #0
34004616:	b291      	uxth	r1, r2
    MODIFY_REG(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB | DCMIPP_P1CCBR2_BA,
34004618:	f8d3 2898 	ldr.w	r2, [r3, #2200]	@ 0x898
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
3400461c:	bfb8      	it	lt
3400461e:	4629      	movlt	r1, r5
    MODIFY_REG(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB | DCMIPP_P1CCBR2_BA,
34004620:	4002      	ands	r2, r0
  return HAL_OK;
34004622:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB | DCMIPP_P1CCBR2_BA,
34004624:	4322      	orrs	r2, r4
34004626:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
3400462a:	f8c3 2898 	str.w	r2, [r3, #2200]	@ 0x898
}
3400462e:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
34004630:	2001      	movs	r0, #1
34004632:	e7fc      	b.n	3400462e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x156>
34004634:	fc00f800 	.word	0xfc00f800

34004638 <HAL_DCMIPP_PIPE_EnableISPColorConversion>:
  if (hdcmipp == NULL)
34004638:	b150      	cbz	r0, 34004650 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x18>
  if (Pipe == DCMIPP_PIPE1)
3400463a:	2901      	cmp	r1, #1
3400463c:	d108      	bne.n	34004650 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x18>
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
3400463e:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34004640:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
34004642:	f8d2 3880 	ldr.w	r3, [r2, #2176]	@ 0x880
34004646:	f043 0301 	orr.w	r3, r3, #1
3400464a:	f8c2 3880 	str.w	r3, [r2, #2176]	@ 0x880
  return HAL_OK;
3400464e:	4770      	bx	lr
    return HAL_ERROR;
34004650:	2001      	movs	r0, #1
}
34004652:	4770      	bx	lr

34004654 <HAL_DCMIPP_PIPE_DisableISPColorConversion>:
  if (hdcmipp == NULL)
34004654:	b150      	cbz	r0, 3400466c <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x18>
  if (Pipe == DCMIPP_PIPE1)
34004656:	2901      	cmp	r1, #1
34004658:	d108      	bne.n	3400466c <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
3400465a:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400465c:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
3400465e:	f8d2 3880 	ldr.w	r3, [r2, #2176]	@ 0x880
34004662:	f023 0301 	bic.w	r3, r3, #1
34004666:	f8c2 3880 	str.w	r3, [r2, #2176]	@ 0x880
  return HAL_OK;
3400466a:	4770      	bx	lr
    return HAL_ERROR;
3400466c:	2001      	movs	r0, #1
}
3400466e:	4770      	bx	lr

34004670 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>:
{
34004670:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pBlackLevelConfig == NULL))
34004672:	b198      	cbz	r0, 3400469c <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x2c>
34004674:	b192      	cbz	r2, 3400469c <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x2c>
  if (Pipe == DCMIPP_PIPE1)
34004676:	2901      	cmp	r1, #1
34004678:	d110      	bne.n	3400469c <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x2c>
    MODIFY_REG(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_BLCR | DCMIPP_P1BLCCR_BLCG | DCMIPP_P1BLCCR_BLCB,
3400467a:	6800      	ldr	r0, [r0, #0]
3400467c:	7853      	ldrb	r3, [r2, #1]
3400467e:	7814      	ldrb	r4, [r2, #0]
34004680:	f8d0 1840 	ldr.w	r1, [r0, #2112]	@ 0x840
34004684:	7892      	ldrb	r2, [r2, #2]
34004686:	041b      	lsls	r3, r3, #16
34004688:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
3400468c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
34004690:	b2ca      	uxtb	r2, r1
34004692:	4313      	orrs	r3, r2
34004694:	f8c0 3840 	str.w	r3, [r0, #2112]	@ 0x840
  return HAL_OK;
34004698:	2000      	movs	r0, #0
}
3400469a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
3400469c:	2001      	movs	r0, #1
3400469e:	e7fc      	b.n	3400469a <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x2a>

340046a0 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>:
  if (hdcmipp == NULL)
340046a0:	b150      	cbz	r0, 340046b8 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x18>
  if (Pipe == DCMIPP_PIPE1)
340046a2:	2901      	cmp	r1, #1
340046a4:	d108      	bne.n	340046b8 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x18>
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
340046a6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340046a8:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
340046aa:	f8d2 3840 	ldr.w	r3, [r2, #2112]	@ 0x840
340046ae:	f043 0301 	orr.w	r3, r3, #1
340046b2:	f8c2 3840 	str.w	r3, [r2, #2112]	@ 0x840
  return HAL_OK;
340046b6:	4770      	bx	lr
    return HAL_ERROR;
340046b8:	2001      	movs	r0, #1
}
340046ba:	4770      	bx	lr

340046bc <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>:
  if (hdcmipp == NULL)
340046bc:	b150      	cbz	r0, 340046d4 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x18>
  if (Pipe == DCMIPP_PIPE1)
340046be:	2901      	cmp	r1, #1
340046c0:	d108      	bne.n	340046d4 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
340046c2:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340046c4:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
340046c6:	f8d2 3840 	ldr.w	r3, [r2, #2112]	@ 0x840
340046ca:	f023 0301 	bic.w	r3, r3, #1
340046ce:	f8c2 3840 	str.w	r3, [r2, #2112]	@ 0x840
  return HAL_OK;
340046d2:	4770      	bx	lr
    return HAL_ERROR;
340046d4:	2001      	movs	r0, #1
}
340046d6:	4770      	bx	lr

340046d8 <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig>:
  if (Pipe == DCMIPP_PIPE1)
340046d8:	2901      	cmp	r1, #1
340046da:	d108      	bne.n	340046ee <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig+0x16>
    p1blccr_reg = READ_REG(hdcmipp->Instance->P1BLCCR);
340046dc:	6803      	ldr	r3, [r0, #0]
340046de:	f8d3 3840 	ldr.w	r3, [r3, #2112]	@ 0x840
    pBlackLevelConfig->BlueCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCB) >> DCMIPP_P1BLCCR_BLCB_Pos);
340046e2:	0a19      	lsrs	r1, r3, #8
340046e4:	7091      	strb	r1, [r2, #2]
    pBlackLevelConfig->GreenCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCG) >> DCMIPP_P1BLCCR_BLCG_Pos);
340046e6:	0c19      	lsrs	r1, r3, #16
    pBlackLevelConfig->RedCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCR) >> DCMIPP_P1BLCCR_BLCR_Pos);
340046e8:	0e1b      	lsrs	r3, r3, #24
    pBlackLevelConfig->GreenCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCG) >> DCMIPP_P1BLCCR_BLCG_Pos);
340046ea:	7051      	strb	r1, [r2, #1]
    pBlackLevelConfig->RedCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCR) >> DCMIPP_P1BLCCR_BLCR_Pos);
340046ec:	7013      	strb	r3, [r2, #0]
}
340046ee:	4770      	bx	lr

340046f0 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration>:
  if (Pipe == DCMIPP_PIPE1)
340046f0:	2901      	cmp	r1, #1
    return ((READ_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE) == DCMIPP_P1BLCCR_ENABLE) ? 1U : 0U);
340046f2:	bf03      	ittte	eq
340046f4:	6803      	ldreq	r3, [r0, #0]
340046f6:	f8d3 0840 	ldreq.w	r0, [r3, #2112]	@ 0x840
340046fa:	f000 0001 	andeq.w	r0, r0, #1
    return 0;
340046fe:	2000      	movne	r0, #0
}
34004700:	4770      	bx	lr

34004702 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>:
{
34004702:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
34004704:	b330      	cbz	r0, 34004754 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x52>
34004706:	b32b      	cbz	r3, 34004754 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x52>
  if (Pipe == DCMIPP_PIPE1)
34004708:	2901      	cmp	r1, #1
3400470a:	d123      	bne.n	34004754 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x52>
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
3400470c:	e9d3 1400 	ldrd	r1, r4, [r3]
34004710:	689b      	ldr	r3, [r3, #8]
34004712:	4321      	orrs	r1, r4
    switch (ModuleID)
34004714:	2a01      	cmp	r2, #1
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34004716:	ea43 0301 	orr.w	r3, r3, r1
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
3400471a:	6801      	ldr	r1, [r0, #0]
    switch (ModuleID)
3400471c:	d009      	beq.n	34004732 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x30>
3400471e:	2a02      	cmp	r2, #2
34004720:	d010      	beq.n	34004744 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x42>
        MODIFY_REG(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_BINS | DCMIPP_P1ST3CR_SRC | \
34004722:	f8d1 2858 	ldr.w	r2, [r1, #2136]	@ 0x858
34004726:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
3400472a:	4313      	orrs	r3, r2
3400472c:	f8c1 3858 	str.w	r3, [r1, #2136]	@ 0x858
        break;
34004730:	e006      	b.n	34004740 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x3e>
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
34004732:	f8d1 2850 	ldr.w	r2, [r1, #2128]	@ 0x850
34004736:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
3400473a:	4313      	orrs	r3, r2
3400473c:	f8c1 3850 	str.w	r3, [r1, #2128]	@ 0x850
  return HAL_OK;
34004740:	2000      	movs	r0, #0
}
34004742:	bd10      	pop	{r4, pc}
        MODIFY_REG(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_BINS | DCMIPP_P1ST2CR_SRC | \
34004744:	f8d1 2854 	ldr.w	r2, [r1, #2132]	@ 0x854
34004748:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
3400474c:	4313      	orrs	r3, r2
3400474e:	f8c1 3854 	str.w	r3, [r1, #2132]	@ 0x854
        break;
34004752:	e7f5      	b.n	34004740 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x3e>
    return HAL_ERROR;
34004754:	2001      	movs	r0, #1
34004756:	e7f4      	b.n	34004742 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x40>

34004758 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>:
{
34004758:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
3400475a:	b1d8      	cbz	r0, 34004794 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x3c>
3400475c:	b1d2      	cbz	r2, 34004794 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x3c>
  if (Pipe == DCMIPP_PIPE1)
3400475e:	2901      	cmp	r1, #1
34004760:	d118      	bne.n	34004794 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x3c>
    MODIFY_REG(hdcmipp->Instance->P1STSTR, DCMIPP_P1STSTR_HSTART | DCMIPP_P1STSTR_VSTART,
34004762:	e9d2 4300 	ldrd	r4, r3, [r2]
34004766:	6801      	ldr	r1, [r0, #0]
34004768:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
3400476c:	f8d1 085c 	ldr.w	r0, [r1, #2140]	@ 0x85c
34004770:	f000 20f0 	and.w	r0, r0, #4026593280	@ 0xf000f000
34004774:	4303      	orrs	r3, r0
34004776:	f8c1 385c 	str.w	r3, [r1, #2140]	@ 0x85c
    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
3400477a:	f8d1 0860 	ldr.w	r0, [r1, #2144]	@ 0x860
3400477e:	e9d2 4302 	ldrd	r4, r3, [r2, #8]
34004782:	f000 22f0 	and.w	r2, r0, #4026593280	@ 0xf000f000
  return HAL_OK;
34004786:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
34004788:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
3400478c:	4313      	orrs	r3, r2
3400478e:	f8c1 3860 	str.w	r3, [r1, #2144]	@ 0x860
}
34004792:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34004794:	2001      	movs	r0, #1
34004796:	e7fc      	b.n	34004792 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x3a>

34004798 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>:
  if (hdcmipp == NULL)
34004798:	b1e0      	cbz	r0, 340047d4 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x3c>
  if (Pipe == DCMIPP_PIPE1)
3400479a:	2901      	cmp	r1, #1
3400479c:	d11a      	bne.n	340047d4 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x3c>
    switch (ModuleID)
3400479e:	2a01      	cmp	r2, #1
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
340047a0:	6803      	ldr	r3, [r0, #0]
    switch (ModuleID)
340047a2:	d008      	beq.n	340047b6 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x1e>
340047a4:	2a02      	cmp	r2, #2
340047a6:	d00e      	beq.n	340047c6 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x2e>
        SET_BIT(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_ENABLE);
340047a8:	f8d3 2858 	ldr.w	r2, [r3, #2136]	@ 0x858
340047ac:	f042 0201 	orr.w	r2, r2, #1
340047b0:	f8c3 2858 	str.w	r2, [r3, #2136]	@ 0x858
        break;
340047b4:	e005      	b.n	340047c2 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x2a>
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
340047b6:	f8d3 2850 	ldr.w	r2, [r3, #2128]	@ 0x850
340047ba:	f042 0201 	orr.w	r2, r2, #1
340047be:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
  return HAL_OK;
340047c2:	2000      	movs	r0, #0
340047c4:	4770      	bx	lr
        SET_BIT(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_ENABLE);
340047c6:	f8d3 2854 	ldr.w	r2, [r3, #2132]	@ 0x854
340047ca:	f042 0201 	orr.w	r2, r2, #1
340047ce:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
        break;
340047d2:	e7f6      	b.n	340047c2 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x2a>
    return HAL_ERROR;
340047d4:	2001      	movs	r0, #1
}
340047d6:	4770      	bx	lr

340047d8 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>:
  if (hdcmipp == NULL)
340047d8:	b150      	cbz	r0, 340047f0 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x18>
  if (Pipe == DCMIPP_PIPE1)
340047da:	2901      	cmp	r1, #1
340047dc:	d108      	bne.n	340047f0 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x18>
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
340047de:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340047e0:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
340047e2:	f8d2 3860 	ldr.w	r3, [r2, #2144]	@ 0x860
340047e6:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
340047ea:	f8c2 3860 	str.w	r3, [r2, #2144]	@ 0x860
  return HAL_OK;
340047ee:	4770      	bx	lr
    return HAL_ERROR;
340047f0:	2001      	movs	r0, #1
}
340047f2:	4770      	bx	lr

340047f4 <HAL_DCMIPP_PIPE_SetISPExposureConfig>:
{
340047f4:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
340047f6:	b1f0      	cbz	r0, 34004836 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x42>
340047f8:	b1ea      	cbz	r2, 34004836 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x42>
  if (Pipe == DCMIPP_PIPE1)
340047fa:	2901      	cmp	r1, #1
340047fc:	d11b      	bne.n	34004836 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x42>
    MODIFY_REG(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_SHFR | DCMIPP_P1EXCR1_MULTR,
340047fe:	6801      	ldr	r1, [r0, #0]
34004800:	7853      	ldrb	r3, [r2, #1]
34004802:	7814      	ldrb	r4, [r2, #0]
34004804:	f8d1 0844 	ldr.w	r0, [r1, #2116]	@ 0x844
34004808:	051b      	lsls	r3, r3, #20
3400480a:	f36f 501e 	bfc	r0, #20, #11
3400480e:	ea43 7304 	orr.w	r3, r3, r4, lsl #28
34004812:	4303      	orrs	r3, r0
34004814:	f8c1 3844 	str.w	r3, [r1, #2116]	@ 0x844
    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34004818:	78d3      	ldrb	r3, [r2, #3]
3400481a:	7890      	ldrb	r0, [r2, #2]
3400481c:	051b      	lsls	r3, r3, #20
3400481e:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
34004822:	7910      	ldrb	r0, [r2, #4]
34004824:	7952      	ldrb	r2, [r2, #5]
34004826:	ea43 3300 	orr.w	r3, r3, r0, lsl #12
  return HAL_OK;
3400482a:	2000      	movs	r0, #0
    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
3400482c:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
34004830:	f8c1 3848 	str.w	r3, [r1, #2120]	@ 0x848
}
34004834:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34004836:	2001      	movs	r0, #1
34004838:	e7fc      	b.n	34004834 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x40>

3400483a <HAL_DCMIPP_PIPE_EnableISPExposure>:
  if (hdcmipp == NULL)
3400483a:	b150      	cbz	r0, 34004852 <HAL_DCMIPP_PIPE_EnableISPExposure+0x18>
  if (Pipe == DCMIPP_PIPE1)
3400483c:	2901      	cmp	r1, #1
3400483e:	d108      	bne.n	34004852 <HAL_DCMIPP_PIPE_EnableISPExposure+0x18>
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34004840:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34004842:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34004844:	f8d2 3844 	ldr.w	r3, [r2, #2116]	@ 0x844
34004848:	f043 0301 	orr.w	r3, r3, #1
3400484c:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
  return HAL_OK;
34004850:	4770      	bx	lr
    return HAL_ERROR;
34004852:	2001      	movs	r0, #1
}
34004854:	4770      	bx	lr

34004856 <HAL_DCMIPP_PIPE_DisableISPExposure>:
  if (hdcmipp == NULL)
34004856:	b150      	cbz	r0, 3400486e <HAL_DCMIPP_PIPE_DisableISPExposure+0x18>
  if (Pipe == DCMIPP_PIPE1)
34004858:	2901      	cmp	r1, #1
3400485a:	d108      	bne.n	3400486e <HAL_DCMIPP_PIPE_DisableISPExposure+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
3400485c:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400485e:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34004860:	f8d2 3844 	ldr.w	r3, [r2, #2116]	@ 0x844
34004864:	f023 0301 	bic.w	r3, r3, #1
34004868:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
  return HAL_OK;
3400486c:	4770      	bx	lr
    return HAL_ERROR;
3400486e:	2001      	movs	r0, #1
}
34004870:	4770      	bx	lr

34004872 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>:
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
34004872:	b340      	cbz	r0, 340048c6 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x54>
34004874:	b33a      	cbz	r2, 340048c6 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x54>
  if (Pipe == DCMIPP_PIPE1)
34004876:	2901      	cmp	r1, #1
34004878:	d125      	bne.n	340048c6 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x54>
    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
3400487a:	6801      	ldr	r1, [r0, #0]
3400487c:	7810      	ldrb	r0, [r2, #0]
3400487e:	f8d1 38a0 	ldr.w	r3, [r1, #2208]	@ 0x8a0
34004882:	f423 43fc 	bic.w	r3, r3, #32256	@ 0x7e00
34004886:	ea43 2340 	orr.w	r3, r3, r0, lsl #9
3400488a:	f8c1 38a0 	str.w	r3, [r1, #2208]	@ 0x8a0
    WRITE_REG(hdcmipp->Instance->P1CTCR2, (((uint32_t)pContrastConfig->LUM_32 << DCMIPP_P1CTCR2_LUM1_Pos) |
3400488e:	7893      	ldrb	r3, [r2, #2]
34004890:	7850      	ldrb	r0, [r2, #1]
34004892:	045b      	lsls	r3, r3, #17
34004894:	ea43 6340 	orr.w	r3, r3, r0, lsl #25
34004898:	78d0      	ldrb	r0, [r2, #3]
3400489a:	ea43 2340 	orr.w	r3, r3, r0, lsl #9
3400489e:	7910      	ldrb	r0, [r2, #4]
340048a0:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
340048a4:	f8c1 38a4 	str.w	r3, [r1, #2212]	@ 0x8a4
    WRITE_REG(hdcmipp->Instance->P1CTCR3, (((uint32_t)pContrastConfig->LUM_160 << DCMIPP_P1CTCR3_LUM5_Pos) |
340048a8:	7993      	ldrb	r3, [r2, #6]
340048aa:	7950      	ldrb	r0, [r2, #5]
340048ac:	045b      	lsls	r3, r3, #17
340048ae:	ea43 6340 	orr.w	r3, r3, r0, lsl #25
340048b2:	79d0      	ldrb	r0, [r2, #7]
340048b4:	7a12      	ldrb	r2, [r2, #8]
340048b6:	ea43 2340 	orr.w	r3, r3, r0, lsl #9
340048ba:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
  return HAL_OK;
340048be:	2000      	movs	r0, #0
    WRITE_REG(hdcmipp->Instance->P1CTCR3, (((uint32_t)pContrastConfig->LUM_160 << DCMIPP_P1CTCR3_LUM5_Pos) |
340048c0:	f8c1 38a8 	str.w	r3, [r1, #2216]	@ 0x8a8
  return HAL_OK;
340048c4:	4770      	bx	lr
    return HAL_ERROR;
340048c6:	2001      	movs	r0, #1
}
340048c8:	4770      	bx	lr

340048ca <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>:
  if (hdcmipp == NULL)
340048ca:	b150      	cbz	r0, 340048e2 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x18>
  if (Pipe == DCMIPP_PIPE1)
340048cc:	2901      	cmp	r1, #1
340048ce:	d108      	bne.n	340048e2 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x18>
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
340048d0:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340048d2:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
340048d4:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
340048d8:	f043 0301 	orr.w	r3, r3, #1
340048dc:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
340048e0:	4770      	bx	lr
    return HAL_ERROR;
340048e2:	2001      	movs	r0, #1
}
340048e4:	4770      	bx	lr

340048e6 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>:
  if (hdcmipp == NULL)
340048e6:	b150      	cbz	r0, 340048fe <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x18>
  if (Pipe == DCMIPP_PIPE1)
340048e8:	2901      	cmp	r1, #1
340048ea:	d108      	bne.n	340048fe <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
340048ec:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340048ee:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
340048f0:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
340048f4:	f023 0301 	bic.w	r3, r3, #1
340048f8:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
340048fc:	4770      	bx	lr
    return HAL_ERROR;
340048fe:	2001      	movs	r0, #1
}
34004900:	4770      	bx	lr

34004902 <HAL_DCMIPP_PIPE_SetPitch>:
  if (hdcmipp == NULL)
34004902:	b1b0      	cbz	r0, 34004932 <HAL_DCMIPP_PIPE_SetPitch+0x30>
  if (Pipe == DCMIPP_PIPE1)
34004904:	2901      	cmp	r1, #1
34004906:	d109      	bne.n	3400491c <HAL_DCMIPP_PIPE_SetPitch+0x1a>
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH, LinePitch << DCMIPP_P1PPM0PR_PITCH_Pos);
34004908:	6801      	ldr	r1, [r0, #0]
3400490a:	f8d1 39cc 	ldr.w	r3, [r1, #2508]	@ 0x9cc
3400490e:	f36f 030e 	bfc	r3, #0, #15
34004912:	431a      	orrs	r2, r3
34004914:	f8c1 29cc 	str.w	r2, [r1, #2508]	@ 0x9cc
  return HAL_OK;
34004918:	2000      	movs	r0, #0
3400491a:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE2)
3400491c:	2902      	cmp	r1, #2
3400491e:	d108      	bne.n	34004932 <HAL_DCMIPP_PIPE_SetPitch+0x30>
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH, LinePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
34004920:	6801      	ldr	r1, [r0, #0]
34004922:	f8d1 3dcc 	ldr.w	r3, [r1, #3532]	@ 0xdcc
34004926:	f36f 030e 	bfc	r3, #0, #15
3400492a:	431a      	orrs	r2, r3
3400492c:	f8c1 2dcc 	str.w	r2, [r1, #3532]	@ 0xdcc
34004930:	e7f2      	b.n	34004918 <HAL_DCMIPP_PIPE_SetPitch+0x16>
    return HAL_ERROR;
34004932:	2001      	movs	r0, #1
}
34004934:	4770      	bx	lr

34004936 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>:
  if (hdcmipp == NULL)
34004936:	b1b0      	cbz	r0, 34004966 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x30>
  if (Pipe == DCMIPP_PIPE1)
34004938:	2901      	cmp	r1, #1
3400493a:	d109      	bne.n	34004950 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x1a>
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, PixelPackerFormat);
3400493c:	6801      	ldr	r1, [r0, #0]
3400493e:	f8d1 39c0 	ldr.w	r3, [r1, #2496]	@ 0x9c0
34004942:	f023 030f 	bic.w	r3, r3, #15
34004946:	431a      	orrs	r2, r3
34004948:	f8c1 29c0 	str.w	r2, [r1, #2496]	@ 0x9c0
  return HAL_OK;
3400494c:	2000      	movs	r0, #0
3400494e:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE2)
34004950:	2902      	cmp	r1, #2
34004952:	d108      	bne.n	34004966 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x30>
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, PixelPackerFormat);
34004954:	6801      	ldr	r1, [r0, #0]
34004956:	f8d1 3dc0 	ldr.w	r3, [r1, #3520]	@ 0xdc0
3400495a:	f023 030f 	bic.w	r3, r3, #15
3400495e:	431a      	orrs	r2, r3
34004960:	f8c1 2dc0 	str.w	r2, [r1, #3520]	@ 0xdc0
34004964:	e7f2      	b.n	3400494c <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x16>
    return HAL_ERROR;
34004966:	2001      	movs	r0, #1
}
34004968:	4770      	bx	lr

3400496a <HAL_DCMIPP_PIPE_SetMemoryAddress>:
  if (hdcmipp == NULL)
3400496a:	b308      	cbz	r0, 340049b0 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x46>
  if (Pipe == DCMIPP_PIPE0)
3400496c:	b961      	cbnz	r1, 34004988 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x1e>
      WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
3400496e:	6801      	ldr	r1, [r0, #0]
    if (Memory == DCMIPP_MEMORY_ADDRESS_0)
34004970:	b91a      	cbnz	r2, 3400497a <HAL_DCMIPP_PIPE_SetMemoryAddress+0x10>
      WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
34004972:	f8c1 35c4 	str.w	r3, [r1, #1476]	@ 0x5c4
  return HAL_OK;
34004976:	2000      	movs	r0, #0
34004978:	4770      	bx	lr
      if ((hdcmipp->Instance->P0PPCR & DCMIPP_P0PPCR_DBM) == DCMIPP_P0PPCR_DBM)
3400497a:	f8d1 25c0 	ldr.w	r2, [r1, #1472]	@ 0x5c0
3400497e:	03d2      	lsls	r2, r2, #15
34004980:	d516      	bpl.n	340049b0 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x46>
        WRITE_REG(hdcmipp->Instance->P0PPM0AR2, DstAddress);
34004982:	f8c1 35c8 	str.w	r3, [r1, #1480]	@ 0x5c8
34004986:	e7f6      	b.n	34004976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0xc>
  else if (Pipe == DCMIPP_PIPE1)
34004988:	2901      	cmp	r1, #1
3400498a:	d107      	bne.n	3400499c <HAL_DCMIPP_PIPE_SetMemoryAddress+0x32>
      WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
3400498c:	6801      	ldr	r1, [r0, #0]
    if (Memory == DCMIPP_MEMORY_ADDRESS_0)
3400498e:	b912      	cbnz	r2, 34004996 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x2c>
      WRITE_REG(hdcmipp->Instance->P1PPM0AR1, DstAddress);
34004990:	f8c1 39c4 	str.w	r3, [r1, #2500]	@ 0x9c4
34004994:	e7ef      	b.n	34004976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0xc>
      WRITE_REG(hdcmipp->Instance->P1PPM0AR2, DstAddress);
34004996:	f8c1 39c8 	str.w	r3, [r1, #2504]	@ 0x9c8
3400499a:	e7ec      	b.n	34004976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0xc>
  else if (Pipe == DCMIPP_PIPE2)
3400499c:	2902      	cmp	r1, #2
3400499e:	d107      	bne.n	340049b0 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x46>
      WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
340049a0:	6801      	ldr	r1, [r0, #0]
    if (Memory == DCMIPP_MEMORY_ADDRESS_0)
340049a2:	b912      	cbnz	r2, 340049aa <HAL_DCMIPP_PIPE_SetMemoryAddress+0x40>
      WRITE_REG(hdcmipp->Instance->P2PPM0AR1, DstAddress);
340049a4:	f8c1 3dc4 	str.w	r3, [r1, #3524]	@ 0xdc4
340049a8:	e7e5      	b.n	34004976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0xc>
      WRITE_REG(hdcmipp->Instance->P2PPM0AR2, DstAddress);
340049aa:	f8c1 3dc8 	str.w	r3, [r1, #3528]	@ 0xdc8
340049ae:	e7e2      	b.n	34004976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0xc>
    return HAL_ERROR;
340049b0:	2001      	movs	r0, #1
}
340049b2:	4770      	bx	lr

340049b4 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>:
  if (hdcmipp == NULL)
340049b4:	b1b8      	cbz	r0, 340049e6 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x32>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
340049b6:	7903      	ldrb	r3, [r0, #4]
340049b8:	2b02      	cmp	r3, #2
340049ba:	d108      	bne.n	340049ce <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x1a>
    if (Pipe == DCMIPP_PIPE1)
340049bc:	2901      	cmp	r1, #1
340049be:	d108      	bne.n	340049d2 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x1e>
      SET_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
340049c0:	6802      	ldr	r2, [r0, #0]
340049c2:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
340049c6:	f043 0310 	orr.w	r3, r3, #16
340049ca:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
340049ce:	2000      	movs	r0, #0
340049d0:	4770      	bx	lr
    else if (Pipe == DCMIPP_PIPE2)
340049d2:	2902      	cmp	r1, #2
340049d4:	d107      	bne.n	340049e6 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x32>
      SET_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
340049d6:	6802      	ldr	r2, [r0, #0]
340049d8:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
340049dc:	f043 0310 	orr.w	r3, r3, #16
340049e0:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
340049e4:	e7f3      	b.n	340049ce <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x1a>
    return HAL_ERROR;
340049e6:	2001      	movs	r0, #1
}
340049e8:	4770      	bx	lr

340049ea <HAL_DCMIPP_PIPE_DisableRedBlueSwap>:
  if (hdcmipp == NULL)
340049ea:	b1b8      	cbz	r0, 34004a1c <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x32>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
340049ec:	7903      	ldrb	r3, [r0, #4]
340049ee:	2b02      	cmp	r3, #2
340049f0:	d108      	bne.n	34004a04 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x1a>
    if (Pipe == DCMIPP_PIPE1)
340049f2:	2901      	cmp	r1, #1
340049f4:	d108      	bne.n	34004a08 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x1e>
      CLEAR_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
340049f6:	6802      	ldr	r2, [r0, #0]
340049f8:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
340049fc:	f023 0310 	bic.w	r3, r3, #16
34004a00:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
34004a04:	2000      	movs	r0, #0
34004a06:	4770      	bx	lr
    else if (Pipe == DCMIPP_PIPE2)
34004a08:	2902      	cmp	r1, #2
34004a0a:	d107      	bne.n	34004a1c <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x32>
      CLEAR_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34004a0c:	6802      	ldr	r2, [r0, #0]
34004a0e:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
34004a12:	f023 0310 	bic.w	r3, r3, #16
34004a16:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
34004a1a:	e7f3      	b.n	34004a04 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x1a>
    return HAL_ERROR;
34004a1c:	2001      	movs	r0, #1
}
34004a1e:	4770      	bx	lr

34004a20 <HAL_DCMIPP_PIPE_CSI_EnableShare>:
  if (Pipe == DCMIPP_PIPE2)
34004a20:	2902      	cmp	r1, #2
34004a22:	d10e      	bne.n	34004a42 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x22>
    tmp1 = hdcmipp->Instance->P2FSCR;
34004a24:	6803      	ldr	r3, [r0, #0]
34004a26:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
    tmp2 = hdcmipp->Instance->P1FSCR;
34004a2a:	f8d3 1804 	ldr.w	r1, [r3, #2052]	@ 0x804
    if (((tmp1 & DCMIPP_P2FSCR_PIPEN) == DCMIPP_P2FSCR_PIPEN) || ((tmp2 & DCMIPP_P1FSCR_PIPEN) == DCMIPP_P1FSCR_PIPEN))
34004a2e:	430a      	orrs	r2, r1
34004a30:	d407      	bmi.n	34004a42 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x22>
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
34004a32:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
  return HAL_OK;
34004a36:	2000      	movs	r0, #0
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
34004a38:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
34004a3c:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
  return HAL_OK;
34004a40:	4770      	bx	lr
      return HAL_ERROR;
34004a42:	2001      	movs	r0, #1
}
34004a44:	4770      	bx	lr

34004a46 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>:
  if ((hdcmipp == NULL) || (pCounter == NULL))
34004a46:	b1c8      	cbz	r0, 34004a7c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x36>
34004a48:	b1c3      	cbz	r3, 34004a7c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x36>
  if (Pipe == DCMIPP_PIPE1)
34004a4a:	2901      	cmp	r1, #1
34004a4c:	d116      	bne.n	34004a7c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x36>
    switch (ModuleID)
34004a4e:	2a02      	cmp	r2, #2
34004a50:	d00c      	beq.n	34004a6c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x26>
34004a52:	2a03      	cmp	r2, #3
34004a54:	d00e      	beq.n	34004a74 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x2e>
34004a56:	2a01      	cmp	r2, #1
34004a58:	d001      	beq.n	34004a5e <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x18>
{
34004a5a:	2000      	movs	r0, #0
34004a5c:	4770      	bx	lr
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST1SR & DCMIPP_P1ST1SR_ACCU));
34004a5e:	6802      	ldr	r2, [r0, #0]
34004a60:	f8d2 2864 	ldr.w	r2, [r2, #2148]	@ 0x864
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34004a64:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
34004a68:	601a      	str	r2, [r3, #0]
        break;
34004a6a:	e7f6      	b.n	34004a5a <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x14>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34004a6c:	6802      	ldr	r2, [r0, #0]
34004a6e:	f8d2 2868 	ldr.w	r2, [r2, #2152]	@ 0x868
34004a72:	e7f7      	b.n	34004a64 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x1e>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
34004a74:	6802      	ldr	r2, [r0, #0]
34004a76:	f8d2 286c 	ldr.w	r2, [r2, #2156]	@ 0x86c
34004a7a:	e7f3      	b.n	34004a64 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x1e>
    return HAL_ERROR;
34004a7c:	2001      	movs	r0, #1
}
34004a7e:	4770      	bx	lr

34004a80 <HAL_DCMIPP_PIPE_GetISPExposureConfig>:
  if (Pipe == DCMIPP_PIPE1)
34004a80:	2901      	cmp	r1, #1
34004a82:	d113      	bne.n	34004aac <HAL_DCMIPP_PIPE_GetISPExposureConfig+0x2c>
    tmp = READ_REG(hdcmipp->Instance->P1EXCR2);
34004a84:	6801      	ldr	r1, [r0, #0]
34004a86:	f8d1 3848 	ldr.w	r3, [r1, #2120]	@ 0x848
    pExposureConfig->MultiplierBlue  = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTB) >> DCMIPP_P1EXCR2_MULTB_Pos);
34004a8a:	0918      	lsrs	r0, r3, #4
34004a8c:	7150      	strb	r0, [r2, #5]
    pExposureConfig->ShiftBlue       = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFB) >> DCMIPP_P1EXCR2_SHFB_Pos);
34004a8e:	f3c3 3002 	ubfx	r0, r3, #12, #3
34004a92:	7110      	strb	r0, [r2, #4]
    pExposureConfig->ShiftGreen      = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFG) >> DCMIPP_P1EXCR2_SHFG_Pos);
34004a94:	f3c3 7002 	ubfx	r0, r3, #28, #3
    pExposureConfig->MultiplierGreen = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTG) >> DCMIPP_P1EXCR2_MULTG_Pos);
34004a98:	0d1b      	lsrs	r3, r3, #20
    pExposureConfig->ShiftGreen      = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFG) >> DCMIPP_P1EXCR2_SHFG_Pos);
34004a9a:	7090      	strb	r0, [r2, #2]
    pExposureConfig->MultiplierGreen = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTG) >> DCMIPP_P1EXCR2_MULTG_Pos);
34004a9c:	70d3      	strb	r3, [r2, #3]
    tmp = READ_REG(hdcmipp->Instance->P1EXCR1);
34004a9e:	f8d1 3844 	ldr.w	r3, [r1, #2116]	@ 0x844
    pExposureConfig->MultiplierRed   = (uint8_t)((tmp & DCMIPP_P1EXCR1_MULTR) >> DCMIPP_P1EXCR1_MULTR_Pos);
34004aa2:	0d19      	lsrs	r1, r3, #20
    pExposureConfig->ShiftRed        = (uint8_t)((tmp & DCMIPP_P1EXCR1_SHFR) >> DCMIPP_P1EXCR1_SHFR_Pos);
34004aa4:	f3c3 7302 	ubfx	r3, r3, #28, #3
    pExposureConfig->MultiplierRed   = (uint8_t)((tmp & DCMIPP_P1EXCR1_MULTR) >> DCMIPP_P1EXCR1_MULTR_Pos);
34004aa8:	7051      	strb	r1, [r2, #1]
    pExposureConfig->ShiftRed        = (uint8_t)((tmp & DCMIPP_P1EXCR1_SHFR) >> DCMIPP_P1EXCR1_SHFR_Pos);
34004aaa:	7013      	strb	r3, [r2, #0]
}
34004aac:	4770      	bx	lr
	...

34004ab0 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>:
  if (Pipe == DCMIPP_PIPE1)
34004ab0:	2901      	cmp	r1, #1
{
34004ab2:	b570      	push	{r4, r5, r6, lr}
  if (Pipe == DCMIPP_PIPE1)
34004ab4:	f040 808d 	bne.w	34004bd2 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x122>
    tmp = (uint16_t)READ_REG(hdcmipp->Instance->P1CCCR);
34004ab8:	6803      	ldr	r3, [r0, #0]
34004aba:	f8d3 1880 	ldr.w	r1, [r3, #2176]	@ 0x880
                                                 ? ENABLE : DISABLE;
34004abe:	f3c1 0080 	ubfx	r0, r1, #2, #1
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
34004ac2:	f001 0102 	and.w	r1, r1, #2
    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
34004ac6:	7010      	strb	r0, [r2, #0]
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
34004ac8:	7051      	strb	r1, [r2, #1]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
34004aca:	f8d3 4884 	ldr.w	r4, [r3, #2180]	@ 0x884
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34004ace:	4941      	ldr	r1, [pc, #260]	@ (34004bd4 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x124>)
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
34004ad0:	f3c4 400a 	ubfx	r0, r4, #16, #11
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34004ad4:	ea40 0501 	orr.w	r5, r0, r1
34004ad8:	f014 6f80 	tst.w	r4, #67108864	@ 0x4000000
34004adc:	bf18      	it	ne
34004ade:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
34004ae0:	f8d3 4884 	ldr.w	r4, [r3, #2180]	@ 0x884
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34004ae4:	8090      	strh	r0, [r2, #4]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
34004ae6:	f3c4 000a 	ubfx	r0, r4, #0, #11
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
34004aea:	ea40 0501 	orr.w	r5, r0, r1
34004aee:	f414 6f80 	tst.w	r4, #1024	@ 0x400
34004af2:	bf18      	it	ne
34004af4:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
34004af6:	f8d3 5888 	ldr.w	r5, [r3, #2184]	@ 0x888
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
34004afa:	8050      	strh	r0, [r2, #2]
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
34004afc:	4836      	ldr	r0, [pc, #216]	@ (34004bd8 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x128>)
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
34004afe:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
34004b02:	ea44 0600 	orr.w	r6, r4, r0
34004b06:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
34004b0a:	bf18      	it	ne
34004b0c:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
34004b0e:	f8d3 5888 	ldr.w	r5, [r3, #2184]	@ 0x888
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
34004b12:	8114      	strh	r4, [r2, #8]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
34004b14:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
34004b18:	ea44 0601 	orr.w	r6, r4, r1
34004b1c:	f415 6f80 	tst.w	r5, #1024	@ 0x400
34004b20:	bf18      	it	ne
34004b22:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
34004b24:	f8d3 588c 	ldr.w	r5, [r3, #2188]	@ 0x88c
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
34004b28:	80d4      	strh	r4, [r2, #6]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
34004b2a:	f3c5 440a 	ubfx	r4, r5, #16, #11
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
34004b2e:	ea44 0601 	orr.w	r6, r4, r1
34004b32:	f015 6f80 	tst.w	r5, #67108864	@ 0x4000000
34004b36:	bf18      	it	ne
34004b38:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
34004b3a:	f8d3 588c 	ldr.w	r5, [r3, #2188]	@ 0x88c
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
34004b3e:	8194      	strh	r4, [r2, #12]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
34004b40:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
34004b44:	ea44 0601 	orr.w	r6, r4, r1
34004b48:	f415 6f80 	tst.w	r5, #1024	@ 0x400
34004b4c:	bf18      	it	ne
34004b4e:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
34004b50:	f8d3 5890 	ldr.w	r5, [r3, #2192]	@ 0x890
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
34004b54:	8154      	strh	r4, [r2, #10]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
34004b56:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
34004b5a:	ea44 0600 	orr.w	r6, r4, r0
34004b5e:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
34004b62:	bf18      	it	ne
34004b64:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
34004b66:	f8d3 5890 	ldr.w	r5, [r3, #2192]	@ 0x890
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
34004b6a:	8214      	strh	r4, [r2, #16]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
34004b6c:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
34004b70:	ea44 0601 	orr.w	r6, r4, r1
34004b74:	f415 6f80 	tst.w	r5, #1024	@ 0x400
34004b78:	bf18      	it	ne
34004b7a:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
34004b7c:	f8d3 5898 	ldr.w	r5, [r3, #2200]	@ 0x898
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
34004b80:	81d4      	strh	r4, [r2, #14]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
34004b82:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->BA = (int16_t)GET_MATRIX_VALUE10(tmp);
34004b86:	4320      	orrs	r0, r4
34004b88:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
34004b8c:	bf18      	it	ne
34004b8e:	4604      	movne	r4, r0
34004b90:	8314      	strh	r4, [r2, #24]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB) >> DCMIPP_P1CCBR2_BB_Pos);
34004b92:	f8d3 4898 	ldr.w	r4, [r3, #2200]	@ 0x898
34004b96:	f3c4 000a 	ubfx	r0, r4, #0, #11
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
34004b9a:	ea40 0501 	orr.w	r5, r0, r1
34004b9e:	f414 6f80 	tst.w	r4, #1024	@ 0x400
34004ba2:	bf18      	it	ne
34004ba4:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
34004ba6:	f8d3 4894 	ldr.w	r4, [r3, #2196]	@ 0x894
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
34004baa:	82d0      	strh	r0, [r2, #22]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
34004bac:	f3c4 400a 	ubfx	r0, r4, #16, #11
    pColorConversionConfig->BG = (int16_t)GET_MATRIX_VALUE11(tmp);
34004bb0:	ea40 0501 	orr.w	r5, r0, r1
34004bb4:	f014 6f80 	tst.w	r4, #67108864	@ 0x4000000
34004bb8:	bf18      	it	ne
34004bba:	4628      	movne	r0, r5
34004bbc:	8290      	strh	r0, [r2, #20]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR) >> DCMIPP_P1CCBR1_BR_Pos);
34004bbe:	f8d3 0894 	ldr.w	r0, [r3, #2196]	@ 0x894
34004bc2:	f3c0 030a 	ubfx	r3, r0, #0, #11
    pColorConversionConfig->BR = (int16_t)GET_MATRIX_VALUE11(tmp);
34004bc6:	4319      	orrs	r1, r3
34004bc8:	f410 6f80 	tst.w	r0, #1024	@ 0x400
34004bcc:	bf18      	it	ne
34004bce:	460b      	movne	r3, r1
34004bd0:	8253      	strh	r3, [r2, #18]
}
34004bd2:	bd70      	pop	{r4, r5, r6, pc}
34004bd4:	fffff800 	.word	0xfffff800
34004bd8:	fffffc00 	.word	0xfffffc00

34004bdc <HAL_DCMIPP_PIPE_IsEnabledISPExposure>:
  if (Pipe == DCMIPP_PIPE1)
34004bdc:	2901      	cmp	r1, #1
    return ((READ_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE) == DCMIPP_P1EXCR1_ENABLE) ? 1U : 0U);
34004bde:	bf03      	ittte	eq
34004be0:	6803      	ldreq	r3, [r0, #0]
34004be2:	f8d3 0844 	ldreq.w	r0, [r3, #2116]	@ 0x844
34004be6:	f000 0001 	andeq.w	r0, r0, #1
    return 0;
34004bea:	2000      	movne	r0, #0
}
34004bec:	4770      	bx	lr

34004bee <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>:
  if (Pipe == DCMIPP_PIPE1)
34004bee:	2901      	cmp	r1, #1
    return ((READ_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE) == DCMIPP_P1CCCR_ENABLE) ? 1U : 0U);
34004bf0:	bf03      	ittte	eq
34004bf2:	6803      	ldreq	r3, [r0, #0]
34004bf4:	f8d3 0880 	ldreq.w	r0, [r3, #2176]	@ 0x880
34004bf8:	f000 0001 	andeq.w	r0, r0, #1
    return 0;
34004bfc:	2000      	movne	r0, #0
}
34004bfe:	4770      	bx	lr

34004c00 <HAL_DCMIPP_GetState>:
  return hdcmipp->State;
34004c00:	7900      	ldrb	r0, [r0, #4]
}
34004c02:	4770      	bx	lr

34004c04 <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
34004c04:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
34004c06:	6804      	ldr	r4, [r0, #0]
34004c08:	9d05      	ldr	r5, [sp, #20]
34004c0a:	6c66      	ldr	r6, [r4, #68]	@ 0x44
34004c0c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
34004c10:	6843      	ldr	r3, [r0, #4]
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
34004c12:	f006 4640 	and.w	r6, r6, #3221225472	@ 0xc0000000
34004c16:	4335      	orrs	r5, r6
  if (hdma2d->Init.Mode == DMA2D_R2M)
34004c18:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
34004c1c:	6465      	str	r5, [r4, #68]	@ 0x44
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
34004c1e:	63e2      	str	r2, [r4, #60]	@ 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
34004c20:	d12f      	bne.n	34004c82 <DMA2D_SetConfig+0x7e>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
34004c22:	6880      	ldr	r0, [r0, #8]
34004c24:	f001 467f 	and.w	r6, r1, #4278190080	@ 0xff000000
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
34004c28:	f401 037f 	and.w	r3, r1, #16711680	@ 0xff0000
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
34004c2c:	f401 427f 	and.w	r2, r1, #65280	@ 0xff00
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
34004c30:	b2cd      	uxtb	r5, r1

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
34004c32:	2803      	cmp	r0, #3
34004c34:	d81a      	bhi.n	34004c6c <DMA2D_SetConfig+0x68>
34004c36:	e8df f000 	tbb	[pc, r0]
34004c3a:	0204      	.short	0x0204
34004c3c:	0e06      	.short	0x0e06
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
    {
      tmp = (tmp3 | tmp2 | tmp4);
34004c3e:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
      tmp3 = (tmp3 >> 12U);
      tmp4 = (tmp4 >> 4U);
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
34004c42:	63a1      	str	r1, [r4, #56]	@ 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
34004c44:	bdf0      	pop	{r4, r5, r6, r7, pc}
      tmp2 = (tmp2 >> 19U);
34004c46:	0cd9      	lsrs	r1, r3, #19
      tmp3 = (tmp3 >> 10U);
34004c48:	0a92      	lsrs	r2, r2, #10
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
34004c4a:	02c9      	lsls	r1, r1, #11
34004c4c:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
34004c50:	ea41 01d5 	orr.w	r1, r1, r5, lsr #3
34004c54:	e7f5      	b.n	34004c42 <DMA2D_SetConfig+0x3e>
      tmp2 = (tmp2 >> 19U);
34004c56:	0cdb      	lsrs	r3, r3, #19
      tmp3 = (tmp3 >> 11U);
34004c58:	0ad2      	lsrs	r2, r2, #11
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
34004c5a:	029b      	lsls	r3, r3, #10
34004c5c:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
34004c60:	ea43 03d5 	orr.w	r3, r3, r5, lsr #3
      tmp1 = (tmp1 >> 31U);
34004c64:	0ff1      	lsrs	r1, r6, #31
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
34004c66:	ea43 31c1 	orr.w	r1, r3, r1, lsl #15
34004c6a:	e7ea      	b.n	34004c42 <DMA2D_SetConfig+0x3e>
      tmp2 = (tmp2 >> 20U);
34004c6c:	0d1b      	lsrs	r3, r3, #20
      tmp3 = (tmp3 >> 12U);
34004c6e:	0b12      	lsrs	r2, r2, #12
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
34004c70:	021b      	lsls	r3, r3, #8
34004c72:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
34004c76:	ea43 1315 	orr.w	r3, r3, r5, lsr #4
      tmp1 = (tmp1 >> 28U);
34004c7a:	0f36      	lsrs	r6, r6, #28
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
34004c7c:	ea43 3106 	orr.w	r1, r3, r6, lsl #12
34004c80:	e7df      	b.n	34004c42 <DMA2D_SetConfig+0x3e>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
34004c82:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
34004c86:	bf0c      	ite	eq
34004c88:	6161      	streq	r1, [r4, #20]
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
34004c8a:	60e1      	strne	r1, [r4, #12]
}
34004c8c:	e7da      	b.n	34004c44 <DMA2D_SetConfig+0x40>

34004c8e <HAL_DMA2D_Init>:
{
34004c8e:	b510      	push	{r4, lr}
  if (hdma2d == NULL)
34004c90:	4604      	mov	r4, r0
34004c92:	2800      	cmp	r0, #0
34004c94:	d036      	beq.n	34004d04 <HAL_DMA2D_Init+0x76>
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
34004c96:	f890 3061 	ldrb.w	r3, [r0, #97]	@ 0x61
34004c9a:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
34004c9e:	b91b      	cbnz	r3, 34004ca8 <HAL_DMA2D_Init+0x1a>
    hdma2d->Lock = HAL_UNLOCKED;
34004ca0:	f880 2060 	strb.w	r2, [r0, #96]	@ 0x60
    HAL_DMA2D_MspInit(hdma2d);
34004ca4:	f7fd f8a6 	bl	34001df4 <HAL_DMA2D_MspInit>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34004ca8:	2302      	movs	r3, #2
34004caa:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
34004cae:	6823      	ldr	r3, [r4, #0]
34004cb0:	69e0      	ldr	r0, [r4, #28]
34004cb2:	6819      	ldr	r1, [r3, #0]
34004cb4:	6862      	ldr	r2, [r4, #4]
34004cb6:	f421 21e0 	bic.w	r1, r1, #458752	@ 0x70000
34004cba:	4302      	orrs	r2, r0
34004cbc:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
34004cc0:	430a      	orrs	r2, r1
34004cc2:	601a      	str	r2, [r3, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
34004cc4:	6b59      	ldr	r1, [r3, #52]	@ 0x34
34004cc6:	69a0      	ldr	r0, [r4, #24]
34004cc8:	68a2      	ldr	r2, [r4, #8]
34004cca:	f421 7183 	bic.w	r1, r1, #262	@ 0x106
34004cce:	4302      	orrs	r2, r0
34004cd0:	f021 0101 	bic.w	r1, r1, #1
34004cd4:	430a      	orrs	r2, r1
34004cd6:	635a      	str	r2, [r3, #52]	@ 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
34004cd8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34004cda:	68e1      	ldr	r1, [r4, #12]
34004cdc:	f36f 020f 	bfc	r2, #0, #16
34004ce0:	430a      	orrs	r2, r1
34004ce2:	641a      	str	r2, [r3, #64]	@ 0x40
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
34004ce4:	6b59      	ldr	r1, [r3, #52]	@ 0x34
34004ce6:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
34004cea:	0552      	lsls	r2, r2, #21
34004cec:	ea42 5200 	orr.w	r2, r2, r0, lsl #20
34004cf0:	f421 1140 	bic.w	r1, r1, #3145728	@ 0x300000
34004cf4:	430a      	orrs	r2, r1
34004cf6:	635a      	str	r2, [r3, #52]	@ 0x34
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
34004cf8:	2000      	movs	r0, #0
  hdma2d->State  = HAL_DMA2D_STATE_READY;
34004cfa:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
34004cfc:	6660      	str	r0, [r4, #100]	@ 0x64
  hdma2d->State  = HAL_DMA2D_STATE_READY;
34004cfe:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
}
34004d02:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34004d04:	2001      	movs	r0, #1
34004d06:	e7fc      	b.n	34004d02 <HAL_DMA2D_Init+0x74>

34004d08 <HAL_DMA2D_Start>:
{
34004d08:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __HAL_LOCK(hdma2d);
34004d0a:	f890 5060 	ldrb.w	r5, [r0, #96]	@ 0x60
{
34004d0e:	4604      	mov	r4, r0
  __HAL_LOCK(hdma2d);
34004d10:	2d01      	cmp	r5, #1
34004d12:	f04f 0502 	mov.w	r5, #2
34004d16:	d00f      	beq.n	34004d38 <HAL_DMA2D_Start+0x30>
34004d18:	2601      	movs	r6, #1
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34004d1a:	f880 5061 	strb.w	r5, [r0, #97]	@ 0x61
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
34004d1e:	9d06      	ldr	r5, [sp, #24]
  __HAL_LOCK(hdma2d);
34004d20:	f880 6060 	strb.w	r6, [r0, #96]	@ 0x60
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
34004d24:	9500      	str	r5, [sp, #0]
34004d26:	f7ff ff6d 	bl	34004c04 <DMA2D_SetConfig>
  return HAL_OK;
34004d2a:	2000      	movs	r0, #0
  __HAL_DMA2D_ENABLE(hdma2d);
34004d2c:	6822      	ldr	r2, [r4, #0]
34004d2e:	6813      	ldr	r3, [r2, #0]
34004d30:	4333      	orrs	r3, r6
34004d32:	6013      	str	r3, [r2, #0]
}
34004d34:	b002      	add	sp, #8
34004d36:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hdma2d);
34004d38:	4628      	mov	r0, r5
34004d3a:	e7fb      	b.n	34004d34 <HAL_DMA2D_Start+0x2c>

34004d3c <HAL_DMA2D_PollForTransfer>:
  __IO uint32_t isrflags = 0x0U;
34004d3c:	2300      	movs	r3, #0
{
34004d3e:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t isrflags = 0x0U;
34004d40:	9301      	str	r3, [sp, #4]
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
34004d42:	6803      	ldr	r3, [r0, #0]
{
34004d44:	4604      	mov	r4, r0
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
34004d46:	681b      	ldr	r3, [r3, #0]
{
34004d48:	460d      	mov	r5, r1
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
34004d4a:	07db      	lsls	r3, r3, #31
34004d4c:	d418      	bmi.n	34004d80 <HAL_DMA2D_PollForTransfer+0x44>
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
34004d4e:	6822      	ldr	r2, [r4, #0]
34004d50:	69d3      	ldr	r3, [r2, #28]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
34004d52:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34004d54:	4313      	orrs	r3, r2
  if (layer_start != 0U)
34004d56:	069e      	lsls	r6, r3, #26
34004d58:	d506      	bpl.n	34004d68 <HAL_DMA2D_PollForTransfer+0x2c>
    tickstart = HAL_GetTick();
34004d5a:	f7fe fca5 	bl	340036a8 <HAL_GetTick>
34004d5e:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
34004d60:	6823      	ldr	r3, [r4, #0]
34004d62:	685a      	ldr	r2, [r3, #4]
34004d64:	06d2      	lsls	r2, r2, #27
34004d66:	d53f      	bpl.n	34004de8 <HAL_DMA2D_PollForTransfer+0xac>
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
34004d68:	2212      	movs	r2, #18
34004d6a:	6823      	ldr	r3, [r4, #0]
  return HAL_OK;
34004d6c:	2000      	movs	r0, #0
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
34004d6e:	609a      	str	r2, [r3, #8]
  hdma2d->State = HAL_DMA2D_STATE_READY;
34004d70:	2301      	movs	r3, #1
34004d72:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
        __HAL_UNLOCK(hdma2d);
34004d76:	2300      	movs	r3, #0
34004d78:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
}
34004d7c:	b002      	add	sp, #8
34004d7e:	bd70      	pop	{r4, r5, r6, pc}
    tickstart = HAL_GetTick();
34004d80:	f7fe fc92 	bl	340036a8 <HAL_GetTick>
34004d84:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
34004d86:	6823      	ldr	r3, [r4, #0]
34004d88:	685a      	ldr	r2, [r3, #4]
34004d8a:	0792      	lsls	r2, r2, #30
34004d8c:	d4df      	bmi.n	34004d4e <HAL_DMA2D_PollForTransfer+0x12>
      isrflags = READ_REG(hdma2d->Instance->ISR);
34004d8e:	685a      	ldr	r2, [r3, #4]
34004d90:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34004d92:	9a01      	ldr	r2, [sp, #4]
34004d94:	f012 0f21 	tst.w	r2, #33	@ 0x21
34004d98:	d014      	beq.n	34004dc4 <HAL_DMA2D_PollForTransfer+0x88>
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34004d9a:	9a01      	ldr	r2, [sp, #4]
34004d9c:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34004d9e:	bf42      	ittt	mi
34004da0:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34004da2:	f042 0202 	orrmi.w	r2, r2, #2
34004da6:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34004da8:	9a01      	ldr	r2, [sp, #4]
34004daa:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34004dac:	bf42      	ittt	mi
34004dae:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34004db0:	f042 0201 	orrmi.w	r2, r2, #1
34004db4:	6662      	strmi	r2, [r4, #100]	@ 0x64
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34004db6:	2221      	movs	r2, #33	@ 0x21
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34004db8:	609a      	str	r2, [r3, #8]
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34004dba:	2304      	movs	r3, #4
        return HAL_ERROR;
34004dbc:	2001      	movs	r0, #1
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34004dbe:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
        return HAL_ERROR;
34004dc2:	e7d8      	b.n	34004d76 <HAL_DMA2D_PollForTransfer+0x3a>
      if (Timeout != HAL_MAX_DELAY)
34004dc4:	1c69      	adds	r1, r5, #1
34004dc6:	d0df      	beq.n	34004d88 <HAL_DMA2D_PollForTransfer+0x4c>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34004dc8:	f7fe fc6e 	bl	340036a8 <HAL_GetTick>
34004dcc:	1b80      	subs	r0, r0, r6
34004dce:	42a8      	cmp	r0, r5
34004dd0:	d801      	bhi.n	34004dd6 <HAL_DMA2D_PollForTransfer+0x9a>
34004dd2:	2d00      	cmp	r5, #0
34004dd4:	d1d7      	bne.n	34004d86 <HAL_DMA2D_PollForTransfer+0x4a>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34004dd6:	6e63      	ldr	r3, [r4, #100]	@ 0x64
          return HAL_TIMEOUT;
34004dd8:	2003      	movs	r0, #3
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34004dda:	f043 0320 	orr.w	r3, r3, #32
34004dde:	6663      	str	r3, [r4, #100]	@ 0x64
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
34004de0:	2303      	movs	r3, #3
34004de2:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
          return HAL_TIMEOUT;
34004de6:	e7c6      	b.n	34004d76 <HAL_DMA2D_PollForTransfer+0x3a>
      isrflags = READ_REG(hdma2d->Instance->ISR);
34004de8:	685a      	ldr	r2, [r3, #4]
34004dea:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34004dec:	9a01      	ldr	r2, [sp, #4]
34004dee:	f012 0f29 	tst.w	r2, #41	@ 0x29
34004df2:	d016      	beq.n	34004e22 <HAL_DMA2D_PollForTransfer+0xe6>
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
34004df4:	9a01      	ldr	r2, [sp, #4]
34004df6:	0716      	lsls	r6, r2, #28
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
34004df8:	bf42      	ittt	mi
34004dfa:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34004dfc:	f042 0204 	orrmi.w	r2, r2, #4
34004e00:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34004e02:	9a01      	ldr	r2, [sp, #4]
34004e04:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34004e06:	bf42      	ittt	mi
34004e08:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34004e0a:	f042 0202 	orrmi.w	r2, r2, #2
34004e0e:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34004e10:	9a01      	ldr	r2, [sp, #4]
34004e12:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34004e14:	bf42      	ittt	mi
34004e16:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34004e18:	f042 0201 	orrmi.w	r2, r2, #1
34004e1c:	6662      	strmi	r2, [r4, #100]	@ 0x64
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34004e1e:	2229      	movs	r2, #41	@ 0x29
34004e20:	e7ca      	b.n	34004db8 <HAL_DMA2D_PollForTransfer+0x7c>
      if (Timeout != HAL_MAX_DELAY)
34004e22:	1c69      	adds	r1, r5, #1
34004e24:	d09d      	beq.n	34004d62 <HAL_DMA2D_PollForTransfer+0x26>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34004e26:	f7fe fc3f 	bl	340036a8 <HAL_GetTick>
34004e2a:	1b80      	subs	r0, r0, r6
34004e2c:	42a8      	cmp	r0, r5
34004e2e:	d8d2      	bhi.n	34004dd6 <HAL_DMA2D_PollForTransfer+0x9a>
34004e30:	2d00      	cmp	r5, #0
34004e32:	d195      	bne.n	34004d60 <HAL_DMA2D_PollForTransfer+0x24>
34004e34:	e7cf      	b.n	34004dd6 <HAL_DMA2D_PollForTransfer+0x9a>
	...

34004e38 <HAL_DMA2D_ConfigLayer>:
{
34004e38:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma2d);
34004e3a:	f890 3060 	ldrb.w	r3, [r0, #96]	@ 0x60
{
34004e3e:	4602      	mov	r2, r0
  __HAL_LOCK(hdma2d);
34004e40:	2b01      	cmp	r3, #1
34004e42:	f04f 0002 	mov.w	r0, #2
34004e46:	d033      	beq.n	34004eb0 <HAL_DMA2D_ConfigLayer+0x78>
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34004e48:	241c      	movs	r4, #28
  __HAL_LOCK(hdma2d);
34004e4a:	2301      	movs	r3, #1
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34004e4c:	fb04 2401 	mla	r4, r4, r1, r2
  __HAL_LOCK(hdma2d);
34004e50:	f882 3060 	strb.w	r3, [r2, #96]	@ 0x60
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34004e54:	f882 0061 	strb.w	r0, [r2, #97]	@ 0x61
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34004e58:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34004e5a:	e9d4 600b 	ldrd	r6, r0, [r4, #44]	@ 0x2c
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34004e5e:	051b      	lsls	r3, r3, #20
34004e60:	6b67      	ldr	r7, [r4, #52]	@ 0x34
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34004e62:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34004e66:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34004e68:	4333      	orrs	r3, r6
34004e6a:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34004e6e:	f1a6 0509 	sub.w	r5, r6, #9
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
34004e72:	f007 407f 	and.w	r0, r7, #4278190080	@ 0xff000000
34004e76:	4318      	orrs	r0, r3
34004e78:	2d01      	cmp	r5, #1
34004e7a:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
34004e7e:	bf98      	it	ls
34004e80:	4603      	movls	r3, r0
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
34004e82:	6810      	ldr	r0, [r2, #0]
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
34004e84:	b9a9      	cbnz	r1, 34004eb2 <HAL_DMA2D_ConfigLayer+0x7a>
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
34004e86:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34004e88:	4917      	ldr	r1, [pc, #92]	@ (34004ee8 <HAL_DMA2D_ConfigLayer+0xb0>)
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34004e8a:	2d01      	cmp	r5, #1
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
34004e8c:	ea01 0104 	and.w	r1, r1, r4
34004e90:	ea41 0103 	orr.w	r1, r1, r3
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
34004e94:	6a93      	ldr	r3, [r2, #40]	@ 0x28
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
34004e96:	6241      	str	r1, [r0, #36]	@ 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
34004e98:	6183      	str	r3, [r0, #24]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34004e9a:	d803      	bhi.n	34004ea4 <HAL_DMA2D_ConfigLayer+0x6c>
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
34004e9c:	6b53      	ldr	r3, [r2, #52]	@ 0x34
34004e9e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34004ea2:	6283      	str	r3, [r0, #40]	@ 0x28
  hdma2d->State = HAL_DMA2D_STATE_READY;
34004ea4:	2301      	movs	r3, #1
  __HAL_UNLOCK(hdma2d);
34004ea6:	2000      	movs	r0, #0
  hdma2d->State = HAL_DMA2D_STATE_READY;
34004ea8:	f882 3061 	strb.w	r3, [r2, #97]	@ 0x61
  __HAL_UNLOCK(hdma2d);
34004eac:	f882 0060 	strb.w	r0, [r2, #96]	@ 0x60
}
34004eb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
34004eb2:	2e0b      	cmp	r6, #11
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
34004eb4:	bf03      	ittte	eq
34004eb6:	6c24      	ldreq	r4, [r4, #64]	@ 0x40
      regMask  |= DMA2D_FGPFCCR_CSS;
34004eb8:	4e0c      	ldreq	r6, [pc, #48]	@ (34004eec <HAL_DMA2D_ConfigLayer+0xb4>)
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
34004eba:	ea43 4384 	orreq.w	r3, r3, r4, lsl #18
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
34004ebe:	4e0c      	ldrne	r6, [pc, #48]	@ (34004ef0 <HAL_DMA2D_ConfigLayer+0xb8>)
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
34004ec0:	69c4      	ldr	r4, [r0, #28]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34004ec2:	2d01      	cmp	r5, #1
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
34004ec4:	ea24 0406 	bic.w	r4, r4, r6
34004ec8:	ea43 0304 	orr.w	r3, r3, r4
34004ecc:	61c3      	str	r3, [r0, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
34004ece:	f04f 031c 	mov.w	r3, #28
34004ed2:	fb03 2101 	mla	r1, r3, r1, r2
34004ed6:	6a8b      	ldr	r3, [r1, #40]	@ 0x28
34004ed8:	6103      	str	r3, [r0, #16]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
34004eda:	bf9e      	ittt	ls
34004edc:	6b4b      	ldrls	r3, [r1, #52]	@ 0x34
34004ede:	f023 437f 	bicls.w	r3, r3, #4278190080	@ 0xff000000
34004ee2:	6203      	strls	r3, [r0, #32]
34004ee4:	e7de      	b.n	34004ea4 <HAL_DMA2D_ConfigLayer+0x6c>
34004ee6:	bf00      	nop
34004ee8:	00ccfff0 	.word	0x00ccfff0
34004eec:	ff3f000f 	.word	0xff3f000f
34004ef0:	ff33000f 	.word	0xff33000f

34004ef4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
34004ef4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
34004ef8:	2200      	movs	r2, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        temp = EXTI->EXTICR[position >> 2u];
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34004efa:	f04f 0a0f 	mov.w	sl, #15
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
        EXTI->EXTICR[position >> 2u] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
34004efe:	4c73      	ldr	r4, [pc, #460]	@ (340050cc <HAL_GPIO_Init+0x1d8>)
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34004f00:	680b      	ldr	r3, [r1, #0]
34004f02:	fa33 f502 	lsrs.w	r5, r3, r2
34004f06:	d101      	bne.n	34004f0c <HAL_GPIO_Init+0x18>
      }
    }

    position++;
  }
}
34004f08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
34004f0c:	2501      	movs	r5, #1
34004f0e:	fa05 f902 	lsl.w	r9, r5, r2
    if (iocurrent != 0x00u)
34004f12:	ea19 0303 	ands.w	r3, r9, r3
34004f16:	f000 80c1 	beq.w	3400509c <HAL_GPIO_Init+0x1a8>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34004f1a:	2703      	movs	r7, #3
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34004f1c:	684e      	ldr	r6, [r1, #4]
34004f1e:	ea4f 0842 	mov.w	r8, r2, lsl #1
34004f22:	f006 0503 	and.w	r5, r6, #3
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34004f26:	fa07 fe08 	lsl.w	lr, r7, r8
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34004f2a:	1e6f      	subs	r7, r5, #1
34004f2c:	2f01      	cmp	r7, #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34004f2e:	ea6f 0e0e 	mvn.w	lr, lr
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34004f32:	f8d1 c008 	ldr.w	ip, [r1, #8]
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34004f36:	d831      	bhi.n	34004f9c <HAL_GPIO_Init+0xa8>
        temp = GPIOx->OSPEEDR;
34004f38:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34004f3a:	ea07 0b0e 	and.w	fp, r7, lr
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34004f3e:	68cf      	ldr	r7, [r1, #12]
34004f40:	fa07 f708 	lsl.w	r7, r7, r8
34004f44:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
34004f48:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
34004f4a:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34004f4c:	ea27 0909 	bic.w	r9, r7, r9
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34004f50:	f3c6 1700 	ubfx	r7, r6, #4, #1
34004f54:	4097      	lsls	r7, r2
34004f56:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OTYPER = temp;
34004f5a:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
34004f5c:	68c7      	ldr	r7, [r0, #12]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34004f5e:	fa0c fc08 	lsl.w	ip, ip, r8
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34004f62:	ea07 070e 	and.w	r7, r7, lr
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34004f66:	ea4c 0707 	orr.w	r7, ip, r7
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
34004f6a:	2d02      	cmp	r5, #2
        GPIOx->PUPDR = temp;
34004f6c:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
34004f6e:	d11a      	bne.n	34004fa6 <HAL_GPIO_Init+0xb2>
        temp = GPIOx->AFR[position >> 3u];
34004f70:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
34004f74:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34004f78:	f002 0907 	and.w	r9, r2, #7
        temp = GPIOx->AFR[position >> 3u];
34004f7c:	f8dc 7020 	ldr.w	r7, [ip, #32]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34004f80:	ea4f 0989 	mov.w	r9, r9, lsl #2
34004f84:	fa0a fb09 	lsl.w	fp, sl, r9
34004f88:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34004f8c:	690f      	ldr	r7, [r1, #16]
34004f8e:	fa07 f709 	lsl.w	r7, r7, r9
34004f92:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3u] = temp;
34004f96:	f8cc 7020 	str.w	r7, [ip, #32]
34004f9a:	e004      	b.n	34004fa6 <HAL_GPIO_Init+0xb2>
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34004f9c:	2d03      	cmp	r5, #3
34004f9e:	d1dd      	bne.n	34004f5c <HAL_GPIO_Init+0x68>
34004fa0:	f1bc 0f01 	cmp.w	ip, #1
34004fa4:	d1da      	bne.n	34004f5c <HAL_GPIO_Init+0x68>
      temp = GPIOx->MODER;
34004fa6:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
34004fa8:	fa05 f508 	lsl.w	r5, r5, r8
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34004fac:	ea07 070e 	and.w	r7, r7, lr
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
34004fb0:	433d      	orrs	r5, r7
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34004fb2:	f416 3f40 	tst.w	r6, #196608	@ 0x30000
      GPIOx->MODER = temp;
34004fb6:	6005      	str	r5, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34004fb8:	d070      	beq.n	3400509c <HAL_GPIO_Init+0x1a8>
        temp = EXTI->EXTICR[position >> 2u];
34004fba:	f022 0703 	bic.w	r7, r2, #3
34004fbe:	f107 47ac 	add.w	r7, r7, #1442840576	@ 0x56000000
34004fc2:	f507 3714 	add.w	r7, r7, #151552	@ 0x25000
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34004fc6:	f002 0c03 	and.w	ip, r2, #3
        temp = EXTI->EXTICR[position >> 2u];
34004fca:	6e3d      	ldr	r5, [r7, #96]	@ 0x60
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34004fcc:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
34004fd0:	fa0a fe0c 	lsl.w	lr, sl, ip
34004fd4:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34004fd8:	4d3d      	ldr	r5, [pc, #244]	@ (340050d0 <HAL_GPIO_Init+0x1dc>)
34004fda:	42a8      	cmp	r0, r5
34004fdc:	d060      	beq.n	340050a0 <HAL_GPIO_Init+0x1ac>
34004fde:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
34004fe2:	42a8      	cmp	r0, r5
34004fe4:	d05e      	beq.n	340050a4 <HAL_GPIO_Init+0x1b0>
34004fe6:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
34004fea:	42a8      	cmp	r0, r5
34004fec:	d05c      	beq.n	340050a8 <HAL_GPIO_Init+0x1b4>
34004fee:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
34004ff2:	42a8      	cmp	r0, r5
34004ff4:	d05a      	beq.n	340050ac <HAL_GPIO_Init+0x1b8>
34004ff6:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
34004ffa:	42a8      	cmp	r0, r5
34004ffc:	d058      	beq.n	340050b0 <HAL_GPIO_Init+0x1bc>
34004ffe:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
34005002:	42a8      	cmp	r0, r5
34005004:	d056      	beq.n	340050b4 <HAL_GPIO_Init+0x1c0>
34005006:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
3400500a:	42a8      	cmp	r0, r5
3400500c:	d054      	beq.n	340050b8 <HAL_GPIO_Init+0x1c4>
3400500e:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
34005012:	42a8      	cmp	r0, r5
34005014:	d052      	beq.n	340050bc <HAL_GPIO_Init+0x1c8>
34005016:	f505 55c0 	add.w	r5, r5, #6144	@ 0x1800
3400501a:	42a8      	cmp	r0, r5
3400501c:	d050      	beq.n	340050c0 <HAL_GPIO_Init+0x1cc>
3400501e:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
34005022:	42a8      	cmp	r0, r5
34005024:	d04e      	beq.n	340050c4 <HAL_GPIO_Init+0x1d0>
34005026:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
3400502a:	42a8      	cmp	r0, r5
3400502c:	d04c      	beq.n	340050c8 <HAL_GPIO_Init+0x1d4>
3400502e:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
34005032:	42a8      	cmp	r0, r5
34005034:	bf14      	ite	ne
34005036:	2510      	movne	r5, #16
34005038:	250b      	moveq	r5, #11
3400503a:	fa05 f50c 	lsl.w	r5, r5, ip
3400503e:	ea45 050e 	orr.w	r5, r5, lr
        EXTI->EXTICR[position >> 2u] = temp;
34005042:	663d      	str	r5, [r7, #96]	@ 0x60
        temp = EXTI->IMR1;
34005044:	f8d4 5080 	ldr.w	r5, [r4, #128]	@ 0x80
        temp &= ~(iocurrent);
34005048:	f416 3f80 	tst.w	r6, #65536	@ 0x10000
3400504c:	ea25 0703 	bic.w	r7, r5, r3
34005050:	ea45 0503 	orr.w	r5, r5, r3
34005054:	bf08      	it	eq
34005056:	463d      	moveq	r5, r7
        EXTI->IMR1 = temp;
34005058:	f8c4 5080 	str.w	r5, [r4, #128]	@ 0x80
        temp = EXTI->EMR1;
3400505c:	f8d4 5084 	ldr.w	r5, [r4, #132]	@ 0x84
        temp &= ~(iocurrent);
34005060:	f416 3f00 	tst.w	r6, #131072	@ 0x20000
34005064:	ea25 0703 	bic.w	r7, r5, r3
34005068:	ea45 0503 	orr.w	r5, r5, r3
3400506c:	bf08      	it	eq
3400506e:	463d      	moveq	r5, r7
        EXTI->EMR1 = temp;
34005070:	f8c4 5084 	str.w	r5, [r4, #132]	@ 0x84
        temp = EXTI->RTSR1;
34005074:	6825      	ldr	r5, [r4, #0]
        temp &= ~(iocurrent);
34005076:	f416 1f80 	tst.w	r6, #1048576	@ 0x100000
3400507a:	ea25 0703 	bic.w	r7, r5, r3
3400507e:	ea45 0503 	orr.w	r5, r5, r3
34005082:	bf08      	it	eq
34005084:	463d      	moveq	r5, r7
        EXTI->RTSR1 = temp;
34005086:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
34005088:	6865      	ldr	r5, [r4, #4]
        temp &= ~(iocurrent);
3400508a:	f416 1f00 	tst.w	r6, #2097152	@ 0x200000
3400508e:	ea25 0703 	bic.w	r7, r5, r3
34005092:	ea43 0305 	orr.w	r3, r3, r5
34005096:	bf08      	it	eq
34005098:	463b      	moveq	r3, r7
        EXTI->FTSR1 = temp;
3400509a:	6063      	str	r3, [r4, #4]
    position++;
3400509c:	3201      	adds	r2, #1
3400509e:	e72f      	b.n	34004f00 <HAL_GPIO_Init+0xc>
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340050a0:	2500      	movs	r5, #0
340050a2:	e7ca      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050a4:	2501      	movs	r5, #1
340050a6:	e7c8      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050a8:	2502      	movs	r5, #2
340050aa:	e7c6      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050ac:	2503      	movs	r5, #3
340050ae:	e7c4      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050b0:	2504      	movs	r5, #4
340050b2:	e7c2      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050b4:	2505      	movs	r5, #5
340050b6:	e7c0      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050b8:	2506      	movs	r5, #6
340050ba:	e7be      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050bc:	2507      	movs	r5, #7
340050be:	e7bc      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050c0:	2508      	movs	r5, #8
340050c2:	e7ba      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050c4:	2509      	movs	r5, #9
340050c6:	e7b8      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050c8:	250a      	movs	r5, #10
340050ca:	e7b6      	b.n	3400503a <HAL_GPIO_Init+0x146>
340050cc:	56025000 	.word	0x56025000
340050d0:	56020000 	.word	0x56020000

340050d4 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
340050d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
340050d8:	2200      	movs	r2, #0

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1uL << position);
340050da:	f04f 0a01 	mov.w	sl, #1
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = EXTI->EXTICR[position >> 2u];
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340050de:	f04f 080f 	mov.w	r8, #15
        EXTI->EXTICR[position >> 2u] &= ~tmp;
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
340050e2:	f04f 0b03 	mov.w	fp, #3
        EXTI->IMR1 &= ~(iocurrent);
340050e6:	4c51      	ldr	r4, [pc, #324]	@ (3400522c <HAL_GPIO_DeInit+0x158>)
  while ((GPIO_Pin >> position) != 0x00u)
340050e8:	fa31 f302 	lsrs.w	r3, r1, r2
340050ec:	d101      	bne.n	340050f2 <HAL_GPIO_DeInit+0x1e>
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
    }

    position++;
  }
}
340050ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
340050f2:	fa0a fc02 	lsl.w	ip, sl, r2
    if (iocurrent != 0x00u)
340050f6:	ea1c 0601 	ands.w	r6, ip, r1
340050fa:	d07f      	beq.n	340051fc <HAL_GPIO_DeInit+0x128>
      tmp = EXTI->EXTICR[position >> 2u];
340050fc:	f022 0503 	bic.w	r5, r2, #3
34005100:	f105 45ac 	add.w	r5, r5, #1442840576	@ 0x56000000
34005104:	f505 3514 	add.w	r5, r5, #151552	@ 0x25000
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34005108:	f002 0703 	and.w	r7, r2, #3
      tmp = EXTI->EXTICR[position >> 2u];
3400510c:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3400510e:	00ff      	lsls	r7, r7, #3
34005110:	fa08 f907 	lsl.w	r9, r8, r7
34005114:	ea09 0e03 	and.w	lr, r9, r3
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
34005118:	4b45      	ldr	r3, [pc, #276]	@ (34005230 <HAL_GPIO_DeInit+0x15c>)
3400511a:	4298      	cmp	r0, r3
3400511c:	d070      	beq.n	34005200 <HAL_GPIO_DeInit+0x12c>
3400511e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34005122:	4298      	cmp	r0, r3
34005124:	d06e      	beq.n	34005204 <HAL_GPIO_DeInit+0x130>
34005126:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400512a:	4298      	cmp	r0, r3
3400512c:	d06c      	beq.n	34005208 <HAL_GPIO_DeInit+0x134>
3400512e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34005132:	4298      	cmp	r0, r3
34005134:	d06a      	beq.n	3400520c <HAL_GPIO_DeInit+0x138>
34005136:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400513a:	4298      	cmp	r0, r3
3400513c:	d068      	beq.n	34005210 <HAL_GPIO_DeInit+0x13c>
3400513e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34005142:	4298      	cmp	r0, r3
34005144:	d066      	beq.n	34005214 <HAL_GPIO_DeInit+0x140>
34005146:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400514a:	4298      	cmp	r0, r3
3400514c:	d064      	beq.n	34005218 <HAL_GPIO_DeInit+0x144>
3400514e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34005152:	4298      	cmp	r0, r3
34005154:	d062      	beq.n	3400521c <HAL_GPIO_DeInit+0x148>
34005156:	f503 53c0 	add.w	r3, r3, #6144	@ 0x1800
3400515a:	4298      	cmp	r0, r3
3400515c:	d060      	beq.n	34005220 <HAL_GPIO_DeInit+0x14c>
3400515e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34005162:	4298      	cmp	r0, r3
34005164:	d05e      	beq.n	34005224 <HAL_GPIO_DeInit+0x150>
34005166:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400516a:	4298      	cmp	r0, r3
3400516c:	d05c      	beq.n	34005228 <HAL_GPIO_DeInit+0x154>
3400516e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34005172:	4298      	cmp	r0, r3
34005174:	bf14      	ite	ne
34005176:	2310      	movne	r3, #16
34005178:	230b      	moveq	r3, #11
3400517a:	40bb      	lsls	r3, r7
3400517c:	4573      	cmp	r3, lr
3400517e:	d117      	bne.n	340051b0 <HAL_GPIO_DeInit+0xdc>
        EXTI->IMR1 &= ~(iocurrent);
34005180:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
34005184:	ea23 0306 	bic.w	r3, r3, r6
34005188:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
3400518c:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
34005190:	ea23 0306 	bic.w	r3, r3, r6
34005194:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
        EXTI->RTSR1 &= ~(iocurrent);
34005198:	6823      	ldr	r3, [r4, #0]
3400519a:	ea23 0306 	bic.w	r3, r3, r6
3400519e:	6023      	str	r3, [r4, #0]
        EXTI->FTSR1 &= ~(iocurrent);
340051a0:	6863      	ldr	r3, [r4, #4]
340051a2:	ea23 0306 	bic.w	r3, r3, r6
340051a6:	6063      	str	r3, [r4, #4]
        EXTI->EXTICR[position >> 2u] &= ~tmp;
340051a8:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
340051aa:	ea23 0309 	bic.w	r3, r3, r9
340051ae:	662b      	str	r3, [r5, #96]	@ 0x60
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
340051b0:	6803      	ldr	r3, [r0, #0]
340051b2:	0056      	lsls	r6, r2, #1
340051b4:	fa0b f606 	lsl.w	r6, fp, r6
340051b8:	4333      	orrs	r3, r6
340051ba:	6003      	str	r3, [r0, #0]
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos)) ;
340051bc:	08d3      	lsrs	r3, r2, #3
340051be:	eb00 0383 	add.w	r3, r0, r3, lsl #2
340051c2:	f002 0507 	and.w	r5, r2, #7
340051c6:	6a1f      	ldr	r7, [r3, #32]
340051c8:	00ad      	lsls	r5, r5, #2
340051ca:	fa08 f505 	lsl.w	r5, r8, r5
340051ce:	ea27 0705 	bic.w	r7, r7, r5
340051d2:	621f      	str	r7, [r3, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
340051d4:	6887      	ldr	r7, [r0, #8]
340051d6:	ea27 0706 	bic.w	r7, r7, r6
340051da:	6087      	str	r7, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
340051dc:	6847      	ldr	r7, [r0, #4]
340051de:	ea27 070c 	bic.w	r7, r7, ip
340051e2:	6047      	str	r7, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
340051e4:	68c7      	ldr	r7, [r0, #12]
340051e6:	ea27 0706 	bic.w	r7, r7, r6
340051ea:	60c7      	str	r7, [r0, #12]
      GPIOx->DELAYR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_DELAYRL_DLY1_Pos)) ;
340051ec:	6c1e      	ldr	r6, [r3, #64]	@ 0x40
340051ee:	ea26 0605 	bic.w	r6, r6, r5
340051f2:	641e      	str	r6, [r3, #64]	@ 0x40
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
340051f4:	6c9e      	ldr	r6, [r3, #72]	@ 0x48
340051f6:	ea26 0505 	bic.w	r5, r6, r5
340051fa:	649d      	str	r5, [r3, #72]	@ 0x48
    position++;
340051fc:	3201      	adds	r2, #1
340051fe:	e773      	b.n	340050e8 <HAL_GPIO_DeInit+0x14>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
34005200:	2300      	movs	r3, #0
34005202:	e7ba      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
34005204:	2301      	movs	r3, #1
34005206:	e7b8      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
34005208:	2302      	movs	r3, #2
3400520a:	e7b6      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
3400520c:	2303      	movs	r3, #3
3400520e:	e7b4      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
34005210:	2304      	movs	r3, #4
34005212:	e7b2      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
34005214:	2305      	movs	r3, #5
34005216:	e7b0      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
34005218:	2306      	movs	r3, #6
3400521a:	e7ae      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
3400521c:	2307      	movs	r3, #7
3400521e:	e7ac      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
34005220:	2308      	movs	r3, #8
34005222:	e7aa      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
34005224:	2309      	movs	r3, #9
34005226:	e7a8      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
34005228:	230a      	movs	r3, #10
3400522a:	e7a6      	b.n	3400517a <HAL_GPIO_DeInit+0xa6>
3400522c:	56025000 	.word	0x56025000
34005230:	56020000 	.word	0x56020000

34005234 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
34005234:	b10a      	cbz	r2, 3400523a <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34005236:	6181      	str	r1, [r0, #24]
34005238:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
3400523a:	6281      	str	r1, [r0, #40]	@ 0x28
  }
}
3400523c:	4770      	bx	lr

3400523e <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
3400523e:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
34005240:	ea01 0203 	and.w	r2, r1, r3
34005244:	ea21 0103 	bic.w	r1, r1, r3
34005248:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
3400524c:	6181      	str	r1, [r0, #24]
}
3400524e:	4770      	bx	lr

34005250 <HAL_GPIO_ConfigPinAttributes>:
  *            @arg @ref GPIO_PIN_SEC          Secure-only access
  *            @arg @ref GPIO_PIN_NSEC         Secure/Non-secure access
  * @retval None.
  */
void HAL_GPIO_ConfigPinAttributes(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t PinAttributes)
{
34005250:	b510      	push	{r4, lr}
  assert_param(IS_GPIO_PIN_ATTRIBUTES(PinAttributes));

#if defined CPU_IN_SECURE_STATE
  /* Configure the port pins */
  sec = GPIOx->SECCFGR;
  if ((PinAttributes & GPIO_PIN_SEC) == GPIO_PIN_SEC)
34005252:	f240 1401 	movw	r4, #257	@ 0x101
34005256:	4394      	bics	r4, r2
  sec = GPIOx->SECCFGR;
34005258:	6b03      	ldr	r3, [r0, #48]	@ 0x30
  if ((PinAttributes & GPIO_PIN_SEC) == GPIO_PIN_SEC)
3400525a:	d109      	bne.n	34005270 <HAL_GPIO_ConfigPinAttributes+0x20>
  {
    sec |= (uint32_t)GPIO_Pin;
3400525c:	430b      	orrs	r3, r1
  }
  GPIOx->SECCFGR = sec;
#endif /* CPU_IN_SECURE_STATE */

  priv = GPIOx->PRIVCFGR;
  if ((PinAttributes & GPIO_PIN_PRIV) == GPIO_PIN_PRIV)
3400525e:	f240 2402 	movw	r4, #514	@ 0x202
  GPIOx->SECCFGR = sec;
34005262:	6303      	str	r3, [r0, #48]	@ 0x30
  if ((PinAttributes & GPIO_PIN_PRIV) == GPIO_PIN_PRIV)
34005264:	4394      	bics	r4, r2
  priv = GPIOx->PRIVCFGR;
34005266:	6b43      	ldr	r3, [r0, #52]	@ 0x34
  if ((PinAttributes & GPIO_PIN_PRIV) == GPIO_PIN_PRIV)
34005268:	d109      	bne.n	3400527e <HAL_GPIO_ConfigPinAttributes+0x2e>
  {
    priv |= (uint32_t)GPIO_Pin;
3400526a:	430b      	orrs	r3, r1
  else
  {
    /* do nothing */
  }

  GPIOx->PRIVCFGR = priv;
3400526c:	6343      	str	r3, [r0, #52]	@ 0x34
}
3400526e:	bd10      	pop	{r4, pc}
    sec &= ~((uint32_t)GPIO_Pin);
34005270:	ea23 0401 	bic.w	r4, r3, r1
34005274:	f412 7f80 	tst.w	r2, #256	@ 0x100
34005278:	bf18      	it	ne
3400527a:	4623      	movne	r3, r4
3400527c:	e7ef      	b.n	3400525e <HAL_GPIO_ConfigPinAttributes+0xe>
    priv &= ~((uint32_t)GPIO_Pin);
3400527e:	ea23 0101 	bic.w	r1, r3, r1
34005282:	f412 7f00 	tst.w	r2, #512	@ 0x200
34005286:	bf18      	it	ne
34005288:	460b      	movne	r3, r1
3400528a:	e7ef      	b.n	3400526c <HAL_GPIO_ConfigPinAttributes+0x1c>

3400528c <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
3400528c:	6803      	ldr	r3, [r0, #0]
3400528e:	699a      	ldr	r2, [r3, #24]
34005290:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
34005292:	bf44      	itt	mi
34005294:	2200      	movmi	r2, #0
34005296:	629a      	strmi	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
34005298:	699a      	ldr	r2, [r3, #24]
3400529a:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
3400529c:	bf5e      	ittt	pl
3400529e:	699a      	ldrpl	r2, [r3, #24]
340052a0:	f042 0201 	orrpl.w	r2, r2, #1
340052a4:	619a      	strpl	r2, [r3, #24]
  }
}
340052a6:	4770      	bx	lr

340052a8 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
340052a8:	b530      	push	{r4, r5, lr}
340052aa:	9d03      	ldr	r5, [sp, #12]
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
340052ac:	6804      	ldr	r4, [r0, #0]
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
340052ae:	432b      	orrs	r3, r5
340052b0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
340052b4:	4a06      	ldr	r2, [pc, #24]	@ (340052d0 <I2C_TransferConfig+0x28>)
340052b6:	6860      	ldr	r0, [r4, #4]
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
340052b8:	f3c1 0109 	ubfx	r1, r1, #0, #10
340052bc:	430b      	orrs	r3, r1
  MODIFY_REG(hi2c->Instance->CR2, \
340052be:	ea42 5255 	orr.w	r2, r2, r5, lsr #21
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
340052c2:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
  MODIFY_REG(hi2c->Instance->CR2, \
340052c6:	ea20 0002 	bic.w	r0, r0, r2
340052ca:	4303      	orrs	r3, r0
340052cc:	6063      	str	r3, [r4, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
340052ce:	bd30      	pop	{r4, r5, pc}
340052d0:	03ff63ff 	.word	0x03ff63ff

340052d4 <I2C_IsErrorOccurred>:
  uint32_t itflag   = hi2c->Instance->ISR;
340052d4:	6803      	ldr	r3, [r0, #0]
{
340052d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t itflag   = hi2c->Instance->ISR;
340052da:	699c      	ldr	r4, [r3, #24]
{
340052dc:	4605      	mov	r5, r0
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
340052de:	f014 0410 	ands.w	r4, r4, #16
{
340052e2:	460f      	mov	r7, r1
340052e4:	4616      	mov	r6, r2
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
340052e6:	d06f      	beq.n	340053c8 <I2C_IsErrorOccurred+0xf4>
  uint32_t error_code = 0;
340052e8:	2400      	movs	r4, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340052ea:	2210      	movs	r2, #16
  HAL_StatusTypeDef status = HAL_OK;
340052ec:	46a0      	mov	r8, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340052ee:	61da      	str	r2, [r3, #28]
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
340052f0:	682b      	ldr	r3, [r5, #0]
340052f2:	699a      	ldr	r2, [r3, #24]
340052f4:	0690      	lsls	r0, r2, #26
340052f6:	d461      	bmi.n	340053bc <I2C_IsErrorOccurred+0xe8>
340052f8:	f1b8 0f00 	cmp.w	r8, #0
340052fc:	d035      	beq.n	3400536a <I2C_IsErrorOccurred+0x96>
    status = HAL_ERROR;
340052fe:	2001      	movs	r0, #1
    error_code |= HAL_I2C_ERROR_AF;
34005300:	f044 0404 	orr.w	r4, r4, #4
  itflag = hi2c->Instance->ISR;
34005304:	682e      	ldr	r6, [r5, #0]
34005306:	69b3      	ldr	r3, [r6, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
34005308:	05d9      	lsls	r1, r3, #23
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
3400530a:	bf41      	itttt	mi
3400530c:	f44f 7280 	movmi.w	r2, #256	@ 0x100
    status = HAL_ERROR;
34005310:	2001      	movmi	r0, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
34005312:	61f2      	strmi	r2, [r6, #28]
    error_code |= HAL_I2C_ERROR_BERR;
34005314:	f044 0401 	orrmi.w	r4, r4, #1
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
34005318:	055a      	lsls	r2, r3, #21
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
3400531a:	bf41      	itttt	mi
3400531c:	f44f 6280 	movmi.w	r2, #1024	@ 0x400
    status = HAL_ERROR;
34005320:	2001      	movmi	r0, #1
    error_code |= HAL_I2C_ERROR_OVR;
34005322:	f044 0408 	orrmi.w	r4, r4, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
34005326:	61f2      	strmi	r2, [r6, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
34005328:	059b      	lsls	r3, r3, #22
3400532a:	d54f      	bpl.n	340053cc <I2C_IsErrorOccurred+0xf8>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
3400532c:	f44f 7300 	mov.w	r3, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
34005330:	f044 0402 	orr.w	r4, r4, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
34005334:	61f3      	str	r3, [r6, #28]
    I2C_Flush_TXDR(hi2c);
34005336:	4628      	mov	r0, r5
34005338:	f7ff ffa8 	bl	3400528c <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
3400533c:	6873      	ldr	r3, [r6, #4]
    __HAL_UNLOCK(hi2c);
3400533e:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
34005340:	f023 73ff 	bic.w	r3, r3, #33423360	@ 0x1fe0000
34005344:	f423 338b 	bic.w	r3, r3, #71168	@ 0x11600
34005348:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
3400534c:	f023 0301 	bic.w	r3, r3, #1
34005350:	6073      	str	r3, [r6, #4]
    hi2c->ErrorCode |= error_code;
34005352:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
34005354:	4323      	orrs	r3, r4
34005356:	646b      	str	r3, [r5, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
34005358:	2320      	movs	r3, #32
3400535a:	f885 3041 	strb.w	r3, [r5, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
3400535e:	2300      	movs	r3, #0
34005360:	f885 3042 	strb.w	r3, [r5, #66]	@ 0x42
    __HAL_UNLOCK(hi2c);
34005364:	f885 3040 	strb.w	r3, [r5, #64]	@ 0x40
34005368:	e032      	b.n	340053d0 <I2C_IsErrorOccurred+0xfc>
      if (Timeout != HAL_MAX_DELAY)
3400536a:	1c7a      	adds	r2, r7, #1
3400536c:	d0c1      	beq.n	340052f2 <I2C_IsErrorOccurred+0x1e>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
3400536e:	f7fe f99b 	bl	340036a8 <HAL_GetTick>
34005372:	1b80      	subs	r0, r0, r6
34005374:	42b8      	cmp	r0, r7
34005376:	d801      	bhi.n	3400537c <I2C_IsErrorOccurred+0xa8>
34005378:	2f00      	cmp	r7, #0
3400537a:	d1b9      	bne.n	340052f0 <I2C_IsErrorOccurred+0x1c>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
3400537c:	682b      	ldr	r3, [r5, #0]
3400537e:	6859      	ldr	r1, [r3, #4]
          tmp2 = hi2c->Mode;
34005380:	f895 2042 	ldrb.w	r2, [r5, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
34005384:	6998      	ldr	r0, [r3, #24]
          tmp2 = hi2c->Mode;
34005386:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
34005388:	0400      	lsls	r0, r0, #16
3400538a:	d50a      	bpl.n	340053a2 <I2C_IsErrorOccurred+0xce>
3400538c:	0449      	lsls	r1, r1, #17
3400538e:	d408      	bmi.n	340053a2 <I2C_IsErrorOccurred+0xce>
              (tmp1 != I2C_CR2_STOP) && \
34005390:	2a20      	cmp	r2, #32
34005392:	d006      	beq.n	340053a2 <I2C_IsErrorOccurred+0xce>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
34005394:	685a      	ldr	r2, [r3, #4]
34005396:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
3400539a:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
3400539c:	f7fe f984 	bl	340036a8 <HAL_GetTick>
340053a0:	4606      	mov	r6, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
340053a2:	682b      	ldr	r3, [r5, #0]
340053a4:	699b      	ldr	r3, [r3, #24]
340053a6:	069b      	lsls	r3, r3, #26
340053a8:	d4a2      	bmi.n	340052f0 <I2C_IsErrorOccurred+0x1c>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
340053aa:	f7fe f97d 	bl	340036a8 <HAL_GetTick>
340053ae:	1b80      	subs	r0, r0, r6
340053b0:	2819      	cmp	r0, #25
340053b2:	d9f6      	bls.n	340053a2 <I2C_IsErrorOccurred+0xce>
              error_code |= HAL_I2C_ERROR_TIMEOUT;
340053b4:	2420      	movs	r4, #32
              status = HAL_ERROR;
340053b6:	f04f 0801 	mov.w	r8, #1
340053ba:	e799      	b.n	340052f0 <I2C_IsErrorOccurred+0x1c>
    if (status == HAL_OK)
340053bc:	f1b8 0f00 	cmp.w	r8, #0
340053c0:	d19d      	bne.n	340052fe <I2C_IsErrorOccurred+0x2a>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
340053c2:	2220      	movs	r2, #32
340053c4:	61da      	str	r2, [r3, #28]
340053c6:	e79a      	b.n	340052fe <I2C_IsErrorOccurred+0x2a>
  HAL_StatusTypeDef status = HAL_OK;
340053c8:	4620      	mov	r0, r4
340053ca:	e79b      	b.n	34005304 <I2C_IsErrorOccurred+0x30>
  if (status != HAL_OK)
340053cc:	2800      	cmp	r0, #0
340053ce:	d1b2      	bne.n	34005336 <I2C_IsErrorOccurred+0x62>
}
340053d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

340053d4 <I2C_WaitOnTXISFlagUntilTimeout>:
{
340053d4:	b570      	push	{r4, r5, r6, lr}
340053d6:	4604      	mov	r4, r0
340053d8:	460d      	mov	r5, r1
340053da:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
340053dc:	6823      	ldr	r3, [r4, #0]
340053de:	699b      	ldr	r3, [r3, #24]
340053e0:	079b      	lsls	r3, r3, #30
340053e2:	d501      	bpl.n	340053e8 <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
340053e4:	2000      	movs	r0, #0
340053e6:	e01f      	b.n	34005428 <I2C_WaitOnTXISFlagUntilTimeout+0x54>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
340053e8:	4632      	mov	r2, r6
340053ea:	4629      	mov	r1, r5
340053ec:	4620      	mov	r0, r4
340053ee:	f7ff ff71 	bl	340052d4 <I2C_IsErrorOccurred>
340053f2:	b9c0      	cbnz	r0, 34005426 <I2C_WaitOnTXISFlagUntilTimeout+0x52>
    if (Timeout != HAL_MAX_DELAY)
340053f4:	1c6a      	adds	r2, r5, #1
340053f6:	d0f1      	beq.n	340053dc <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
340053f8:	f7fe f956 	bl	340036a8 <HAL_GetTick>
340053fc:	1b80      	subs	r0, r0, r6
340053fe:	42a8      	cmp	r0, r5
34005400:	d801      	bhi.n	34005406 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
34005402:	2d00      	cmp	r5, #0
34005404:	d1ea      	bne.n	340053dc <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34005406:	6823      	ldr	r3, [r4, #0]
34005408:	699b      	ldr	r3, [r3, #24]
3400540a:	f013 0302 	ands.w	r3, r3, #2
3400540e:	d1e5      	bne.n	340053dc <I2C_WaitOnTXISFlagUntilTimeout+0x8>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34005410:	6c62      	ldr	r2, [r4, #68]	@ 0x44
          __HAL_UNLOCK(hi2c);
34005412:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34005416:	f042 0220 	orr.w	r2, r2, #32
3400541a:	6462      	str	r2, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
3400541c:	2220      	movs	r2, #32
3400541e:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34005422:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
34005426:	2001      	movs	r0, #1
}
34005428:	bd70      	pop	{r4, r5, r6, pc}

3400542a <I2C_WaitOnFlagUntilTimeout>:
{
3400542a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400542e:	4604      	mov	r4, r0
34005430:	460f      	mov	r7, r1
34005432:	4616      	mov	r6, r2
34005434:	461d      	mov	r5, r3
34005436:	f8dd 8018 	ldr.w	r8, [sp, #24]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
3400543a:	6823      	ldr	r3, [r4, #0]
3400543c:	699b      	ldr	r3, [r3, #24]
3400543e:	ea37 0303 	bics.w	r3, r7, r3
34005442:	bf0c      	ite	eq
34005444:	2301      	moveq	r3, #1
34005446:	2300      	movne	r3, #0
34005448:	42b3      	cmp	r3, r6
3400544a:	d001      	beq.n	34005450 <I2C_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
3400544c:	2000      	movs	r0, #0
3400544e:	e025      	b.n	3400549c <I2C_WaitOnFlagUntilTimeout+0x72>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34005450:	4642      	mov	r2, r8
34005452:	4629      	mov	r1, r5
34005454:	4620      	mov	r0, r4
34005456:	f7ff ff3d 	bl	340052d4 <I2C_IsErrorOccurred>
3400545a:	b9f0      	cbnz	r0, 3400549a <I2C_WaitOnFlagUntilTimeout+0x70>
    if (Timeout != HAL_MAX_DELAY)
3400545c:	1c6b      	adds	r3, r5, #1
3400545e:	d0ec      	beq.n	3400543a <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34005460:	f7fe f922 	bl	340036a8 <HAL_GetTick>
34005464:	eba0 0008 	sub.w	r0, r0, r8
34005468:	42a8      	cmp	r0, r5
3400546a:	d801      	bhi.n	34005470 <I2C_WaitOnFlagUntilTimeout+0x46>
3400546c:	2d00      	cmp	r5, #0
3400546e:	d1e4      	bne.n	3400543a <I2C_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34005470:	6823      	ldr	r3, [r4, #0]
34005472:	699b      	ldr	r3, [r3, #24]
34005474:	ea37 0303 	bics.w	r3, r7, r3
34005478:	bf0c      	ite	eq
3400547a:	2301      	moveq	r3, #1
3400547c:	2300      	movne	r3, #0
3400547e:	42b3      	cmp	r3, r6
34005480:	d1db      	bne.n	3400543a <I2C_WaitOnFlagUntilTimeout+0x10>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34005482:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34005484:	f043 0320 	orr.w	r3, r3, #32
34005488:	6463      	str	r3, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
3400548a:	2320      	movs	r3, #32
3400548c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34005490:	2300      	movs	r3, #0
34005492:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
          __HAL_UNLOCK(hi2c);
34005496:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
3400549a:	2001      	movs	r0, #1
}
3400549c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

340054a0 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
340054a0:	b570      	push	{r4, r5, r6, lr}
340054a2:	4604      	mov	r4, r0
340054a4:	460d      	mov	r5, r1
340054a6:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
340054a8:	6823      	ldr	r3, [r4, #0]
340054aa:	699b      	ldr	r3, [r3, #24]
340054ac:	069b      	lsls	r3, r3, #26
340054ae:	d501      	bpl.n	340054b4 <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
340054b0:	2000      	movs	r0, #0
340054b2:	e01d      	b.n	340054f0 <I2C_WaitOnSTOPFlagUntilTimeout+0x50>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
340054b4:	4632      	mov	r2, r6
340054b6:	4629      	mov	r1, r5
340054b8:	4620      	mov	r0, r4
340054ba:	f7ff ff0b 	bl	340052d4 <I2C_IsErrorOccurred>
340054be:	b9b0      	cbnz	r0, 340054ee <I2C_WaitOnSTOPFlagUntilTimeout+0x4e>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
340054c0:	f7fe f8f2 	bl	340036a8 <HAL_GetTick>
340054c4:	1b80      	subs	r0, r0, r6
340054c6:	42a8      	cmp	r0, r5
340054c8:	d801      	bhi.n	340054ce <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
340054ca:	2d00      	cmp	r5, #0
340054cc:	d1ec      	bne.n	340054a8 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
340054ce:	6823      	ldr	r3, [r4, #0]
340054d0:	699b      	ldr	r3, [r3, #24]
340054d2:	f013 0320 	ands.w	r3, r3, #32
340054d6:	d1e7      	bne.n	340054a8 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
340054d8:	6c62      	ldr	r2, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
340054da:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
340054de:	f042 0220 	orr.w	r2, r2, #32
340054e2:	6462      	str	r2, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
340054e4:	2220      	movs	r2, #32
340054e6:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
340054ea:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
340054ee:	2001      	movs	r0, #1
}
340054f0:	bd70      	pop	{r4, r5, r6, pc}

340054f2 <HAL_I2C_Init>:
{
340054f2:	b510      	push	{r4, lr}
  if (hi2c == NULL)
340054f4:	4604      	mov	r4, r0
340054f6:	2800      	cmp	r0, #0
340054f8:	d04e      	beq.n	34005598 <HAL_I2C_Init+0xa6>
  if (hi2c->State == HAL_I2C_STATE_RESET)
340054fa:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
340054fe:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
34005502:	b91b      	cbnz	r3, 3400550c <HAL_I2C_Init+0x1a>
    hi2c->Lock = HAL_UNLOCKED;
34005504:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
    HAL_I2C_MspInit(hi2c);
34005508:	f7fc fd34 	bl	34001f74 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
3400550c:	2324      	movs	r3, #36	@ 0x24
3400550e:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
34005512:	6823      	ldr	r3, [r4, #0]
34005514:	681a      	ldr	r2, [r3, #0]
34005516:	f022 0201 	bic.w	r2, r2, #1
3400551a:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
3400551c:	6862      	ldr	r2, [r4, #4]
3400551e:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
34005522:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
34005524:	689a      	ldr	r2, [r3, #8]
34005526:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
3400552a:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
3400552c:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
34005530:	2901      	cmp	r1, #1
34005532:	d106      	bne.n	34005542 <HAL_I2C_Init+0x50>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
34005534:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34005538:	609a      	str	r2, [r3, #8]
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
3400553a:	685a      	ldr	r2, [r3, #4]
3400553c:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
34005540:	e007      	b.n	34005552 <HAL_I2C_Init+0x60>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
34005542:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
34005546:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
34005548:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
3400554a:	d1f6      	bne.n	3400553a <HAL_I2C_Init+0x48>
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
3400554c:	685a      	ldr	r2, [r3, #4]
3400554e:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34005552:	605a      	str	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
34005554:	685a      	ldr	r2, [r3, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34005556:	2000      	movs	r0, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
34005558:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
3400555c:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34005560:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
34005562:	68da      	ldr	r2, [r3, #12]
34005564:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34005568:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
3400556a:	e9d4 2104 	ldrd	r2, r1, [r4, #16]
3400556e:	430a      	orrs	r2, r1
                          (hi2c->Init.OwnAddress2Masks << 8));
34005570:	69a1      	ldr	r1, [r4, #24]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
34005572:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
34005576:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
34005578:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
3400557c:	430a      	orrs	r2, r1
3400557e:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
34005580:	681a      	ldr	r2, [r3, #0]
34005582:	f042 0201 	orr.w	r2, r2, #1
34005586:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
34005588:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400558a:	6460      	str	r0, [r4, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
3400558c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
34005590:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
34005592:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
34005596:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34005598:	2001      	movs	r0, #1
3400559a:	e7fc      	b.n	34005596 <HAL_I2C_Init+0xa4>

3400559c <HAL_I2C_DeInit>:
{
3400559c:	b510      	push	{r4, lr}
  if (hi2c == NULL)
3400559e:	4604      	mov	r4, r0
340055a0:	b198      	cbz	r0, 340055ca <HAL_I2C_DeInit+0x2e>
  hi2c->State = HAL_I2C_STATE_BUSY;
340055a2:	2324      	movs	r3, #36	@ 0x24
  __HAL_I2C_DISABLE(hi2c);
340055a4:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
340055a6:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
340055aa:	6813      	ldr	r3, [r2, #0]
340055ac:	f023 0301 	bic.w	r3, r3, #1
340055b0:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
340055b2:	f7fc fd27 	bl	34002004 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
340055b6:	2000      	movs	r0, #0
340055b8:	6460      	str	r0, [r4, #68]	@ 0x44
  __HAL_UNLOCK(hi2c);
340055ba:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
340055be:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
340055c2:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
340055c4:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
340055c8:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
340055ca:	2001      	movs	r0, #1
340055cc:	e7fc      	b.n	340055c8 <HAL_I2C_DeInit+0x2c>
	...

340055d0 <HAL_I2C_Mem_Write>:
{
340055d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
340055d4:	4699      	mov	r9, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
340055d6:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
340055da:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
340055dc:	2b20      	cmp	r3, #32
{
340055de:	460f      	mov	r7, r1
340055e0:	4616      	mov	r6, r2
340055e2:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
340055e6:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
340055ea:	f040 80c6 	bne.w	3400577a <HAL_I2C_Mem_Write+0x1aa>
    if ((pData == NULL) || (Size == 0U))
340055ee:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
340055f0:	b113      	cbz	r3, 340055f8 <HAL_I2C_Mem_Write+0x28>
340055f2:	f1ba 0f00 	cmp.w	sl, #0
340055f6:	d106      	bne.n	34005606 <HAL_I2C_Mem_Write+0x36>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
340055f8:	f44f 7300 	mov.w	r3, #512	@ 0x200
340055fc:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
340055fe:	2001      	movs	r0, #1
}
34005600:	b003      	add	sp, #12
34005602:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
34005606:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
3400560a:	2b01      	cmp	r3, #1
3400560c:	f000 80b5 	beq.w	3400577a <HAL_I2C_Mem_Write+0x1aa>
34005610:	f04f 0b01 	mov.w	fp, #1
34005614:	f880 b040 	strb.w	fp, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
34005618:	f7fe f846 	bl	340036a8 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
3400561c:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
3400561e:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34005620:	9000      	str	r0, [sp, #0]
34005622:	465a      	mov	r2, fp
34005624:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34005628:	4620      	mov	r0, r4
3400562a:	f7ff fefe 	bl	3400542a <I2C_WaitOnFlagUntilTimeout>
3400562e:	2800      	cmp	r0, #0
34005630:	d1e5      	bne.n	340055fe <HAL_I2C_Mem_Write+0x2e>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
34005632:	2321      	movs	r3, #33	@ 0x21
34005634:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
34005638:	2340      	movs	r3, #64	@ 0x40
3400563a:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
3400563e:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34005640:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->pBuffPtr  = pData;
34005642:	6263      	str	r3, [r4, #36]	@ 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34005644:	4b4e      	ldr	r3, [pc, #312]	@ (34005780 <HAL_I2C_Mem_Write+0x1b0>)
    hi2c->XferISR   = NULL;
34005646:	6360      	str	r0, [r4, #52]	@ 0x34
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34005648:	4639      	mov	r1, r7
3400564a:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
3400564c:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34005650:	fa5f f289 	uxtb.w	r2, r9
34005654:	9300      	str	r3, [sp, #0]
34005656:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400565a:	f7ff fe25 	bl	340052a8 <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3400565e:	462a      	mov	r2, r5
34005660:	4641      	mov	r1, r8
34005662:	4620      	mov	r0, r4
34005664:	f7ff feb6 	bl	340053d4 <I2C_WaitOnTXISFlagUntilTimeout>
34005668:	bb18      	cbnz	r0, 340056b2 <HAL_I2C_Mem_Write+0xe2>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3400566a:	f1b9 0f01 	cmp.w	r9, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400566e:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34005670:	d115      	bne.n	3400569e <HAL_I2C_Mem_Write+0xce>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34005672:	b2f6      	uxtb	r6, r6
34005674:	629e      	str	r6, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
34005676:	2200      	movs	r2, #0
34005678:	4643      	mov	r3, r8
3400567a:	2180      	movs	r1, #128	@ 0x80
3400567c:	4620      	mov	r0, r4
3400567e:	9500      	str	r5, [sp, #0]
34005680:	f7ff fed3 	bl	3400542a <I2C_WaitOnFlagUntilTimeout>
34005684:	b9a8      	cbnz	r0, 340056b2 <HAL_I2C_Mem_Write+0xe2>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34005686:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34005688:	b29b      	uxth	r3, r3
3400568a:	2bff      	cmp	r3, #255	@ 0xff
3400568c:	d815      	bhi.n	340056ba <HAL_I2C_Mem_Write+0xea>
      hi2c->XferSize = hi2c->XferCount;
3400568e:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
34005690:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
34005694:	b292      	uxth	r2, r2
34005696:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
34005698:	9000      	str	r0, [sp, #0]
3400569a:	b2d2      	uxtb	r2, r2
3400569c:	e012      	b.n	340056c4 <HAL_I2C_Mem_Write+0xf4>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
3400569e:	0a32      	lsrs	r2, r6, #8
340056a0:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
340056a2:	4641      	mov	r1, r8
340056a4:	462a      	mov	r2, r5
340056a6:	4620      	mov	r0, r4
340056a8:	f7ff fe94 	bl	340053d4 <I2C_WaitOnTXISFlagUntilTimeout>
340056ac:	b908      	cbnz	r0, 340056b2 <HAL_I2C_Mem_Write+0xe2>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
340056ae:	6823      	ldr	r3, [r4, #0]
340056b0:	e7df      	b.n	34005672 <HAL_I2C_Mem_Write+0xa2>
      __HAL_UNLOCK(hi2c);
340056b2:	2300      	movs	r3, #0
340056b4:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
340056b8:	e7a1      	b.n	340055fe <HAL_I2C_Mem_Write+0x2e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
340056ba:	22ff      	movs	r2, #255	@ 0xff
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
340056bc:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
340056c0:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
340056c2:	9000      	str	r0, [sp, #0]
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
340056c4:	4639      	mov	r1, r7
340056c6:	4620      	mov	r0, r4
340056c8:	f7ff fdee 	bl	340052a8 <I2C_TransferConfig>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
340056cc:	462a      	mov	r2, r5
340056ce:	4641      	mov	r1, r8
340056d0:	4620      	mov	r0, r4
340056d2:	f7ff fe7f 	bl	340053d4 <I2C_WaitOnTXISFlagUntilTimeout>
340056d6:	2800      	cmp	r0, #0
340056d8:	d191      	bne.n	340055fe <HAL_I2C_Mem_Write+0x2e>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
340056da:	6a63      	ldr	r3, [r4, #36]	@ 0x24
340056dc:	6822      	ldr	r2, [r4, #0]
340056de:	f813 1b01 	ldrb.w	r1, [r3], #1
340056e2:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
340056e4:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
340056e6:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
340056e8:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->XferCount--;
340056ea:	3b01      	subs	r3, #1
340056ec:	b29b      	uxth	r3, r3
340056ee:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340056f0:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
340056f2:	3a01      	subs	r2, #1
340056f4:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340056f6:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
340056f8:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340056fa:	b1b3      	cbz	r3, 3400572a <HAL_I2C_Mem_Write+0x15a>
340056fc:	b9aa      	cbnz	r2, 3400572a <HAL_I2C_Mem_Write+0x15a>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
340056fe:	4643      	mov	r3, r8
34005700:	2180      	movs	r1, #128	@ 0x80
34005702:	4620      	mov	r0, r4
34005704:	9500      	str	r5, [sp, #0]
34005706:	f7ff fe90 	bl	3400542a <I2C_WaitOnFlagUntilTimeout>
3400570a:	2800      	cmp	r0, #0
3400570c:	f47f af77 	bne.w	340055fe <HAL_I2C_Mem_Write+0x2e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
34005710:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34005712:	b29b      	uxth	r3, r3
34005714:	2bff      	cmp	r3, #255	@ 0xff
34005716:	d928      	bls.n	3400576a <HAL_I2C_Mem_Write+0x19a>
          hi2c->XferSize = MAX_NBYTE_SIZE;
34005718:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
3400571a:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
3400571e:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
34005720:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34005722:	4639      	mov	r1, r7
34005724:	4620      	mov	r0, r4
34005726:	f7ff fdbf 	bl	340052a8 <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
3400572a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
3400572c:	b29b      	uxth	r3, r3
3400572e:	2b00      	cmp	r3, #0
34005730:	d1cc      	bne.n	340056cc <HAL_I2C_Mem_Write+0xfc>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
34005732:	462a      	mov	r2, r5
34005734:	4641      	mov	r1, r8
34005736:	4620      	mov	r0, r4
34005738:	f7ff feb2 	bl	340054a0 <I2C_WaitOnSTOPFlagUntilTimeout>
3400573c:	2800      	cmp	r0, #0
3400573e:	f47f af5e 	bne.w	340055fe <HAL_I2C_Mem_Write+0x2e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34005742:	2120      	movs	r1, #32
34005744:	6823      	ldr	r3, [r4, #0]
34005746:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
34005748:	685a      	ldr	r2, [r3, #4]
3400574a:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
3400574e:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
34005752:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
34005756:	f022 0201 	bic.w	r2, r2, #1
3400575a:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
3400575c:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
34005760:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
34005764:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
34005768:	e74a      	b.n	34005600 <HAL_I2C_Mem_Write+0x30>
          hi2c->XferSize = hi2c->XferCount;
3400576a:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400576c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
34005770:	b292      	uxth	r2, r2
34005772:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34005774:	9000      	str	r0, [sp, #0]
34005776:	b2d2      	uxtb	r2, r2
34005778:	e7d3      	b.n	34005722 <HAL_I2C_Mem_Write+0x152>
    __HAL_LOCK(hi2c);
3400577a:	2002      	movs	r0, #2
3400577c:	e740      	b.n	34005600 <HAL_I2C_Mem_Write+0x30>
3400577e:	bf00      	nop
34005780:	80002000 	.word	0x80002000

34005784 <HAL_I2C_Mem_Read>:
{
34005784:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34005788:	4699      	mov	r9, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
3400578a:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
3400578e:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
34005790:	2b20      	cmp	r3, #32
{
34005792:	460f      	mov	r7, r1
34005794:	4616      	mov	r6, r2
34005796:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
3400579a:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
3400579e:	f040 80c9 	bne.w	34005934 <HAL_I2C_Mem_Read+0x1b0>
    if ((pData == NULL) || (Size == 0U))
340057a2:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
340057a4:	b113      	cbz	r3, 340057ac <HAL_I2C_Mem_Read+0x28>
340057a6:	f1ba 0f00 	cmp.w	sl, #0
340057aa:	d106      	bne.n	340057ba <HAL_I2C_Mem_Read+0x36>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
340057ac:	f44f 7300 	mov.w	r3, #512	@ 0x200
340057b0:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
340057b2:	2001      	movs	r0, #1
}
340057b4:	b003      	add	sp, #12
340057b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
340057ba:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
340057be:	2b01      	cmp	r3, #1
340057c0:	f000 80b8 	beq.w	34005934 <HAL_I2C_Mem_Read+0x1b0>
340057c4:	f04f 0b01 	mov.w	fp, #1
340057c8:	f880 b040 	strb.w	fp, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
340057cc:	f7fd ff6c 	bl	340036a8 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
340057d0:	2319      	movs	r3, #25
340057d2:	9000      	str	r0, [sp, #0]
    tickstart = HAL_GetTick();
340057d4:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
340057d6:	465a      	mov	r2, fp
340057d8:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
340057dc:	4620      	mov	r0, r4
340057de:	f7ff fe24 	bl	3400542a <I2C_WaitOnFlagUntilTimeout>
340057e2:	4603      	mov	r3, r0
340057e4:	2800      	cmp	r0, #0
340057e6:	d1e4      	bne.n	340057b2 <HAL_I2C_Mem_Read+0x2e>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
340057e8:	2222      	movs	r2, #34	@ 0x22
340057ea:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
340057ee:	2240      	movs	r2, #64	@ 0x40
340057f0:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
340057f4:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
340057f6:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->pBuffPtr  = pData;
340057f8:	6262      	str	r2, [r4, #36]	@ 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
340057fa:	4a4f      	ldr	r2, [pc, #316]	@ (34005938 <HAL_I2C_Mem_Read+0x1b4>)
    hi2c->XferISR   = NULL;
340057fc:	6360      	str	r0, [r4, #52]	@ 0x34
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
340057fe:	4639      	mov	r1, r7
34005800:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
34005802:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
34005806:	9200      	str	r2, [sp, #0]
34005808:	fa5f f289 	uxtb.w	r2, r9
3400580c:	f7ff fd4c 	bl	340052a8 <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34005810:	462a      	mov	r2, r5
34005812:	4641      	mov	r1, r8
34005814:	4620      	mov	r0, r4
34005816:	f7ff fddd 	bl	340053d4 <I2C_WaitOnTXISFlagUntilTimeout>
3400581a:	bb20      	cbnz	r0, 34005866 <HAL_I2C_Mem_Read+0xe2>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3400581c:	f1b9 0f01 	cmp.w	r9, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34005820:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34005822:	d116      	bne.n	34005852 <HAL_I2C_Mem_Read+0xce>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34005824:	b2f6      	uxtb	r6, r6
34005826:	629e      	str	r6, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
34005828:	2200      	movs	r2, #0
3400582a:	4643      	mov	r3, r8
3400582c:	2140      	movs	r1, #64	@ 0x40
3400582e:	4620      	mov	r0, r4
34005830:	9500      	str	r5, [sp, #0]
34005832:	f7ff fdfa 	bl	3400542a <I2C_WaitOnFlagUntilTimeout>
34005836:	b9b0      	cbnz	r0, 34005866 <HAL_I2C_Mem_Read+0xe2>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34005838:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
3400583a:	b29b      	uxth	r3, r3
3400583c:	2bff      	cmp	r3, #255	@ 0xff
3400583e:	4b3f      	ldr	r3, [pc, #252]	@ (3400593c <HAL_I2C_Mem_Read+0x1b8>)
34005840:	d815      	bhi.n	3400586e <HAL_I2C_Mem_Read+0xea>
      hi2c->XferSize = hi2c->XferCount;
34005842:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
34005844:	b292      	uxth	r2, r2
34005846:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34005848:	9300      	str	r3, [sp, #0]
3400584a:	b2d2      	uxtb	r2, r2
3400584c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34005850:	e012      	b.n	34005878 <HAL_I2C_Mem_Read+0xf4>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
34005852:	0a32      	lsrs	r2, r6, #8
34005854:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34005856:	4641      	mov	r1, r8
34005858:	462a      	mov	r2, r5
3400585a:	4620      	mov	r0, r4
3400585c:	f7ff fdba 	bl	340053d4 <I2C_WaitOnTXISFlagUntilTimeout>
34005860:	b908      	cbnz	r0, 34005866 <HAL_I2C_Mem_Read+0xe2>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34005862:	6823      	ldr	r3, [r4, #0]
34005864:	e7de      	b.n	34005824 <HAL_I2C_Mem_Read+0xa0>
      __HAL_UNLOCK(hi2c);
34005866:	2300      	movs	r3, #0
34005868:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
3400586c:	e7a1      	b.n	340057b2 <HAL_I2C_Mem_Read+0x2e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
3400586e:	22ff      	movs	r2, #255	@ 0xff
34005870:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
34005872:	9300      	str	r3, [sp, #0]
34005874:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34005878:	4639      	mov	r1, r7
3400587a:	4620      	mov	r0, r4
3400587c:	f7ff fd14 	bl	340052a8 <I2C_TransferConfig>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
34005880:	4643      	mov	r3, r8
34005882:	2200      	movs	r2, #0
34005884:	2104      	movs	r1, #4
34005886:	4620      	mov	r0, r4
34005888:	9500      	str	r5, [sp, #0]
3400588a:	f7ff fdce 	bl	3400542a <I2C_WaitOnFlagUntilTimeout>
3400588e:	2800      	cmp	r0, #0
34005890:	d18f      	bne.n	340057b2 <HAL_I2C_Mem_Read+0x2e>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
34005892:	6823      	ldr	r3, [r4, #0]
34005894:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34005896:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34005898:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
3400589a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
      hi2c->XferSize--;
3400589c:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->pBuffPtr++;
3400589e:	3301      	adds	r3, #1
340058a0:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
340058a2:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
340058a4:	3a01      	subs	r2, #1
      hi2c->XferCount--;
340058a6:	3b01      	subs	r3, #1
340058a8:	b29b      	uxth	r3, r3
340058aa:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340058ac:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
340058ae:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340058b0:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
340058b2:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340058b4:	b1b3      	cbz	r3, 340058e4 <HAL_I2C_Mem_Read+0x160>
340058b6:	b9aa      	cbnz	r2, 340058e4 <HAL_I2C_Mem_Read+0x160>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
340058b8:	4643      	mov	r3, r8
340058ba:	2180      	movs	r1, #128	@ 0x80
340058bc:	4620      	mov	r0, r4
340058be:	9500      	str	r5, [sp, #0]
340058c0:	f7ff fdb3 	bl	3400542a <I2C_WaitOnFlagUntilTimeout>
340058c4:	2800      	cmp	r0, #0
340058c6:	f47f af74 	bne.w	340057b2 <HAL_I2C_Mem_Read+0x2e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
340058ca:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
340058cc:	b29b      	uxth	r3, r3
340058ce:	2bff      	cmp	r3, #255	@ 0xff
340058d0:	d928      	bls.n	34005924 <HAL_I2C_Mem_Read+0x1a0>
          hi2c->XferSize = MAX_NBYTE_SIZE;
340058d2:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
340058d4:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
340058d8:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
340058da:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
340058dc:	4639      	mov	r1, r7
340058de:	4620      	mov	r0, r4
340058e0:	f7ff fce2 	bl	340052a8 <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
340058e4:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
340058e6:	b29b      	uxth	r3, r3
340058e8:	2b00      	cmp	r3, #0
340058ea:	d1c9      	bne.n	34005880 <HAL_I2C_Mem_Read+0xfc>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
340058ec:	462a      	mov	r2, r5
340058ee:	4641      	mov	r1, r8
340058f0:	4620      	mov	r0, r4
340058f2:	f7ff fdd5 	bl	340054a0 <I2C_WaitOnSTOPFlagUntilTimeout>
340058f6:	2800      	cmp	r0, #0
340058f8:	f47f af5b 	bne.w	340057b2 <HAL_I2C_Mem_Read+0x2e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
340058fc:	2120      	movs	r1, #32
340058fe:	6823      	ldr	r3, [r4, #0]
34005900:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
34005902:	685a      	ldr	r2, [r3, #4]
34005904:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
34005908:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
3400590c:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
34005910:	f022 0201 	bic.w	r2, r2, #1
34005914:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
34005916:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
3400591a:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
3400591e:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
34005922:	e747      	b.n	340057b4 <HAL_I2C_Mem_Read+0x30>
          hi2c->XferSize = hi2c->XferCount;
34005924:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34005926:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
3400592a:	b292      	uxth	r2, r2
3400592c:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400592e:	9000      	str	r0, [sp, #0]
34005930:	b2d2      	uxtb	r2, r2
34005932:	e7d3      	b.n	340058dc <HAL_I2C_Mem_Read+0x158>
    __HAL_LOCK(hi2c);
34005934:	2002      	movs	r0, #2
34005936:	e73d      	b.n	340057b4 <HAL_I2C_Mem_Read+0x30>
34005938:	80002000 	.word	0x80002000
3400593c:	80002400 	.word	0x80002400

34005940 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
34005940:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
34005942:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
{
34005946:	4603      	mov	r3, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
34005948:	2a20      	cmp	r2, #32
3400594a:	b2d4      	uxtb	r4, r2
3400594c:	d11c      	bne.n	34005988 <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
3400594e:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
34005952:	2a01      	cmp	r2, #1
34005954:	d018      	beq.n	34005988 <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
34005956:	2224      	movs	r2, #36	@ 0x24
34005958:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
3400595c:	6802      	ldr	r2, [r0, #0]
3400595e:	6810      	ldr	r0, [r2, #0]
34005960:	f020 0001 	bic.w	r0, r0, #1
34005964:	6010      	str	r0, [r2, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
34005966:	6810      	ldr	r0, [r2, #0]
34005968:	f420 5080 	bic.w	r0, r0, #4096	@ 0x1000
3400596c:	6010      	str	r0, [r2, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
3400596e:	6810      	ldr	r0, [r2, #0]
34005970:	4301      	orrs	r1, r0
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34005972:	2000      	movs	r0, #0
    hi2c->Instance->CR1 |= AnalogFilter;
34005974:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
34005976:	6811      	ldr	r1, [r2, #0]
34005978:	f041 0101 	orr.w	r1, r1, #1
3400597c:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
3400597e:	f883 4041 	strb.w	r4, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
34005982:	f883 0040 	strb.w	r0, [r3, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
34005986:	bd10      	pop	{r4, pc}
    __HAL_LOCK(hi2c);
34005988:	2002      	movs	r0, #2
3400598a:	e7fc      	b.n	34005986 <HAL_I2CEx_ConfigAnalogFilter+0x46>

3400598c <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
3400598c:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
3400598e:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
{
34005992:	4603      	mov	r3, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
34005994:	2a20      	cmp	r2, #32
34005996:	b2d4      	uxtb	r4, r2
34005998:	d11b      	bne.n	340059d2 <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
3400599a:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
3400599e:	2a01      	cmp	r2, #1
340059a0:	d017      	beq.n	340059d2 <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
340059a2:	2224      	movs	r2, #36	@ 0x24
340059a4:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
340059a8:	6802      	ldr	r2, [r0, #0]
340059aa:	6810      	ldr	r0, [r2, #0]
340059ac:	f020 0001 	bic.w	r0, r0, #1
340059b0:	6010      	str	r0, [r2, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
340059b2:	6810      	ldr	r0, [r2, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
340059b4:	f420 6070 	bic.w	r0, r0, #3840	@ 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
340059b8:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
340059bc:	2000      	movs	r0, #0
    hi2c->Instance->CR1 = tmpreg;
340059be:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
340059c0:	6811      	ldr	r1, [r2, #0]
340059c2:	f041 0101 	orr.w	r1, r1, #1
340059c6:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
340059c8:	f883 4041 	strb.w	r4, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
340059cc:	f883 0040 	strb.w	r0, [r3, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
340059d0:	bd10      	pop	{r4, pc}
    __HAL_LOCK(hi2c);
340059d2:	2002      	movs	r0, #2
340059d4:	e7fc      	b.n	340059d0 <HAL_I2CEx_ConfigDigitalFilter+0x44>

340059d6 <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
340059d6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
340059da:	2634      	movs	r6, #52	@ 0x34
{
340059dc:	b087      	sub	sp, #28
340059de:	f8dd c040 	ldr.w	ip, [sp, #64]	@ 0x40
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
340059e2:	6804      	ldr	r4, [r0, #0]
340059e4:	fb06 060c 	mla	r6, r6, ip, r0

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340059e8:	f8d6 e048 	ldr.w	lr, [r6, #72]	@ 0x48
{
340059ec:	e9cd 2302 	strd	r2, r3, [sp, #8]
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
340059f0:	6e75      	ldr	r5, [r6, #100]	@ 0x64
340059f2:	f10c 0301 	add.w	r3, ip, #1
340059f6:	eb04 2303 	add.w	r3, r4, r3, lsl #8
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340059fa:	f1be 0f03 	cmp.w	lr, #3
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
340059fe:	63dd      	str	r5, [r3, #60]	@ 0x3c
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005a00:	d84c      	bhi.n	34005a9c <LTDC_SetConfig+0xc6>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
34005a02:	2604      	movs	r6, #4
      stride = 1U;
      break;
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34005a04:	2734      	movs	r7, #52	@ 0x34
34005a06:	fb07 000c 	mla	r0, r7, ip, r0
34005a0a:	f8d4 c00c 	ldr.w	ip, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34005a0e:	f8d0 b038 	ldr.w	fp, [r0, #56]	@ 0x38
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34005a12:	68e7      	ldr	r7, [r4, #12]
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34005a14:	f8d0 803c 	ldr.w	r8, [r0, #60]	@ 0x3c
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34005a18:	f10b 0901 	add.w	r9, fp, #1
34005a1c:	f3c7 470b 	ubfx	r7, r7, #16, #12
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34005a20:	f3cc 4c0b 	ubfx	ip, ip, #16, #12
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34005a24:	444f      	add	r7, r9
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34005a26:	44c4      	add	ip, r8
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34005a28:	ea47 470c 	orr.w	r7, r7, ip, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34005a2c:	611f      	str	r7, [r3, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34005a2e:	6c47      	ldr	r7, [r0, #68]	@ 0x44
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
34005a30:	6c02      	ldr	r2, [r0, #64]	@ 0x40
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34005a32:	9704      	str	r7, [sp, #16]
34005a34:	68e7      	ldr	r7, [r4, #12]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34005a36:	68e4      	ldr	r4, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
34005a38:	9205      	str	r2, [sp, #20]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34005a3a:	f3c4 0c0b 	ubfx	ip, r4, #0, #12
34005a3e:	1c54      	adds	r4, r2, #1
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34005a40:	9a04      	ldr	r2, [sp, #16]
34005a42:	f3c7 070b 	ubfx	r7, r7, #0, #12
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34005a46:	4464      	add	r4, ip
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34005a48:	4417      	add	r7, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34005a4a:	ea44 4407 	orr.w	r4, r4, r7, lsl #16

  if (Mirror == LTDC_MIRROR_NONE)
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34005a4e:	6dc2      	ldr	r2, [r0, #92]	@ 0x5c
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
34005a50:	615c      	str	r4, [r3, #20]
        /* Configure the auxiliary frame buffer address 1 */
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;

        /* Configure the buffer length */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34005a52:	eba8 040b 	sub.w	r4, r8, fp
        break;
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
34005a56:	fb04 f906 	mul.w	r9, r4, r6
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34005a5a:	9201      	str	r2, [sp, #4]
  if (Mirror == LTDC_MIRROR_NONE)
34005a5c:	9a03      	ldr	r2, [sp, #12]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34005a5e:	6e00      	ldr	r0, [r0, #96]	@ 0x60
  if (Mirror == LTDC_MIRROR_NONE)
34005a60:	2a03      	cmp	r2, #3
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34005a62:	fb00 fc06 	mul.w	ip, r0, r6
                                            stride)  + 7U));
34005a66:	f109 0a07 	add.w	sl, r9, #7
  if (Mirror == LTDC_MIRROR_NONE)
34005a6a:	d145      	bne.n	34005af8 <LTDC_SetConfig+0x122>
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005a6c:	f240 160d 	movw	r6, #269	@ 0x10d
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34005a70:	9a01      	ldr	r2, [sp, #4]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005a72:	45b6      	cmp	lr, r6
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34005a74:	635a      	str	r2, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005a76:	d02a      	beq.n	34005ace <LTDC_SetConfig+0xf8>
34005a78:	f240 260d 	movw	r6, #525	@ 0x20d
34005a7c:	45b6      	cmp	lr, r6
34005a7e:	d031      	beq.n	34005ae4 <LTDC_SetConfig+0x10e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34005a80:	ea4a 420c 	orr.w	r2, sl, ip, lsl #16
34005a84:	639a      	str	r2, [r3, #56]	@ 0x38
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
34005a86:	68da      	ldr	r2, [r3, #12]
34005a88:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
34005a8c:	f022 0201 	bic.w	r2, r2, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
34005a90:	f042 0201 	orr.w	r2, r2, #1
34005a94:	60da      	str	r2, [r3, #12]
  }
}
34005a96:	b007      	add	sp, #28
34005a98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005a9c:	f1ae 0704 	sub.w	r7, lr, #4
34005aa0:	2f09      	cmp	r7, #9
34005aa2:	f04f 0601 	mov.w	r6, #1
34005aa6:	d8ad      	bhi.n	34005a04 <LTDC_SetConfig+0x2e>
34005aa8:	f240 299b 	movw	r9, #667	@ 0x29b
34005aac:	fa06 f807 	lsl.w	r8, r6, r7
34005ab0:	ea18 0f09 	tst.w	r8, r9
34005ab4:	d107      	bne.n	34005ac6 <LTDC_SetConfig+0xf0>
34005ab6:	2f02      	cmp	r7, #2
34005ab8:	d007      	beq.n	34005aca <LTDC_SetConfig+0xf4>
34005aba:	2f08      	cmp	r7, #8
34005abc:	d1a2      	bne.n	34005a04 <LTDC_SetConfig+0x2e>
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
34005abe:	6f9e      	ldr	r6, [r3, #120]	@ 0x78
34005ac0:	f3c6 4682 	ubfx	r6, r6, #18, #3
      break;
34005ac4:	e79e      	b.n	34005a04 <LTDC_SetConfig+0x2e>
      stride = 2U;
34005ac6:	2602      	movs	r6, #2
34005ac8:	e79c      	b.n	34005a04 <LTDC_SetConfig+0x2e>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005aca:	2603      	movs	r6, #3
34005acc:	e79a      	b.n	34005a04 <LTDC_SetConfig+0x2e>
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
34005ace:	f108 0207 	add.w	r2, r8, #7
34005ad2:	eba2 020b 	sub.w	r2, r2, fp
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34005ad6:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
34005ada:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34005adc:	649a      	str	r2, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
34005ade:	086d      	lsrs	r5, r5, #1
34005ae0:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34005ae2:	e7cd      	b.n	34005a80 <LTDC_SetConfig+0xaa>
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34005ae4:	0864      	lsrs	r4, r4, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
34005ae6:	9a02      	ldr	r2, [sp, #8]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34005ae8:	0840      	lsrs	r0, r0, #1
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34005aea:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34005aec:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
34005af0:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
34005af2:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34005af4:	649c      	str	r4, [r3, #72]	@ 0x48
34005af6:	e7f2      	b.n	34005ade <LTDC_SetConfig+0x108>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
34005af8:	9a03      	ldr	r2, [sp, #12]
34005afa:	bb3a      	cbnz	r2, 34005b4c <LTDC_SetConfig+0x176>
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
34005afc:	9a01      	ldr	r2, [sp, #4]
34005afe:	1e57      	subs	r7, r2, #1
34005b00:	444f      	add	r7, r9
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34005b02:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005b04:	f240 170d 	movw	r7, #269	@ 0x10d
34005b08:	45be      	cmp	lr, r7
34005b0a:	d00a      	beq.n	34005b22 <LTDC_SetConfig+0x14c>
34005b0c:	f240 270d 	movw	r7, #525	@ 0x20d
34005b10:	45be      	cmp	lr, r7
34005b12:	d010      	beq.n	34005b36 <LTDC_SetConfig+0x160>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34005b14:	ea4a 420c 	orr.w	r2, sl, ip, lsl #16
34005b18:	639a      	str	r2, [r3, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
34005b1a:	68da      	ldr	r2, [r3, #12]
34005b1c:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
34005b20:	e7b6      	b.n	34005a90 <LTDC_SetConfig+0xba>
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
34005b22:	3901      	subs	r1, #1
34005b24:	4449      	add	r1, r9
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34005b26:	6419      	str	r1, [r3, #64]	@ 0x40
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34005b28:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34005b2a:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34005b2e:	086d      	lsrs	r5, r5, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34005b30:	649c      	str	r4, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34005b32:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34005b34:	e7ee      	b.n	34005b14 <LTDC_SetConfig+0x13e>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34005b36:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34005b38:	4366      	muls	r6, r4
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34005b3a:	9a02      	ldr	r2, [sp, #8]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34005b3c:	3901      	subs	r1, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34005b3e:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34005b40:	4431      	add	r1, r6
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34005b42:	4432      	add	r2, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34005b44:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34005b46:	0840      	lsrs	r0, r0, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34005b48:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34005b4a:	e7ed      	b.n	34005b28 <LTDC_SetConfig+0x152>
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34005b4c:	e9dd 2704 	ldrd	r2, r7, [sp, #16]
34005b50:	eba2 0807 	sub.w	r8, r2, r7
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34005b54:	9a03      	ldr	r2, [sp, #12]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34005b56:	f5cc 4c00 	rsb	ip, ip, #32768	@ 0x8000
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34005b5a:	2a01      	cmp	r2, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34005b5c:	ea4a 4c0c 	orr.w	ip, sl, ip, lsl #16
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34005b60:	d131      	bne.n	34005bc6 <LTDC_SetConfig+0x1f0>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34005b62:	9a01      	ldr	r2, [sp, #4]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34005b64:	f108 3aff 	add.w	sl, r8, #4294967295
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34005b68:	fb09 270a 	mla	r7, r9, sl, r2
34005b6c:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005b6e:	f240 170d 	movw	r7, #269	@ 0x10d
34005b72:	45be      	cmp	lr, r7
34005b74:	d006      	beq.n	34005b84 <LTDC_SetConfig+0x1ae>
34005b76:	f240 270d 	movw	r7, #525	@ 0x20d
34005b7a:	45be      	cmp	lr, r7
34005b7c:	d00d      	beq.n	34005b9a <LTDC_SetConfig+0x1c4>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
34005b7e:	f8c3 c038 	str.w	ip, [r3, #56]	@ 0x38
34005b82:	e780      	b.n	34005a86 <LTDC_SetConfig+0xb0>
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34005b84:	ea4f 0258 	mov.w	r2, r8, lsr #1
34005b88:	3a01      	subs	r2, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34005b8a:	fb09 1202 	mla	r2, r9, r2, r1
34005b8e:	641a      	str	r2, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34005b90:	f8c3 c048 	str.w	ip, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34005b94:	086d      	lsrs	r5, r5, #1
34005b96:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34005b98:	e7f1      	b.n	34005b7e <LTDC_SetConfig+0x1a8>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34005b9a:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34005b9c:	4374      	muls	r4, r6
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34005b9e:	ea4f 0858 	mov.w	r8, r8, lsr #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34005ba2:	0840      	lsrs	r0, r0, #1
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34005ba4:	f108 38ff 	add.w	r8, r8, #4294967295
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34005ba8:	f5c0 4000 	rsb	r0, r0, #32768	@ 0x8000
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34005bac:	fb04 f808 	mul.w	r8, r4, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34005bb0:	4370      	muls	r0, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34005bb2:	9a02      	ldr	r2, [sp, #8]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34005bb4:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34005bb6:	4441      	add	r1, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34005bb8:	4442      	add	r2, r8
                                               stride) << 16U) |
34005bba:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34005bbe:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34005bc0:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34005bc2:	649c      	str	r4, [r3, #72]	@ 0x48
34005bc4:	e7e6      	b.n	34005b94 <LTDC_SetConfig+0x1be>
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
34005bc6:	9a01      	ldr	r2, [sp, #4]
34005bc8:	1e57      	subs	r7, r2, #1
34005bca:	fb09 7708 	mla	r7, r9, r8, r7
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34005bce:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005bd0:	f240 170d 	movw	r7, #269	@ 0x10d
34005bd4:	45be      	cmp	lr, r7
34005bd6:	d006      	beq.n	34005be6 <LTDC_SetConfig+0x210>
34005bd8:	f240 270d 	movw	r7, #525	@ 0x20d
34005bdc:	45be      	cmp	lr, r7
34005bde:	d00d      	beq.n	34005bfc <LTDC_SetConfig+0x226>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
34005be0:	f8c3 c038 	str.w	ip, [r3, #56]	@ 0x38
34005be4:	e799      	b.n	34005b1a <LTDC_SetConfig+0x144>
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34005be6:	ea4f 0858 	mov.w	r8, r8, lsr #1
34005bea:	3901      	subs	r1, #1
34005bec:	fb09 1108 	mla	r1, r9, r8, r1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34005bf0:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34005bf2:	f8c3 c048 	str.w	ip, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34005bf6:	086d      	lsrs	r5, r5, #1
34005bf8:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34005bfa:	e7f1      	b.n	34005be0 <LTDC_SetConfig+0x20a>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34005bfc:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34005bfe:	4374      	muls	r4, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34005c00:	0840      	lsrs	r0, r0, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34005c02:	ea4f 0858 	mov.w	r8, r8, lsr #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34005c06:	f5c0 4000 	rsb	r0, r0, #32768	@ 0x8000
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34005c0a:	fb04 f808 	mul.w	r8, r4, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34005c0e:	4370      	muls	r0, r6
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34005c10:	9a02      	ldr	r2, [sp, #8]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34005c12:	3901      	subs	r1, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34005c14:	3a01      	subs	r2, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34005c16:	3407      	adds	r4, #7
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34005c18:	4442      	add	r2, r8
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34005c1a:	4441      	add	r1, r8
                                              << 16U) |
34005c1c:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34005c20:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34005c22:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34005c24:	649c      	str	r4, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
34005c26:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
34005c28:	f36f 020f 	bfc	r2, #0, #16
34005c2c:	64da      	str	r2, [r3, #76]	@ 0x4c
34005c2e:	e7e2      	b.n	34005bf6 <LTDC_SetConfig+0x220>

34005c30 <LTDC_SetCompositionConfig>:

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34005c30:	6802      	ldr	r2, [r0, #0]
34005c32:	1c4b      	adds	r3, r1, #1
34005c34:	eb02 2203 	add.w	r2, r2, r3, lsl #8
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
34005c38:	2334      	movs	r3, #52	@ 0x34
34005c3a:	fb03 0101 	mla	r1, r3, r1, r0
34005c3e:	6d08      	ldr	r0, [r1, #80]	@ 0x50
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34005c40:	f891 3068 	ldrb.w	r3, [r1, #104]	@ 0x68
34005c44:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
34005c48:	f891 0069 	ldrb.w	r0, [r1, #105]	@ 0x69
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34005c4c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
34005c50:	f891 006a 	ldrb.w	r0, [r1, #106]	@ 0x6a
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34005c54:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005c58:	6253      	str	r3, [r2, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
34005c5a:	6a13      	ldr	r3, [r2, #32]
34005c5c:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
34005c60:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
34005c62:	6ccb      	ldr	r3, [r1, #76]	@ 0x4c
34005c64:	6213      	str	r3, [r2, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
34005c66:	6a90      	ldr	r0, [r2, #40]	@ 0x28
34005c68:	4b05      	ldr	r3, [pc, #20]	@ (34005c80 <LTDC_SetCompositionConfig+0x50>)
34005c6a:	4003      	ands	r3, r0
34005c6c:	6293      	str	r3, [r2, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
34005c6e:	6a90      	ldr	r0, [r2, #40]	@ 0x28
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34005c70:	e9d1 3115 	ldrd	r3, r1, [r1, #84]	@ 0x54
34005c74:	430b      	orrs	r3, r1
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
34005c76:	f400 3180 	and.w	r1, r0, #65536	@ 0x10000
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
34005c7a:	430b      	orrs	r3, r1
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34005c7c:	6293      	str	r3, [r2, #40]	@ 0x28
}
34005c7e:	4770      	bx	lr
34005c80:	fffef8f8 	.word	0xfffef8f8

34005c84 <LTDC_SetPredefFormat>:
  uint32_t BPOS = 0U;
  uint32_t GLEN = 0U;
  uint32_t GPOS = 0U;

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005c84:	2334      	movs	r3, #52	@ 0x34
34005c86:	fb03 0301 	mla	r3, r3, r1, r0
34005c8a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
{
34005c8c:	b5f0      	push	{r4, r5, r6, r7, lr}
34005c8e:	1fd4      	subs	r4, r2, #7
34005c90:	2c04      	cmp	r4, #4
34005c92:	d823      	bhi.n	34005cdc <LTDC_SetPredefFormat+0x58>
34005c94:	4a16      	ldr	r2, [pc, #88]	@ (34005cf0 <LTDC_SetPredefFormat+0x6c>)
34005c96:	f8df c06c 	ldr.w	ip, [pc, #108]	@ 34005d04 <LTDC_SetPredefFormat+0x80>
34005c9a:	5d16      	ldrb	r6, [r2, r4]
34005c9c:	4a15      	ldr	r2, [pc, #84]	@ (34005cf4 <LTDC_SetPredefFormat+0x70>)
34005c9e:	4b16      	ldr	r3, [pc, #88]	@ (34005cf8 <LTDC_SetPredefFormat+0x74>)
34005ca0:	5d17      	ldrb	r7, [r2, r4]
34005ca2:	4a16      	ldr	r2, [pc, #88]	@ (34005cfc <LTDC_SetPredefFormat+0x78>)
34005ca4:	5d1b      	ldrb	r3, [r3, r4]
34005ca6:	5d15      	ldrb	r5, [r2, r4]
34005ca8:	4a15      	ldr	r2, [pc, #84]	@ (34005d00 <LTDC_SetPredefFormat+0x7c>)
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34005caa:	049b      	lsls	r3, r3, #18
34005cac:	5d12      	ldrb	r2, [r2, r4]
34005cae:	f81c 4004 	ldrb.w	r4, [ip, r4]
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
34005cb2:	f101 0c01 	add.w	ip, r1, #1
34005cb6:	6801      	ldr	r1, [r0, #0]
34005cb8:	2007      	movs	r0, #7
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
34005cba:	0252      	lsls	r2, r2, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34005cbc:	eb02 3285 	add.w	r2, r2, r5, lsl #14
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
34005cc0:	443a      	add	r2, r7
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34005cc2:	eb03 3385 	add.w	r3, r3, r5, lsl #14
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
34005cc6:	eb01 210c 	add.w	r1, r1, ip, lsl #8
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
34005cca:	eb02 1246 	add.w	r2, r2, r6, lsl #5
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
34005cce:	4423      	add	r3, r4
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
34005cd0:	61c8      	str	r0, [r1, #28]
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
34005cd2:	eb03 1345 	add.w	r3, r3, r5, lsl #5
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34005cd6:	674a      	str	r2, [r1, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
34005cd8:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
    default:
      break;
  }
}
34005cda:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005cdc:	2a06      	cmp	r2, #6
34005cde:	d8fc      	bhi.n	34005cda <LTDC_SetPredefFormat+0x56>
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
34005ce0:	6803      	ldr	r3, [r0, #0]
34005ce2:	3101      	adds	r1, #1
34005ce4:	eb03 2101 	add.w	r1, r3, r1, lsl #8
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
34005ce8:	2300      	movs	r3, #0
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
34005cea:	61ca      	str	r2, [r1, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
34005cec:	674b      	str	r3, [r1, #116]	@ 0x74
34005cee:	e7f3      	b.n	34005cd8 <LTDC_SetPredefFormat+0x54>
34005cf0:	340103cc 	.word	0x340103cc
34005cf4:	340103c7 	.word	0x340103c7
34005cf8:	340103d1 	.word	0x340103d1
34005cfc:	340103c2 	.word	0x340103c2
34005d00:	340103bd 	.word	0x340103bd
34005d04:	340103b8 	.word	0x340103b8

34005d08 <LTDC_RetrieveUserConfig.constprop.0>:
static void LTDC_RetrieveUserConfig(LTDC_HandleTypeDef *hltdc, uint32_t *Mirror, uint32_t *Aux0Addr,
34005d08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34005d0c:	468c      	mov	ip, r1
34005d0e:	9907      	ldr	r1, [sp, #28]
  const uint32_t hmirror = ((LTDC_LAYER(hltdc, LayerIdx)->CR) & LTDC_LxCR_HMEN_Msk);
34005d10:	6805      	ldr	r5, [r0, #0]
34005d12:	1c4c      	adds	r4, r1, #1
34005d14:	eb05 2504 	add.w	r5, r5, r4, lsl #8
34005d18:	68ec      	ldr	r4, [r5, #12]
34005d1a:	f404 7e80 	and.w	lr, r4, #256	@ 0x100
  const uint32_t pitchSign = (LTDC_LAYER(hltdc, LayerIdx)->CFBLR & LTDC_LxCFBLR_CFBP) & LTDC_PITCH_SIGN_MSK;
34005d1e:	6bac      	ldr	r4, [r5, #56]	@ 0x38
34005d20:	f004 4880 	and.w	r8, r4, #1073741824	@ 0x40000000
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005d24:	2434      	movs	r4, #52	@ 0x34
34005d26:	fb04 0401 	mla	r4, r4, r1, r0
34005d2a:	6ca6      	ldr	r6, [r4, #72]	@ 0x48
34005d2c:	2e03      	cmp	r6, #3
34005d2e:	d813      	bhi.n	34005d58 <LTDC_RetrieveUserConfig.constprop.0+0x50>
      stride = 4U;
34005d30:	2404      	movs	r4, #4
  if ((pitchSign == 0U) && (hmirror == 0U))
34005d32:	f1b8 0f00 	cmp.w	r8, #0
34005d36:	d153      	bne.n	34005de0 <LTDC_RetrieveUserConfig.constprop.0+0xd8>
34005d38:	2734      	movs	r7, #52	@ 0x34
34005d3a:	f1be 0f00 	cmp.w	lr, #0
34005d3e:	d123      	bne.n	34005d88 <LTDC_RetrieveUserConfig.constprop.0+0x80>
    *Mirror = LTDC_MIRROR_NONE;
34005d40:	2403      	movs	r4, #3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
34005d42:	fb07 0701 	mla	r7, r7, r1, r0
    *Mirror = LTDC_MIRROR_NONE;
34005d46:	f8cc 4000 	str.w	r4, [ip]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
34005d4a:	6b6c      	ldr	r4, [r5, #52]	@ 0x34
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
34005d4c:	6c29      	ldr	r1, [r5, #64]	@ 0x40
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
34005d4e:	65fc      	str	r4, [r7, #92]	@ 0x5c
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
34005d50:	6011      	str	r1, [r2, #0]
    *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R;
34005d52:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34005d54:	601a      	str	r2, [r3, #0]
}
34005d56:	e02d      	b.n	34005db4 <LTDC_RetrieveUserConfig.constprop.0+0xac>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005d58:	3e04      	subs	r6, #4
34005d5a:	2e09      	cmp	r6, #9
34005d5c:	f04f 0401 	mov.w	r4, #1
34005d60:	d8e7      	bhi.n	34005d32 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
34005d62:	f240 299b 	movw	r9, #667	@ 0x29b
34005d66:	fa04 f706 	lsl.w	r7, r4, r6
34005d6a:	ea17 0f09 	tst.w	r7, r9
34005d6e:	d107      	bne.n	34005d80 <LTDC_RetrieveUserConfig.constprop.0+0x78>
34005d70:	2e02      	cmp	r6, #2
34005d72:	d007      	beq.n	34005d84 <LTDC_RetrieveUserConfig.constprop.0+0x7c>
34005d74:	2e08      	cmp	r6, #8
34005d76:	d1dc      	bne.n	34005d32 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
      stride = ((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos;
34005d78:	6fac      	ldr	r4, [r5, #120]	@ 0x78
34005d7a:	f3c4 4482 	ubfx	r4, r4, #18, #3
      break;
34005d7e:	e7d8      	b.n	34005d32 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
      stride = 2U;
34005d80:	2402      	movs	r4, #2
34005d82:	e7d6      	b.n	34005d32 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005d84:	2403      	movs	r4, #3
34005d86:	e7d4      	b.n	34005d32 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
    *Mirror = LTDC_MIRROR_HORIZONTAL;
34005d88:	f8cc 8000 	str.w	r8, [ip]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005d8c:	f240 1c0d 	movw	ip, #269	@ 0x10d
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34005d90:	fb07 0001 	mla	r0, r7, r1, r0
34005d94:	e9d0 710e 	ldrd	r7, r1, [r0, #56]	@ 0x38
34005d98:	1bc9      	subs	r1, r1, r7
34005d9a:	fb04 f701 	mul.w	r7, r4, r1
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34005d9e:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
34005da0:	3601      	adds	r6, #1
34005da2:	1bf6      	subs	r6, r6, r7
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34005da4:	65c6      	str	r6, [r0, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005da6:	6c86      	ldr	r6, [r0, #72]	@ 0x48
34005da8:	4566      	cmp	r6, ip
34005daa:	d005      	beq.n	34005db8 <LTDC_RetrieveUserConfig.constprop.0+0xb0>
34005dac:	f240 270d 	movw	r7, #525	@ 0x20d
34005db0:	42be      	cmp	r6, r7
34005db2:	d006      	beq.n	34005dc2 <LTDC_RetrieveUserConfig.constprop.0+0xba>
}
34005db4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34005db8:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                               hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
34005dba:	3301      	adds	r3, #1
34005dbc:	1bdb      	subs	r3, r3, r7
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34005dbe:	6013      	str	r3, [r2, #0]
        break;
34005dc0:	e7f8      	b.n	34005db4 <LTDC_RetrieveUserConfig.constprop.0+0xac>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34005dc2:	6c2e      	ldr	r6, [r5, #64]	@ 0x40
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34005dc4:	0849      	lsrs	r1, r1, #1
34005dc6:	3601      	adds	r6, #1
34005dc8:	fb04 6111 	mls	r1, r4, r1, r6
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34005dcc:	6011      	str	r1, [r2, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
34005dce:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34005dd0:	e9d0 010e 	ldrd	r0, r1, [r0, #56]	@ 0x38
34005dd4:	1a09      	subs	r1, r1, r0
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34005dd6:	3201      	adds	r2, #1
34005dd8:	0849      	lsrs	r1, r1, #1
34005dda:	fb04 2211 	mls	r2, r4, r1, r2
34005dde:	e7b9      	b.n	34005d54 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
  else if ((pitchSign != 0U) && (hmirror == 0U))
34005de0:	2634      	movs	r6, #52	@ 0x34
34005de2:	f1be 0f00 	cmp.w	lr, #0
34005de6:	d138      	bne.n	34005e5a <LTDC_RetrieveUserConfig.constprop.0+0x152>
    *Mirror = LTDC_MIRROR_VERTICAL;
34005de8:	2701      	movs	r7, #1
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34005dea:	fb06 0601 	mla	r6, r6, r1, r0
    *Mirror = LTDC_MIRROR_VERTICAL;
34005dee:	f8cc 7000 	str.w	r7, [ip]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34005df2:	e9d6 100e 	ldrd	r1, r0, [r6, #56]	@ 0x38
34005df6:	1a40      	subs	r0, r0, r1
34005df8:	fb00 fc04 	mul.w	ip, r0, r4
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34005dfc:	e9d6 1710 	ldrd	r1, r7, [r6, #64]	@ 0x40
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34005e00:	f8d5 8034 	ldr.w	r8, [r5, #52]	@ 0x34
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34005e04:	1a79      	subs	r1, r7, r1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34005e06:	f101 3eff 	add.w	lr, r1, #4294967295
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34005e0a:	fb0c 871e 	mls	r7, ip, lr, r8
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005e0e:	f240 1e0d 	movw	lr, #269	@ 0x10d
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34005e12:	65f7      	str	r7, [r6, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005e14:	6cb7      	ldr	r7, [r6, #72]	@ 0x48
34005e16:	4577      	cmp	r7, lr
34005e18:	d019      	beq.n	34005e4e <LTDC_RetrieveUserConfig.constprop.0+0x146>
34005e1a:	f240 2c0d 	movw	ip, #525	@ 0x20d
34005e1e:	4567      	cmp	r7, ip
34005e20:	d1c8      	bne.n	34005db4 <LTDC_RetrieveUserConfig.constprop.0+0xac>
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34005e22:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34005e24:	0840      	lsrs	r0, r0, #1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34005e26:	3901      	subs	r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34005e28:	4341      	muls	r1, r0
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34005e2a:	6c2f      	ldr	r7, [r5, #64]	@ 0x40
34005e2c:	fb04 7111 	mls	r1, r4, r1, r7
34005e30:	6011      	str	r1, [r2, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34005e32:	e9d6 1210 	ldrd	r1, r2, [r6, #64]	@ 0x40
34005e36:	1a52      	subs	r2, r2, r1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34005e38:	6c68      	ldr	r0, [r5, #68]	@ 0x44
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34005e3a:	0852      	lsrs	r2, r2, #1
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34005e3c:	e9d6 510e 	ldrd	r5, r1, [r6, #56]	@ 0x38
34005e40:	1b49      	subs	r1, r1, r5
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34005e42:	3a01      	subs	r2, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34005e44:	0849      	lsrs	r1, r1, #1
34005e46:	434a      	muls	r2, r1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34005e48:	fb04 0212 	mls	r2, r4, r2, r0
34005e4c:	e782      	b.n	34005d54 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34005e4e:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34005e50:	0849      	lsrs	r1, r1, #1
34005e52:	3901      	subs	r1, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34005e54:	fb0c 3311 	mls	r3, ip, r1, r3
34005e58:	e7b1      	b.n	34005dbe <LTDC_RetrieveUserConfig.constprop.0+0xb6>
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
34005e5a:	2702      	movs	r7, #2
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34005e5c:	fb06 0001 	mla	r0, r6, r1, r0
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
34005e60:	f8cc 7000 	str.w	r7, [ip]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34005e64:	f8d5 e034 	ldr.w	lr, [r5, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34005e68:	e9d0 610e 	ldrd	r6, r1, [r0, #56]	@ 0x38
34005e6c:	1b89      	subs	r1, r1, r6
                                               (hltdc->LayerCfg[LayerIdx].WindowY1 - \
34005e6e:	e9d0 7610 	ldrd	r7, r6, [r0, #64]	@ 0x40
34005e72:	1bf7      	subs	r7, r6, r7
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
34005e74:	f10e 0601 	add.w	r6, lr, #1
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005e78:	f240 1e0d 	movw	lr, #269	@ 0x10d
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34005e7c:	fb01 fc04 	mul.w	ip, r1, r4
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
34005e80:	fb07 661c 	mls	r6, r7, ip, r6
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34005e84:	65c6      	str	r6, [r0, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34005e86:	6c86      	ldr	r6, [r0, #72]	@ 0x48
34005e88:	4576      	cmp	r6, lr
34005e8a:	d019      	beq.n	34005ec0 <LTDC_RetrieveUserConfig.constprop.0+0x1b8>
34005e8c:	f240 2c0d 	movw	ip, #525	@ 0x20d
34005e90:	4566      	cmp	r6, ip
34005e92:	d18f      	bne.n	34005db4 <LTDC_RetrieveUserConfig.constprop.0+0xac>
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34005e94:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34005e96:	087f      	lsrs	r7, r7, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34005e98:	4379      	muls	r1, r7
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34005e9a:	6c2e      	ldr	r6, [r5, #64]	@ 0x40
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34005e9c:	3601      	adds	r6, #1
34005e9e:	fb04 6111 	mls	r1, r4, r1, r6
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34005ea2:	6011      	str	r1, [r2, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34005ea4:	6c69      	ldr	r1, [r5, #68]	@ 0x44
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34005ea6:	e9d0 520e 	ldrd	r5, r2, [r0, #56]	@ 0x38
34005eaa:	1b52      	subs	r2, r2, r5
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34005eac:	e9d0 0510 	ldrd	r0, r5, [r0, #64]	@ 0x40
34005eb0:	1a28      	subs	r0, r5, r0
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34005eb2:	0852      	lsrs	r2, r2, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34005eb4:	0840      	lsrs	r0, r0, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34005eb6:	4342      	muls	r2, r0
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34005eb8:	3101      	adds	r1, #1
34005eba:	fb04 1212 	mls	r2, r4, r2, r1
34005ebe:	e749      	b.n	34005d54 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34005ec0:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34005ec2:	087f      	lsrs	r7, r7, #1
34005ec4:	3301      	adds	r3, #1
34005ec6:	fb0c 3317 	mls	r3, ip, r7, r3
34005eca:	e778      	b.n	34005dbe <LTDC_RetrieveUserConfig.constprop.0+0xb6>

34005ecc <HAL_LTDC_Init>:
{
34005ecc:	b538      	push	{r3, r4, r5, lr}
  if (hltdc == NULL)
34005ece:	4604      	mov	r4, r0
34005ed0:	2800      	cmp	r0, #0
34005ed2:	d053      	beq.n	34005f7c <HAL_LTDC_Init+0xb0>
  if (hltdc->State == HAL_LTDC_STATE_RESET)
34005ed4:	f890 30a1 	ldrb.w	r3, [r0, #161]	@ 0xa1
34005ed8:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
34005edc:	b91b      	cbnz	r3, 34005ee6 <HAL_LTDC_Init+0x1a>
    hltdc->Lock = HAL_UNLOCKED;
34005ede:	f880 20a0 	strb.w	r2, [r0, #160]	@ 0xa0
    HAL_LTDC_MspInit(hltdc);
34005ee2:	f7fc f92f 	bl	34002144 <HAL_LTDC_MspInit>
  hltdc->State = HAL_LTDC_STATE_BUSY;
34005ee6:	2302      	movs	r3, #2
34005ee8:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
34005eec:	6823      	ldr	r3, [r4, #0]
34005eee:	699a      	ldr	r2, [r3, #24]
34005ef0:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
34005ef4:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34005ef6:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
34005efa:	4302      	orrs	r2, r0
34005efc:	68e0      	ldr	r0, [r4, #12]
34005efe:	6999      	ldr	r1, [r3, #24]
34005f00:	4302      	orrs	r2, r0
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34005f02:	6920      	ldr	r0, [r4, #16]
34005f04:	4302      	orrs	r2, r0
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34005f06:	430a      	orrs	r2, r1
34005f08:	619a      	str	r2, [r3, #24]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
34005f0a:	e9d4 1205 	ldrd	r1, r2, [r4, #20]
34005f0e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34005f12:	609a      	str	r2, [r3, #8]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
34005f14:	e9d4 1207 	ldrd	r1, r2, [r4, #28]
34005f18:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34005f1c:	60da      	str	r2, [r3, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
34005f1e:	e9d4 1209 	ldrd	r1, r2, [r4, #36]	@ 0x24
34005f22:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34005f26:	611a      	str	r2, [r3, #16]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
34005f28:	e9d4 120b 	ldrd	r1, r2, [r4, #44]	@ 0x2c
34005f2c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34005f30:	615a      	str	r2, [r3, #20]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34005f32:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
34005f34:	f894 0035 	ldrb.w	r0, [r4, #53]	@ 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34005f38:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
34005f3c:	f894 1036 	ldrb.w	r1, [r4, #54]	@ 0x36
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34005f40:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
34005f42:	6add      	ldr	r5, [r3, #44]	@ 0x2c
34005f44:	f894 2034 	ldrb.w	r2, [r4, #52]	@ 0x34
34005f48:	432a      	orrs	r2, r5
34005f4a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
34005f4e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34005f52:	62da      	str	r2, [r3, #44]	@ 0x2c
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
34005f54:	2204      	movs	r2, #4
34005f56:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
34005f5a:	f8c3 2208 	str.w	r2, [r3, #520]	@ 0x208
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34005f5e:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34005f60:	2000      	movs	r0, #0
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34005f62:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
34005f66:	665a      	str	r2, [r3, #100]	@ 0x64
  __HAL_LTDC_ENABLE(hltdc);
34005f68:	699a      	ldr	r2, [r3, #24]
34005f6a:	f042 0201 	orr.w	r2, r2, #1
34005f6e:	619a      	str	r2, [r3, #24]
  hltdc->State = HAL_LTDC_STATE_READY;
34005f70:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34005f72:	f8c4 00a4 	str.w	r0, [r4, #164]	@ 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
34005f76:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
}
34005f7a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
34005f7c:	2001      	movs	r0, #1
34005f7e:	e7fc      	b.n	34005f7a <HAL_LTDC_Init+0xae>

34005f80 <HAL_LTDC_ConfigLayer>:
{
34005f80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __HAL_LOCK(hltdc);
34005f82:	f890 30a0 	ldrb.w	r3, [r0, #160]	@ 0xa0
{
34005f86:	4606      	mov	r6, r0
  __HAL_LOCK(hltdc);
34005f88:	2b01      	cmp	r3, #1
{
34005f8a:	460d      	mov	r5, r1
34005f8c:	4617      	mov	r7, r2
34005f8e:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hltdc);
34005f92:	d02c      	beq.n	34005fee <HAL_LTDC_ConfigLayer+0x6e>
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34005f94:	2434      	movs	r4, #52	@ 0x34
34005f96:	fb04 6402 	mla	r4, r4, r2, r6
  hltdc->State = HAL_LTDC_STATE_BUSY;
34005f9a:	f886 00a1 	strb.w	r0, [r6, #161]	@ 0xa1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34005f9e:	3438      	adds	r4, #56	@ 0x38
34005fa0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34005fa2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34005fa4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34005fa6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34005fa8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34005faa:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34005fac:	682b      	ldr	r3, [r5, #0]
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34005fae:	4639      	mov	r1, r7
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34005fb0:	6023      	str	r3, [r4, #0]
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34005fb2:	4630      	mov	r0, r6
34005fb4:	f7ff fe66 	bl	34005c84 <LTDC_SetPredefFormat>
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
34005fb8:	4639      	mov	r1, r7
34005fba:	4630      	mov	r0, r6
34005fbc:	f7ff fe38 	bl	34005c30 <LTDC_SetCompositionConfig>
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34005fc0:	2200      	movs	r2, #0
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34005fc2:	6834      	ldr	r4, [r6, #0]
34005fc4:	1c7b      	adds	r3, r7, #1
34005fc6:	eb04 2403 	add.w	r4, r4, r3, lsl #8
34005fca:	6b23      	ldr	r3, [r4, #48]	@ 0x30
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34005fcc:	4630      	mov	r0, r6
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34005fce:	f023 0308 	bic.w	r3, r3, #8
34005fd2:	6323      	str	r3, [r4, #48]	@ 0x30
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34005fd4:	4611      	mov	r1, r2
34005fd6:	2303      	movs	r3, #3
34005fd8:	9700      	str	r7, [sp, #0]
34005fda:	f7ff fcfc 	bl	340059d6 <LTDC_SetConfig>
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34005fde:	2305      	movs	r3, #5
  __HAL_UNLOCK(hltdc);
34005fe0:	2000      	movs	r0, #0
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34005fe2:	60a3      	str	r3, [r4, #8]
  hltdc->State  = HAL_LTDC_STATE_READY;
34005fe4:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
34005fe6:	f886 00a0 	strb.w	r0, [r6, #160]	@ 0xa0
  hltdc->State  = HAL_LTDC_STATE_READY;
34005fea:	f886 30a1 	strb.w	r3, [r6, #161]	@ 0xa1
}
34005fee:	b003      	add	sp, #12
34005ff0:	bdf0      	pop	{r4, r5, r6, r7, pc}

34005ff2 <HAL_LTDC_ReloadLayer>:
{
34005ff2:	b510      	push	{r4, lr}
34005ff4:	4603      	mov	r3, r0
  __HAL_LOCK(hltdc);
34005ff6:	f890 00a0 	ldrb.w	r0, [r0, #160]	@ 0xa0
34005ffa:	2801      	cmp	r0, #1
34005ffc:	f04f 0002 	mov.w	r0, #2
34006000:	d012      	beq.n	34006028 <HAL_LTDC_ReloadLayer+0x36>
  hltdc->State = HAL_LTDC_STATE_BUSY;
34006002:	f883 00a1 	strb.w	r0, [r3, #161]	@ 0xa1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34006006:	6818      	ldr	r0, [r3, #0]
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
34006008:	3201      	adds	r2, #1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
3400600a:	6e44      	ldr	r4, [r0, #100]	@ 0x64
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
3400600c:	f041 0104 	orr.w	r1, r1, #4
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34006010:	f044 0408 	orr.w	r4, r4, #8
34006014:	6644      	str	r4, [r0, #100]	@ 0x64
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
34006016:	eb00 2002 	add.w	r0, r0, r2, lsl #8
3400601a:	6081      	str	r1, [r0, #8]
  hltdc->State = HAL_LTDC_STATE_READY;
3400601c:	2201      	movs	r2, #1
  __HAL_UNLOCK(hltdc);
3400601e:	2000      	movs	r0, #0
  hltdc->State = HAL_LTDC_STATE_READY;
34006020:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1
  __HAL_UNLOCK(hltdc);
34006024:	f883 00a0 	strb.w	r0, [r3, #160]	@ 0xa0
}
34006028:	bd10      	pop	{r4, pc}

3400602a <HAL_LTDC_SetAddress_NoReload>:
{
3400602a:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t aux0Addr = 0U;
3400602c:	2500      	movs	r5, #0
  __HAL_LOCK(hltdc);
3400602e:	f890 30a0 	ldrb.w	r3, [r0, #160]	@ 0xa0
{
34006032:	b087      	sub	sp, #28
  __HAL_LOCK(hltdc);
34006034:	2b01      	cmp	r3, #1
{
34006036:	4604      	mov	r4, r0
34006038:	460f      	mov	r7, r1
3400603a:	4616      	mov	r6, r2
3400603c:	f04f 0302 	mov.w	r3, #2
  uint32_t aux1Addr = 0U;
34006040:	e9cd 5503 	strd	r5, r5, [sp, #12]
  uint32_t mirror = 0U;
34006044:	9505      	str	r5, [sp, #20]
  __HAL_LOCK(hltdc);
34006046:	d01a      	beq.n	3400607e <HAL_LTDC_SetAddress_NoReload+0x54>
  hltdc->State = HAL_LTDC_STATE_BUSY;
34006048:	f880 30a1 	strb.w	r3, [r0, #161]	@ 0xa1
  LTDC_RetrieveUserConfig(hltdc, &mirror, &aux0Addr, &aux1Addr, LayerIdx);
3400604c:	a905      	add	r1, sp, #20
3400604e:	9200      	str	r2, [sp, #0]
34006050:	ab04      	add	r3, sp, #16
34006052:	aa03      	add	r2, sp, #12
34006054:	f7ff fe58 	bl	34005d08 <LTDC_RetrieveUserConfig.constprop.0>
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34006058:	2334      	movs	r3, #52	@ 0x34
3400605a:	fb03 4306 	mla	r3, r3, r6, r4
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
3400605e:	4620      	mov	r0, r4
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34006060:	65df      	str	r7, [r3, #92]	@ 0x5c
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
34006062:	462a      	mov	r2, r5
34006064:	9b05      	ldr	r3, [sp, #20]
34006066:	4629      	mov	r1, r5
34006068:	9600      	str	r6, [sp, #0]
3400606a:	f7ff fcb4 	bl	340059d6 <LTDC_SetConfig>
  hltdc->State = HAL_LTDC_STATE_READY;
3400606e:	2301      	movs	r3, #1
  return HAL_OK;
34006070:	4628      	mov	r0, r5
  hltdc->State = HAL_LTDC_STATE_READY;
34006072:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
  __HAL_UNLOCK(hltdc);
34006076:	f884 50a0 	strb.w	r5, [r4, #160]	@ 0xa0
}
3400607a:	b007      	add	sp, #28
3400607c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_LOCK(hltdc);
3400607e:	4618      	mov	r0, r3
34006080:	e7fb      	b.n	3400607a <HAL_LTDC_SetAddress_NoReload+0x50>
	...

34006084 <HAL_PWR_ConfigAttributes>:
  assert_param(IS_PWR_ITEMS_ATTRIBUTES(Item));
  assert_param(IS_PWR_ATTRIBUTES(Attributes));

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Secure item management (TZEN = 1) */
  if ((Attributes & PWR_ITEM_ATTR_SEC_PRIV_MASK) == PWR_ITEM_ATTR_SEC_PRIV_MASK)
34006084:	f011 0f20 	tst.w	r1, #32
{
34006088:	b510      	push	{r4, lr}
3400608a:	4b0d      	ldr	r3, [pc, #52]	@ (340060c0 <HAL_PWR_ConfigAttributes+0x3c>)
  if ((Attributes & PWR_ITEM_ATTR_SEC_PRIV_MASK) == PWR_ITEM_ATTR_SEC_PRIV_MASK)
3400608c:	d00d      	beq.n	340060aa <HAL_PWR_ConfigAttributes+0x26>
  {
    /* Privilege item management */
    if ((Attributes & PWR_SEC_PRIV) == PWR_SEC_PRIV)
    {
      SET_BIT(PWR_S->SECCFGR, Item);
3400608e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
    if ((Attributes & PWR_SEC_PRIV) == PWR_SEC_PRIV)
34006090:	f001 0122 	and.w	r1, r1, #34	@ 0x22
      SET_BIT(PWR_S->SECCFGR, Item);
34006094:	4302      	orrs	r2, r0
34006096:	671a      	str	r2, [r3, #112]	@ 0x70
    if ((Attributes & PWR_SEC_PRIV) == PWR_SEC_PRIV)
34006098:	2922      	cmp	r1, #34	@ 0x22
      SET_BIT(PWR->PRIVCFGR, Item);
3400609a:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
    if ((Attributes & PWR_SEC_PRIV) == PWR_SEC_PRIV)
3400609c:	d101      	bne.n	340060a2 <HAL_PWR_ConfigAttributes+0x1e>
  {
    /* Privilege item management */
    if ((Attributes & PWR_NSEC_PRIV) == PWR_NSEC_PRIV)
    {
      CLEAR_BIT(PWR_S->SECCFGR, Item);
      SET_BIT(PWR->PRIVCFGR, Item);
3400609e:	4302      	orrs	r2, r0
340060a0:	e001      	b.n	340060a6 <HAL_PWR_ConfigAttributes+0x22>
      CLEAR_BIT(PWR->PRIVCFGR, Item);
340060a2:	ea22 0200 	bic.w	r2, r2, r0
    }
    else
    {
      CLEAR_BIT(PWR_S->SECCFGR, Item);
      CLEAR_BIT(PWR->PRIVCFGR, Item);
340060a6:	675a      	str	r2, [r3, #116]	@ 0x74
    {
      CLEAR_BIT(PWR->PRIVCFGR, Item);
    }
  }
#endif /* __ARM_FEATURE_CMSE */
}
340060a8:	bd10      	pop	{r4, pc}
      CLEAR_BIT(PWR->PRIVCFGR, Item);
340060aa:	43c4      	mvns	r4, r0
      CLEAR_BIT(PWR_S->SECCFGR, Item);
340060ac:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
    if ((Attributes & PWR_NSEC_PRIV) == PWR_NSEC_PRIV)
340060ae:	f001 0111 	and.w	r1, r1, #17
      CLEAR_BIT(PWR_S->SECCFGR, Item);
340060b2:	4022      	ands	r2, r4
340060b4:	671a      	str	r2, [r3, #112]	@ 0x70
    if ((Attributes & PWR_NSEC_PRIV) == PWR_NSEC_PRIV)
340060b6:	2911      	cmp	r1, #17
      SET_BIT(PWR->PRIVCFGR, Item);
340060b8:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
    if ((Attributes & PWR_NSEC_PRIV) == PWR_NSEC_PRIV)
340060ba:	d0f0      	beq.n	3400609e <HAL_PWR_ConfigAttributes+0x1a>
      CLEAR_BIT(PWR->PRIVCFGR, Item);
340060bc:	4022      	ands	r2, r4
340060be:	e7f2      	b.n	340060a6 <HAL_PWR_ConfigAttributes+0x22>
340060c0:	56024800 	.word	0x56024800

340060c4 <HAL_PWREx_ConfigVddIORange>:
{
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));

  switch (VddIOPort)
340060c4:	2804      	cmp	r0, #4
340060c6:	d829      	bhi.n	3400611c <HAL_PWREx_ConfigVddIORange+0x58>
340060c8:	e8df f000 	tbb	[pc, r0]
340060cc:	19120b03 	.word	0x19120b03
340060d0:	21          	.byte	0x21
340060d1:	00          	.byte	0x00
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
340060d2:	4a13      	ldr	r2, [pc, #76]	@ (34006120 <HAL_PWREx_ConfigVddIORange+0x5c>)
340060d4:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
340060d6:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
340060da:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
      break;

    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
340060de:	63d3      	str	r3, [r2, #60]	@ 0x3c
      break;
340060e0:	4770      	bx	lr
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
340060e2:	4a0f      	ldr	r2, [pc, #60]	@ (34006120 <HAL_PWREx_ConfigVddIORange+0x5c>)
340060e4:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
340060e6:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
340060ea:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
340060ee:	e7f6      	b.n	340060de <HAL_PWREx_ConfigVddIORange+0x1a>

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
340060f0:	4a0b      	ldr	r2, [pc, #44]	@ (34006120 <HAL_PWREx_ConfigVddIORange+0x5c>)
340060f2:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
340060f4:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
340060f8:	ea43 6381 	orr.w	r3, r3, r1, lsl #26
340060fc:	e7ef      	b.n	340060de <HAL_PWREx_ConfigVddIORange+0x1a>
      break;

    case PWR_VDDIO4:
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
340060fe:	4a08      	ldr	r2, [pc, #32]	@ (34006120 <HAL_PWREx_ConfigVddIORange+0x5c>)
34006100:	6b53      	ldr	r3, [r2, #52]	@ 0x34
34006102:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34006106:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
3400610a:	6353      	str	r3, [r2, #52]	@ 0x34
      break;
3400610c:	4770      	bx	lr

    case PWR_VDDIO5:
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
3400610e:	4a04      	ldr	r2, [pc, #16]	@ (34006120 <HAL_PWREx_ConfigVddIORange+0x5c>)
34006110:	6b93      	ldr	r3, [r2, #56]	@ 0x38
34006112:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34006116:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
3400611a:	6393      	str	r3, [r2, #56]	@ 0x38
      break;

    default:
      break;
  }
}
3400611c:	4770      	bx	lr
3400611e:	bf00      	nop
34006120:	56024800 	.word	0x56024800

34006124 <HAL_PWREx_EnableVddIO2>:
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34006124:	4a02      	ldr	r2, [pc, #8]	@ (34006130 <HAL_PWREx_EnableVddIO2+0xc>)
34006126:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34006128:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400612c:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400612e:	4770      	bx	lr
34006130:	56024800 	.word	0x56024800

34006134 <HAL_PWREx_EnableVddIO3>:
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34006134:	4a02      	ldr	r2, [pc, #8]	@ (34006140 <HAL_PWREx_EnableVddIO3+0xc>)
34006136:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34006138:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
3400613c:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400613e:	4770      	bx	lr
34006140:	56024800 	.word	0x56024800

34006144 <HAL_PWREx_EnableVddIO4>:
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
34006144:	4a02      	ldr	r2, [pc, #8]	@ (34006150 <HAL_PWREx_EnableVddIO4+0xc>)
34006146:	6b53      	ldr	r3, [r2, #52]	@ 0x34
34006148:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400614c:	6353      	str	r3, [r2, #52]	@ 0x34
}
3400614e:	4770      	bx	lr
34006150:	56024800 	.word	0x56024800

34006154 <HAL_RAMCFG_Init>:
  *                   the configuration information for the specified RAMCFG
  *                   instance.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_RAMCFG_Init(RAMCFG_HandleTypeDef *hramcfg)
{
34006154:	b510      	push	{r4, lr}
  /* Check the RAMCFG peripheral handle */
  if (hramcfg == NULL)
34006156:	4604      	mov	r4, r0
34006158:	b1b8      	cbz	r0, 3400618a <HAL_RAMCFG_Init+0x36>

  /* Check the parameters */
  assert_param(IS_RAMCFG_ALL_INSTANCE(hramcfg->Instance));

  /* Update RAMCFG peripheral state */
  hramcfg->State = HAL_RAMCFG_STATE_BUSY;
3400615a:	2302      	movs	r3, #2
3400615c:	7103      	strb	r3, [r0, #4]
  }

  /* Init the low level hardware */
  hramcfg->MspInitCallback(hramcfg);
#else
  HAL_RAMCFG_MspInit(hramcfg);
3400615e:	f7fc fb0d 	bl	3400277c <HAL_RAMCFG_MspInit>
#endif /* USE_HAL_RAMCFG_REGISTER_CALLBACKS */

  /* Disable the ECC Address latch */
  hramcfg->Instance->CR &= ~(RAMCFG_CR_ALE);
34006162:	6823      	ldr	r3, [r4, #0]

  /* Clear RAMCFG monitor flags */
  __HAL_RAMCFG_CLEAR_FLAG(hramcfg, RAMCFG_FLAGS_ALL);

  /* Initialize the RAMCFG error code */
  hramcfg->ErrorCode = HAL_RAMCFG_ERROR_NONE;
34006164:	2000      	movs	r0, #0
  hramcfg->Instance->CR &= ~(RAMCFG_CR_ALE);
34006166:	681a      	ldr	r2, [r3, #0]
34006168:	f022 0210 	bic.w	r2, r2, #16
3400616c:	601a      	str	r2, [r3, #0]
  __HAL_RAMCFG_DISABLE_IT(hramcfg, RAMCFG_IT_ALL);
3400616e:	685a      	ldr	r2, [r3, #4]
34006170:	f022 0203 	bic.w	r2, r2, #3
34006174:	605a      	str	r2, [r3, #4]
  __HAL_RAMCFG_CLEAR_FLAG(hramcfg, RAMCFG_FLAGS_ALL);
34006176:	695a      	ldr	r2, [r3, #20]
34006178:	f442 7281 	orr.w	r2, r2, #258	@ 0x102
3400617c:	f042 0201 	orr.w	r2, r2, #1
34006180:	615a      	str	r2, [r3, #20]

  /* Initialize the RAMCFG state */
  hramcfg->State = HAL_RAMCFG_STATE_READY;
34006182:	2301      	movs	r3, #1
  hramcfg->ErrorCode = HAL_RAMCFG_ERROR_NONE;
34006184:	60a0      	str	r0, [r4, #8]
  hramcfg->State = HAL_RAMCFG_STATE_READY;
34006186:	7123      	strb	r3, [r4, #4]

  return HAL_OK;
}
34006188:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
3400618a:	2001      	movs	r0, #1
3400618c:	e7fc      	b.n	34006188 <HAL_RAMCFG_Init+0x34>
	...

34006190 <RCC_GetSysClockFreq>:
  * @param  icx_divider The intermediate clock divider
  *
  * @retval SYSCLK frequency
  */
static uint32_t RCC_GetSysClockFreq(uint32_t icx_source, uint32_t icx_divider)
{
34006190:	b510      	push	{r4, lr}
34006192:	460c      	mov	r4, r1
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
34006194:	4919      	ldr	r1, [pc, #100]	@ (340061fc <RCC_GetSysClockFreq+0x6c>)
34006196:	6a0a      	ldr	r2, [r1, #32]
34006198:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
  uint32_t frequency = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
3400619c:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
340061a0:	d02a      	beq.n	340061f8 <RCC_GetSysClockFreq+0x68>
340061a2:	d806      	bhi.n	340061b2 <RCC_GetSysClockFreq+0x22>
340061a4:	b952      	cbnz	r2, 340061bc <RCC_GetSysClockFreq+0x2c>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
340061a6:	6c8b      	ldr	r3, [r1, #72]	@ 0x48
  {
    /* No check on Ready: Won't be selected by hardware if not */
    case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340061a8:	4815      	ldr	r0, [pc, #84]	@ (34006200 <RCC_GetSysClockFreq+0x70>)
340061aa:	f3c3 13c1 	ubfx	r3, r3, #7, #2
340061ae:	40d8      	lsrs	r0, r3
      /* Unexpected case */
      break;
  }

  return frequency;
}
340061b0:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSysClkSource())
340061b2:	f1b2 5f40 	cmp.w	r2, #805306368	@ 0x30000000
340061b6:	d009      	beq.n	340061cc <RCC_GetSysClockFreq+0x3c>
      switch (icx_source)
340061b8:	2000      	movs	r0, #0
340061ba:	e7f9      	b.n	340061b0 <RCC_GetSysClockFreq+0x20>
      frequency = RCC_GET_MSI_FREQUENCY();
340061bc:	6c4b      	ldr	r3, [r1, #68]	@ 0x44
340061be:	4811      	ldr	r0, [pc, #68]	@ (34006204 <RCC_GetSysClockFreq+0x74>)
340061c0:	f413 7f00 	tst.w	r3, #512	@ 0x200
340061c4:	4b10      	ldr	r3, [pc, #64]	@ (34006208 <RCC_GetSysClockFreq+0x78>)
340061c6:	bf18      	it	ne
340061c8:	4618      	movne	r0, r3
340061ca:	e7f1      	b.n	340061b0 <RCC_GetSysClockFreq+0x20>
      switch (icx_source)
340061cc:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
340061d0:	d00f      	beq.n	340061f2 <RCC_GetSysClockFreq+0x62>
340061d2:	d805      	bhi.n	340061e0 <RCC_GetSysClockFreq+0x50>
340061d4:	b950      	cbnz	r0, 340061ec <RCC_GetSysClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
340061d6:	f001 fdb3 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
          frequency = frequency / icx_divider;
340061da:	fbb0 f0f4 	udiv	r0, r0, r4
          break;
340061de:	e7e7      	b.n	340061b0 <RCC_GetSysClockFreq+0x20>
      switch (icx_source)
340061e0:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
340061e4:	d1e8      	bne.n	340061b8 <RCC_GetSysClockFreq+0x28>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
340061e6:	f001 fe6b 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
340061ea:	e7f6      	b.n	340061da <RCC_GetSysClockFreq+0x4a>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
340061ec:	f001 fde8 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
340061f0:	e7f3      	b.n	340061da <RCC_GetSysClockFreq+0x4a>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
340061f2:	f001 fe25 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
340061f6:	e7f0      	b.n	340061da <RCC_GetSysClockFreq+0x4a>
  switch (LL_RCC_GetSysClkSource())
340061f8:	4804      	ldr	r0, [pc, #16]	@ (3400620c <RCC_GetSysClockFreq+0x7c>)
340061fa:	e7d9      	b.n	340061b0 <RCC_GetSysClockFreq+0x20>
340061fc:	56028000 	.word	0x56028000
34006200:	03d09000 	.word	0x03d09000
34006204:	003d0900 	.word	0x003d0900
34006208:	00f42400 	.word	0x00f42400
3400620c:	02dc6c00 	.word	0x02dc6c00

34006210 <HAL_RCC_GetSysClockFreq>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34006210:	4b05      	ldr	r3, [pc, #20]	@ (34006228 <HAL_RCC_GetSysClockFreq+0x18>)
34006212:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  * @rmtoll IC2CFGR      IC2INT        LL_RCC_IC2_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetDivider(void)
{
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
34006216:	f8d3 10c8 	ldr.w	r1, [r3, #200]	@ 0xc8
  return RCC_GetSysClockFreq(LL_RCC_IC2_GetSource(), LL_RCC_IC2_GetDivider());
3400621a:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400621e:	f3c1 4107 	ubfx	r1, r1, #16, #8
34006222:	3101      	adds	r1, #1
34006224:	f7ff bfb4 	b.w	34006190 <RCC_GetSysClockFreq>
34006228:	56028000 	.word	0x56028000

3400622c <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400622c:	4a02      	ldr	r2, [pc, #8]	@ (34006238 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0xc>)
3400622e:	6d53      	ldr	r3, [r2, #84]	@ 0x54
34006230:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34006234:	6553      	str	r3, [r2, #84]	@ 0x54
}
34006236:	4770      	bx	lr
34006238:	56028000 	.word	0x56028000

3400623c <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400623c:	4a02      	ldr	r2, [pc, #8]	@ (34006248 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0xc>)
3400623e:	6d53      	ldr	r3, [r2, #84]	@ 0x54
34006240:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34006244:	6553      	str	r3, [r2, #84]	@ 0x54
}
34006246:	4770      	bx	lr
34006248:	56028000 	.word	0x56028000

3400624c <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3400624c:	4b02      	ldr	r3, [pc, #8]	@ (34006258 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0xc>)
3400624e:	6d58      	ldr	r0, [r3, #84]	@ 0x54
}
34006250:	f3c0 1080 	ubfx	r0, r0, #6, #1
34006254:	4770      	bx	lr
34006256:	bf00      	nop
34006258:	56028000 	.word	0x56028000

3400625c <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400625c:	4b02      	ldr	r3, [pc, #8]	@ (34006268 <LL_RCC_HSE_IsReady+0xc>)
3400625e:	6858      	ldr	r0, [r3, #4]
}
34006260:	f3c0 1000 	ubfx	r0, r0, #4, #1
34006264:	4770      	bx	lr
34006266:	bf00      	nop
34006268:	56028000 	.word	0x56028000

3400626c <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3400626c:	4b02      	ldr	r3, [pc, #8]	@ (34006278 <LL_RCC_HSI_IsReady+0xc>)
3400626e:	6858      	ldr	r0, [r3, #4]
}
34006270:	f3c0 00c0 	ubfx	r0, r0, #3, #1
34006274:	4770      	bx	lr
34006276:	bf00      	nop
34006278:	56028000 	.word	0x56028000

3400627c <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3400627c:	4b02      	ldr	r3, [pc, #8]	@ (34006288 <LL_RCC_MSI_IsReady+0xc>)
3400627e:	6858      	ldr	r0, [r3, #4]
}
34006280:	f3c0 0080 	ubfx	r0, r0, #2, #1
34006284:	4770      	bx	lr
34006286:	bf00      	nop
34006288:	56028000 	.word	0x56028000

3400628c <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3400628c:	4b02      	ldr	r3, [pc, #8]	@ (34006298 <LL_RCC_LSE_IsReady+0xc>)
3400628e:	6858      	ldr	r0, [r3, #4]
}
34006290:	f3c0 0040 	ubfx	r0, r0, #1, #1
34006294:	4770      	bx	lr
34006296:	bf00      	nop
34006298:	56028000 	.word	0x56028000

3400629c <LL_RCC_SetClockSource>:
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3400629c:	4907      	ldr	r1, [pc, #28]	@ (340062bc <LL_RCC_SetClockSource+0x20>)
{
3400629e:	b530      	push	{r4, r5, lr}
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
340062a0:	b2c4      	uxtb	r4, r0
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
340062a2:	f3c0 2504 	ubfx	r5, r0, #8, #5
340062a6:	5863      	ldr	r3, [r4, r1]
340062a8:	0e02      	lsrs	r2, r0, #24
340062aa:	40aa      	lsls	r2, r5
340062ac:	f3c0 4007 	ubfx	r0, r0, #16, #8
340062b0:	ea23 0302 	bic.w	r3, r3, r2
340062b4:	40a8      	lsls	r0, r5
340062b6:	4303      	orrs	r3, r0
340062b8:	5063      	str	r3, [r4, r1]
}
340062ba:	bd30      	pop	{r4, r5, pc}
340062bc:	56028144 	.word	0x56028144

340062c0 <LL_RCC_GetClockSource>:
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
340062c0:	4b05      	ldr	r3, [pc, #20]	@ (340062d8 <LL_RCC_GetClockSource+0x18>)
340062c2:	b2c2      	uxtb	r2, r0
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
340062c4:	58d1      	ldr	r1, [r2, r3]
340062c6:	f3c0 2204 	ubfx	r2, r0, #8, #5
340062ca:	0e03      	lsrs	r3, r0, #24
340062cc:	4093      	lsls	r3, r2
340062ce:	400b      	ands	r3, r1
340062d0:	40d3      	lsrs	r3, r2
}
340062d2:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
340062d6:	4770      	bx	lr
340062d8:	56028144 	.word	0x56028144

340062dc <LL_RCC_IC7_IsEnabled>:
  * @rmtoll DIVENR       IC7EN         LL_RCC_IC7_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC7_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
340062dc:	4b02      	ldr	r3, [pc, #8]	@ (340062e8 <LL_RCC_IC7_IsEnabled+0xc>)
340062de:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
340062e2:	f3c0 1080 	ubfx	r0, r0, #6, #1
340062e6:	4770      	bx	lr
340062e8:	56028000 	.word	0x56028000

340062ec <LL_RCC_IC7_GetDivider>:
  * @rmtoll IC7CFGR      IC7INT        LL_RCC_IC7_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC7_GetDivider(void)
{
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
340062ec:	4b03      	ldr	r3, [pc, #12]	@ (340062fc <LL_RCC_IC7_GetDivider+0x10>)
340062ee:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
340062f2:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
340062f6:	3001      	adds	r0, #1
340062f8:	4770      	bx	lr
340062fa:	bf00      	nop
340062fc:	56028000 	.word	0x56028000

34006300 <LL_RCC_IC8_IsEnabled>:
  * @rmtoll DIVENR       IC8EN         LL_RCC_IC8_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC8_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
34006300:	4b02      	ldr	r3, [pc, #8]	@ (3400630c <LL_RCC_IC8_IsEnabled+0xc>)
34006302:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
34006306:	f3c0 10c0 	ubfx	r0, r0, #7, #1
3400630a:	4770      	bx	lr
3400630c:	56028000 	.word	0x56028000

34006310 <LL_RCC_IC8_GetDivider>:
  * @rmtoll IC8CFGR      IC8INT        LL_RCC_IC8_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC8_GetDivider(void)
{
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
34006310:	4b03      	ldr	r3, [pc, #12]	@ (34006320 <LL_RCC_IC8_GetDivider+0x10>)
34006312:	f8d3 00e0 	ldr.w	r0, [r3, #224]	@ 0xe0
34006316:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400631a:	3001      	adds	r0, #1
3400631c:	4770      	bx	lr
3400631e:	bf00      	nop
34006320:	56028000 	.word	0x56028000

34006324 <LL_RCC_IC9_IsEnabled>:
  * @rmtoll DIVENR       IC9EN         LL_RCC_IC9_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC9_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
34006324:	4b02      	ldr	r3, [pc, #8]	@ (34006330 <LL_RCC_IC9_IsEnabled+0xc>)
34006326:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400632a:	f3c0 2000 	ubfx	r0, r0, #8, #1
3400632e:	4770      	bx	lr
34006330:	56028000 	.word	0x56028000

34006334 <LL_RCC_IC9_GetDivider>:
  * @rmtoll IC9CFGR      IC9INT        LL_RCC_IC9_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC9_GetDivider(void)
{
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
34006334:	4b03      	ldr	r3, [pc, #12]	@ (34006344 <LL_RCC_IC9_GetDivider+0x10>)
34006336:	f8d3 00e4 	ldr.w	r0, [r3, #228]	@ 0xe4
3400633a:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400633e:	3001      	adds	r0, #1
34006340:	4770      	bx	lr
34006342:	bf00      	nop
34006344:	56028000 	.word	0x56028000

34006348 <LL_RCC_IC14_IsEnabled>:
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
34006348:	4b02      	ldr	r3, [pc, #8]	@ (34006354 <LL_RCC_IC14_IsEnabled+0xc>)
3400634a:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400634e:	f3c0 3040 	ubfx	r0, r0, #13, #1
34006352:	4770      	bx	lr
34006354:	56028000 	.word	0x56028000

34006358 <LL_RCC_IC14_GetDivider>:
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
34006358:	4b03      	ldr	r3, [pc, #12]	@ (34006368 <LL_RCC_IC14_GetDivider+0x10>)
3400635a:	f8d3 00f8 	ldr.w	r0, [r3, #248]	@ 0xf8
3400635e:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
34006362:	3001      	adds	r0, #1
34006364:	4770      	bx	lr
34006366:	bf00      	nop
34006368:	56028000 	.word	0x56028000

3400636c <LL_RCC_IC15_IsEnabled>:
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
3400636c:	4b02      	ldr	r3, [pc, #8]	@ (34006378 <LL_RCC_IC15_IsEnabled+0xc>)
3400636e:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
34006372:	f3c0 3080 	ubfx	r0, r0, #14, #1
34006376:	4770      	bx	lr
34006378:	56028000 	.word	0x56028000

3400637c <LL_RCC_IC15_GetDivider>:
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
3400637c:	4b03      	ldr	r3, [pc, #12]	@ (3400638c <LL_RCC_IC15_GetDivider+0x10>)
3400637e:	f8d3 00fc 	ldr.w	r0, [r3, #252]	@ 0xfc
34006382:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
34006386:	3001      	adds	r0, #1
34006388:	4770      	bx	lr
3400638a:	bf00      	nop
3400638c:	56028000 	.word	0x56028000

34006390 <RCCEx_GetHCLKFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
34006390:	4b02      	ldr	r3, [pc, #8]	@ (3400639c <RCCEx_GetHCLKFreq+0xc>)
34006392:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
34006394:	f3c3 5302 	ubfx	r3, r3, #20, #3
}
34006398:	40d8      	lsrs	r0, r3
3400639a:	4770      	bx	lr
3400639c:	56028000 	.word	0x56028000

340063a0 <RCCEx_GetPLLSourceFreq>:
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;

  switch (PLLsource)
340063a0:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
{
340063a4:	b508      	push	{r3, lr}
  switch (PLLsource)
340063a6:	d01d      	beq.n	340063e4 <RCCEx_GetPLLSourceFreq+0x44>
340063a8:	d80a      	bhi.n	340063c0 <RCCEx_GetPLLSourceFreq+0x20>
340063aa:	b970      	cbnz	r0, 340063ca <RCCEx_GetPLLSourceFreq+0x2a>
  {
    case LL_RCC_PLLSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340063ac:	f7ff ff5e 	bl	3400626c <LL_RCC_HSI_IsReady>
340063b0:	b148      	cbz	r0, 340063c6 <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
340063b2:	4b10      	ldr	r3, [pc, #64]	@ (340063f4 <RCCEx_GetPLLSourceFreq+0x54>)
      {
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340063b4:	4810      	ldr	r0, [pc, #64]	@ (340063f8 <RCCEx_GetPLLSourceFreq+0x58>)
340063b6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340063b8:	f3c3 13c1 	ubfx	r3, r3, #7, #2
340063bc:	40d8      	lsrs	r0, r3
340063be:	e003      	b.n	340063c8 <RCCEx_GetPLLSourceFreq+0x28>
  switch (PLLsource)
340063c0:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
340063c4:	d014      	beq.n	340063f0 <RCCEx_GetPLLSourceFreq+0x50>
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
340063c6:	2000      	movs	r0, #0
      /* unexpected case */
      break;
  }

  return pllinputfreq;
}
340063c8:	bd08      	pop	{r3, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
340063ca:	f7ff ff57 	bl	3400627c <LL_RCC_MSI_IsReady>
340063ce:	2800      	cmp	r0, #0
340063d0:	d0f9      	beq.n	340063c6 <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
340063d2:	4b08      	ldr	r3, [pc, #32]	@ (340063f4 <RCCEx_GetPLLSourceFreq+0x54>)
          pllinputfreq = MSI_VALUE;
340063d4:	4809      	ldr	r0, [pc, #36]	@ (340063fc <RCCEx_GetPLLSourceFreq+0x5c>)
340063d6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340063d8:	f413 7f00 	tst.w	r3, #512	@ 0x200
340063dc:	4b08      	ldr	r3, [pc, #32]	@ (34006400 <RCCEx_GetPLLSourceFreq+0x60>)
340063de:	bf08      	it	eq
340063e0:	4618      	moveq	r0, r3
340063e2:	e7f1      	b.n	340063c8 <RCCEx_GetPLLSourceFreq+0x28>
      if (LL_RCC_HSE_IsReady() != 0U)
340063e4:	f7ff ff3a 	bl	3400625c <LL_RCC_HSE_IsReady>
340063e8:	2800      	cmp	r0, #0
340063ea:	d0ec      	beq.n	340063c6 <RCCEx_GetPLLSourceFreq+0x26>
        pllinputfreq = HSE_VALUE;
340063ec:	4805      	ldr	r0, [pc, #20]	@ (34006404 <RCCEx_GetPLLSourceFreq+0x64>)
340063ee:	e7eb      	b.n	340063c8 <RCCEx_GetPLLSourceFreq+0x28>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
340063f0:	4805      	ldr	r0, [pc, #20]	@ (34006408 <RCCEx_GetPLLSourceFreq+0x68>)
340063f2:	e7e9      	b.n	340063c8 <RCCEx_GetPLLSourceFreq+0x28>
340063f4:	56028000 	.word	0x56028000
340063f8:	03d09000 	.word	0x03d09000
340063fc:	00f42400 	.word	0x00f42400
34006400:	003d0900 	.word	0x003d0900
34006404:	02dc6c00 	.word	0x02dc6c00
34006408:	00bb8000 	.word	0x00bb8000

3400640c <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
3400640c:	ee07 2a10 	vmov	s14, r2
34006410:	ee06 3a10 	vmov	s12, r3
34006414:	ee07 0a90 	vmov	s15, r0
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
34006418:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
3400641c:	eddf 5a10 	vldr	s11, [pc, #64]	@ 34006460 <RCCEx_CalcPLLFreq+0x54>
34006420:	eeb8 7a47 	vcvt.f32.u32	s14, s14
{
34006424:	ee06 1a90 	vmov	s13, r1
  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
34006428:	eea6 7a25 	vfma.f32	s14, s12, s11
3400642c:	eef8 7a67 	vcvt.f32.u32	s15, s15
34006430:	ee67 7a87 	vmul.f32	s15, s15, s14
34006434:	eeb8 7a66 	vcvt.f32.u32	s14, s13
34006438:	ee87 6a87 	vdiv.f32	s12, s15, s14

  freq = freq / (float_t)P1;
3400643c:	eddd 7a00 	vldr	s15, [sp]
34006440:	eef8 7a67 	vcvt.f32.u32	s15, s15
34006444:	eec6 6a27 	vdiv.f32	s13, s12, s15
  freq = freq / (float_t)P2;
34006448:	eddd 7a01 	vldr	s15, [sp, #4]
3400644c:	eef8 7a67 	vcvt.f32.u32	s15, s15
34006450:	ee86 7aa7 	vdiv.f32	s14, s13, s15

  return (uint32_t)freq;
}
34006454:	eefc 7ac7 	vcvt.u32.f32	s15, s14
34006458:	ee17 0a90 	vmov	r0, s15
3400645c:	4770      	bx	lr
3400645e:	bf00      	nop
34006460:	33800000 	.word	0x33800000

34006464 <HAL_RCCEx_PeriphCLKConfig>:
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
34006464:	6803      	ldr	r3, [r0, #0]
{
34006466:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3400646a:	0119      	lsls	r1, r3, #4
{
3400646c:	4604      	mov	r4, r0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3400646e:	d52b      	bpl.n	340064c8 <HAL_RCCEx_PeriphCLKConfig+0x64>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
34006470:	4b2a      	ldr	r3, [pc, #168]	@ (3400651c <HAL_RCCEx_PeriphCLKConfig+0xb8>)
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
34006472:	f8d0 1188 	ldr.w	r1, [r0, #392]	@ 0x188
34006476:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400647a:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
3400647e:	d136      	bne.n	340064ee <HAL_RCCEx_PeriphCLKConfig+0x8a>
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
34006480:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
34006484:	d108      	bne.n	34006498 <HAL_RCCEx_PeriphCLKConfig+0x34>
        tickstart = HAL_GetTick();
34006486:	f7fd f90f 	bl	340036a8 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400648a:	f241 3688 	movw	r6, #5000	@ 0x1388
        tickstart = HAL_GetTick();
3400648e:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() == 0U)
34006490:	f7ff fefc 	bl	3400628c <LL_RCC_LSE_IsReady>
34006494:	2800      	cmp	r0, #0
34006496:	d039      	beq.n	3400650c <HAL_RCCEx_PeriphCLKConfig+0xa8>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
34006498:	f8d4 3188 	ldr.w	r3, [r4, #392]	@ 0x188
3400649c:	4a1f      	ldr	r2, [pc, #124]	@ (3400651c <HAL_RCCEx_PeriphCLKConfig+0xb8>)
3400649e:	f403 7040 	and.w	r0, r3, #768	@ 0x300
340064a2:	f5b0 7f40 	cmp.w	r0, #768	@ 0x300
340064a6:	d108      	bne.n	340064ba <HAL_RCCEx_PeriphCLKConfig+0x56>
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
340064a8:	f8d2 115c 	ldr.w	r1, [r2, #348]	@ 0x15c
340064ac:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
340064b0:	f421 317c 	bic.w	r1, r1, #258048	@ 0x3f000
340064b4:	430b      	orrs	r3, r1
340064b6:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
340064ba:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
340064be:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
340064c2:	4303      	orrs	r3, r0
340064c4:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
340064c8:	f04f 0800 	mov.w	r8, #0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
340064cc:	e9d4 5600 	ldrd	r5, r6, [r4]
340064d0:	076b      	lsls	r3, r5, #29
340064d2:	d540      	bpl.n	34006556 <HAL_RCCEx_PeriphCLKConfig+0xf2>
    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
340064d4:	f8d4 10b8 	ldr.w	r1, [r4, #184]	@ 0xb8
340064d8:	4b10      	ldr	r3, [pc, #64]	@ (3400651c <HAL_RCCEx_PeriphCLKConfig+0xb8>)
340064da:	1eca      	subs	r2, r1, #3
340064dc:	2a04      	cmp	r2, #4
340064de:	d832      	bhi.n	34006546 <HAL_RCCEx_PeriphCLKConfig+0xe2>
340064e0:	e8df f012 	tbh	[pc, r2, lsl #1]
340064e4:	002006cc 	.word	0x002006cc
340064e8:	06ba06a8 	.word	0x06ba06a8
340064ec:	06f6      	.short	0x06f6
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
340064ee:	f401 7240 	and.w	r2, r1, #768	@ 0x300
340064f2:	429a      	cmp	r2, r3
340064f4:	d0c4      	beq.n	34006480 <HAL_RCCEx_PeriphCLKConfig+0x1c>
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
340064f6:	4b0a      	ldr	r3, [pc, #40]	@ (34006520 <HAL_RCCEx_PeriphCLKConfig+0xbc>)
340064f8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340064fa:	f042 0201 	orr.w	r2, r2, #1
340064fe:	62da      	str	r2, [r3, #44]	@ 0x2c
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
34006500:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34006502:	07da      	lsls	r2, r3, #31
34006504:	d4bc      	bmi.n	34006480 <HAL_RCCEx_PeriphCLKConfig+0x1c>
      status = ret;
34006506:	f04f 0801 	mov.w	r8, #1
3400650a:	e7df      	b.n	340064cc <HAL_RCCEx_PeriphCLKConfig+0x68>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400650c:	f7fd f8cc 	bl	340036a8 <HAL_GetTick>
34006510:	1b40      	subs	r0, r0, r5
34006512:	42b0      	cmp	r0, r6
34006514:	d9bc      	bls.n	34006490 <HAL_RCCEx_PeriphCLKConfig+0x2c>
        status = ret;
34006516:	f04f 0803 	mov.w	r8, #3
3400651a:	e7d7      	b.n	340064cc <HAL_RCCEx_PeriphCLKConfig+0x68>
3400651c:	56028000 	.word	0x56028000
34006520:	56024800 	.word	0x56024800
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34006524:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
34006528:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
3400652a:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
3400652c:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
34006530:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
34006534:	3801      	subs	r0, #1
34006536:	433a      	orrs	r2, r7
34006538:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3400653c:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
34006540:	2210      	movs	r2, #16
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
34006542:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
34006546:	4ac5      	ldr	r2, [pc, #788]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006548:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400654c:	f023 0307 	bic.w	r3, r3, #7
34006550:	430b      	orrs	r3, r1
34006552:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
34006556:	0277      	lsls	r7, r6, #9
34006558:	d519      	bpl.n	3400658e <HAL_RCCEx_PeriphCLKConfig+0x12a>
    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3400655a:	f8d4 00ac 	ldr.w	r0, [r4, #172]	@ 0xac
3400655e:	4bc0      	ldr	r3, [pc, #768]	@ (34006860 <HAL_RCCEx_PeriphCLKConfig+0x3fc>)
34006560:	4298      	cmp	r0, r3
34006562:	f040 86c9 	bne.w	340072f8 <HAL_RCCEx_PeriphCLKConfig+0xe94>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34006566:	4abd      	ldr	r2, [pc, #756]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006568:	69e1      	ldr	r1, [r4, #28]
3400656a:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400656e:	69a7      	ldr	r7, [r4, #24]
34006570:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006574:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006578:	3901      	subs	r1, #1
3400657a:	433b      	orrs	r3, r7
3400657c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006580:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
34006584:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
34006586:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400658a:	f7ff fe87 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3400658e:	0230      	lsls	r0, r6, #8
34006590:	d519      	bpl.n	340065c6 <HAL_RCCEx_PeriphCLKConfig+0x162>
    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
34006592:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
34006596:	4bb3      	ldr	r3, [pc, #716]	@ (34006864 <HAL_RCCEx_PeriphCLKConfig+0x400>)
34006598:	4298      	cmp	r0, r3
3400659a:	f040 86cb 	bne.w	34007334 <HAL_RCCEx_PeriphCLKConfig+0xed0>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400659e:	4aaf      	ldr	r2, [pc, #700]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
340065a0:	69e1      	ldr	r1, [r4, #28]
340065a2:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
340065a6:	69a7      	ldr	r7, [r4, #24]
340065a8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340065ac:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340065b0:	3901      	subs	r1, #1
340065b2:	433b      	orrs	r3, r7
340065b4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340065b8:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
340065bc:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
340065be:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
340065c2:	f7ff fe6b 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
340065c6:	01f1      	lsls	r1, r6, #7
340065c8:	d519      	bpl.n	340065fe <HAL_RCCEx_PeriphCLKConfig+0x19a>
    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
340065ca:	f8d4 00b4 	ldr.w	r0, [r4, #180]	@ 0xb4
340065ce:	4ba6      	ldr	r3, [pc, #664]	@ (34006868 <HAL_RCCEx_PeriphCLKConfig+0x404>)
340065d0:	4298      	cmp	r0, r3
340065d2:	f040 86cd 	bne.w	34007370 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
340065d6:	4aa1      	ldr	r2, [pc, #644]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
340065d8:	69e1      	ldr	r1, [r4, #28]
340065da:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
340065de:	69a7      	ldr	r7, [r4, #24]
340065e0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340065e4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340065e8:	3901      	subs	r1, #1
340065ea:	433b      	orrs	r3, r7
340065ec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340065f0:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
340065f4:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
340065f6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
340065fa:	f7ff fe4f 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
340065fe:	052a      	lsls	r2, r5, #20
34006600:	d51e      	bpl.n	34006640 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
34006602:	f8d4 10a8 	ldr.w	r1, [r4, #168]	@ 0xa8
34006606:	4a95      	ldr	r2, [pc, #596]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006608:	2920      	cmp	r1, #32
3400660a:	f040 86cf 	bne.w	340073ac <HAL_RCCEx_PeriphCLKConfig+0xf48>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400660e:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
34006612:	69e0      	ldr	r0, [r4, #28]
34006614:	69a7      	ldr	r7, [r4, #24]
34006616:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400661a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400661e:	3801      	subs	r0, #1
34006620:	433b      	orrs	r3, r7
34006622:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006626:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400662a:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400662c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
34006630:	4a8a      	ldr	r2, [pc, #552]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006632:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
34006636:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
3400663a:	430b      	orrs	r3, r1
3400663c:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
34006640:	006b      	lsls	r3, r5, #1
34006642:	d519      	bpl.n	34006678 <HAL_RCCEx_PeriphCLKConfig+0x214>
    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
34006644:	f8d4 012c 	ldr.w	r0, [r4, #300]	@ 0x12c
34006648:	4b88      	ldr	r3, [pc, #544]	@ (3400686c <HAL_RCCEx_PeriphCLKConfig+0x408>)
3400664a:	4298      	cmp	r0, r3
3400664c:	f040 86c8 	bne.w	340073e0 <HAL_RCCEx_PeriphCLKConfig+0xf7c>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34006650:	4a82      	ldr	r2, [pc, #520]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006652:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34006654:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
34006658:	6a27      	ldr	r7, [r4, #32]
3400665a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400665e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006662:	3901      	subs	r1, #1
34006664:	433b      	orrs	r3, r7
34006666:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400666a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400666e:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
34006670:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006674:	f7ff fe12 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
34006678:	2d00      	cmp	r5, #0
3400667a:	da19      	bge.n	340066b0 <HAL_RCCEx_PeriphCLKConfig+0x24c>
    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
3400667c:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
34006680:	4b7b      	ldr	r3, [pc, #492]	@ (34006870 <HAL_RCCEx_PeriphCLKConfig+0x40c>)
34006682:	4298      	cmp	r0, r3
34006684:	f040 86ca 	bne.w	3400741c <HAL_RCCEx_PeriphCLKConfig+0xfb8>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34006688:	4a74      	ldr	r2, [pc, #464]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3400668a:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400668c:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
34006690:	6a27      	ldr	r7, [r4, #32]
34006692:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006696:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400669a:	3901      	subs	r1, #1
3400669c:	433b      	orrs	r3, r7
3400669e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340066a2:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
340066a6:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
340066a8:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
340066ac:	f7ff fdf6 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
340066b0:	07ef      	lsls	r7, r5, #31
340066b2:	d525      	bpl.n	34006700 <HAL_RCCEx_PeriphCLKConfig+0x29c>
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
340066b4:	f8d4 20bc 	ldr.w	r2, [r4, #188]	@ 0xbc
340066b8:	4968      	ldr	r1, [pc, #416]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
340066ba:	2a20      	cmp	r2, #32
340066bc:	f040 86cc 	bne.w	34007458 <HAL_RCCEx_PeriphCLKConfig+0xff4>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
340066c0:	f8d1 30dc 	ldr.w	r3, [r1, #220]	@ 0xdc
340066c4:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
340066c6:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
340066c8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340066cc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340066d0:	3801      	subs	r0, #1
340066d2:	433b      	orrs	r3, r7
340066d4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
340066d8:	f8c1 30dc 	str.w	r3, [r1, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
340066dc:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
340066de:	f8c1 3a40 	str.w	r3, [r1, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
340066e2:	485e      	ldr	r0, [pc, #376]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
340066e4:	f8d4 10c0 	ldr.w	r1, [r4, #192]	@ 0xc0
340066e8:	f8d0 3144 	ldr.w	r3, [r0, #324]	@ 0x144
340066ec:	3901      	subs	r1, #1
340066ee:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
340066f2:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
340066f6:	4313      	orrs	r3, r2
340066f8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
340066fc:	f8c0 3144 	str.w	r3, [r0, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
34006700:	07a8      	lsls	r0, r5, #30
34006702:	d51e      	bpl.n	34006742 <HAL_RCCEx_PeriphCLKConfig+0x2de>
    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
34006704:	f8d4 10c4 	ldr.w	r1, [r4, #196]	@ 0xc4
34006708:	4a54      	ldr	r2, [pc, #336]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3400670a:	2902      	cmp	r1, #2
3400670c:	f040 86be 	bne.w	3400748c <HAL_RCCEx_PeriphCLKConfig+0x1028>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34006710:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
34006714:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
34006716:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
34006718:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400671c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006720:	3801      	subs	r0, #1
34006722:	433b      	orrs	r3, r7
34006724:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006728:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400672c:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400672e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
34006732:	4a4a      	ldr	r2, [pc, #296]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006734:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
34006738:	f023 0307 	bic.w	r3, r3, #7
3400673c:	430b      	orrs	r3, r1
3400673e:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
34006742:	0729      	lsls	r1, r5, #28
34006744:	d514      	bpl.n	34006770 <HAL_RCCEx_PeriphCLKConfig+0x30c>
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
34006746:	4a45      	ldr	r2, [pc, #276]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006748:	f8d4 1094 	ldr.w	r1, [r4, #148]	@ 0x94
3400674c:	f8d2 3108 	ldr.w	r3, [r2, #264]	@ 0x108
34006750:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
34006754:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006758:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400675c:	3901      	subs	r1, #1
3400675e:	4303      	orrs	r3, r0
34006760:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006764:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
34006768:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
3400676c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
34006770:	06ea      	lsls	r2, r5, #27
34006772:	d522      	bpl.n	340067ba <HAL_RCCEx_PeriphCLKConfig+0x356>
    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
34006774:	f8d4 10c8 	ldr.w	r1, [r4, #200]	@ 0xc8
34006778:	4a38      	ldr	r2, [pc, #224]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3400677a:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
3400677e:	f040 869f 	bne.w	340074c0 <HAL_RCCEx_PeriphCLKConfig+0x105c>
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
34006782:	f8d2 3104 	ldr.w	r3, [r2, #260]	@ 0x104
34006786:	f8d4 008c 	ldr.w	r0, [r4, #140]	@ 0x8c
3400678a:	f8d4 7088 	ldr.w	r7, [r4, #136]	@ 0x88
3400678e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006792:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006796:	3801      	subs	r0, #1
34006798:	433b      	orrs	r3, r7
3400679a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400679e:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
340067a2:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
340067a6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
340067aa:	4a2c      	ldr	r2, [pc, #176]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
340067ac:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
340067b0:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
340067b4:	430b      	orrs	r3, r1
340067b6:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
340067ba:	06ab      	lsls	r3, r5, #26
340067bc:	d520      	bpl.n	34006800 <HAL_RCCEx_PeriphCLKConfig+0x39c>
    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
340067be:	f8d4 10cc 	ldr.w	r1, [r4, #204]	@ 0xcc
340067c2:	4a26      	ldr	r2, [pc, #152]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
340067c4:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
340067c8:	f040 8682 	bne.w	340074d0 <HAL_RCCEx_PeriphCLKConfig+0x106c>
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
340067cc:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
340067d0:	6e60      	ldr	r0, [r4, #100]	@ 0x64
340067d2:	6e27      	ldr	r7, [r4, #96]	@ 0x60
340067d4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340067d8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340067dc:	3801      	subs	r0, #1
340067de:	433b      	orrs	r3, r7
340067e0:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
340067e4:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
340067e8:	f44f 6300 	mov.w	r3, #2048	@ 0x800
340067ec:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
340067f0:	4a1a      	ldr	r2, [pc, #104]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
340067f2:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
340067f6:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
340067fa:	430b      	orrs	r3, r1
340067fc:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
34006800:	066f      	lsls	r7, r5, #25
34006802:	d509      	bpl.n	34006818 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
34006804:	4a15      	ldr	r2, [pc, #84]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006806:	f8d4 10d0 	ldr.w	r1, [r4, #208]	@ 0xd0
3400680a:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400680e:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
34006812:	430b      	orrs	r3, r1
34006814:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
34006818:	0628      	lsls	r0, r5, #24
3400681a:	d509      	bpl.n	34006830 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3400681c:	4a0f      	ldr	r2, [pc, #60]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3400681e:	f8d4 10d4 	ldr.w	r1, [r4, #212]	@ 0xd4
34006822:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
34006826:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3400682a:	430b      	orrs	r3, r1
3400682c:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
34006830:	05e9      	lsls	r1, r5, #23
34006832:	d509      	bpl.n	34006848 <HAL_RCCEx_PeriphCLKConfig+0x3e4>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
34006834:	4a09      	ldr	r2, [pc, #36]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006836:	f8d4 10d8 	ldr.w	r1, [r4, #216]	@ 0xd8
3400683a:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400683e:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34006842:	430b      	orrs	r3, r1
34006844:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
34006848:	05aa      	lsls	r2, r5, #22
3400684a:	d532      	bpl.n	340068b2 <HAL_RCCEx_PeriphCLKConfig+0x44e>
    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
3400684c:	f8d4 10dc 	ldr.w	r1, [r4, #220]	@ 0xdc
34006850:	4a02      	ldr	r2, [pc, #8]	@ (3400685c <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
34006852:	2902      	cmp	r1, #2
34006854:	f040 8644 	bne.w	340074e0 <HAL_RCCEx_PeriphCLKConfig+0x107c>
34006858:	e00c      	b.n	34006874 <HAL_RCCEx_PeriphCLKConfig+0x410>
3400685a:	bf00      	nop
3400685c:	56028000 	.word	0x56028000
34006860:	03020014 	.word	0x03020014
34006864:	03020414 	.word	0x03020414
34006868:	03020814 	.word	0x03020814
3400686c:	0302001c 	.word	0x0302001c
34006870:	0302041c 	.word	0x0302041c
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
34006874:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
34006878:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
3400687a:	6ea7      	ldr	r7, [r4, #104]	@ 0x68
3400687c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006880:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006884:	3801      	subs	r0, #1
34006886:	433b      	orrs	r3, r7
34006888:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400688c:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
34006890:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34006894:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
34006898:	48c9      	ldr	r0, [pc, #804]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3400689a:	f8d4 20e0 	ldr.w	r2, [r4, #224]	@ 0xe0
3400689e:	f8d0 3148 	ldr.w	r3, [r0, #328]	@ 0x148
340068a2:	3a01      	subs	r2, #1
340068a4:	f023 03f3 	bic.w	r3, r3, #243	@ 0xf3
340068a8:	430b      	orrs	r3, r1
340068aa:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
340068ae:	f8c0 3148 	str.w	r3, [r0, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
340068b2:	056b      	lsls	r3, r5, #21
340068b4:	d521      	bpl.n	340068fa <HAL_RCCEx_PeriphCLKConfig+0x496>
    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
340068b6:	f8d4 10e4 	ldr.w	r1, [r4, #228]	@ 0xe4
340068ba:	4ac1      	ldr	r2, [pc, #772]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
340068bc:	2902      	cmp	r1, #2
340068be:	f040 8616 	bne.w	340074ee <HAL_RCCEx_PeriphCLKConfig+0x108a>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
340068c2:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
340068c6:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
340068ca:	f8d4 7098 	ldr.w	r7, [r4, #152]	@ 0x98
340068ce:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340068d2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340068d6:	3801      	subs	r0, #1
340068d8:	433b      	orrs	r3, r7
340068da:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
340068de:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
340068e2:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
340068e6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
340068ea:	4ab5      	ldr	r2, [pc, #724]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
340068ec:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
340068f0:	f023 0303 	bic.w	r3, r3, #3
340068f4:	430b      	orrs	r3, r1
340068f6:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
340068fa:	04ef      	lsls	r7, r5, #19
340068fc:	d51a      	bpl.n	34006934 <HAL_RCCEx_PeriphCLKConfig+0x4d0>
    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
340068fe:	f8d4 00e8 	ldr.w	r0, [r4, #232]	@ 0xe8
34006902:	4bb0      	ldr	r3, [pc, #704]	@ (34006bc4 <HAL_RCCEx_PeriphCLKConfig+0x760>)
34006904:	4298      	cmp	r0, r3
34006906:	f040 85f9 	bne.w	340074fc <HAL_RCCEx_PeriphCLKConfig+0x1098>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400690a:	4aad      	ldr	r2, [pc, #692]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3400690c:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400690e:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
34006912:	6d27      	ldr	r7, [r4, #80]	@ 0x50
34006914:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006918:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400691c:	3901      	subs	r1, #1
3400691e:	433b      	orrs	r3, r7
34006920:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006924:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34006928:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400692c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006930:	f7ff fcb4 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
34006934:	04a8      	lsls	r0, r5, #18
34006936:	d51a      	bpl.n	3400696e <HAL_RCCEx_PeriphCLKConfig+0x50a>
    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
34006938:	f8d4 00ec 	ldr.w	r0, [r4, #236]	@ 0xec
3400693c:	4ba2      	ldr	r3, [pc, #648]	@ (34006bc8 <HAL_RCCEx_PeriphCLKConfig+0x764>)
3400693e:	4298      	cmp	r0, r3
34006940:	f040 85fb 	bne.w	3400753a <HAL_RCCEx_PeriphCLKConfig+0x10d6>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34006944:	4a9e      	ldr	r2, [pc, #632]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006946:	6d61      	ldr	r1, [r4, #84]	@ 0x54
34006948:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400694c:	6d27      	ldr	r7, [r4, #80]	@ 0x50
3400694e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006952:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006956:	3901      	subs	r1, #1
34006958:	433b      	orrs	r3, r7
3400695a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400695e:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34006962:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34006966:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400696a:	f7ff fc97 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3400696e:	0469      	lsls	r1, r5, #17
34006970:	d51a      	bpl.n	340069a8 <HAL_RCCEx_PeriphCLKConfig+0x544>
    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
34006972:	f8d4 00f0 	ldr.w	r0, [r4, #240]	@ 0xf0
34006976:	4b95      	ldr	r3, [pc, #596]	@ (34006bcc <HAL_RCCEx_PeriphCLKConfig+0x768>)
34006978:	4298      	cmp	r0, r3
3400697a:	f040 85fd 	bne.w	34007578 <HAL_RCCEx_PeriphCLKConfig+0x1114>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400697e:	4a90      	ldr	r2, [pc, #576]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006980:	6d61      	ldr	r1, [r4, #84]	@ 0x54
34006982:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
34006986:	6d27      	ldr	r7, [r4, #80]	@ 0x50
34006988:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400698c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006990:	3901      	subs	r1, #1
34006992:	433b      	orrs	r3, r7
34006994:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006998:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400699c:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
340069a0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
340069a4:	f7ff fc7a 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
340069a8:	042a      	lsls	r2, r5, #16
340069aa:	d51a      	bpl.n	340069e2 <HAL_RCCEx_PeriphCLKConfig+0x57e>
    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
340069ac:	f8d4 00f4 	ldr.w	r0, [r4, #244]	@ 0xf4
340069b0:	4b87      	ldr	r3, [pc, #540]	@ (34006bd0 <HAL_RCCEx_PeriphCLKConfig+0x76c>)
340069b2:	4298      	cmp	r0, r3
340069b4:	f040 85ff 	bne.w	340075b6 <HAL_RCCEx_PeriphCLKConfig+0x1152>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340069b8:	4a81      	ldr	r2, [pc, #516]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
340069ba:	6d61      	ldr	r1, [r4, #84]	@ 0x54
340069bc:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
340069c0:	6d27      	ldr	r7, [r4, #80]	@ 0x50
340069c2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340069c6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340069ca:	3901      	subs	r1, #1
340069cc:	433b      	orrs	r3, r7
340069ce:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340069d2:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
340069d6:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
340069da:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
340069de:	f7ff fc5d 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
340069e2:	03eb      	lsls	r3, r5, #15
340069e4:	d51a      	bpl.n	34006a1c <HAL_RCCEx_PeriphCLKConfig+0x5b8>
    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
340069e6:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
340069ea:	4b7a      	ldr	r3, [pc, #488]	@ (34006bd4 <HAL_RCCEx_PeriphCLKConfig+0x770>)
340069ec:	4298      	cmp	r0, r3
340069ee:	f040 8627 	bne.w	34007640 <HAL_RCCEx_PeriphCLKConfig+0x11dc>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340069f2:	4a73      	ldr	r2, [pc, #460]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
340069f4:	6d61      	ldr	r1, [r4, #84]	@ 0x54
340069f6:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
340069fa:	6d27      	ldr	r7, [r4, #80]	@ 0x50
340069fc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006a00:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006a04:	3901      	subs	r1, #1
34006a06:	433b      	orrs	r3, r7
34006a08:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006a0c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34006a10:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34006a14:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006a18:	f7ff fc40 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
34006a1c:	03af      	lsls	r7, r5, #14
34006a1e:	d51a      	bpl.n	34006a56 <HAL_RCCEx_PeriphCLKConfig+0x5f2>
    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
34006a20:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
34006a24:	4b6c      	ldr	r3, [pc, #432]	@ (34006bd8 <HAL_RCCEx_PeriphCLKConfig+0x774>)
34006a26:	4298      	cmp	r0, r3
34006a28:	f040 8629 	bne.w	3400767e <HAL_RCCEx_PeriphCLKConfig+0x121a>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34006a2c:	4a64      	ldr	r2, [pc, #400]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006a2e:	6d61      	ldr	r1, [r4, #84]	@ 0x54
34006a30:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
34006a34:	6d27      	ldr	r7, [r4, #80]	@ 0x50
34006a36:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006a3a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006a3e:	3901      	subs	r1, #1
34006a40:	433b      	orrs	r3, r7
34006a42:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006a46:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34006a4a:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34006a4e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006a52:	f7ff fc23 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
34006a56:	0368      	lsls	r0, r5, #13
34006a58:	d51a      	bpl.n	34006a90 <HAL_RCCEx_PeriphCLKConfig+0x62c>
    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
34006a5a:	f8d4 0100 	ldr.w	r0, [r4, #256]	@ 0x100
34006a5e:	4b5f      	ldr	r3, [pc, #380]	@ (34006bdc <HAL_RCCEx_PeriphCLKConfig+0x778>)
34006a60:	4298      	cmp	r0, r3
34006a62:	f040 862b 	bne.w	340076bc <HAL_RCCEx_PeriphCLKConfig+0x1258>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34006a66:	4a56      	ldr	r2, [pc, #344]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006a68:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
34006a6a:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
34006a6e:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
34006a70:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006a74:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006a78:	3901      	subs	r1, #1
34006a7a:	433b      	orrs	r3, r7
34006a7c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006a80:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34006a84:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34006a88:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006a8c:	f7ff fc06 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
34006a90:	0329      	lsls	r1, r5, #12
34006a92:	d51a      	bpl.n	34006aca <HAL_RCCEx_PeriphCLKConfig+0x666>
    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
34006a94:	f8d4 0104 	ldr.w	r0, [r4, #260]	@ 0x104
34006a98:	4b51      	ldr	r3, [pc, #324]	@ (34006be0 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
34006a9a:	4298      	cmp	r0, r3
34006a9c:	f040 8617 	bne.w	340076ce <HAL_RCCEx_PeriphCLKConfig+0x126a>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34006aa0:	4a47      	ldr	r2, [pc, #284]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006aa2:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
34006aa4:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
34006aa8:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
34006aaa:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006aae:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006ab2:	3901      	subs	r1, #1
34006ab4:	433b      	orrs	r3, r7
34006ab6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006aba:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34006abe:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34006ac2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006ac6:	f7ff fbe9 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
34006aca:	02ea      	lsls	r2, r5, #11
34006acc:	d51a      	bpl.n	34006b04 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
34006ace:	f8d4 0108 	ldr.w	r0, [r4, #264]	@ 0x108
34006ad2:	4b44      	ldr	r3, [pc, #272]	@ (34006be4 <HAL_RCCEx_PeriphCLKConfig+0x780>)
34006ad4:	4298      	cmp	r0, r3
34006ad6:	f040 8603 	bne.w	340076e0 <HAL_RCCEx_PeriphCLKConfig+0x127c>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34006ada:	4a39      	ldr	r2, [pc, #228]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006adc:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
34006ade:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
34006ae2:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
34006ae4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006ae8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006aec:	3901      	subs	r1, #1
34006aee:	433b      	orrs	r3, r7
34006af0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006af4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34006af8:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34006afc:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006b00:	f7ff fbcc 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
34006b04:	02ab      	lsls	r3, r5, #10
34006b06:	d51a      	bpl.n	34006b3e <HAL_RCCEx_PeriphCLKConfig+0x6da>
    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
34006b08:	f8d4 010c 	ldr.w	r0, [r4, #268]	@ 0x10c
34006b0c:	4b36      	ldr	r3, [pc, #216]	@ (34006be8 <HAL_RCCEx_PeriphCLKConfig+0x784>)
34006b0e:	4298      	cmp	r0, r3
34006b10:	f040 85ef 	bne.w	340076f2 <HAL_RCCEx_PeriphCLKConfig+0x128e>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34006b14:	4a2a      	ldr	r2, [pc, #168]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006b16:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
34006b18:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
34006b1c:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
34006b1e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006b22:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006b26:	3901      	subs	r1, #1
34006b28:	433b      	orrs	r3, r7
34006b2a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006b2e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34006b32:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34006b36:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006b3a:	f7ff fbaf 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
34006b3e:	026f      	lsls	r7, r5, #9
34006b40:	d51a      	bpl.n	34006b78 <HAL_RCCEx_PeriphCLKConfig+0x714>
    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
34006b42:	f8d4 0110 	ldr.w	r0, [r4, #272]	@ 0x110
34006b46:	4b29      	ldr	r3, [pc, #164]	@ (34006bec <HAL_RCCEx_PeriphCLKConfig+0x788>)
34006b48:	4298      	cmp	r0, r3
34006b4a:	f040 85db 	bne.w	34007704 <HAL_RCCEx_PeriphCLKConfig+0x12a0>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34006b4e:	4a1c      	ldr	r2, [pc, #112]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006b50:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
34006b52:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
34006b56:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
34006b58:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006b5c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006b60:	3901      	subs	r1, #1
34006b62:	433b      	orrs	r3, r7
34006b64:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006b68:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34006b6c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34006b70:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006b74:	f7ff fb92 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
34006b78:	0228      	lsls	r0, r5, #8
34006b7a:	d539      	bpl.n	34006bf0 <HAL_RCCEx_PeriphCLKConfig+0x78c>
    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
34006b7c:	f8d4 1114 	ldr.w	r1, [r4, #276]	@ 0x114
34006b80:	4a0f      	ldr	r2, [pc, #60]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006b82:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
34006b86:	f040 85c6 	bne.w	34007716 <HAL_RCCEx_PeriphCLKConfig+0x12b2>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006b8a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34006b8e:	6ce0      	ldr	r0, [r4, #76]	@ 0x4c
34006b90:	6ca7      	ldr	r7, [r4, #72]	@ 0x48
34006b92:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006b96:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006b9a:	3801      	subs	r0, #1
34006b9c:	433b      	orrs	r3, r7
34006b9e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006ba2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006ba6:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34006baa:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
34006bae:	4a04      	ldr	r2, [pc, #16]	@ (34006bc0 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
34006bb0:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
34006bb4:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
34006bb8:	430b      	orrs	r3, r1
34006bba:	f8c2 3178 	str.w	r3, [r2, #376]	@ 0x178
34006bbe:	e017      	b.n	34006bf0 <HAL_RCCEx_PeriphCLKConfig+0x78c>
34006bc0:	56028000 	.word	0x56028000
34006bc4:	0702000c 	.word	0x0702000c
34006bc8:	0702040c 	.word	0x0702040c
34006bcc:	0702080c 	.word	0x0702080c
34006bd0:	07020c0c 	.word	0x07020c0c
34006bd4:	0702100c 	.word	0x0702100c
34006bd8:	0702140c 	.word	0x0702140c
34006bdc:	0702082c 	.word	0x0702082c
34006be0:	07020c2c 	.word	0x07020c2c
34006be4:	0702102c 	.word	0x0702102c
34006be8:	0702142c 	.word	0x0702142c
34006bec:	0702182c 	.word	0x0702182c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
34006bf0:	01e9      	lsls	r1, r5, #7
34006bf2:	d522      	bpl.n	34006c3a <HAL_RCCEx_PeriphCLKConfig+0x7d6>
    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
34006bf4:	f8d4 1118 	ldr.w	r1, [r4, #280]	@ 0x118
34006bf8:	4ac9      	ldr	r2, [pc, #804]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006bfa:	f1b1 7f00 	cmp.w	r1, #33554432	@ 0x2000000
34006bfe:	f040 85a7 	bne.w	34007750 <HAL_RCCEx_PeriphCLKConfig+0x12ec>
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
34006c02:	f8d2 3100 	ldr.w	r3, [r2, #256]	@ 0x100
34006c06:	f8d4 0084 	ldr.w	r0, [r4, #132]	@ 0x84
34006c0a:	f8d4 7080 	ldr.w	r7, [r4, #128]	@ 0x80
34006c0e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006c12:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006c16:	3801      	subs	r0, #1
34006c18:	433b      	orrs	r3, r7
34006c1a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006c1e:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
34006c22:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34006c26:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
34006c2a:	4abd      	ldr	r2, [pc, #756]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006c2c:	f8d2 3150 	ldr.w	r3, [r2, #336]	@ 0x150
34006c30:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
34006c34:	430b      	orrs	r3, r1
34006c36:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
34006c3a:	01aa      	lsls	r2, r5, #6
34006c3c:	d51f      	bpl.n	34006c7e <HAL_RCCEx_PeriphCLKConfig+0x81a>
    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
34006c3e:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
34006c42:	4ab7      	ldr	r2, [pc, #732]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006c44:	f5b1 3f00 	cmp.w	r1, #131072	@ 0x20000
34006c48:	f040 858a 	bne.w	34007760 <HAL_RCCEx_PeriphCLKConfig+0x12fc>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34006c4c:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
34006c50:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
34006c52:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
34006c54:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006c58:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006c5c:	3801      	subs	r0, #1
34006c5e:	433b      	orrs	r3, r7
34006c60:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006c64:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
34006c68:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34006c6a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
34006c6e:	4aac      	ldr	r2, [pc, #688]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006c70:	f8d2 3154 	ldr.w	r3, [r2, #340]	@ 0x154
34006c74:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
34006c78:	430b      	orrs	r3, r1
34006c7a:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
34006c7e:	016b      	lsls	r3, r5, #5
34006c80:	d521      	bpl.n	34006cc6 <HAL_RCCEx_PeriphCLKConfig+0x862>
    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
34006c82:	f8d4 1120 	ldr.w	r1, [r4, #288]	@ 0x120
34006c86:	4aa6      	ldr	r2, [pc, #664]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006c88:	2920      	cmp	r1, #32
34006c8a:	f040 8585 	bne.w	34007798 <HAL_RCCEx_PeriphCLKConfig+0x1334>
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
34006c8e:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
34006c92:	f8d4 00a4 	ldr.w	r0, [r4, #164]	@ 0xa4
34006c96:	f8d4 70a0 	ldr.w	r7, [r4, #160]	@ 0xa0
34006c9a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006c9e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006ca2:	3801      	subs	r0, #1
34006ca4:	433b      	orrs	r3, r7
34006ca6:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006caa:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
34006cae:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
34006cb2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
34006cb6:	4a9a      	ldr	r2, [pc, #616]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006cb8:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
34006cbc:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
34006cc0:	430b      	orrs	r3, r1
34006cc2:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
34006cc6:	00ef      	lsls	r7, r5, #3
34006cc8:	d519      	bpl.n	34006cfe <HAL_RCCEx_PeriphCLKConfig+0x89a>
    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
34006cca:	f8d4 0124 	ldr.w	r0, [r4, #292]	@ 0x124
34006cce:	4b95      	ldr	r3, [pc, #596]	@ (34006f24 <HAL_RCCEx_PeriphCLKConfig+0xac0>)
34006cd0:	4298      	cmp	r0, r3
34006cd2:	f040 8568 	bne.w	340077a6 <HAL_RCCEx_PeriphCLKConfig+0x1342>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34006cd6:	4a92      	ldr	r2, [pc, #584]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006cd8:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
34006cda:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
34006cde:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
34006ce0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006ce4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006ce8:	3901      	subs	r1, #1
34006cea:	433b      	orrs	r3, r7
34006cec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006cf0:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
34006cf4:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34006cf6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006cfa:	f7ff facf 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
34006cfe:	00ad      	lsls	r5, r5, #2
34006d00:	d519      	bpl.n	34006d36 <HAL_RCCEx_PeriphCLKConfig+0x8d2>
    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
34006d02:	f8d4 0128 	ldr.w	r0, [r4, #296]	@ 0x128
34006d06:	4b88      	ldr	r3, [pc, #544]	@ (34006f28 <HAL_RCCEx_PeriphCLKConfig+0xac4>)
34006d08:	4298      	cmp	r0, r3
34006d0a:	f040 856a 	bne.w	340077e2 <HAL_RCCEx_PeriphCLKConfig+0x137e>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34006d0e:	4a84      	ldr	r2, [pc, #528]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006d10:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
34006d12:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
34006d16:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
34006d18:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006d1c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006d20:	3901      	subs	r1, #1
34006d22:	432b      	orrs	r3, r5
34006d24:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006d28:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
34006d2c:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34006d2e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006d32:	f7ff fab3 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
34006d36:	07f0      	lsls	r0, r6, #31
34006d38:	d51e      	bpl.n	34006d78 <HAL_RCCEx_PeriphCLKConfig+0x914>
    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
34006d3a:	f8d4 114c 	ldr.w	r1, [r4, #332]	@ 0x14c
34006d3e:	4a78      	ldr	r2, [pc, #480]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006d40:	2902      	cmp	r1, #2
34006d42:	f040 856c 	bne.w	3400781e <HAL_RCCEx_PeriphCLKConfig+0x13ba>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34006d46:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
34006d4a:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
34006d4c:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
34006d4e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006d52:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006d56:	3801      	subs	r0, #1
34006d58:	432b      	orrs	r3, r5
34006d5a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006d5e:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
34006d62:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34006d64:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
34006d68:	4a6d      	ldr	r2, [pc, #436]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006d6a:	f8d2 3164 	ldr.w	r3, [r2, #356]	@ 0x164
34006d6e:	f023 0307 	bic.w	r3, r3, #7
34006d72:	430b      	orrs	r3, r1
34006d74:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
34006d78:	07b1      	lsls	r1, r6, #30
34006d7a:	d519      	bpl.n	34006db0 <HAL_RCCEx_PeriphCLKConfig+0x94c>
    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
34006d7c:	f8d4 0134 	ldr.w	r0, [r4, #308]	@ 0x134
34006d80:	4b6a      	ldr	r3, [pc, #424]	@ (34006f2c <HAL_RCCEx_PeriphCLKConfig+0xac8>)
34006d82:	4298      	cmp	r0, r3
34006d84:	f040 8565 	bne.w	34007852 <HAL_RCCEx_PeriphCLKConfig+0x13ee>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006d88:	4a65      	ldr	r2, [pc, #404]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006d8a:	6c61      	ldr	r1, [r4, #68]	@ 0x44
34006d8c:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
34006d90:	6c25      	ldr	r5, [r4, #64]	@ 0x40
34006d92:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006d96:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006d9a:	3901      	subs	r1, #1
34006d9c:	432b      	orrs	r3, r5
34006d9e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006da2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34006da6:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006da8:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006dac:	f7ff fa76 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
34006db0:	0772      	lsls	r2, r6, #29
34006db2:	d519      	bpl.n	34006de8 <HAL_RCCEx_PeriphCLKConfig+0x984>
    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
34006db4:	f8d4 0138 	ldr.w	r0, [r4, #312]	@ 0x138
34006db8:	4b5d      	ldr	r3, [pc, #372]	@ (34006f30 <HAL_RCCEx_PeriphCLKConfig+0xacc>)
34006dba:	4298      	cmp	r0, r3
34006dbc:	f040 8568 	bne.w	34007890 <HAL_RCCEx_PeriphCLKConfig+0x142c>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006dc0:	4a57      	ldr	r2, [pc, #348]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006dc2:	6c61      	ldr	r1, [r4, #68]	@ 0x44
34006dc4:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
34006dc8:	6c25      	ldr	r5, [r4, #64]	@ 0x40
34006dca:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006dce:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006dd2:	3901      	subs	r1, #1
34006dd4:	432b      	orrs	r3, r5
34006dd6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006dda:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34006dde:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006de0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006de4:	f7ff fa5a 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
34006de8:	0733      	lsls	r3, r6, #28
34006dea:	d519      	bpl.n	34006e20 <HAL_RCCEx_PeriphCLKConfig+0x9bc>
    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
34006dec:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
34006df0:	4b50      	ldr	r3, [pc, #320]	@ (34006f34 <HAL_RCCEx_PeriphCLKConfig+0xad0>)
34006df2:	4298      	cmp	r0, r3
34006df4:	f040 856b 	bne.w	340078ce <HAL_RCCEx_PeriphCLKConfig+0x146a>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006df8:	4a49      	ldr	r2, [pc, #292]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006dfa:	6c61      	ldr	r1, [r4, #68]	@ 0x44
34006dfc:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
34006e00:	6c25      	ldr	r5, [r4, #64]	@ 0x40
34006e02:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006e06:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006e0a:	3901      	subs	r1, #1
34006e0c:	432b      	orrs	r3, r5
34006e0e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006e12:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34006e16:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006e18:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006e1c:	f7ff fa3e 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
34006e20:	06f7      	lsls	r7, r6, #27
34006e22:	d51a      	bpl.n	34006e5a <HAL_RCCEx_PeriphCLKConfig+0x9f6>
    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
34006e24:	f8d4 0140 	ldr.w	r0, [r4, #320]	@ 0x140
34006e28:	4b43      	ldr	r3, [pc, #268]	@ (34006f38 <HAL_RCCEx_PeriphCLKConfig+0xad4>)
34006e2a:	4298      	cmp	r0, r3
34006e2c:	f040 8596 	bne.w	3400795c <HAL_RCCEx_PeriphCLKConfig+0x14f8>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006e30:	4a3b      	ldr	r2, [pc, #236]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006e32:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34006e34:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34006e38:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34006e3a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006e3e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006e42:	3901      	subs	r1, #1
34006e44:	432b      	orrs	r3, r5
34006e46:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006e4a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006e4e:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34006e52:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006e56:	f7ff fa21 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
34006e5a:	06b5      	lsls	r5, r6, #26
34006e5c:	d51a      	bpl.n	34006e94 <HAL_RCCEx_PeriphCLKConfig+0xa30>
    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
34006e5e:	f8d4 0144 	ldr.w	r0, [r4, #324]	@ 0x144
34006e62:	4b36      	ldr	r3, [pc, #216]	@ (34006f3c <HAL_RCCEx_PeriphCLKConfig+0xad8>)
34006e64:	4298      	cmp	r0, r3
34006e66:	f040 8598 	bne.w	3400799a <HAL_RCCEx_PeriphCLKConfig+0x1536>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006e6a:	4a2d      	ldr	r2, [pc, #180]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006e6c:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34006e6e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34006e72:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34006e74:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006e78:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006e7c:	3901      	subs	r1, #1
34006e7e:	432b      	orrs	r3, r5
34006e80:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006e84:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006e88:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34006e8c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006e90:	f7ff fa04 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
34006e94:	0670      	lsls	r0, r6, #25
34006e96:	d519      	bpl.n	34006ecc <HAL_RCCEx_PeriphCLKConfig+0xa68>
    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
34006e98:	f8d4 0148 	ldr.w	r0, [r4, #328]	@ 0x148
34006e9c:	4b28      	ldr	r3, [pc, #160]	@ (34006f40 <HAL_RCCEx_PeriphCLKConfig+0xadc>)
34006e9e:	4298      	cmp	r0, r3
34006ea0:	f040 859a 	bne.w	340079d8 <HAL_RCCEx_PeriphCLKConfig+0x1574>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006ea4:	4a1e      	ldr	r2, [pc, #120]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006ea6:	6c61      	ldr	r1, [r4, #68]	@ 0x44
34006ea8:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
34006eac:	6c25      	ldr	r5, [r4, #64]	@ 0x40
34006eae:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006eb2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006eb6:	3901      	subs	r1, #1
34006eb8:	432b      	orrs	r3, r5
34006eba:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006ebe:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34006ec2:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006ec4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006ec8:	f7ff f9e8 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
34006ecc:	05f1      	lsls	r1, r6, #23
34006ece:	d51a      	bpl.n	34006f06 <HAL_RCCEx_PeriphCLKConfig+0xaa2>
    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
34006ed0:	f8d4 0150 	ldr.w	r0, [r4, #336]	@ 0x150
34006ed4:	4b1b      	ldr	r3, [pc, #108]	@ (34006f44 <HAL_RCCEx_PeriphCLKConfig+0xae0>)
34006ed6:	4298      	cmp	r0, r3
34006ed8:	f040 859d 	bne.w	34007a16 <HAL_RCCEx_PeriphCLKConfig+0x15b2>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006edc:	4a10      	ldr	r2, [pc, #64]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006ede:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34006ee0:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34006ee4:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34006ee6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006eea:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006eee:	3901      	subs	r1, #1
34006ef0:	432b      	orrs	r3, r5
34006ef2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006ef6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006efa:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34006efe:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006f02:	f7ff f9cb 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
34006f06:	05b2      	lsls	r2, r6, #22
34006f08:	d531      	bpl.n	34006f6e <HAL_RCCEx_PeriphCLKConfig+0xb0a>
    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
34006f0a:	f8d4 0154 	ldr.w	r0, [r4, #340]	@ 0x154
34006f0e:	4b0e      	ldr	r3, [pc, #56]	@ (34006f48 <HAL_RCCEx_PeriphCLKConfig+0xae4>)
34006f10:	4298      	cmp	r0, r3
34006f12:	f040 859f 	bne.w	34007a54 <HAL_RCCEx_PeriphCLKConfig+0x15f0>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006f16:	4a02      	ldr	r2, [pc, #8]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
34006f18:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34006f1a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34006f1e:	e015      	b.n	34006f4c <HAL_RCCEx_PeriphCLKConfig+0xae8>
34006f20:	56028000 	.word	0x56028000
34006f24:	07021418 	.word	0x07021418
34006f28:	07021818 	.word	0x07021818
34006f2c:	07020420 	.word	0x07020420
34006f30:	07020820 	.word	0x07020820
34006f34:	07020c20 	.word	0x07020c20
34006f38:	07021020 	.word	0x07021020
34006f3c:	07021420 	.word	0x07021420
34006f40:	07021820 	.word	0x07021820
34006f44:	07020030 	.word	0x07020030
34006f48:	07020430 	.word	0x07020430
34006f4c:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34006f4e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006f52:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006f56:	3901      	subs	r1, #1
34006f58:	432b      	orrs	r3, r5
34006f5a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006f5e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006f62:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34006f66:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006f6a:	f7ff f997 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
34006f6e:	0573      	lsls	r3, r6, #21
34006f70:	d51a      	bpl.n	34006fa8 <HAL_RCCEx_PeriphCLKConfig+0xb44>
    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
34006f72:	f8d4 0158 	ldr.w	r0, [r4, #344]	@ 0x158
34006f76:	4bcb      	ldr	r3, [pc, #812]	@ (340072a4 <HAL_RCCEx_PeriphCLKConfig+0xe40>)
34006f78:	4298      	cmp	r0, r3
34006f7a:	f040 858a 	bne.w	34007a92 <HAL_RCCEx_PeriphCLKConfig+0x162e>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006f7e:	4aca      	ldr	r2, [pc, #808]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
34006f80:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34006f82:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34006f86:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34006f88:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006f8c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006f90:	3901      	subs	r1, #1
34006f92:	432b      	orrs	r3, r5
34006f94:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006f98:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006f9c:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34006fa0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006fa4:	f7ff f97a 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
34006fa8:	0537      	lsls	r7, r6, #20
34006faa:	d51a      	bpl.n	34006fe2 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
34006fac:	f8d4 015c 	ldr.w	r0, [r4, #348]	@ 0x15c
34006fb0:	4bbe      	ldr	r3, [pc, #760]	@ (340072ac <HAL_RCCEx_PeriphCLKConfig+0xe48>)
34006fb2:	4298      	cmp	r0, r3
34006fb4:	f040 858c 	bne.w	34007ad0 <HAL_RCCEx_PeriphCLKConfig+0x166c>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006fb8:	4abb      	ldr	r2, [pc, #748]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
34006fba:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34006fbc:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34006fc0:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34006fc2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34006fc6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34006fca:	3901      	subs	r1, #1
34006fcc:	432b      	orrs	r3, r5
34006fce:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34006fd2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006fd6:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34006fda:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34006fde:	f7ff f95d 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
34006fe2:	04f5      	lsls	r5, r6, #19
34006fe4:	d51a      	bpl.n	3400701c <HAL_RCCEx_PeriphCLKConfig+0xbb8>
    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
34006fe6:	f8d4 0160 	ldr.w	r0, [r4, #352]	@ 0x160
34006fea:	4bb1      	ldr	r3, [pc, #708]	@ (340072b0 <HAL_RCCEx_PeriphCLKConfig+0xe4c>)
34006fec:	4298      	cmp	r0, r3
34006fee:	f040 858e 	bne.w	34007b0e <HAL_RCCEx_PeriphCLKConfig+0x16aa>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006ff2:	4aad      	ldr	r2, [pc, #692]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
34006ff4:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34006ff6:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34006ffa:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34006ffc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007000:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007004:	3901      	subs	r1, #1
34007006:	432b      	orrs	r3, r5
34007008:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400700c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34007010:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007014:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34007018:	f7ff f940 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
3400701c:	04b0      	lsls	r0, r6, #18
3400701e:	d51a      	bpl.n	34007056 <HAL_RCCEx_PeriphCLKConfig+0xbf2>
    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
34007020:	f8d4 0164 	ldr.w	r0, [r4, #356]	@ 0x164
34007024:	4ba3      	ldr	r3, [pc, #652]	@ (340072b4 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
34007026:	4298      	cmp	r0, r3
34007028:	f040 8590 	bne.w	34007b4c <HAL_RCCEx_PeriphCLKConfig+0x16e8>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400702c:	4a9e      	ldr	r2, [pc, #632]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3400702e:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34007030:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34007034:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34007036:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400703a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400703e:	3901      	subs	r1, #1
34007040:	432b      	orrs	r3, r5
34007042:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007046:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400704a:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400704e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34007052:	f7ff f923 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
34007056:	0471      	lsls	r1, r6, #17
34007058:	d51a      	bpl.n	34007090 <HAL_RCCEx_PeriphCLKConfig+0xc2c>
    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
3400705a:	f8d4 0168 	ldr.w	r0, [r4, #360]	@ 0x168
3400705e:	4b96      	ldr	r3, [pc, #600]	@ (340072b8 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
34007060:	4298      	cmp	r0, r3
34007062:	f040 8592 	bne.w	34007b8a <HAL_RCCEx_PeriphCLKConfig+0x1726>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007066:	4a90      	ldr	r2, [pc, #576]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
34007068:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400706a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400706e:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34007070:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007074:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007078:	3901      	subs	r1, #1
3400707a:	432b      	orrs	r3, r5
3400707c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007080:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34007084:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007088:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400708c:	f7ff f906 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
34007090:	0432      	lsls	r2, r6, #16
34007092:	d51a      	bpl.n	340070ca <HAL_RCCEx_PeriphCLKConfig+0xc66>
    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
34007094:	f8d4 016c 	ldr.w	r0, [r4, #364]	@ 0x16c
34007098:	4b88      	ldr	r3, [pc, #544]	@ (340072bc <HAL_RCCEx_PeriphCLKConfig+0xe58>)
3400709a:	4298      	cmp	r0, r3
3400709c:	f040 8594 	bne.w	34007bc8 <HAL_RCCEx_PeriphCLKConfig+0x1764>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340070a0:	4a81      	ldr	r2, [pc, #516]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
340070a2:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
340070a4:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
340070a8:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
340070aa:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340070ae:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340070b2:	3901      	subs	r1, #1
340070b4:	432b      	orrs	r3, r5
340070b6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340070ba:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
340070be:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
340070c2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
340070c6:	f7ff f8e9 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
340070ca:	03f3      	lsls	r3, r6, #15
340070cc:	d51a      	bpl.n	34007104 <HAL_RCCEx_PeriphCLKConfig+0xca0>
    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
340070ce:	f8d4 0170 	ldr.w	r0, [r4, #368]	@ 0x170
340070d2:	4b7b      	ldr	r3, [pc, #492]	@ (340072c0 <HAL_RCCEx_PeriphCLKConfig+0xe5c>)
340070d4:	4298      	cmp	r0, r3
340070d6:	f040 8596 	bne.w	34007c06 <HAL_RCCEx_PeriphCLKConfig+0x17a2>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340070da:	4a73      	ldr	r2, [pc, #460]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
340070dc:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
340070de:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
340070e2:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
340070e4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340070e8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340070ec:	3901      	subs	r1, #1
340070ee:	432b      	orrs	r3, r5
340070f0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340070f4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
340070f8:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
340070fc:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
34007100:	f7ff f8cc 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
34007104:	03b7      	lsls	r7, r6, #14
34007106:	d51a      	bpl.n	3400713e <HAL_RCCEx_PeriphCLKConfig+0xcda>
    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
34007108:	f8d4 0174 	ldr.w	r0, [r4, #372]	@ 0x174
3400710c:	4b6d      	ldr	r3, [pc, #436]	@ (340072c4 <HAL_RCCEx_PeriphCLKConfig+0xe60>)
3400710e:	4298      	cmp	r0, r3
34007110:	f040 85ca 	bne.w	34007ca8 <HAL_RCCEx_PeriphCLKConfig+0x1844>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007114:	4a64      	ldr	r2, [pc, #400]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
34007116:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34007118:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400711c:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3400711e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007122:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007126:	3901      	subs	r1, #1
34007128:	432b      	orrs	r3, r5
3400712a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400712e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34007132:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007136:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400713a:	f7ff f8af 	bl	3400629c <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
3400713e:	0375      	lsls	r5, r6, #13
34007140:	d50c      	bpl.n	3400715c <HAL_RCCEx_PeriphCLKConfig+0xcf8>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
34007142:	f8d4 0178 	ldr.w	r0, [r4, #376]	@ 0x178
  LL_RCC_SetClockSource(ClkSource);
34007146:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400714a:	f7ff f8a7 	bl	3400629c <LL_RCC_SetClockSource>
3400714e:	f8d4 3178 	ldr.w	r3, [r4, #376]	@ 0x178
34007152:	2b00      	cmp	r3, #0
34007154:	f280 85c7 	bge.w	34007ce6 <HAL_RCCEx_PeriphCLKConfig+0x1882>
34007158:	f7ff f870 	bl	3400623c <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
3400715c:	02f0      	lsls	r0, r6, #11
3400715e:	d50c      	bpl.n	3400717a <HAL_RCCEx_PeriphCLKConfig+0xd16>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
34007160:	f8d4 0180 	ldr.w	r0, [r4, #384]	@ 0x180
34007164:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
34007168:	f7ff f898 	bl	3400629c <LL_RCC_SetClockSource>
3400716c:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
34007170:	2b00      	cmp	r3, #0
34007172:	f280 85bc 	bge.w	34007cee <HAL_RCCEx_PeriphCLKConfig+0x188a>
34007176:	f7ff f861 	bl	3400623c <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
3400717a:	0331      	lsls	r1, r6, #12
3400717c:	d523      	bpl.n	340071c6 <HAL_RCCEx_PeriphCLKConfig+0xd62>
    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
3400717e:	f8d4 017c 	ldr.w	r0, [r4, #380]	@ 0x17c
34007182:	4b51      	ldr	r3, [pc, #324]	@ (340072c8 <HAL_RCCEx_PeriphCLKConfig+0xe64>)
34007184:	4298      	cmp	r0, r3
34007186:	f040 85b6 	bne.w	34007cf6 <HAL_RCCEx_PeriphCLKConfig+0x1892>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400718a:	4a47      	ldr	r2, [pc, #284]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3400718c:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400718e:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
34007192:	6fa5      	ldr	r5, [r4, #120]	@ 0x78
34007194:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007198:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400719c:	3901      	subs	r1, #1
3400719e:	432b      	orrs	r3, r5
340071a0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340071a4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
340071a8:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
340071ac:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
340071b0:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
340071b4:	f7ff f872 	bl	3400629c <LL_RCC_SetClockSource>
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
340071b8:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
340071bc:	2b00      	cmp	r3, #0
340071be:	f280 85a3 	bge.w	34007d08 <HAL_RCCEx_PeriphCLKConfig+0x18a4>
340071c2:	f7ff f83b 	bl	3400623c <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
340071c6:	02b2      	lsls	r2, r6, #10
340071c8:	d523      	bpl.n	34007212 <HAL_RCCEx_PeriphCLKConfig+0xdae>
    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
340071ca:	f8d4 0184 	ldr.w	r0, [r4, #388]	@ 0x184
340071ce:	4b3f      	ldr	r3, [pc, #252]	@ (340072cc <HAL_RCCEx_PeriphCLKConfig+0xe68>)
340071d0:	4298      	cmp	r0, r3
340071d2:	f040 859d 	bne.w	34007d10 <HAL_RCCEx_PeriphCLKConfig+0x18ac>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340071d6:	4a34      	ldr	r2, [pc, #208]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
340071d8:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
340071da:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
340071de:	6fa5      	ldr	r5, [r4, #120]	@ 0x78
340071e0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340071e4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340071e8:	3901      	subs	r1, #1
340071ea:	432b      	orrs	r3, r5
340071ec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340071f0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
340071f4:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
340071f8:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
340071fc:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
34007200:	f7ff f84c 	bl	3400629c <LL_RCC_SetClockSource>
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
34007204:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
34007208:	2b00      	cmp	r3, #0
3400720a:	f280 858a 	bge.w	34007d22 <HAL_RCCEx_PeriphCLKConfig+0x18be>
3400720e:	f7ff f815 	bl	3400623c <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
34007212:	0633      	lsls	r3, r6, #24
34007214:	d508      	bpl.n	34007228 <HAL_RCCEx_PeriphCLKConfig+0xdc4>
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
34007216:	4a24      	ldr	r2, [pc, #144]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
34007218:	f8d4 118c 	ldr.w	r1, [r4, #396]	@ 0x18c
3400721c:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400721e:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
34007222:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
34007226:	6253      	str	r3, [r2, #36]	@ 0x24
}
34007228:	f1b8 0000 	subs.w	r0, r8, #0
3400722c:	bf18      	it	ne
3400722e:	2001      	movne	r0, #1
34007230:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34007234:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34007238:	6d60      	ldr	r0, [r4, #84]	@ 0x54
3400723a:	6d27      	ldr	r7, [r4, #80]	@ 0x50
3400723c:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
34007240:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
34007244:	3801      	subs	r0, #1
34007246:	433a      	orrs	r2, r7
34007248:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3400724c:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34007250:	f44f 7200 	mov.w	r2, #512	@ 0x200
34007254:	f7ff b975 	b.w	34006542 <HAL_RCCEx_PeriphCLKConfig+0xde>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34007258:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400725c:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
3400725e:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
34007260:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
34007264:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
34007268:	3801      	subs	r0, #1
3400726a:	433a      	orrs	r2, r7
3400726c:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34007270:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34007274:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34007278:	f7ff b963 	b.w	34006542 <HAL_RCCEx_PeriphCLKConfig+0xde>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400727c:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34007280:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
34007284:	f8d4 7098 	ldr.w	r7, [r4, #152]	@ 0x98
34007288:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
3400728c:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
34007290:	3801      	subs	r0, #1
34007292:	433a      	orrs	r2, r7
34007294:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34007298:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3400729c:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
340072a0:	f7ff b94f 	b.w	34006542 <HAL_RCCEx_PeriphCLKConfig+0xde>
340072a4:	07020830 	.word	0x07020830
340072a8:	56028000 	.word	0x56028000
340072ac:	07020c30 	.word	0x07020c30
340072b0:	07021030 	.word	0x07021030
340072b4:	07021430 	.word	0x07021430
340072b8:	07021830 	.word	0x07021830
340072bc:	07021c30 	.word	0x07021c30
340072c0:	07020034 	.word	0x07020034
340072c4:	07020434 	.word	0x07020434
340072c8:	03020c14 	.word	0x03020c14
340072cc:	03021414 	.word	0x03021414
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
340072d0:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
340072d4:	f8d4 00a4 	ldr.w	r0, [r4, #164]	@ 0xa4
340072d8:	f8d4 70a0 	ldr.w	r7, [r4, #160]	@ 0xa0
340072dc:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
340072e0:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
340072e4:	3801      	subs	r0, #1
340072e6:	433a      	orrs	r2, r7
340072e8:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340072ec:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
340072f0:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
340072f4:	f7ff b925 	b.w	34006542 <HAL_RCCEx_PeriphCLKConfig+0xde>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
340072f8:	4bbe      	ldr	r3, [pc, #760]	@ (340075f4 <HAL_RCCEx_PeriphCLKConfig+0x1190>)
340072fa:	4298      	cmp	r0, r3
340072fc:	d111      	bne.n	34007322 <HAL_RCCEx_PeriphCLKConfig+0xebe>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
340072fe:	4abe      	ldr	r2, [pc, #760]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007300:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34007302:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
34007306:	6a27      	ldr	r7, [r4, #32]
34007308:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400730c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007310:	3901      	subs	r1, #1
34007312:	433b      	orrs	r3, r7
34007314:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007318:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400731c:	2308      	movs	r3, #8
3400731e:	f7ff b932 	b.w	34006586 <HAL_RCCEx_PeriphCLKConfig+0x122>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
34007322:	4bb6      	ldr	r3, [pc, #728]	@ (340075fc <HAL_RCCEx_PeriphCLKConfig+0x1198>)
34007324:	4298      	cmp	r0, r3
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007326:	bf02      	ittt	eq
34007328:	2240      	moveq	r2, #64	@ 0x40
3400732a:	4bb3      	ldreq	r3, [pc, #716]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3400732c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007330:	f7ff b92b 	b.w	3400658a <HAL_RCCEx_PeriphCLKConfig+0x126>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
34007334:	4bb2      	ldr	r3, [pc, #712]	@ (34007600 <HAL_RCCEx_PeriphCLKConfig+0x119c>)
34007336:	4298      	cmp	r0, r3
34007338:	d111      	bne.n	3400735e <HAL_RCCEx_PeriphCLKConfig+0xefa>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400733a:	4aaf      	ldr	r2, [pc, #700]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3400733c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400733e:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
34007342:	6a27      	ldr	r7, [r4, #32]
34007344:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007348:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400734c:	3901      	subs	r1, #1
3400734e:	433b      	orrs	r3, r7
34007350:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007354:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
34007358:	2308      	movs	r3, #8
3400735a:	f7ff b930 	b.w	340065be <HAL_RCCEx_PeriphCLKConfig+0x15a>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3400735e:	4ba9      	ldr	r3, [pc, #676]	@ (34007604 <HAL_RCCEx_PeriphCLKConfig+0x11a0>)
34007360:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007362:	bf02      	ittt	eq
34007364:	2240      	moveq	r2, #64	@ 0x40
34007366:	4ba4      	ldreq	r3, [pc, #656]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007368:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400736c:	f7ff b929 	b.w	340065c2 <HAL_RCCEx_PeriphCLKConfig+0x15e>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
34007370:	4ba5      	ldr	r3, [pc, #660]	@ (34007608 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
34007372:	4298      	cmp	r0, r3
34007374:	d111      	bne.n	3400739a <HAL_RCCEx_PeriphCLKConfig+0xf36>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34007376:	4aa0      	ldr	r2, [pc, #640]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007378:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400737a:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400737e:	6a27      	ldr	r7, [r4, #32]
34007380:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007384:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007388:	3901      	subs	r1, #1
3400738a:	433b      	orrs	r3, r7
3400738c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007390:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
34007394:	2308      	movs	r3, #8
34007396:	f7ff b92e 	b.w	340065f6 <HAL_RCCEx_PeriphCLKConfig+0x192>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
3400739a:	4b9c      	ldr	r3, [pc, #624]	@ (3400760c <HAL_RCCEx_PeriphCLKConfig+0x11a8>)
3400739c:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400739e:	bf02      	ittt	eq
340073a0:	2240      	moveq	r2, #64	@ 0x40
340073a2:	4b95      	ldreq	r3, [pc, #596]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
340073a4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340073a8:	f7ff b927 	b.w	340065fa <HAL_RCCEx_PeriphCLKConfig+0x196>
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
340073ac:	2930      	cmp	r1, #48	@ 0x30
340073ae:	d110      	bne.n	340073d2 <HAL_RCCEx_PeriphCLKConfig+0xf6e>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
340073b0:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
340073b4:	6a60      	ldr	r0, [r4, #36]	@ 0x24
340073b6:	6a27      	ldr	r7, [r4, #32]
340073b8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340073bc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340073c0:	3801      	subs	r0, #1
340073c2:	433b      	orrs	r3, r7
340073c4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
340073c8:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
340073cc:	2308      	movs	r3, #8
340073ce:	f7ff b92d 	b.w	3400662c <HAL_RCCEx_PeriphCLKConfig+0x1c8>
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
340073d2:	2910      	cmp	r1, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340073d4:	bf04      	itt	eq
340073d6:	2340      	moveq	r3, #64	@ 0x40
340073d8:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
340073dc:	f7ff b928 	b.w	34006630 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
340073e0:	4b8b      	ldr	r3, [pc, #556]	@ (34007610 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
340073e2:	4298      	cmp	r0, r3
340073e4:	d111      	bne.n	3400740a <HAL_RCCEx_PeriphCLKConfig+0xfa6>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
340073e6:	4a84      	ldr	r2, [pc, #528]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
340073e8:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
340073ea:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
340073ee:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
340073f0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340073f4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340073f8:	3901      	subs	r1, #1
340073fa:	433b      	orrs	r3, r7
340073fc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007400:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
34007404:	2310      	movs	r3, #16
34007406:	f7ff b933 	b.w	34006670 <HAL_RCCEx_PeriphCLKConfig+0x20c>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
3400740a:	4b82      	ldr	r3, [pc, #520]	@ (34007614 <HAL_RCCEx_PeriphCLKConfig+0x11b0>)
3400740c:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400740e:	bf02      	ittt	eq
34007410:	2240      	moveq	r2, #64	@ 0x40
34007412:	4b79      	ldreq	r3, [pc, #484]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007414:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007418:	f7ff b92c 	b.w	34006674 <HAL_RCCEx_PeriphCLKConfig+0x210>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3400741c:	4b7e      	ldr	r3, [pc, #504]	@ (34007618 <HAL_RCCEx_PeriphCLKConfig+0x11b4>)
3400741e:	4298      	cmp	r0, r3
34007420:	d111      	bne.n	34007446 <HAL_RCCEx_PeriphCLKConfig+0xfe2>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34007422:	4a75      	ldr	r2, [pc, #468]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007424:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
34007426:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400742a:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
3400742c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007430:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007434:	3901      	subs	r1, #1
34007436:	433b      	orrs	r3, r7
34007438:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400743c:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
34007440:	2310      	movs	r3, #16
34007442:	f7ff b931 	b.w	340066a8 <HAL_RCCEx_PeriphCLKConfig+0x244>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
34007446:	4b75      	ldr	r3, [pc, #468]	@ (3400761c <HAL_RCCEx_PeriphCLKConfig+0x11b8>)
34007448:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400744a:	bf02      	ittt	eq
3400744c:	2240      	moveq	r2, #64	@ 0x40
3400744e:	4b6a      	ldreq	r3, [pc, #424]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007450:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007454:	f7ff b92a 	b.w	340066ac <HAL_RCCEx_PeriphCLKConfig+0x248>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
34007458:	2a30      	cmp	r2, #48	@ 0x30
3400745a:	d110      	bne.n	3400747e <HAL_RCCEx_PeriphCLKConfig+0x101a>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400745c:	f8d1 30e0 	ldr.w	r3, [r1, #224]	@ 0xe0
34007460:	6c60      	ldr	r0, [r4, #68]	@ 0x44
34007462:	6c27      	ldr	r7, [r4, #64]	@ 0x40
34007464:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007468:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400746c:	3801      	subs	r0, #1
3400746e:	433b      	orrs	r3, r7
34007470:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34007474:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34007478:	2380      	movs	r3, #128	@ 0x80
3400747a:	f7ff b930 	b.w	340066de <HAL_RCCEx_PeriphCLKConfig+0x27a>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
3400747e:	2a10      	cmp	r2, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007480:	bf04      	itt	eq
34007482:	2340      	moveq	r3, #64	@ 0x40
34007484:	f8c1 3a48 	streq.w	r3, [r1, #2632]	@ 0xa48
}
34007488:	f7ff b92b 	b.w	340066e2 <HAL_RCCEx_PeriphCLKConfig+0x27e>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
3400748c:	2903      	cmp	r1, #3
3400748e:	d110      	bne.n	340074b2 <HAL_RCCEx_PeriphCLKConfig+0x104e>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34007490:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
34007494:	6c60      	ldr	r0, [r4, #68]	@ 0x44
34007496:	6c27      	ldr	r7, [r4, #64]	@ 0x40
34007498:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400749c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340074a0:	3801      	subs	r0, #1
340074a2:	433b      	orrs	r3, r7
340074a4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
340074a8:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
340074ac:	2380      	movs	r3, #128	@ 0x80
340074ae:	f7ff b93e 	b.w	3400672e <HAL_RCCEx_PeriphCLKConfig+0x2ca>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
340074b2:	2901      	cmp	r1, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340074b4:	bf04      	itt	eq
340074b6:	2340      	moveq	r3, #64	@ 0x40
340074b8:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
340074bc:	f7ff b939 	b.w	34006732 <HAL_RCCEx_PeriphCLKConfig+0x2ce>
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
340074c0:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340074c4:	bf04      	itt	eq
340074c6:	2340      	moveq	r3, #64	@ 0x40
340074c8:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
340074cc:	f7ff b96d 	b.w	340067aa <HAL_RCCEx_PeriphCLKConfig+0x346>
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
340074d0:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340074d4:	bf04      	itt	eq
340074d6:	2340      	moveq	r3, #64	@ 0x40
340074d8:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
340074dc:	f7ff b988 	b.w	340067f0 <HAL_RCCEx_PeriphCLKConfig+0x38c>
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
340074e0:	2901      	cmp	r1, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340074e2:	bf04      	itt	eq
340074e4:	2340      	moveq	r3, #64	@ 0x40
340074e6:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
340074ea:	f7ff b9d5 	b.w	34006898 <HAL_RCCEx_PeriphCLKConfig+0x434>
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
340074ee:	2901      	cmp	r1, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340074f0:	bf04      	itt	eq
340074f2:	2340      	moveq	r3, #64	@ 0x40
340074f4:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
340074f8:	f7ff b9f7 	b.w	340068ea <HAL_RCCEx_PeriphCLKConfig+0x486>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
340074fc:	4b48      	ldr	r3, [pc, #288]	@ (34007620 <HAL_RCCEx_PeriphCLKConfig+0x11bc>)
340074fe:	4298      	cmp	r0, r3
34007500:	d112      	bne.n	34007528 <HAL_RCCEx_PeriphCLKConfig+0x10c4>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34007502:	4a3d      	ldr	r2, [pc, #244]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007504:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
34007506:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400750a:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3400750c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007510:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007514:	3901      	subs	r1, #1
34007516:	433b      	orrs	r3, r7
34007518:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400751c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34007520:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34007524:	f7ff ba02 	b.w	3400692c <HAL_RCCEx_PeriphCLKConfig+0x4c8>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
34007528:	4b3e      	ldr	r3, [pc, #248]	@ (34007624 <HAL_RCCEx_PeriphCLKConfig+0x11c0>)
3400752a:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400752c:	bf02      	ittt	eq
3400752e:	2240      	moveq	r2, #64	@ 0x40
34007530:	4b31      	ldreq	r3, [pc, #196]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007532:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007536:	f7ff b9fb 	b.w	34006930 <HAL_RCCEx_PeriphCLKConfig+0x4cc>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
3400753a:	4b3b      	ldr	r3, [pc, #236]	@ (34007628 <HAL_RCCEx_PeriphCLKConfig+0x11c4>)
3400753c:	4298      	cmp	r0, r3
3400753e:	d112      	bne.n	34007566 <HAL_RCCEx_PeriphCLKConfig+0x1102>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34007540:	4a2d      	ldr	r2, [pc, #180]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007542:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
34007544:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
34007548:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3400754a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400754e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007552:	3901      	subs	r1, #1
34007554:	433b      	orrs	r3, r7
34007556:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400755a:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400755e:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34007562:	f7ff ba00 	b.w	34006966 <HAL_RCCEx_PeriphCLKConfig+0x502>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
34007566:	4b31      	ldr	r3, [pc, #196]	@ (3400762c <HAL_RCCEx_PeriphCLKConfig+0x11c8>)
34007568:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400756a:	bf02      	ittt	eq
3400756c:	2240      	moveq	r2, #64	@ 0x40
3400756e:	4b22      	ldreq	r3, [pc, #136]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007570:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007574:	f7ff b9f9 	b.w	3400696a <HAL_RCCEx_PeriphCLKConfig+0x506>
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
34007578:	4b2d      	ldr	r3, [pc, #180]	@ (34007630 <HAL_RCCEx_PeriphCLKConfig+0x11cc>)
3400757a:	4298      	cmp	r0, r3
3400757c:	d112      	bne.n	340075a4 <HAL_RCCEx_PeriphCLKConfig+0x1140>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400757e:	4a1e      	ldr	r2, [pc, #120]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
34007580:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
34007582:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
34007586:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
34007588:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400758c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007590:	3901      	subs	r1, #1
34007592:	433b      	orrs	r3, r7
34007594:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007598:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400759c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
340075a0:	f7ff b9fe 	b.w	340069a0 <HAL_RCCEx_PeriphCLKConfig+0x53c>
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
340075a4:	4b23      	ldr	r3, [pc, #140]	@ (34007634 <HAL_RCCEx_PeriphCLKConfig+0x11d0>)
340075a6:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340075a8:	bf02      	ittt	eq
340075aa:	2240      	moveq	r2, #64	@ 0x40
340075ac:	4b12      	ldreq	r3, [pc, #72]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
340075ae:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340075b2:	f7ff b9f7 	b.w	340069a4 <HAL_RCCEx_PeriphCLKConfig+0x540>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
340075b6:	4b20      	ldr	r3, [pc, #128]	@ (34007638 <HAL_RCCEx_PeriphCLKConfig+0x11d4>)
340075b8:	4298      	cmp	r0, r3
340075ba:	d112      	bne.n	340075e2 <HAL_RCCEx_PeriphCLKConfig+0x117e>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340075bc:	4a0e      	ldr	r2, [pc, #56]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
340075be:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
340075c0:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
340075c4:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
340075c6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340075ca:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340075ce:	3901      	subs	r1, #1
340075d0:	433b      	orrs	r3, r7
340075d2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340075d6:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
340075da:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
340075de:	f7ff b9fc 	b.w	340069da <HAL_RCCEx_PeriphCLKConfig+0x576>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
340075e2:	4b16      	ldr	r3, [pc, #88]	@ (3400763c <HAL_RCCEx_PeriphCLKConfig+0x11d8>)
340075e4:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340075e6:	bf02      	ittt	eq
340075e8:	2240      	moveq	r2, #64	@ 0x40
340075ea:	4b03      	ldreq	r3, [pc, #12]	@ (340075f8 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
340075ec:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340075f0:	f7ff b9f5 	b.w	340069de <HAL_RCCEx_PeriphCLKConfig+0x57a>
340075f4:	03030014 	.word	0x03030014
340075f8:	56028000 	.word	0x56028000
340075fc:	03010014 	.word	0x03010014
34007600:	03030414 	.word	0x03030414
34007604:	03010414 	.word	0x03010414
34007608:	03030814 	.word	0x03030814
3400760c:	03010814 	.word	0x03010814
34007610:	0303001c 	.word	0x0303001c
34007614:	0301001c 	.word	0x0301001c
34007618:	0303041c 	.word	0x0303041c
3400761c:	0301041c 	.word	0x0301041c
34007620:	0703000c 	.word	0x0703000c
34007624:	0701000c 	.word	0x0701000c
34007628:	0703040c 	.word	0x0703040c
3400762c:	0701040c 	.word	0x0701040c
34007630:	0703080c 	.word	0x0703080c
34007634:	0701080c 	.word	0x0701080c
34007638:	07030c0c 	.word	0x07030c0c
3400763c:	07010c0c 	.word	0x07010c0c
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
34007640:	4bb2      	ldr	r3, [pc, #712]	@ (3400790c <HAL_RCCEx_PeriphCLKConfig+0x14a8>)
34007642:	4298      	cmp	r0, r3
34007644:	d112      	bne.n	3400766c <HAL_RCCEx_PeriphCLKConfig+0x1208>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34007646:	4ab2      	ldr	r2, [pc, #712]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
34007648:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400764a:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400764e:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
34007650:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007654:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007658:	3901      	subs	r1, #1
3400765a:	433b      	orrs	r3, r7
3400765c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007660:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34007664:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34007668:	f7ff b9d4 	b.w	34006a14 <HAL_RCCEx_PeriphCLKConfig+0x5b0>
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3400766c:	4ba9      	ldr	r3, [pc, #676]	@ (34007914 <HAL_RCCEx_PeriphCLKConfig+0x14b0>)
3400766e:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007670:	bf02      	ittt	eq
34007672:	2240      	moveq	r2, #64	@ 0x40
34007674:	4ba6      	ldreq	r3, [pc, #664]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
34007676:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400767a:	f7ff b9cd 	b.w	34006a18 <HAL_RCCEx_PeriphCLKConfig+0x5b4>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3400767e:	4ba6      	ldr	r3, [pc, #664]	@ (34007918 <HAL_RCCEx_PeriphCLKConfig+0x14b4>)
34007680:	4298      	cmp	r0, r3
34007682:	d112      	bne.n	340076aa <HAL_RCCEx_PeriphCLKConfig+0x1246>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34007684:	4aa2      	ldr	r2, [pc, #648]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
34007686:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
34007688:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400768c:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3400768e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007692:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007696:	3901      	subs	r1, #1
34007698:	433b      	orrs	r3, r7
3400769a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400769e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
340076a2:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
340076a6:	f7ff b9d2 	b.w	34006a4e <HAL_RCCEx_PeriphCLKConfig+0x5ea>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
340076aa:	4b9c      	ldr	r3, [pc, #624]	@ (3400791c <HAL_RCCEx_PeriphCLKConfig+0x14b8>)
340076ac:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340076ae:	bf02      	ittt	eq
340076b0:	2240      	moveq	r2, #64	@ 0x40
340076b2:	4b97      	ldreq	r3, [pc, #604]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340076b4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340076b8:	f7ff b9cb 	b.w	34006a52 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
340076bc:	4b98      	ldr	r3, [pc, #608]	@ (34007920 <HAL_RCCEx_PeriphCLKConfig+0x14bc>)
340076be:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340076c0:	bf02      	ittt	eq
340076c2:	2240      	moveq	r2, #64	@ 0x40
340076c4:	4b92      	ldreq	r3, [pc, #584]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340076c6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340076ca:	f7ff b9df 	b.w	34006a8c <HAL_RCCEx_PeriphCLKConfig+0x628>
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
340076ce:	4b95      	ldr	r3, [pc, #596]	@ (34007924 <HAL_RCCEx_PeriphCLKConfig+0x14c0>)
340076d0:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340076d2:	bf02      	ittt	eq
340076d4:	2240      	moveq	r2, #64	@ 0x40
340076d6:	4b8e      	ldreq	r3, [pc, #568]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340076d8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340076dc:	f7ff b9f3 	b.w	34006ac6 <HAL_RCCEx_PeriphCLKConfig+0x662>
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
340076e0:	4b91      	ldr	r3, [pc, #580]	@ (34007928 <HAL_RCCEx_PeriphCLKConfig+0x14c4>)
340076e2:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340076e4:	bf02      	ittt	eq
340076e6:	2240      	moveq	r2, #64	@ 0x40
340076e8:	4b89      	ldreq	r3, [pc, #548]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340076ea:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340076ee:	f7ff ba07 	b.w	34006b00 <HAL_RCCEx_PeriphCLKConfig+0x69c>
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
340076f2:	4b8e      	ldr	r3, [pc, #568]	@ (3400792c <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
340076f4:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340076f6:	bf02      	ittt	eq
340076f8:	2240      	moveq	r2, #64	@ 0x40
340076fa:	4b85      	ldreq	r3, [pc, #532]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340076fc:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007700:	f7ff ba1b 	b.w	34006b3a <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
34007704:	4b8a      	ldr	r3, [pc, #552]	@ (34007930 <HAL_RCCEx_PeriphCLKConfig+0x14cc>)
34007706:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007708:	bf02      	ittt	eq
3400770a:	2240      	moveq	r2, #64	@ 0x40
3400770c:	4b80      	ldreq	r3, [pc, #512]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3400770e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007712:	f7ff ba2f 	b.w	34006b74 <HAL_RCCEx_PeriphCLKConfig+0x710>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
34007716:	f5b1 7f40 	cmp.w	r1, #768	@ 0x300
3400771a:	d111      	bne.n	34007740 <HAL_RCCEx_PeriphCLKConfig+0x12dc>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400771c:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007720:	6f60      	ldr	r0, [r4, #116]	@ 0x74
34007722:	6f27      	ldr	r7, [r4, #112]	@ 0x70
34007724:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007728:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400772c:	3801      	subs	r0, #1
3400772e:	433b      	orrs	r3, r7
34007730:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34007734:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007738:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400773c:	f7ff ba35 	b.w	34006baa <HAL_RCCEx_PeriphCLKConfig+0x746>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
34007740:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007744:	bf04      	itt	eq
34007746:	2340      	moveq	r3, #64	@ 0x40
34007748:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3400774c:	f7ff ba2f 	b.w	34006bae <HAL_RCCEx_PeriphCLKConfig+0x74a>
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
34007750:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007754:	bf04      	itt	eq
34007756:	2340      	moveq	r3, #64	@ 0x40
34007758:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3400775c:	f7ff ba65 	b.w	34006c2a <HAL_RCCEx_PeriphCLKConfig+0x7c6>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
34007760:	f5b1 3f40 	cmp.w	r1, #196608	@ 0x30000
34007764:	d110      	bne.n	34007788 <HAL_RCCEx_PeriphCLKConfig+0x1324>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34007766:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400776a:	6c60      	ldr	r0, [r4, #68]	@ 0x44
3400776c:	6c27      	ldr	r7, [r4, #64]	@ 0x40
3400776e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007772:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007776:	3801      	subs	r0, #1
34007778:	433b      	orrs	r3, r7
3400777a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400777e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34007782:	2380      	movs	r3, #128	@ 0x80
34007784:	f7ff ba71 	b.w	34006c6a <HAL_RCCEx_PeriphCLKConfig+0x806>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
34007788:	f5b1 3f80 	cmp.w	r1, #65536	@ 0x10000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400778c:	bf04      	itt	eq
3400778e:	2340      	moveq	r3, #64	@ 0x40
34007790:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
34007794:	f7ff ba6b 	b.w	34006c6e <HAL_RCCEx_PeriphCLKConfig+0x80a>
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
34007798:	2910      	cmp	r1, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400779a:	bf04      	itt	eq
3400779c:	2340      	moveq	r3, #64	@ 0x40
3400779e:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
340077a2:	f7ff ba88 	b.w	34006cb6 <HAL_RCCEx_PeriphCLKConfig+0x852>
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
340077a6:	4b63      	ldr	r3, [pc, #396]	@ (34007934 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
340077a8:	4298      	cmp	r0, r3
340077aa:	d111      	bne.n	340077d0 <HAL_RCCEx_PeriphCLKConfig+0x136c>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
340077ac:	4a58      	ldr	r2, [pc, #352]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340077ae:	6c61      	ldr	r1, [r4, #68]	@ 0x44
340077b0:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
340077b4:	6c27      	ldr	r7, [r4, #64]	@ 0x40
340077b6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340077ba:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340077be:	3901      	subs	r1, #1
340077c0:	433b      	orrs	r3, r7
340077c2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340077c6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
340077ca:	2380      	movs	r3, #128	@ 0x80
340077cc:	f7ff ba93 	b.w	34006cf6 <HAL_RCCEx_PeriphCLKConfig+0x892>
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
340077d0:	4b59      	ldr	r3, [pc, #356]	@ (34007938 <HAL_RCCEx_PeriphCLKConfig+0x14d4>)
340077d2:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340077d4:	bf02      	ittt	eq
340077d6:	2240      	moveq	r2, #64	@ 0x40
340077d8:	4b4d      	ldreq	r3, [pc, #308]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340077da:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340077de:	f7ff ba8c 	b.w	34006cfa <HAL_RCCEx_PeriphCLKConfig+0x896>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
340077e2:	4b56      	ldr	r3, [pc, #344]	@ (3400793c <HAL_RCCEx_PeriphCLKConfig+0x14d8>)
340077e4:	4298      	cmp	r0, r3
340077e6:	d111      	bne.n	3400780c <HAL_RCCEx_PeriphCLKConfig+0x13a8>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
340077e8:	4a49      	ldr	r2, [pc, #292]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340077ea:	6c61      	ldr	r1, [r4, #68]	@ 0x44
340077ec:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
340077f0:	6c25      	ldr	r5, [r4, #64]	@ 0x40
340077f2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340077f6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340077fa:	3901      	subs	r1, #1
340077fc:	432b      	orrs	r3, r5
340077fe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007802:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34007806:	2380      	movs	r3, #128	@ 0x80
34007808:	f7ff ba91 	b.w	34006d2e <HAL_RCCEx_PeriphCLKConfig+0x8ca>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
3400780c:	4b4c      	ldr	r3, [pc, #304]	@ (34007940 <HAL_RCCEx_PeriphCLKConfig+0x14dc>)
3400780e:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007810:	bf02      	ittt	eq
34007812:	2240      	moveq	r2, #64	@ 0x40
34007814:	4b3e      	ldreq	r3, [pc, #248]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
34007816:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400781a:	f7ff ba8a 	b.w	34006d32 <HAL_RCCEx_PeriphCLKConfig+0x8ce>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
3400781e:	2903      	cmp	r1, #3
34007820:	d110      	bne.n	34007844 <HAL_RCCEx_PeriphCLKConfig+0x13e0>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34007822:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
34007826:	6c60      	ldr	r0, [r4, #68]	@ 0x44
34007828:	6c25      	ldr	r5, [r4, #64]	@ 0x40
3400782a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400782e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007832:	3801      	subs	r0, #1
34007834:	432b      	orrs	r3, r5
34007836:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400783a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400783e:	2380      	movs	r3, #128	@ 0x80
34007840:	f7ff ba90 	b.w	34006d64 <HAL_RCCEx_PeriphCLKConfig+0x900>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
34007844:	2901      	cmp	r1, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007846:	bf04      	itt	eq
34007848:	2340      	moveq	r3, #64	@ 0x40
3400784a:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3400784e:	f7ff ba8b 	b.w	34006d68 <HAL_RCCEx_PeriphCLKConfig+0x904>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
34007852:	4b3c      	ldr	r3, [pc, #240]	@ (34007944 <HAL_RCCEx_PeriphCLKConfig+0x14e0>)
34007854:	4298      	cmp	r0, r3
34007856:	d112      	bne.n	3400787e <HAL_RCCEx_PeriphCLKConfig+0x141a>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007858:	4a2d      	ldr	r2, [pc, #180]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3400785a:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400785c:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
34007860:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34007862:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007866:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400786a:	3901      	subs	r1, #1
3400786c:	432b      	orrs	r3, r5
3400786e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007872:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34007876:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400787a:	f7ff ba95 	b.w	34006da8 <HAL_RCCEx_PeriphCLKConfig+0x944>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
3400787e:	4b32      	ldr	r3, [pc, #200]	@ (34007948 <HAL_RCCEx_PeriphCLKConfig+0x14e4>)
34007880:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007882:	bf02      	ittt	eq
34007884:	2240      	moveq	r2, #64	@ 0x40
34007886:	4b22      	ldreq	r3, [pc, #136]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
34007888:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400788c:	f7ff ba8e 	b.w	34006dac <HAL_RCCEx_PeriphCLKConfig+0x948>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
34007890:	4b2e      	ldr	r3, [pc, #184]	@ (3400794c <HAL_RCCEx_PeriphCLKConfig+0x14e8>)
34007892:	4298      	cmp	r0, r3
34007894:	d112      	bne.n	340078bc <HAL_RCCEx_PeriphCLKConfig+0x1458>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007896:	4a1e      	ldr	r2, [pc, #120]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
34007898:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400789a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400789e:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
340078a0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340078a4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340078a8:	3901      	subs	r1, #1
340078aa:	432b      	orrs	r3, r5
340078ac:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340078b0:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
340078b4:	f44f 7380 	mov.w	r3, #256	@ 0x100
340078b8:	f7ff ba92 	b.w	34006de0 <HAL_RCCEx_PeriphCLKConfig+0x97c>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
340078bc:	4b24      	ldr	r3, [pc, #144]	@ (34007950 <HAL_RCCEx_PeriphCLKConfig+0x14ec>)
340078be:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340078c0:	bf02      	ittt	eq
340078c2:	2240      	moveq	r2, #64	@ 0x40
340078c4:	4b12      	ldreq	r3, [pc, #72]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340078c6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340078ca:	f7ff ba8b 	b.w	34006de4 <HAL_RCCEx_PeriphCLKConfig+0x980>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
340078ce:	4b21      	ldr	r3, [pc, #132]	@ (34007954 <HAL_RCCEx_PeriphCLKConfig+0x14f0>)
340078d0:	4298      	cmp	r0, r3
340078d2:	d112      	bne.n	340078fa <HAL_RCCEx_PeriphCLKConfig+0x1496>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340078d4:	4a0e      	ldr	r2, [pc, #56]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
340078d6:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
340078d8:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
340078dc:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
340078de:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340078e2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340078e6:	3901      	subs	r1, #1
340078e8:	432b      	orrs	r3, r5
340078ea:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340078ee:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
340078f2:	f44f 7380 	mov.w	r3, #256	@ 0x100
340078f6:	f7ff ba8f 	b.w	34006e18 <HAL_RCCEx_PeriphCLKConfig+0x9b4>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
340078fa:	4b17      	ldr	r3, [pc, #92]	@ (34007958 <HAL_RCCEx_PeriphCLKConfig+0x14f4>)
340078fc:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340078fe:	bf02      	ittt	eq
34007900:	2240      	moveq	r2, #64	@ 0x40
34007902:	4b03      	ldreq	r3, [pc, #12]	@ (34007910 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
34007904:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007908:	f7ff ba88 	b.w	34006e1c <HAL_RCCEx_PeriphCLKConfig+0x9b8>
3400790c:	0703100c 	.word	0x0703100c
34007910:	56028000 	.word	0x56028000
34007914:	0701100c 	.word	0x0701100c
34007918:	0703140c 	.word	0x0703140c
3400791c:	0701140c 	.word	0x0701140c
34007920:	0701082c 	.word	0x0701082c
34007924:	07010c2c 	.word	0x07010c2c
34007928:	0701102c 	.word	0x0701102c
3400792c:	0701142c 	.word	0x0701142c
34007930:	0701182c 	.word	0x0701182c
34007934:	07031418 	.word	0x07031418
34007938:	07011418 	.word	0x07011418
3400793c:	07031818 	.word	0x07031818
34007940:	07011818 	.word	0x07011818
34007944:	07030420 	.word	0x07030420
34007948:	07010420 	.word	0x07010420
3400794c:	07030820 	.word	0x07030820
34007950:	07010820 	.word	0x07010820
34007954:	07030c20 	.word	0x07030c20
34007958:	07010c20 	.word	0x07010c20
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3400795c:	4bb9      	ldr	r3, [pc, #740]	@ (34007c44 <HAL_RCCEx_PeriphCLKConfig+0x17e0>)
3400795e:	4298      	cmp	r0, r3
34007960:	d112      	bne.n	34007988 <HAL_RCCEx_PeriphCLKConfig+0x1524>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007962:	4ab9      	ldr	r2, [pc, #740]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007964:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007966:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400796a:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3400796c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007970:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007974:	3901      	subs	r1, #1
34007976:	432b      	orrs	r3, r5
34007978:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400797c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007980:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007984:	f7ff ba65 	b.w	34006e52 <HAL_RCCEx_PeriphCLKConfig+0x9ee>
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
34007988:	4bb0      	ldr	r3, [pc, #704]	@ (34007c4c <HAL_RCCEx_PeriphCLKConfig+0x17e8>)
3400798a:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400798c:	bf02      	ittt	eq
3400798e:	2240      	moveq	r2, #64	@ 0x40
34007990:	4bad      	ldreq	r3, [pc, #692]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007992:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007996:	f7ff ba5e 	b.w	34006e56 <HAL_RCCEx_PeriphCLKConfig+0x9f2>
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
3400799a:	4bad      	ldr	r3, [pc, #692]	@ (34007c50 <HAL_RCCEx_PeriphCLKConfig+0x17ec>)
3400799c:	4298      	cmp	r0, r3
3400799e:	d112      	bne.n	340079c6 <HAL_RCCEx_PeriphCLKConfig+0x1562>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340079a0:	4aa9      	ldr	r2, [pc, #676]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
340079a2:	6f61      	ldr	r1, [r4, #116]	@ 0x74
340079a4:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
340079a8:	6f25      	ldr	r5, [r4, #112]	@ 0x70
340079aa:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340079ae:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340079b2:	3901      	subs	r1, #1
340079b4:	432b      	orrs	r3, r5
340079b6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340079ba:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
340079be:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
340079c2:	f7ff ba63 	b.w	34006e8c <HAL_RCCEx_PeriphCLKConfig+0xa28>
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
340079c6:	4ba3      	ldr	r3, [pc, #652]	@ (34007c54 <HAL_RCCEx_PeriphCLKConfig+0x17f0>)
340079c8:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340079ca:	bf02      	ittt	eq
340079cc:	2240      	moveq	r2, #64	@ 0x40
340079ce:	4b9e      	ldreq	r3, [pc, #632]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
340079d0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
340079d4:	f7ff ba5c 	b.w	34006e90 <HAL_RCCEx_PeriphCLKConfig+0xa2c>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
340079d8:	4b9f      	ldr	r3, [pc, #636]	@ (34007c58 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
340079da:	4298      	cmp	r0, r3
340079dc:	d112      	bne.n	34007a04 <HAL_RCCEx_PeriphCLKConfig+0x15a0>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340079de:	4a9a      	ldr	r2, [pc, #616]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
340079e0:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
340079e2:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
340079e6:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
340079e8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340079ec:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340079f0:	3901      	subs	r1, #1
340079f2:	432b      	orrs	r3, r5
340079f4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340079f8:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
340079fc:	f44f 7380 	mov.w	r3, #256	@ 0x100
34007a00:	f7ff ba60 	b.w	34006ec4 <HAL_RCCEx_PeriphCLKConfig+0xa60>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
34007a04:	4b95      	ldr	r3, [pc, #596]	@ (34007c5c <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
34007a06:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007a08:	bf02      	ittt	eq
34007a0a:	2240      	moveq	r2, #64	@ 0x40
34007a0c:	4b8e      	ldreq	r3, [pc, #568]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007a0e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007a12:	f7ff ba59 	b.w	34006ec8 <HAL_RCCEx_PeriphCLKConfig+0xa64>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
34007a16:	4b92      	ldr	r3, [pc, #584]	@ (34007c60 <HAL_RCCEx_PeriphCLKConfig+0x17fc>)
34007a18:	4298      	cmp	r0, r3
34007a1a:	d112      	bne.n	34007a42 <HAL_RCCEx_PeriphCLKConfig+0x15de>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007a1c:	4a8a      	ldr	r2, [pc, #552]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007a1e:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007a20:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007a24:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007a26:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007a2a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007a2e:	3901      	subs	r1, #1
34007a30:	432b      	orrs	r3, r5
34007a32:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007a36:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007a3a:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007a3e:	f7ff ba5e 	b.w	34006efe <HAL_RCCEx_PeriphCLKConfig+0xa9a>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
34007a42:	4b88      	ldr	r3, [pc, #544]	@ (34007c64 <HAL_RCCEx_PeriphCLKConfig+0x1800>)
34007a44:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007a46:	bf02      	ittt	eq
34007a48:	2240      	moveq	r2, #64	@ 0x40
34007a4a:	4b7f      	ldreq	r3, [pc, #508]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007a4c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007a50:	f7ff ba57 	b.w	34006f02 <HAL_RCCEx_PeriphCLKConfig+0xa9e>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
34007a54:	4b84      	ldr	r3, [pc, #528]	@ (34007c68 <HAL_RCCEx_PeriphCLKConfig+0x1804>)
34007a56:	4298      	cmp	r0, r3
34007a58:	d112      	bne.n	34007a80 <HAL_RCCEx_PeriphCLKConfig+0x161c>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007a5a:	4a7b      	ldr	r2, [pc, #492]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007a5c:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007a5e:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007a62:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007a64:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007a68:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007a6c:	3901      	subs	r1, #1
34007a6e:	432b      	orrs	r3, r5
34007a70:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007a74:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007a78:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007a7c:	f7ff ba73 	b.w	34006f66 <HAL_RCCEx_PeriphCLKConfig+0xb02>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
34007a80:	4b7a      	ldr	r3, [pc, #488]	@ (34007c6c <HAL_RCCEx_PeriphCLKConfig+0x1808>)
34007a82:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007a84:	bf02      	ittt	eq
34007a86:	2240      	moveq	r2, #64	@ 0x40
34007a88:	4b6f      	ldreq	r3, [pc, #444]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007a8a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007a8e:	f7ff ba6c 	b.w	34006f6a <HAL_RCCEx_PeriphCLKConfig+0xb06>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
34007a92:	4b77      	ldr	r3, [pc, #476]	@ (34007c70 <HAL_RCCEx_PeriphCLKConfig+0x180c>)
34007a94:	4298      	cmp	r0, r3
34007a96:	d112      	bne.n	34007abe <HAL_RCCEx_PeriphCLKConfig+0x165a>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007a98:	4a6b      	ldr	r2, [pc, #428]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007a9a:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007a9c:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007aa0:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007aa2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007aa6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007aaa:	3901      	subs	r1, #1
34007aac:	432b      	orrs	r3, r5
34007aae:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007ab2:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007ab6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007aba:	f7ff ba71 	b.w	34006fa0 <HAL_RCCEx_PeriphCLKConfig+0xb3c>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
34007abe:	4b6d      	ldr	r3, [pc, #436]	@ (34007c74 <HAL_RCCEx_PeriphCLKConfig+0x1810>)
34007ac0:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007ac2:	bf02      	ittt	eq
34007ac4:	2240      	moveq	r2, #64	@ 0x40
34007ac6:	4b60      	ldreq	r3, [pc, #384]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007ac8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007acc:	f7ff ba6a 	b.w	34006fa4 <HAL_RCCEx_PeriphCLKConfig+0xb40>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
34007ad0:	4b69      	ldr	r3, [pc, #420]	@ (34007c78 <HAL_RCCEx_PeriphCLKConfig+0x1814>)
34007ad2:	4298      	cmp	r0, r3
34007ad4:	d112      	bne.n	34007afc <HAL_RCCEx_PeriphCLKConfig+0x1698>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007ad6:	4a5c      	ldr	r2, [pc, #368]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007ad8:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007ada:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007ade:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007ae0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007ae4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007ae8:	3901      	subs	r1, #1
34007aea:	432b      	orrs	r3, r5
34007aec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007af0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007af4:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007af8:	f7ff ba6f 	b.w	34006fda <HAL_RCCEx_PeriphCLKConfig+0xb76>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
34007afc:	4b5f      	ldr	r3, [pc, #380]	@ (34007c7c <HAL_RCCEx_PeriphCLKConfig+0x1818>)
34007afe:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007b00:	bf02      	ittt	eq
34007b02:	2240      	moveq	r2, #64	@ 0x40
34007b04:	4b50      	ldreq	r3, [pc, #320]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007b06:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007b0a:	f7ff ba68 	b.w	34006fde <HAL_RCCEx_PeriphCLKConfig+0xb7a>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
34007b0e:	4b5c      	ldr	r3, [pc, #368]	@ (34007c80 <HAL_RCCEx_PeriphCLKConfig+0x181c>)
34007b10:	4298      	cmp	r0, r3
34007b12:	d112      	bne.n	34007b3a <HAL_RCCEx_PeriphCLKConfig+0x16d6>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007b14:	4a4c      	ldr	r2, [pc, #304]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007b16:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007b18:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007b1c:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007b1e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007b22:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007b26:	3901      	subs	r1, #1
34007b28:	432b      	orrs	r3, r5
34007b2a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007b2e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007b32:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007b36:	f7ff ba6d 	b.w	34007014 <HAL_RCCEx_PeriphCLKConfig+0xbb0>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
34007b3a:	4b52      	ldr	r3, [pc, #328]	@ (34007c84 <HAL_RCCEx_PeriphCLKConfig+0x1820>)
34007b3c:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007b3e:	bf02      	ittt	eq
34007b40:	2240      	moveq	r2, #64	@ 0x40
34007b42:	4b41      	ldreq	r3, [pc, #260]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007b44:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007b48:	f7ff ba66 	b.w	34007018 <HAL_RCCEx_PeriphCLKConfig+0xbb4>
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
34007b4c:	4b4e      	ldr	r3, [pc, #312]	@ (34007c88 <HAL_RCCEx_PeriphCLKConfig+0x1824>)
34007b4e:	4298      	cmp	r0, r3
34007b50:	d112      	bne.n	34007b78 <HAL_RCCEx_PeriphCLKConfig+0x1714>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007b52:	4a3d      	ldr	r2, [pc, #244]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007b54:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007b56:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007b5a:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007b5c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007b60:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007b64:	3901      	subs	r1, #1
34007b66:	432b      	orrs	r3, r5
34007b68:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007b6c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007b70:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007b74:	f7ff ba6b 	b.w	3400704e <HAL_RCCEx_PeriphCLKConfig+0xbea>
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
34007b78:	4b44      	ldr	r3, [pc, #272]	@ (34007c8c <HAL_RCCEx_PeriphCLKConfig+0x1828>)
34007b7a:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007b7c:	bf02      	ittt	eq
34007b7e:	2240      	moveq	r2, #64	@ 0x40
34007b80:	4b31      	ldreq	r3, [pc, #196]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007b82:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007b86:	f7ff ba64 	b.w	34007052 <HAL_RCCEx_PeriphCLKConfig+0xbee>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
34007b8a:	4b41      	ldr	r3, [pc, #260]	@ (34007c90 <HAL_RCCEx_PeriphCLKConfig+0x182c>)
34007b8c:	4298      	cmp	r0, r3
34007b8e:	d112      	bne.n	34007bb6 <HAL_RCCEx_PeriphCLKConfig+0x1752>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007b90:	4a2d      	ldr	r2, [pc, #180]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007b92:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007b94:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007b98:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007b9a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007b9e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007ba2:	3901      	subs	r1, #1
34007ba4:	432b      	orrs	r3, r5
34007ba6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007baa:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007bae:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007bb2:	f7ff ba69 	b.w	34007088 <HAL_RCCEx_PeriphCLKConfig+0xc24>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
34007bb6:	4b37      	ldr	r3, [pc, #220]	@ (34007c94 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
34007bb8:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007bba:	bf02      	ittt	eq
34007bbc:	2240      	moveq	r2, #64	@ 0x40
34007bbe:	4b22      	ldreq	r3, [pc, #136]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007bc0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007bc4:	f7ff ba62 	b.w	3400708c <HAL_RCCEx_PeriphCLKConfig+0xc28>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
34007bc8:	4b33      	ldr	r3, [pc, #204]	@ (34007c98 <HAL_RCCEx_PeriphCLKConfig+0x1834>)
34007bca:	4298      	cmp	r0, r3
34007bcc:	d112      	bne.n	34007bf4 <HAL_RCCEx_PeriphCLKConfig+0x1790>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007bce:	4a1e      	ldr	r2, [pc, #120]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007bd0:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007bd2:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007bd6:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007bd8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007bdc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007be0:	3901      	subs	r1, #1
34007be2:	432b      	orrs	r3, r5
34007be4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007be8:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007bec:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007bf0:	f7ff ba67 	b.w	340070c2 <HAL_RCCEx_PeriphCLKConfig+0xc5e>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
34007bf4:	4b29      	ldr	r3, [pc, #164]	@ (34007c9c <HAL_RCCEx_PeriphCLKConfig+0x1838>)
34007bf6:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007bf8:	bf02      	ittt	eq
34007bfa:	2240      	moveq	r2, #64	@ 0x40
34007bfc:	4b12      	ldreq	r3, [pc, #72]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007bfe:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007c02:	f7ff ba60 	b.w	340070c6 <HAL_RCCEx_PeriphCLKConfig+0xc62>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
34007c06:	4b26      	ldr	r3, [pc, #152]	@ (34007ca0 <HAL_RCCEx_PeriphCLKConfig+0x183c>)
34007c08:	4298      	cmp	r0, r3
34007c0a:	d112      	bne.n	34007c32 <HAL_RCCEx_PeriphCLKConfig+0x17ce>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007c0c:	4a0e      	ldr	r2, [pc, #56]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007c0e:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007c10:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007c14:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007c16:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007c1a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007c1e:	3901      	subs	r1, #1
34007c20:	432b      	orrs	r3, r5
34007c22:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007c26:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007c2a:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007c2e:	f7ff ba65 	b.w	340070fc <HAL_RCCEx_PeriphCLKConfig+0xc98>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
34007c32:	4b1c      	ldr	r3, [pc, #112]	@ (34007ca4 <HAL_RCCEx_PeriphCLKConfig+0x1840>)
34007c34:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007c36:	bf02      	ittt	eq
34007c38:	2240      	moveq	r2, #64	@ 0x40
34007c3a:	4b03      	ldreq	r3, [pc, #12]	@ (34007c48 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
34007c3c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007c40:	f7ff ba5e 	b.w	34007100 <HAL_RCCEx_PeriphCLKConfig+0xc9c>
34007c44:	07031020 	.word	0x07031020
34007c48:	56028000 	.word	0x56028000
34007c4c:	07011020 	.word	0x07011020
34007c50:	07031420 	.word	0x07031420
34007c54:	07011420 	.word	0x07011420
34007c58:	07031820 	.word	0x07031820
34007c5c:	07011820 	.word	0x07011820
34007c60:	07030030 	.word	0x07030030
34007c64:	07010030 	.word	0x07010030
34007c68:	07030430 	.word	0x07030430
34007c6c:	07010430 	.word	0x07010430
34007c70:	07030830 	.word	0x07030830
34007c74:	07010830 	.word	0x07010830
34007c78:	07030c30 	.word	0x07030c30
34007c7c:	07010c30 	.word	0x07010c30
34007c80:	07031030 	.word	0x07031030
34007c84:	07011030 	.word	0x07011030
34007c88:	07031430 	.word	0x07031430
34007c8c:	07011430 	.word	0x07011430
34007c90:	07031830 	.word	0x07031830
34007c94:	07011830 	.word	0x07011830
34007c98:	07031c30 	.word	0x07031c30
34007c9c:	07011c30 	.word	0x07011c30
34007ca0:	07030034 	.word	0x07030034
34007ca4:	07010034 	.word	0x07010034
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
34007ca8:	4b20      	ldr	r3, [pc, #128]	@ (34007d2c <HAL_RCCEx_PeriphCLKConfig+0x18c8>)
34007caa:	4298      	cmp	r0, r3
34007cac:	d112      	bne.n	34007cd4 <HAL_RCCEx_PeriphCLKConfig+0x1870>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007cae:	4a20      	ldr	r2, [pc, #128]	@ (34007d30 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
34007cb0:	6f61      	ldr	r1, [r4, #116]	@ 0x74
34007cb2:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
34007cb6:	6f25      	ldr	r5, [r4, #112]	@ 0x70
34007cb8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007cbc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34007cc0:	3901      	subs	r1, #1
34007cc2:	432b      	orrs	r3, r5
34007cc4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34007cc8:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34007ccc:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34007cd0:	f7ff ba31 	b.w	34007136 <HAL_RCCEx_PeriphCLKConfig+0xcd2>
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
34007cd4:	4b17      	ldr	r3, [pc, #92]	@ (34007d34 <HAL_RCCEx_PeriphCLKConfig+0x18d0>)
34007cd6:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007cd8:	bf02      	ittt	eq
34007cda:	2240      	moveq	r2, #64	@ 0x40
34007cdc:	4b14      	ldreq	r3, [pc, #80]	@ (34007d30 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
34007cde:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007ce2:	f7ff ba2a 	b.w	3400713a <HAL_RCCEx_PeriphCLKConfig+0xcd6>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
34007ce6:	f7fe faa1 	bl	3400622c <LL_RCC_HSE_SelectHSEAsDiv2Clock>
34007cea:	f7ff ba37 	b.w	3400715c <HAL_RCCEx_PeriphCLKConfig+0xcf8>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
34007cee:	f7fe fa9d 	bl	3400622c <LL_RCC_HSE_SelectHSEAsDiv2Clock>
34007cf2:	f7ff ba42 	b.w	3400717a <HAL_RCCEx_PeriphCLKConfig+0xd16>
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
34007cf6:	4b10      	ldr	r3, [pc, #64]	@ (34007d38 <HAL_RCCEx_PeriphCLKConfig+0x18d4>)
34007cf8:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007cfa:	bf02      	ittt	eq
34007cfc:	2240      	moveq	r2, #64	@ 0x40
34007cfe:	4b0c      	ldreq	r3, [pc, #48]	@ (34007d30 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
34007d00:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007d04:	f7ff ba54 	b.w	340071b0 <HAL_RCCEx_PeriphCLKConfig+0xd4c>
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
34007d08:	f7fe fa90 	bl	3400622c <LL_RCC_HSE_SelectHSEAsDiv2Clock>
34007d0c:	f7ff ba5b 	b.w	340071c6 <HAL_RCCEx_PeriphCLKConfig+0xd62>
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
34007d10:	4b0a      	ldr	r3, [pc, #40]	@ (34007d3c <HAL_RCCEx_PeriphCLKConfig+0x18d8>)
34007d12:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34007d14:	bf02      	ittt	eq
34007d16:	2240      	moveq	r2, #64	@ 0x40
34007d18:	4b05      	ldreq	r3, [pc, #20]	@ (34007d30 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
34007d1a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
34007d1e:	f7ff ba6d 	b.w	340071fc <HAL_RCCEx_PeriphCLKConfig+0xd98>
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
34007d22:	f7fe fa83 	bl	3400622c <LL_RCC_HSE_SelectHSEAsDiv2Clock>
34007d26:	f7ff ba74 	b.w	34007212 <HAL_RCCEx_PeriphCLKConfig+0xdae>
34007d2a:	bf00      	nop
34007d2c:	07030434 	.word	0x07030434
34007d30:	56028000 	.word	0x56028000
34007d34:	07010434 	.word	0x07010434
34007d38:	03010c14 	.word	0x03010c14
34007d3c:	03011414 	.word	0x03011414

34007d40 <HAL_RCCEx_GetPLL1CLKFreq>:
{
34007d40:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
34007d42:	4c1e      	ldr	r4, [pc, #120]	@ (34007dbc <HAL_RCCEx_GetPLL1CLKFreq+0x7c>)
34007d44:	6863      	ldr	r3, [r4, #4]
34007d46:	05d9      	lsls	r1, r3, #23
34007d48:	d506      	bpl.n	34007d58 <HAL_RCCEx_GetPLL1CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
34007d4a:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
34007d4e:	005a      	lsls	r2, r3, #1
34007d50:	d40f      	bmi.n	34007d72 <HAL_RCCEx_GetPLL1CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34007d52:	2000      	movs	r0, #0
}
34007d54:	b003      	add	sp, #12
34007d56:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34007d58:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
34007d5c:	011b      	lsls	r3, r3, #4
34007d5e:	d5f8      	bpl.n	34007d52 <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34007d60:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34007d64:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
34007d68:	b003      	add	sp, #12
34007d6a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34007d6e:	f7fe bb17 	b.w	340063a0 <RCCEx_GetPLLSourceFreq>
34007d72:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34007d76:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
34007d7a:	f7fe fb11 	bl	340063a0 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34007d7e:	2800      	cmp	r0, #0
34007d80:	d0e7      	beq.n	34007d52 <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
34007d82:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
        if (divm != 0U)
34007d86:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
34007d8a:	f3c3 5105 	ubfx	r1, r3, #20, #6
34007d8e:	d0e0      	beq.n	34007d52 <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
34007d90:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
34007d94:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
34007d98:	f8d4 5088 	ldr.w	r5, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
34007d9c:	f8d4 4088 	ldr.w	r4, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
34007da0:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
34007da4:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
34007da8:	9401      	str	r4, [sp, #4]
34007daa:	9500      	str	r5, [sp, #0]
34007dac:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34007db0:	f3c2 220b 	ubfx	r2, r2, #8, #12
34007db4:	f7fe fb2a 	bl	3400640c <RCCEx_CalcPLLFreq>
34007db8:	e7cc      	b.n	34007d54 <HAL_RCCEx_GetPLL1CLKFreq+0x14>
34007dba:	bf00      	nop
34007dbc:	56028000 	.word	0x56028000

34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>:
{
34007dc0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34007dc2:	4c1e      	ldr	r4, [pc, #120]	@ (34007e3c <HAL_RCCEx_GetPLL2CLKFreq+0x7c>)
34007dc4:	6863      	ldr	r3, [r4, #4]
34007dc6:	0599      	lsls	r1, r3, #22
34007dc8:	d506      	bpl.n	34007dd8 <HAL_RCCEx_GetPLL2CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
34007dca:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
34007dce:	005a      	lsls	r2, r3, #1
34007dd0:	d40f      	bmi.n	34007df2 <HAL_RCCEx_GetPLL2CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34007dd2:	2000      	movs	r0, #0
}
34007dd4:	b003      	add	sp, #12
34007dd6:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34007dd8:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
34007ddc:	011b      	lsls	r3, r3, #4
34007dde:	d5f8      	bpl.n	34007dd2 <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34007de0:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34007de4:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
34007de8:	b003      	add	sp, #12
34007dea:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34007dee:	f7fe bad7 	b.w	340063a0 <RCCEx_GetPLLSourceFreq>
34007df2:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34007df6:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
34007dfa:	f7fe fad1 	bl	340063a0 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34007dfe:	2800      	cmp	r0, #0
34007e00:	d0e7      	beq.n	34007dd2 <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
34007e02:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
        if (divm != 0U)
34007e06:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
34007e0a:	f3c3 5105 	ubfx	r1, r3, #20, #6
34007e0e:	d0e0      	beq.n	34007dd2 <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
34007e10:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
34007e14:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
34007e18:	f8d4 5098 	ldr.w	r5, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
34007e1c:	f8d4 4098 	ldr.w	r4, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
34007e20:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
34007e24:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
34007e28:	9401      	str	r4, [sp, #4]
34007e2a:	9500      	str	r5, [sp, #0]
34007e2c:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34007e30:	f3c2 220b 	ubfx	r2, r2, #8, #12
34007e34:	f7fe faea 	bl	3400640c <RCCEx_CalcPLLFreq>
34007e38:	e7cc      	b.n	34007dd4 <HAL_RCCEx_GetPLL2CLKFreq+0x14>
34007e3a:	bf00      	nop
34007e3c:	56028000 	.word	0x56028000

34007e40 <HAL_RCCEx_GetPLL3CLKFreq>:
{
34007e40:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
34007e42:	4c1e      	ldr	r4, [pc, #120]	@ (34007ebc <HAL_RCCEx_GetPLL3CLKFreq+0x7c>)
34007e44:	6863      	ldr	r3, [r4, #4]
34007e46:	0559      	lsls	r1, r3, #21
34007e48:	d506      	bpl.n	34007e58 <HAL_RCCEx_GetPLL3CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
34007e4a:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
34007e4e:	005a      	lsls	r2, r3, #1
34007e50:	d40f      	bmi.n	34007e72 <HAL_RCCEx_GetPLL3CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34007e52:	2000      	movs	r0, #0
}
34007e54:	b003      	add	sp, #12
34007e56:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34007e58:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
34007e5c:	011b      	lsls	r3, r3, #4
34007e5e:	d5f8      	bpl.n	34007e52 <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34007e60:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34007e64:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
34007e68:	b003      	add	sp, #12
34007e6a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34007e6e:	f7fe ba97 	b.w	340063a0 <RCCEx_GetPLLSourceFreq>
34007e72:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34007e76:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
34007e7a:	f7fe fa91 	bl	340063a0 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34007e7e:	2800      	cmp	r0, #0
34007e80:	d0e7      	beq.n	34007e52 <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
34007e82:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
        if (divm != 0U)
34007e86:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
34007e8a:	f3c3 5105 	ubfx	r1, r3, #20, #6
34007e8e:	d0e0      	beq.n	34007e52 <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
34007e90:	f8d4 20a0 	ldr.w	r2, [r4, #160]	@ 0xa0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
34007e94:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
34007e98:	f8d4 50a8 	ldr.w	r5, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
34007e9c:	f8d4 40a8 	ldr.w	r4, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
34007ea0:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
34007ea4:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
34007ea8:	9401      	str	r4, [sp, #4]
34007eaa:	9500      	str	r5, [sp, #0]
34007eac:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34007eb0:	f3c2 220b 	ubfx	r2, r2, #8, #12
34007eb4:	f7fe faaa 	bl	3400640c <RCCEx_CalcPLLFreq>
34007eb8:	e7cc      	b.n	34007e54 <HAL_RCCEx_GetPLL3CLKFreq+0x14>
34007eba:	bf00      	nop
34007ebc:	56028000 	.word	0x56028000

34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>:
{
34007ec0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34007ec2:	4c1e      	ldr	r4, [pc, #120]	@ (34007f3c <HAL_RCCEx_GetPLL4CLKFreq+0x7c>)
34007ec4:	6863      	ldr	r3, [r4, #4]
34007ec6:	0519      	lsls	r1, r3, #20
34007ec8:	d506      	bpl.n	34007ed8 <HAL_RCCEx_GetPLL4CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
34007eca:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
34007ece:	005a      	lsls	r2, r3, #1
34007ed0:	d40f      	bmi.n	34007ef2 <HAL_RCCEx_GetPLL4CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34007ed2:	2000      	movs	r0, #0
}
34007ed4:	b003      	add	sp, #12
34007ed6:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34007ed8:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
34007edc:	011b      	lsls	r3, r3, #4
34007ede:	d5f8      	bpl.n	34007ed2 <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34007ee0:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34007ee4:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
34007ee8:	b003      	add	sp, #12
34007eea:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34007eee:	f7fe ba57 	b.w	340063a0 <RCCEx_GetPLLSourceFreq>
34007ef2:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34007ef6:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
34007efa:	f7fe fa51 	bl	340063a0 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34007efe:	2800      	cmp	r0, #0
34007f00:	d0e7      	beq.n	34007ed2 <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
34007f02:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
        if (divm != 0U)
34007f06:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
34007f0a:	f3c3 5105 	ubfx	r1, r3, #20, #6
34007f0e:	d0e0      	beq.n	34007ed2 <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
34007f10:	f8d4 20b0 	ldr.w	r2, [r4, #176]	@ 0xb0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
34007f14:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
34007f18:	f8d4 50b8 	ldr.w	r5, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
34007f1c:	f8d4 40b8 	ldr.w	r4, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
34007f20:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
34007f24:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
34007f28:	9401      	str	r4, [sp, #4]
34007f2a:	9500      	str	r5, [sp, #0]
34007f2c:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34007f30:	f3c2 220b 	ubfx	r2, r2, #8, #12
34007f34:	f7fe fa6a 	bl	3400640c <RCCEx_CalcPLLFreq>
34007f38:	e7cc      	b.n	34007ed4 <HAL_RCCEx_GetPLL4CLKFreq+0x14>
34007f3a:	bf00      	nop
34007f3c:	56028000 	.word	0x56028000

34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>:
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
34007f40:	4b3e      	ldr	r3, [pc, #248]	@ (3400803c <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
  * @param  CLKPxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
34007f42:	b510      	push	{r4, lr}
34007f44:	f8d3 2248 	ldr.w	r2, [r3, #584]	@ 0x248
34007f48:	0652      	lsls	r2, r2, #25
34007f4a:	d56b      	bpl.n	34008024 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
34007f4c:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34007f50:	f002 0207 	and.w	r2, r2, #7
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
34007f54:	3a01      	subs	r2, #1
34007f56:	2a06      	cmp	r2, #6
34007f58:	d805      	bhi.n	34007f66 <RCCEx_GetCLKPCLKFreq.constprop.0+0x26>
34007f5a:	e8df f002 	tbb	[pc, r2]
34007f5e:	150f      	.short	0x150f
34007f60:	3e321b48 	.word	0x3e321b48
34007f64:	54          	.byte	0x54
34007f65:	00          	.byte	0x00
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
34007f66:	f7fe f981 	bl	3400626c <LL_RCC_HSI_IsReady>
34007f6a:	2800      	cmp	r0, #0
34007f6c:	d05a      	beq.n	34008024 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34007f6e:	4b33      	ldr	r3, [pc, #204]	@ (3400803c <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34007f70:	4833      	ldr	r0, [pc, #204]	@ (34008040 <RCCEx_GetCLKPCLKFreq.constprop.0+0x100>)
34007f72:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34007f74:	f3c3 13c1 	ubfx	r3, r3, #7, #2
34007f78:	40d8      	lsrs	r0, r3
34007f7a:	e054      	b.n	34008026 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
34007f7c:	f7fe f97e 	bl	3400627c <LL_RCC_MSI_IsReady>
34007f80:	2800      	cmp	r0, #0
34007f82:	d04f      	beq.n	34008024 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = MSI_VALUE;
34007f84:	482f      	ldr	r0, [pc, #188]	@ (34008044 <RCCEx_GetCLKPCLKFreq.constprop.0+0x104>)
34007f86:	e04e      	b.n	34008026 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
34007f88:	f7fe f968 	bl	3400625c <LL_RCC_HSE_IsReady>
34007f8c:	2800      	cmp	r0, #0
34007f8e:	d049      	beq.n	34008024 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = HSE_VALUE;
34007f90:	482d      	ldr	r0, [pc, #180]	@ (34008048 <RCCEx_GetCLKPCLKFreq.constprop.0+0x108>)
        /* Unexpected case */
        break;
    }
  }

  return clkp_frequency;
34007f92:	e048      	b.n	34008026 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
34007f94:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
34007f98:	06d4      	lsls	r4, r2, #27
34007f9a:	d543      	bpl.n	34008024 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
34007f9c:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
34007fa0:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
34007fa4:	f3c0 4007 	ubfx	r0, r0, #16, #8
34007fa8:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
34007faa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
          switch (LL_RCC_IC20_GetSource())
34007fae:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007fb2:	d03c      	beq.n	3400802e <RCCEx_GetCLKPCLKFreq.constprop.0+0xee>
34007fb4:	d833      	bhi.n	3400801e <RCCEx_GetCLKPCLKFreq.constprop.0+0xde>
34007fb6:	bbbb      	cbnz	r3, 34008028 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe8>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34007fb8:	f7ff fec2 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
              clkp_frequency = clkp_frequency / ic_divider;
34007fbc:	fbb0 f0f4 	udiv	r0, r0, r4
              break;
34007fc0:	e031      	b.n	34008026 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
34007fc2:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
34007fc6:	0590      	lsls	r0, r2, #22
34007fc8:	d52c      	bpl.n	34008024 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
34007fca:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
34007fce:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
34007fd2:	f3c0 4007 	ubfx	r0, r0, #16, #8
34007fd6:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
34007fd8:	e7e7      	b.n	34007faa <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
        if (LL_RCC_IC15_IsEnabled() != 0U)
34007fda:	f7fe f9c7 	bl	3400636c <LL_RCC_IC15_IsEnabled>
34007fde:	b308      	cbz	r0, 34008024 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
          ic_divider = LL_RCC_IC15_GetDivider();
34007fe0:	f7fe f9cc 	bl	3400637c <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
34007fe4:	4b15      	ldr	r3, [pc, #84]	@ (3400803c <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
34007fe6:	4604      	mov	r4, r0
34007fe8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34007fec:	e7dd      	b.n	34007faa <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
34007fee:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
34007ff2:	0351      	lsls	r1, r2, #13
34007ff4:	d516      	bpl.n	34008024 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
34007ff6:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
34007ffa:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
34007ffe:	f3c0 4007 	ubfx	r0, r0, #16, #8
34008002:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
34008004:	e7d1      	b.n	34007faa <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
34008006:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400800a:	0312      	lsls	r2, r2, #12
3400800c:	d50a      	bpl.n	34008024 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400800e:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
34008012:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
34008016:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400801a:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400801c:	e7c5      	b.n	34007faa <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
          switch (LL_RCC_IC20_GetSource())
3400801e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008022:	d007      	beq.n	34008034 <RCCEx_GetCLKPCLKFreq.constprop.0+0xf4>
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
34008024:	2000      	movs	r0, #0
}
34008026:	bd10      	pop	{r4, pc}
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008028:	f7ff feca 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
3400802c:	e7c6      	b.n	34007fbc <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400802e:	f7ff ff07 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
34008032:	e7c3      	b.n	34007fbc <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008034:	f7ff ff44 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
34008038:	e7c0      	b.n	34007fbc <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
3400803a:	bf00      	nop
3400803c:	56028000 	.word	0x56028000
34008040:	03d09000 	.word	0x03d09000
34008044:	003d0900 	.word	0x003d0900
34008048:	02dc6c00 	.word	0x02dc6c00

3400804c <RCCEx_GetSPDIFRXCLKFreq.constprop.0>:
  * @param  SPDIFRXxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
3400804c:	b538      	push	{r3, r4, r5, lr}
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
3400804e:	4d2b      	ldr	r5, [pc, #172]	@ (340080fc <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb0>)
34008050:	f8d5 3164 	ldr.w	r3, [r5, #356]	@ 0x164
34008054:	f003 0307 	and.w	r3, r3, #7
{
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
34008058:	2b06      	cmp	r3, #6
3400805a:	d835      	bhi.n	340080c8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
3400805c:	e8df f003 	tbb	[pc, r3]
34008060:	28110d04 	.word	0x28110d04
34008064:	3c45      	.short	0x3c45
34008066:	4b          	.byte	0x4b
34008067:	00          	.byte	0x00
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34008068:	f7fe f8d2 	bl	34006210 <HAL_RCC_GetSysClockFreq>
3400806c:	f7fe f990 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
34008070:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
34008072:	f003 0307 	and.w	r3, r3, #7
      break;

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34008076:	40d8      	lsrs	r0, r3
34008078:	e027      	b.n	340080ca <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      /* Unexpected case */
      break;
  }

  return spdifrx_frequency;
}
3400807a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400807e:	f7ff bf5f 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC7_IsEnabled() != 0U)
34008082:	f7fe f92b 	bl	340062dc <LL_RCC_IC7_IsEnabled>
34008086:	b1f8      	cbz	r0, 340080c8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC7_GetDivider();
34008088:	f7fe f930 	bl	340062ec <LL_RCC_IC7_GetDivider>
3400808c:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400808e:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
34008092:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
34008096:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400809a:	d017      	beq.n	340080cc <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x80>
3400809c:	d811      	bhi.n	340080c2 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x76>
3400809e:	b913      	cbnz	r3, 340080a6 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5a>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340080a0:	f7ff fe4e 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
340080a4:	e001      	b.n	340080aa <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340080a6:	f7ff fe8b 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
            spdifrx_frequency = spdifrx_frequency / ic_divider;
340080aa:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
340080ae:	e00c      	b.n	340080ca <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      if (LL_RCC_IC8_IsEnabled() != 0U)
340080b0:	f7fe f926 	bl	34006300 <LL_RCC_IC8_IsEnabled>
340080b4:	b140      	cbz	r0, 340080c8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC8_GetDivider();
340080b6:	f7fe f92b 	bl	34006310 <LL_RCC_IC8_GetDivider>
340080ba:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
340080be:	4604      	mov	r4, r0
340080c0:	e7e7      	b.n	34008092 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x46>
        switch (LL_RCC_IC8_GetSource())
340080c2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340080c6:	d004      	beq.n	340080d2 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x86>
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
340080c8:	2000      	movs	r0, #0
}
340080ca:	bd38      	pop	{r3, r4, r5, pc}
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340080cc:	f7ff feb8 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
340080d0:	e7eb      	b.n	340080aa <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340080d2:	f7ff fef5 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
340080d6:	e7e8      	b.n	340080aa <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
      if (LL_RCC_HSI_IsReady() != 0U)
340080d8:	f7fe f8c8 	bl	3400626c <LL_RCC_HSI_IsReady>
340080dc:	2800      	cmp	r0, #0
340080de:	d0f3      	beq.n	340080c8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
340080e0:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340080e2:	4807      	ldr	r0, [pc, #28]	@ (34008100 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb4>)
340080e4:	f3c3 13c1 	ubfx	r3, r3, #7, #2
340080e8:	e7c5      	b.n	34008076 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x2a>
      if (LL_RCC_MSI_IsReady() != 0U)
340080ea:	f7fe f8c7 	bl	3400627c <LL_RCC_MSI_IsReady>
340080ee:	2800      	cmp	r0, #0
340080f0:	d0ea      	beq.n	340080c8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        spdifrx_frequency = MSI_VALUE;
340080f2:	4804      	ldr	r0, [pc, #16]	@ (34008104 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb8>)
340080f4:	e7e9      	b.n	340080ca <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
340080f6:	4804      	ldr	r0, [pc, #16]	@ (34008108 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xbc>)
  return spdifrx_frequency;
340080f8:	e7e7      	b.n	340080ca <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
340080fa:	bf00      	nop
340080fc:	56028000 	.word	0x56028000
34008100:	03d09000 	.word	0x03d09000
34008104:	003d0900 	.word	0x003d0900
34008108:	00bb8000 	.word	0x00bb8000

3400810c <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
3400810c:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400810e:	f7fe f8d7 	bl	340062c0 <LL_RCC_GetClockSource>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
34008112:	4b36      	ldr	r3, [pc, #216]	@ (340081ec <RCCEx_GetXSPICLKFreq+0xe0>)
34008114:	4298      	cmp	r0, r3
34008116:	d028      	beq.n	3400816a <RCCEx_GetXSPICLKFreq+0x5e>
34008118:	d81b      	bhi.n	34008152 <RCCEx_GetXSPICLKFreq+0x46>
3400811a:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400811e:	4298      	cmp	r0, r3
34008120:	d013      	beq.n	3400814a <RCCEx_GetXSPICLKFreq+0x3e>
34008122:	d80b      	bhi.n	3400813c <RCCEx_GetXSPICLKFreq+0x30>
34008124:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
34008128:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400812c:	429a      	cmp	r2, r3
3400812e:	d04a      	beq.n	340081c6 <RCCEx_GetXSPICLKFreq+0xba>
34008130:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34008134:	4298      	cmp	r0, r3
34008136:	d046      	beq.n	340081c6 <RCCEx_GetXSPICLKFreq+0xba>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
34008138:	2000      	movs	r0, #0
      /* Nothing to do */
      break;
  }

  return xspi_frequency;
}
3400813a:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400813c:	4b2c      	ldr	r3, [pc, #176]	@ (340081f0 <RCCEx_GetXSPICLKFreq+0xe4>)
3400813e:	4298      	cmp	r0, r3
34008140:	d003      	beq.n	3400814a <RCCEx_GetXSPICLKFreq+0x3e>
34008142:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008146:	4298      	cmp	r0, r3
34008148:	d1f6      	bne.n	34008138 <RCCEx_GetXSPICLKFreq+0x2c>
}
3400814a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400814e:	f7ff bef7 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
34008152:	4b28      	ldr	r3, [pc, #160]	@ (340081f4 <RCCEx_GetXSPICLKFreq+0xe8>)
34008154:	4298      	cmp	r0, r3
34008156:	d028      	beq.n	340081aa <RCCEx_GetXSPICLKFreq+0x9e>
34008158:	d820      	bhi.n	3400819c <RCCEx_GetXSPICLKFreq+0x90>
3400815a:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400815e:	4298      	cmp	r0, r3
34008160:	d003      	beq.n	3400816a <RCCEx_GetXSPICLKFreq+0x5e>
34008162:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008166:	4298      	cmp	r0, r3
34008168:	d1e6      	bne.n	34008138 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3400816a:	4b23      	ldr	r3, [pc, #140]	@ (340081f8 <RCCEx_GetXSPICLKFreq+0xec>)
3400816c:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
34008170:	f010 0004 	ands.w	r0, r0, #4
34008174:	d0e1      	beq.n	3400813a <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
34008176:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400817a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400817e:	f3c0 4007 	ubfx	r0, r0, #16, #8
34008182:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
34008184:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC4_GetSource())
34008188:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400818c:	d02a      	beq.n	340081e4 <RCCEx_GetXSPICLKFreq+0xd8>
3400818e:	d820      	bhi.n	340081d2 <RCCEx_GetXSPICLKFreq+0xc6>
34008190:	bb2b      	cbnz	r3, 340081de <RCCEx_GetXSPICLKFreq+0xd2>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008192:	f7ff fdd5 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            xspi_frequency = xspi_frequency / ic_divider;
34008196:	fbb0 f0f4 	udiv	r0, r0, r4
  return xspi_frequency;
3400819a:	e7ce      	b.n	3400813a <RCCEx_GetXSPICLKFreq+0x2e>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400819c:	4b17      	ldr	r3, [pc, #92]	@ (340081fc <RCCEx_GetXSPICLKFreq+0xf0>)
3400819e:	4298      	cmp	r0, r3
340081a0:	d003      	beq.n	340081aa <RCCEx_GetXSPICLKFreq+0x9e>
340081a2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
340081a6:	4298      	cmp	r0, r3
340081a8:	d1c6      	bne.n	34008138 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
340081aa:	4b13      	ldr	r3, [pc, #76]	@ (340081f8 <RCCEx_GetXSPICLKFreq+0xec>)
340081ac:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
340081b0:	f010 0008 	ands.w	r0, r0, #8
340081b4:	d0c1      	beq.n	3400813a <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
340081b6:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
340081ba:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
340081be:	f3c0 4007 	ubfx	r0, r0, #16, #8
340081c2:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
340081c4:	e7de      	b.n	34008184 <RCCEx_GetXSPICLKFreq+0x78>
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340081c6:	f7fe f823 	bl	34006210 <HAL_RCC_GetSysClockFreq>
}
340081ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340081ce:	f7fe b8df 	b.w	34006390 <RCCEx_GetHCLKFreq>
        switch (LL_RCC_IC4_GetSource())
340081d2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340081d6:	d1af      	bne.n	34008138 <RCCEx_GetXSPICLKFreq+0x2c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340081d8:	f7ff fe72 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
340081dc:	e7db      	b.n	34008196 <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340081de:	f7ff fdef 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
340081e2:	e7d8      	b.n	34008196 <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340081e4:	f7ff fe2c 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
340081e8:	e7d5      	b.n	34008196 <RCCEx_GetXSPICLKFreq+0x8a>
340081ea:	bf00      	nop
340081ec:	03020014 	.word	0x03020014
340081f0:	03010414 	.word	0x03010414
340081f4:	03030014 	.word	0x03030014
340081f8:	56028000 	.word	0x56028000
340081fc:	03030414 	.word	0x03030414

34008200 <RCCEx_GetOTGPHYCLKFreq>:
{
34008200:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
34008202:	f7fe f85d 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
34008206:	4b2b      	ldr	r3, [pc, #172]	@ (340082b4 <RCCEx_GetOTGPHYCLKFreq+0xb4>)
34008208:	4298      	cmp	r0, r3
3400820a:	d021      	beq.n	34008250 <RCCEx_GetOTGPHYCLKFreq+0x50>
3400820c:	d815      	bhi.n	3400823a <RCCEx_GetOTGPHYCLKFreq+0x3a>
3400820e:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008212:	4298      	cmp	r0, r3
34008214:	d00d      	beq.n	34008232 <RCCEx_GetOTGPHYCLKFreq+0x32>
34008216:	d809      	bhi.n	3400822c <RCCEx_GetOTGPHYCLKFreq+0x2c>
34008218:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400821c:	4298      	cmp	r0, r3
3400821e:	d02d      	beq.n	3400827c <RCCEx_GetOTGPHYCLKFreq+0x7c>
34008220:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34008224:	4298      	cmp	r0, r3
34008226:	d029      	beq.n	3400827c <RCCEx_GetOTGPHYCLKFreq+0x7c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
34008228:	2000      	movs	r0, #0
}
3400822a:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400822c:	4b22      	ldr	r3, [pc, #136]	@ (340082b8 <RCCEx_GetOTGPHYCLKFreq+0xb8>)
3400822e:	4298      	cmp	r0, r3
34008230:	d1fa      	bne.n	34008228 <RCCEx_GetOTGPHYCLKFreq+0x28>
}
34008232:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008236:	f7ff be83 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400823a:	4b20      	ldr	r3, [pc, #128]	@ (340082bc <RCCEx_GetOTGPHYCLKFreq+0xbc>)
3400823c:	4298      	cmp	r0, r3
3400823e:	d023      	beq.n	34008288 <RCCEx_GetOTGPHYCLKFreq+0x88>
34008240:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34008244:	4298      	cmp	r0, r3
34008246:	d01f      	beq.n	34008288 <RCCEx_GetOTGPHYCLKFreq+0x88>
34008248:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400824c:	4298      	cmp	r0, r3
3400824e:	d1eb      	bne.n	34008228 <RCCEx_GetOTGPHYCLKFreq+0x28>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34008250:	f7fe f88c 	bl	3400636c <LL_RCC_IC15_IsEnabled>
34008254:	2800      	cmp	r0, #0
34008256:	d0e7      	beq.n	34008228 <RCCEx_GetOTGPHYCLKFreq+0x28>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
34008258:	f7fe f890 	bl	3400637c <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400825c:	4b18      	ldr	r3, [pc, #96]	@ (340082c0 <RCCEx_GetOTGPHYCLKFreq+0xc0>)
3400825e:	4604      	mov	r4, r0
34008260:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34008264:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
34008268:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400826c:	d01f      	beq.n	340082ae <RCCEx_GetOTGPHYCLKFreq+0xae>
3400826e:	d815      	bhi.n	3400829c <RCCEx_GetOTGPHYCLKFreq+0x9c>
34008270:	b9d3      	cbnz	r3, 340082a8 <RCCEx_GetOTGPHYCLKFreq+0xa8>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008272:	f7ff fd65 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            usb_frequency = usb_frequency / ic_divider;
34008276:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400827a:	e7d6      	b.n	3400822a <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
3400827c:	f7fd ffee 	bl	3400625c <LL_RCC_HSE_IsReady>
34008280:	2800      	cmp	r0, #0
34008282:	d0d1      	beq.n	34008228 <RCCEx_GetOTGPHYCLKFreq+0x28>
        usb_frequency = HSE_VALUE / 2U;
34008284:	480f      	ldr	r0, [pc, #60]	@ (340082c4 <RCCEx_GetOTGPHYCLKFreq+0xc4>)
34008286:	e7d0      	b.n	3400822a <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
34008288:	f7fd ffe8 	bl	3400625c <LL_RCC_HSE_IsReady>
3400828c:	2800      	cmp	r0, #0
3400828e:	d0cb      	beq.n	34008228 <RCCEx_GetOTGPHYCLKFreq+0x28>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
34008290:	f7fd ffdc 	bl	3400624c <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
34008294:	2800      	cmp	r0, #0
34008296:	d1f5      	bne.n	34008284 <RCCEx_GetOTGPHYCLKFreq+0x84>
          usb_frequency = HSE_VALUE;
34008298:	480b      	ldr	r0, [pc, #44]	@ (340082c8 <RCCEx_GetOTGPHYCLKFreq+0xc8>)
  return usb_frequency;
3400829a:	e7c6      	b.n	3400822a <RCCEx_GetOTGPHYCLKFreq+0x2a>
        switch (LL_RCC_IC15_GetSource())
3400829c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340082a0:	d1c2      	bne.n	34008228 <RCCEx_GetOTGPHYCLKFreq+0x28>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340082a2:	f7ff fe0d 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
340082a6:	e7e6      	b.n	34008276 <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340082a8:	f7ff fd8a 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
340082ac:	e7e3      	b.n	34008276 <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340082ae:	f7ff fdc7 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
340082b2:	e7e0      	b.n	34008276 <RCCEx_GetOTGPHYCLKFreq+0x76>
340082b4:	03020c14 	.word	0x03020c14
340082b8:	03011414 	.word	0x03011414
340082bc:	03030c14 	.word	0x03030c14
340082c0:	56028000 	.word	0x56028000
340082c4:	016e3600 	.word	0x016e3600
340082c8:	02dc6c00 	.word	0x02dc6c00

340082cc <RCCEx_GetOTGPHYCKREFCLKFreq>:
{
340082cc:	b508      	push	{r3, lr}
  return LL_RCC_GetClockSource(Periph);
340082ce:	f7fd fff7 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
340082d2:	4b11      	ldr	r3, [pc, #68]	@ (34008318 <RCCEx_GetOTGPHYCKREFCLKFreq+0x4c>)
340082d4:	4298      	cmp	r0, r3
340082d6:	d01c      	beq.n	34008312 <RCCEx_GetOTGPHYCKREFCLKFreq+0x46>
340082d8:	d805      	bhi.n	340082e6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x1a>
340082da:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
340082de:	4298      	cmp	r0, r3
340082e0:	d012      	beq.n	34008308 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
340082e2:	2000      	movs	r0, #0
}
340082e4:	bd08      	pop	{r3, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
340082e6:	4b0d      	ldr	r3, [pc, #52]	@ (3400831c <RCCEx_GetOTGPHYCKREFCLKFreq+0x50>)
340082e8:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
340082ec:	4298      	cmp	r0, r3
340082ee:	d1f8      	bne.n	340082e2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
      if (LL_RCC_HSE_IsReady() != 0U)
340082f0:	f7fd ffb4 	bl	3400625c <LL_RCC_HSE_IsReady>
340082f4:	2800      	cmp	r0, #0
340082f6:	d0f4      	beq.n	340082e2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
340082f8:	f7fd ffa8 	bl	3400624c <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
          usb_frequency = HSE_VALUE;
340082fc:	4b08      	ldr	r3, [pc, #32]	@ (34008320 <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>)
340082fe:	2800      	cmp	r0, #0
34008300:	4808      	ldr	r0, [pc, #32]	@ (34008324 <RCCEx_GetOTGPHYCKREFCLKFreq+0x58>)
34008302:	bf08      	it	eq
34008304:	4618      	moveq	r0, r3
34008306:	e7ed      	b.n	340082e4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x18>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34008308:	4807      	ldr	r0, [pc, #28]	@ (34008328 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5c>)
}
3400830a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400830e:	f7ff bf77 	b.w	34008200 <RCCEx_GetOTGPHYCLKFreq>
34008312:	4806      	ldr	r0, [pc, #24]	@ (3400832c <RCCEx_GetOTGPHYCKREFCLKFreq+0x60>)
34008314:	e7f9      	b.n	3400830a <RCCEx_GetOTGPHYCKREFCLKFreq+0x3e>
34008316:	bf00      	nop
34008318:	01001814 	.word	0x01001814
3400831c:	01011014 	.word	0x01011014
34008320:	02dc6c00 	.word	0x02dc6c00
34008324:	016e3600 	.word	0x016e3600
34008328:	03000c14 	.word	0x03000c14
3400832c:	03001414 	.word	0x03001414

34008330 <RCCEx_GetUSARTCLKFreq>:
{
34008330:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
34008332:	f7fd ffc5 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
34008336:	4b6f      	ldr	r3, [pc, #444]	@ (340084f4 <RCCEx_GetUSARTCLKFreq+0x1c4>)
34008338:	4298      	cmp	r0, r3
3400833a:	d039      	beq.n	340083b0 <RCCEx_GetUSARTCLKFreq+0x80>
3400833c:	d852      	bhi.n	340083e4 <RCCEx_GetUSARTCLKFreq+0xb4>
3400833e:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
34008342:	4298      	cmp	r0, r3
34008344:	f000 80b5 	beq.w	340084b2 <RCCEx_GetUSARTCLKFreq+0x182>
34008348:	d813      	bhi.n	34008372 <RCCEx_GetUSARTCLKFreq+0x42>
3400834a:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400834e:	4298      	cmp	r0, r3
34008350:	f000 80af 	beq.w	340084b2 <RCCEx_GetUSARTCLKFreq+0x182>
34008354:	d80b      	bhi.n	3400836e <RCCEx_GetUSARTCLKFreq+0x3e>
34008356:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3400835a:	4298      	cmp	r0, r3
3400835c:	f000 80a9 	beq.w	340084b2 <RCCEx_GetUSARTCLKFreq+0x182>
34008360:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008364:	4298      	cmp	r0, r3
34008366:	f000 80ae 	beq.w	340084c6 <RCCEx_GetUSARTCLKFreq+0x196>
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
3400836a:	2000      	movs	r0, #0
}
3400836c:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400836e:	4b62      	ldr	r3, [pc, #392]	@ (340084f8 <RCCEx_GetUSARTCLKFreq+0x1c8>)
34008370:	e7f8      	b.n	34008364 <RCCEx_GetUSARTCLKFreq+0x34>
34008372:	4b62      	ldr	r3, [pc, #392]	@ (340084fc <RCCEx_GetUSARTCLKFreq+0x1cc>)
34008374:	4298      	cmp	r0, r3
34008376:	d00c      	beq.n	34008392 <RCCEx_GetUSARTCLKFreq+0x62>
34008378:	d80f      	bhi.n	3400839a <RCCEx_GetUSARTCLKFreq+0x6a>
3400837a:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400837e:	4298      	cmp	r0, r3
34008380:	d007      	beq.n	34008392 <RCCEx_GetUSARTCLKFreq+0x62>
34008382:	bf8e      	itee	hi
34008384:	4b5e      	ldrhi	r3, [pc, #376]	@ (34008500 <RCCEx_GetUSARTCLKFreq+0x1d0>)
34008386:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
3400838a:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
3400838e:	4298      	cmp	r0, r3
34008390:	d1eb      	bne.n	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
}
34008392:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008396:	f7ff bdd3 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400839a:	4b5a      	ldr	r3, [pc, #360]	@ (34008504 <RCCEx_GetUSARTCLKFreq+0x1d4>)
3400839c:	4298      	cmp	r0, r3
3400839e:	d007      	beq.n	340083b0 <RCCEx_GetUSARTCLKFreq+0x80>
340083a0:	bf8e      	itee	hi
340083a2:	4b59      	ldrhi	r3, [pc, #356]	@ (34008508 <RCCEx_GetUSARTCLKFreq+0x1d8>)
340083a4:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
340083a8:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
340083ac:	4298      	cmp	r0, r3
340083ae:	d1dc      	bne.n	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC9_IsEnabled() != 0U)
340083b0:	f7fd ffb8 	bl	34006324 <LL_RCC_IC9_IsEnabled>
340083b4:	2800      	cmp	r0, #0
340083b6:	d0d8      	beq.n	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC9_GetDivider();
340083b8:	f7fd ffbc 	bl	34006334 <LL_RCC_IC9_GetDivider>
340083bc:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
340083be:	4b53      	ldr	r3, [pc, #332]	@ (3400850c <RCCEx_GetUSARTCLKFreq+0x1dc>)
340083c0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
340083c4:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
340083c8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340083cc:	f000 808e 	beq.w	340084ec <RCCEx_GetUSARTCLKFreq+0x1bc>
340083d0:	f200 8082 	bhi.w	340084d8 <RCCEx_GetUSARTCLKFreq+0x1a8>
340083d4:	2b00      	cmp	r3, #0
340083d6:	f040 8086 	bne.w	340084e6 <RCCEx_GetUSARTCLKFreq+0x1b6>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340083da:	f7ff fcb1 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            usart_frequency = usart_frequency / ic_divider;
340083de:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
340083e2:	e7c3      	b.n	3400836c <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
340083e4:	4b4a      	ldr	r3, [pc, #296]	@ (34008510 <RCCEx_GetUSARTCLKFreq+0x1e0>)
340083e6:	4298      	cmp	r0, r3
340083e8:	d045      	beq.n	34008476 <RCCEx_GetUSARTCLKFreq+0x146>
340083ea:	d833      	bhi.n	34008454 <RCCEx_GetUSARTCLKFreq+0x124>
340083ec:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
340083f0:	4298      	cmp	r0, r3
340083f2:	d028      	beq.n	34008446 <RCCEx_GetUSARTCLKFreq+0x116>
340083f4:	d81c      	bhi.n	34008430 <RCCEx_GetUSARTCLKFreq+0x100>
340083f6:	f5a3 437b 	sub.w	r3, r3, #64256	@ 0xfb00
340083fa:	3bfc      	subs	r3, #252	@ 0xfc
340083fc:	4298      	cmp	r0, r3
340083fe:	d006      	beq.n	3400840e <RCCEx_GetUSARTCLKFreq+0xde>
34008400:	d810      	bhi.n	34008424 <RCCEx_GetUSARTCLKFreq+0xf4>
34008402:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
34008406:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3400840a:	4298      	cmp	r0, r3
3400840c:	d1ad      	bne.n	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400840e:	f7fd ff9b 	bl	34006348 <LL_RCC_IC14_IsEnabled>
34008412:	2800      	cmp	r0, #0
34008414:	d0a9      	beq.n	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC14_GetDivider();
34008416:	f7fd ff9f 	bl	34006358 <LL_RCC_IC14_GetDivider>
3400841a:	4b3c      	ldr	r3, [pc, #240]	@ (3400850c <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400841c:	4604      	mov	r4, r0
3400841e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34008422:	e7cf      	b.n	340083c4 <RCCEx_GetUSARTCLKFreq+0x94>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
34008424:	4b3b      	ldr	r3, [pc, #236]	@ (34008514 <RCCEx_GetUSARTCLKFreq+0x1e4>)
34008426:	4298      	cmp	r0, r3
34008428:	d0f1      	beq.n	3400840e <RCCEx_GetUSARTCLKFreq+0xde>
3400842a:	f503 6340 	add.w	r3, r3, #3072	@ 0xc00
3400842e:	e7ec      	b.n	3400840a <RCCEx_GetUSARTCLKFreq+0xda>
34008430:	4b39      	ldr	r3, [pc, #228]	@ (34008518 <RCCEx_GetUSARTCLKFreq+0x1e8>)
34008432:	4298      	cmp	r0, r3
34008434:	d007      	beq.n	34008446 <RCCEx_GetUSARTCLKFreq+0x116>
34008436:	bf8e      	itee	hi
34008438:	4b38      	ldrhi	r3, [pc, #224]	@ (3400851c <RCCEx_GetUSARTCLKFreq+0x1ec>)
3400843a:	f020 0004 	bicls.w	r0, r0, #4
3400843e:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
34008442:	4298      	cmp	r0, r3
34008444:	d191      	bne.n	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_LSE_IsReady() != 0U)
34008446:	f7fd ff21 	bl	3400628c <LL_RCC_LSE_IsReady>
3400844a:	3800      	subs	r0, #0
3400844c:	bf18      	it	ne
3400844e:	2001      	movne	r0, #1
34008450:	03c0      	lsls	r0, r0, #15
34008452:	e78b      	b.n	3400836c <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
34008454:	4b32      	ldr	r3, [pc, #200]	@ (34008520 <RCCEx_GetUSARTCLKFreq+0x1f0>)
34008456:	4298      	cmp	r0, r3
34008458:	d020      	beq.n	3400849c <RCCEx_GetUSARTCLKFreq+0x16c>
3400845a:	d813      	bhi.n	34008484 <RCCEx_GetUSARTCLKFreq+0x154>
3400845c:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
34008460:	4298      	cmp	r0, r3
34008462:	d008      	beq.n	34008476 <RCCEx_GetUSARTCLKFreq+0x146>
34008464:	bf8e      	itee	hi
34008466:	4b2f      	ldrhi	r3, [pc, #188]	@ (34008524 <RCCEx_GetUSARTCLKFreq+0x1f4>)
34008468:	f020 0004 	bicls.w	r0, r0, #4
3400846c:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
34008470:	4298      	cmp	r0, r3
34008472:	f47f af7a 	bne.w	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_MSI_IsReady() != 0U)
34008476:	f7fd ff01 	bl	3400627c <LL_RCC_MSI_IsReady>
3400847a:	2800      	cmp	r0, #0
3400847c:	f43f af75 	beq.w	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
        usart_frequency = MSI_VALUE;
34008480:	4829      	ldr	r0, [pc, #164]	@ (34008528 <RCCEx_GetUSARTCLKFreq+0x1f8>)
  return usart_frequency;
34008482:	e773      	b.n	3400836c <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
34008484:	4b29      	ldr	r3, [pc, #164]	@ (3400852c <RCCEx_GetUSARTCLKFreq+0x1fc>)
34008486:	4298      	cmp	r0, r3
34008488:	d008      	beq.n	3400849c <RCCEx_GetUSARTCLKFreq+0x16c>
3400848a:	bf8e      	itee	hi
3400848c:	4b28      	ldrhi	r3, [pc, #160]	@ (34008530 <RCCEx_GetUSARTCLKFreq+0x200>)
3400848e:	f020 0004 	bicls.w	r0, r0, #4
34008492:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
34008496:	4298      	cmp	r0, r3
34008498:	f47f af67 	bne.w	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_HSI_IsReady() != 0U)
3400849c:	f7fd fee6 	bl	3400626c <LL_RCC_HSI_IsReady>
340084a0:	2800      	cmp	r0, #0
340084a2:	f43f af62 	beq.w	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
340084a6:	4b19      	ldr	r3, [pc, #100]	@ (3400850c <RCCEx_GetUSARTCLKFreq+0x1dc>)
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340084a8:	4822      	ldr	r0, [pc, #136]	@ (34008534 <RCCEx_GetUSARTCLKFreq+0x204>)
340084aa:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340084ac:	f3c3 13c1 	ubfx	r3, r3, #7, #2
340084b0:	e007      	b.n	340084c2 <RCCEx_GetUSARTCLKFreq+0x192>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340084b2:	f7fd fead 	bl	34006210 <HAL_RCC_GetSysClockFreq>
340084b6:	f7fd ff6b 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
340084ba:	4b14      	ldr	r3, [pc, #80]	@ (3400850c <RCCEx_GetUSARTCLKFreq+0x1dc>)
340084bc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
340084be:	f3c3 1302 	ubfx	r3, r3, #4, #3
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340084c2:	40d8      	lsrs	r0, r3
340084c4:	e752      	b.n	3400836c <RCCEx_GetUSARTCLKFreq+0x3c>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340084c6:	f7fd fea3 	bl	34006210 <HAL_RCC_GetSysClockFreq>
340084ca:	f7fd ff61 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
340084ce:	4b0f      	ldr	r3, [pc, #60]	@ (3400850c <RCCEx_GetUSARTCLKFreq+0x1dc>)
340084d0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340084d2:	f003 0307 	and.w	r3, r3, #7
340084d6:	e7f4      	b.n	340084c2 <RCCEx_GetUSARTCLKFreq+0x192>
        switch (LL_RCC_IC14_GetSource())
340084d8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340084dc:	f47f af45 	bne.w	3400836a <RCCEx_GetUSARTCLKFreq+0x3a>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340084e0:	f7ff fcee 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
340084e4:	e77b      	b.n	340083de <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340084e6:	f7ff fc6b 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
340084ea:	e778      	b.n	340083de <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340084ec:	f7ff fca8 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
340084f0:	e775      	b.n	340083de <RCCEx_GetUSARTCLKFreq+0xae>
340084f2:	bf00      	nop
340084f4:	07021430 	.word	0x07021430
340084f8:	07000830 	.word	0x07000830
340084fc:	07011430 	.word	0x07011430
34008500:	07010830 	.word	0x07010830
34008504:	07020434 	.word	0x07020434
34008508:	07020830 	.word	0x07020830
3400850c:	56028000 	.word	0x56028000
34008510:	07050030 	.word	0x07050030
34008514:	07030830 	.word	0x07030830
34008518:	07040830 	.word	0x07040830
3400851c:	07041430 	.word	0x07041430
34008520:	07060030 	.word	0x07060030
34008524:	07051430 	.word	0x07051430
34008528:	003d0900 	.word	0x003d0900
3400852c:	07060830 	.word	0x07060830
34008530:	07061430 	.word	0x07061430
34008534:	03d09000 	.word	0x03d09000

34008538 <RCCEx_GetUARTCLKFreq>:
{
34008538:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400853a:	f7fd fec1 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400853e:	4b77      	ldr	r3, [pc, #476]	@ (3400871c <RCCEx_GetUARTCLKFreq+0x1e4>)
34008540:	4298      	cmp	r0, r3
34008542:	d03e      	beq.n	340085c2 <RCCEx_GetUARTCLKFreq+0x8a>
34008544:	d859      	bhi.n	340085fa <RCCEx_GetUARTCLKFreq+0xc2>
34008546:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400854a:	4298      	cmp	r0, r3
3400854c:	f000 80c6 	beq.w	340086dc <RCCEx_GetUARTCLKFreq+0x1a4>
34008550:	d814      	bhi.n	3400857c <RCCEx_GetUARTCLKFreq+0x44>
34008552:	4b73      	ldr	r3, [pc, #460]	@ (34008720 <RCCEx_GetUARTCLKFreq+0x1e8>)
34008554:	4298      	cmp	r0, r3
34008556:	f000 80cb 	beq.w	340086f0 <RCCEx_GetUARTCLKFreq+0x1b8>
3400855a:	3b01      	subs	r3, #1
3400855c:	4298      	cmp	r0, r3
3400855e:	d90b      	bls.n	34008578 <RCCEx_GetUARTCLKFreq+0x40>
34008560:	f420 6200 	bic.w	r2, r0, #2048	@ 0x800
34008564:	f603 73fd 	addw	r3, r3, #4093	@ 0xffd
34008568:	429a      	cmp	r2, r3
3400856a:	f000 80b7 	beq.w	340086dc <RCCEx_GetUARTCLKFreq+0x1a4>
3400856e:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
34008572:	4298      	cmp	r0, r3
34008574:	f000 80b2 	beq.w	340086dc <RCCEx_GetUARTCLKFreq+0x1a4>
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
34008578:	2000      	movs	r0, #0
}
3400857a:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400857c:	4b69      	ldr	r3, [pc, #420]	@ (34008724 <RCCEx_GetUARTCLKFreq+0x1ec>)
3400857e:	4298      	cmp	r0, r3
34008580:	d00d      	beq.n	3400859e <RCCEx_GetUARTCLKFreq+0x66>
34008582:	d812      	bhi.n	340085aa <RCCEx_GetUARTCLKFreq+0x72>
34008584:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
34008588:	4298      	cmp	r0, r3
3400858a:	d008      	beq.n	3400859e <RCCEx_GetUARTCLKFreq+0x66>
3400858c:	d80b      	bhi.n	340085a6 <RCCEx_GetUARTCLKFreq+0x6e>
3400858e:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
34008592:	4298      	cmp	r0, r3
34008594:	d003      	beq.n	3400859e <RCCEx_GetUARTCLKFreq+0x66>
34008596:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400859a:	4298      	cmp	r0, r3
3400859c:	d1ec      	bne.n	34008578 <RCCEx_GetUARTCLKFreq+0x40>
}
3400859e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340085a2:	f7ff bccd 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
340085a6:	4b60      	ldr	r3, [pc, #384]	@ (34008728 <RCCEx_GetUARTCLKFreq+0x1f0>)
340085a8:	e7f7      	b.n	3400859a <RCCEx_GetUARTCLKFreq+0x62>
340085aa:	4b60      	ldr	r3, [pc, #384]	@ (3400872c <RCCEx_GetUARTCLKFreq+0x1f4>)
340085ac:	4298      	cmp	r0, r3
340085ae:	d008      	beq.n	340085c2 <RCCEx_GetUARTCLKFreq+0x8a>
340085b0:	d821      	bhi.n	340085f6 <RCCEx_GetUARTCLKFreq+0xbe>
340085b2:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
340085b6:	4298      	cmp	r0, r3
340085b8:	d003      	beq.n	340085c2 <RCCEx_GetUARTCLKFreq+0x8a>
340085ba:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
340085be:	4298      	cmp	r0, r3
340085c0:	d1da      	bne.n	34008578 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC9_IsEnabled() != 0U)
340085c2:	f7fd feaf 	bl	34006324 <LL_RCC_IC9_IsEnabled>
340085c6:	2800      	cmp	r0, #0
340085c8:	d0d6      	beq.n	34008578 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC9_GetDivider();
340085ca:	f7fd feb3 	bl	34006334 <LL_RCC_IC9_GetDivider>
340085ce:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
340085d0:	4b57      	ldr	r3, [pc, #348]	@ (34008730 <RCCEx_GetUARTCLKFreq+0x1f8>)
340085d2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
340085d6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
340085da:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340085de:	f000 809a 	beq.w	34008716 <RCCEx_GetUARTCLKFreq+0x1de>
340085e2:	f200 808e 	bhi.w	34008702 <RCCEx_GetUARTCLKFreq+0x1ca>
340085e6:	2b00      	cmp	r3, #0
340085e8:	f040 8092 	bne.w	34008710 <RCCEx_GetUARTCLKFreq+0x1d8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340085ec:	f7ff fba8 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            uart_frequency = uart_frequency / ic_divider;
340085f0:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
340085f4:	e7c1      	b.n	3400857a <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
340085f6:	4b4f      	ldr	r3, [pc, #316]	@ (34008734 <RCCEx_GetUARTCLKFreq+0x1fc>)
340085f8:	e7e1      	b.n	340085be <RCCEx_GetUARTCLKFreq+0x86>
340085fa:	4b4f      	ldr	r3, [pc, #316]	@ (34008738 <RCCEx_GetUARTCLKFreq+0x200>)
340085fc:	4298      	cmp	r0, r3
340085fe:	d04a      	beq.n	34008696 <RCCEx_GetUARTCLKFreq+0x15e>
34008600:	d836      	bhi.n	34008670 <RCCEx_GetUARTCLKFreq+0x138>
34008602:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008606:	4298      	cmp	r0, r3
34008608:	d029      	beq.n	3400865e <RCCEx_GetUARTCLKFreq+0x126>
3400860a:	d81c      	bhi.n	34008646 <RCCEx_GetUARTCLKFreq+0x10e>
3400860c:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
34008610:	3b04      	subs	r3, #4
34008612:	4298      	cmp	r0, r3
34008614:	d008      	beq.n	34008628 <RCCEx_GetUARTCLKFreq+0xf0>
34008616:	d812      	bhi.n	3400863e <RCCEx_GetUARTCLKFreq+0x106>
34008618:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400861c:	4298      	cmp	r0, r3
3400861e:	d003      	beq.n	34008628 <RCCEx_GetUARTCLKFreq+0xf0>
34008620:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
34008624:	4298      	cmp	r0, r3
34008626:	d1a7      	bne.n	34008578 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC14_IsEnabled() != 0U)
34008628:	f7fd fe8e 	bl	34006348 <LL_RCC_IC14_IsEnabled>
3400862c:	2800      	cmp	r0, #0
3400862e:	d0a3      	beq.n	34008578 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC14_GetDivider();
34008630:	f7fd fe92 	bl	34006358 <LL_RCC_IC14_GetDivider>
34008634:	4b3e      	ldr	r3, [pc, #248]	@ (34008730 <RCCEx_GetUARTCLKFreq+0x1f8>)
34008636:	4604      	mov	r4, r0
34008638:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400863c:	e7cb      	b.n	340085d6 <RCCEx_GetUARTCLKFreq+0x9e>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400863e:	4b3f      	ldr	r3, [pc, #252]	@ (3400873c <RCCEx_GetUARTCLKFreq+0x204>)
34008640:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
34008644:	e7ee      	b.n	34008624 <RCCEx_GetUARTCLKFreq+0xec>
34008646:	4b3e      	ldr	r3, [pc, #248]	@ (34008740 <RCCEx_GetUARTCLKFreq+0x208>)
34008648:	4298      	cmp	r0, r3
3400864a:	d008      	beq.n	3400865e <RCCEx_GetUARTCLKFreq+0x126>
3400864c:	d80e      	bhi.n	3400866c <RCCEx_GetUARTCLKFreq+0x134>
3400864e:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
34008652:	4298      	cmp	r0, r3
34008654:	d003      	beq.n	3400865e <RCCEx_GetUARTCLKFreq+0x126>
34008656:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400865a:	4298      	cmp	r0, r3
3400865c:	d18c      	bne.n	34008578 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_LSE_IsReady() != 0U)
3400865e:	f7fd fe15 	bl	3400628c <LL_RCC_LSE_IsReady>
34008662:	3800      	subs	r0, #0
34008664:	bf18      	it	ne
34008666:	2001      	movne	r0, #1
34008668:	03c0      	lsls	r0, r0, #15
3400866a:	e786      	b.n	3400857a <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400866c:	4b35      	ldr	r3, [pc, #212]	@ (34008744 <RCCEx_GetUARTCLKFreq+0x20c>)
3400866e:	e7f4      	b.n	3400865a <RCCEx_GetUARTCLKFreq+0x122>
34008670:	4b35      	ldr	r3, [pc, #212]	@ (34008748 <RCCEx_GetUARTCLKFreq+0x210>)
34008672:	4298      	cmp	r0, r3
34008674:	d025      	beq.n	340086c2 <RCCEx_GetUARTCLKFreq+0x18a>
34008676:	d817      	bhi.n	340086a8 <RCCEx_GetUARTCLKFreq+0x170>
34008678:	f5a3 4368 	sub.w	r3, r3, #59392	@ 0xe800
3400867c:	3b04      	subs	r3, #4
3400867e:	4298      	cmp	r0, r3
34008680:	d009      	beq.n	34008696 <RCCEx_GetUARTCLKFreq+0x15e>
34008682:	d80f      	bhi.n	340086a4 <RCCEx_GetUARTCLKFreq+0x16c>
34008684:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
34008688:	4298      	cmp	r0, r3
3400868a:	d004      	beq.n	34008696 <RCCEx_GetUARTCLKFreq+0x15e>
3400868c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008690:	4298      	cmp	r0, r3
34008692:	f47f af71 	bne.w	34008578 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_MSI_IsReady() != 0U)
34008696:	f7fd fdf1 	bl	3400627c <LL_RCC_MSI_IsReady>
3400869a:	2800      	cmp	r0, #0
3400869c:	f43f af6c 	beq.w	34008578 <RCCEx_GetUARTCLKFreq+0x40>
        uart_frequency = MSI_VALUE;
340086a0:	482a      	ldr	r0, [pc, #168]	@ (3400874c <RCCEx_GetUARTCLKFreq+0x214>)
  return uart_frequency;
340086a2:	e76a      	b.n	3400857a <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
340086a4:	4b2a      	ldr	r3, [pc, #168]	@ (34008750 <RCCEx_GetUARTCLKFreq+0x218>)
340086a6:	e7f3      	b.n	34008690 <RCCEx_GetUARTCLKFreq+0x158>
340086a8:	4b2a      	ldr	r3, [pc, #168]	@ (34008754 <RCCEx_GetUARTCLKFreq+0x21c>)
340086aa:	4298      	cmp	r0, r3
340086ac:	d009      	beq.n	340086c2 <RCCEx_GetUARTCLKFreq+0x18a>
340086ae:	d813      	bhi.n	340086d8 <RCCEx_GetUARTCLKFreq+0x1a0>
340086b0:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
340086b4:	4298      	cmp	r0, r3
340086b6:	d004      	beq.n	340086c2 <RCCEx_GetUARTCLKFreq+0x18a>
340086b8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
340086bc:	4298      	cmp	r0, r3
340086be:	f47f af5b 	bne.w	34008578 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_HSI_IsReady() != 0U)
340086c2:	f7fd fdd3 	bl	3400626c <LL_RCC_HSI_IsReady>
340086c6:	2800      	cmp	r0, #0
340086c8:	f43f af56 	beq.w	34008578 <RCCEx_GetUARTCLKFreq+0x40>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
340086cc:	4b18      	ldr	r3, [pc, #96]	@ (34008730 <RCCEx_GetUARTCLKFreq+0x1f8>)
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340086ce:	4822      	ldr	r0, [pc, #136]	@ (34008758 <RCCEx_GetUARTCLKFreq+0x220>)
340086d0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340086d2:	f3c3 13c1 	ubfx	r3, r3, #7, #2
340086d6:	e009      	b.n	340086ec <RCCEx_GetUARTCLKFreq+0x1b4>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
340086d8:	4b20      	ldr	r3, [pc, #128]	@ (3400875c <RCCEx_GetUARTCLKFreq+0x224>)
340086da:	e7ef      	b.n	340086bc <RCCEx_GetUARTCLKFreq+0x184>
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340086dc:	f7fd fd98 	bl	34006210 <HAL_RCC_GetSysClockFreq>
340086e0:	f7fd fe56 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
340086e4:	4b12      	ldr	r3, [pc, #72]	@ (34008730 <RCCEx_GetUARTCLKFreq+0x1f8>)
340086e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340086e8:	f003 0307 	and.w	r3, r3, #7
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340086ec:	40d8      	lsrs	r0, r3
340086ee:	e744      	b.n	3400857a <RCCEx_GetUARTCLKFreq+0x42>
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340086f0:	f7fd fd8e 	bl	34006210 <HAL_RCC_GetSysClockFreq>
340086f4:	f7fd fe4c 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
340086f8:	4b0d      	ldr	r3, [pc, #52]	@ (34008730 <RCCEx_GetUARTCLKFreq+0x1f8>)
340086fa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
340086fc:	f3c3 1302 	ubfx	r3, r3, #4, #3
34008700:	e7f4      	b.n	340086ec <RCCEx_GetUARTCLKFreq+0x1b4>
        switch (LL_RCC_IC14_GetSource())
34008702:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008706:	f47f af37 	bne.w	34008578 <RCCEx_GetUARTCLKFreq+0x40>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400870a:	f7ff fbd9 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
3400870e:	e76f      	b.n	340085f0 <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008710:	f7ff fb56 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
34008714:	e76c      	b.n	340085f0 <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008716:	f7ff fb93 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
3400871a:	e769      	b.n	340085f0 <RCCEx_GetUARTCLKFreq+0xb8>
3400871c:	07021c30 	.word	0x07021c30
34008720:	07000034 	.word	0x07000034
34008724:	07011c30 	.word	0x07011c30
34008728:	07011830 	.word	0x07011830
3400872c:	07021030 	.word	0x07021030
34008730:	56028000 	.word	0x56028000
34008734:	07021830 	.word	0x07021830
34008738:	07050034 	.word	0x07050034
3400873c:	07031830 	.word	0x07031830
34008740:	07041830 	.word	0x07041830
34008744:	07041c30 	.word	0x07041c30
34008748:	07060034 	.word	0x07060034
3400874c:	003d0900 	.word	0x003d0900
34008750:	07051c30 	.word	0x07051c30
34008754:	07061830 	.word	0x07061830
34008758:	03d09000 	.word	0x03d09000
3400875c:	07061c30 	.word	0x07061c30

34008760 <RCCEx_GetSPICLKFreq>:
{
34008760:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
34008762:	f7fd fdad 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
34008766:	4b89      	ldr	r3, [pc, #548]	@ (3400898c <RCCEx_GetSPICLKFreq+0x22c>)
34008768:	4298      	cmp	r0, r3
3400876a:	d055      	beq.n	34008818 <RCCEx_GetSPICLKFreq+0xb8>
3400876c:	d865      	bhi.n	3400883a <RCCEx_GetSPICLKFreq+0xda>
3400876e:	f5a3 333c 	sub.w	r3, r3, #192512	@ 0x2f000
34008772:	4298      	cmp	r0, r3
34008774:	f000 80ca 	beq.w	3400890c <RCCEx_GetSPICLKFreq+0x1ac>
34008778:	d81e      	bhi.n	340087b8 <RCCEx_GetSPICLKFreq+0x58>
3400877a:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400877e:	4298      	cmp	r0, r3
34008780:	f000 80ba 	beq.w	340088f8 <RCCEx_GetSPICLKFreq+0x198>
34008784:	d80a      	bhi.n	3400879c <RCCEx_GetSPICLKFreq+0x3c>
34008786:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400878a:	4298      	cmp	r0, r3
3400878c:	d00b      	beq.n	340087a6 <RCCEx_GetSPICLKFreq+0x46>
3400878e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008792:	4298      	cmp	r0, r3
34008794:	f000 80b0 	beq.w	340088f8 <RCCEx_GetSPICLKFreq+0x198>
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
34008798:	2000      	movs	r0, #0
}
3400879a:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400879c:	4b7c      	ldr	r3, [pc, #496]	@ (34008990 <RCCEx_GetSPICLKFreq+0x230>)
3400879e:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
340087a2:	4298      	cmp	r0, r3
340087a4:	d1f8      	bne.n	34008798 <RCCEx_GetSPICLKFreq+0x38>
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340087a6:	f7fd fd33 	bl	34006210 <HAL_RCC_GetSysClockFreq>
340087aa:	f7fd fdf1 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
340087ae:	4b79      	ldr	r3, [pc, #484]	@ (34008994 <RCCEx_GetSPICLKFreq+0x234>)
340087b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
340087b2:	f3c3 1302 	ubfx	r3, r3, #4, #3
340087b6:	e0a7      	b.n	34008908 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
340087b8:	4b77      	ldr	r3, [pc, #476]	@ (34008998 <RCCEx_GetSPICLKFreq+0x238>)
340087ba:	4298      	cmp	r0, r3
340087bc:	f000 80af 	beq.w	3400891e <RCCEx_GetSPICLKFreq+0x1be>
340087c0:	d81d      	bhi.n	340087fe <RCCEx_GetSPICLKFreq+0x9e>
340087c2:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
340087c6:	4298      	cmp	r0, r3
340087c8:	d00a      	beq.n	340087e0 <RCCEx_GetSPICLKFreq+0x80>
340087ca:	d80d      	bhi.n	340087e8 <RCCEx_GetSPICLKFreq+0x88>
340087cc:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
340087d0:	4298      	cmp	r0, r3
340087d2:	d005      	beq.n	340087e0 <RCCEx_GetSPICLKFreq+0x80>
340087d4:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
340087d8:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
340087dc:	4298      	cmp	r0, r3
340087de:	d1db      	bne.n	34008798 <RCCEx_GetSPICLKFreq+0x38>
}
340087e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340087e4:	f7ff bbac 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
340087e8:	4b6c      	ldr	r3, [pc, #432]	@ (3400899c <RCCEx_GetSPICLKFreq+0x23c>)
340087ea:	4298      	cmp	r0, r3
340087ec:	d0f8      	beq.n	340087e0 <RCCEx_GetSPICLKFreq+0x80>
340087ee:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
340087f2:	4298      	cmp	r0, r3
340087f4:	f000 8093 	beq.w	3400891e <RCCEx_GetSPICLKFreq+0x1be>
340087f8:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
340087fc:	e7ee      	b.n	340087dc <RCCEx_GetSPICLKFreq+0x7c>
340087fe:	4b68      	ldr	r3, [pc, #416]	@ (340089a0 <RCCEx_GetSPICLKFreq+0x240>)
34008800:	4298      	cmp	r0, r3
34008802:	d009      	beq.n	34008818 <RCCEx_GetSPICLKFreq+0xb8>
34008804:	d813      	bhi.n	3400882e <RCCEx_GetSPICLKFreq+0xce>
34008806:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400880a:	4298      	cmp	r0, r3
3400880c:	f000 8087 	beq.w	3400891e <RCCEx_GetSPICLKFreq+0x1be>
34008810:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008814:	4298      	cmp	r0, r3
34008816:	d1bf      	bne.n	34008798 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_IC9_IsEnabled() != 0U)
34008818:	f7fd fd84 	bl	34006324 <LL_RCC_IC9_IsEnabled>
3400881c:	2800      	cmp	r0, #0
3400881e:	d0bb      	beq.n	34008798 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC9_GetDivider();
34008820:	f7fd fd88 	bl	34006334 <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
34008824:	4b5b      	ldr	r3, [pc, #364]	@ (34008994 <RCCEx_GetSPICLKFreq+0x234>)
34008826:	4604      	mov	r4, r0
34008828:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400882c:	e082      	b.n	34008934 <RCCEx_GetSPICLKFreq+0x1d4>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400882e:	4b5d      	ldr	r3, [pc, #372]	@ (340089a4 <RCCEx_GetSPICLKFreq+0x244>)
34008830:	4298      	cmp	r0, r3
34008832:	d074      	beq.n	3400891e <RCCEx_GetSPICLKFreq+0x1be>
34008834:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
34008838:	e7ec      	b.n	34008814 <RCCEx_GetSPICLKFreq+0xb4>
3400883a:	4b5b      	ldr	r3, [pc, #364]	@ (340089a8 <RCCEx_GetSPICLKFreq+0x248>)
3400883c:	4298      	cmp	r0, r3
3400883e:	d043      	beq.n	340088c8 <RCCEx_GetSPICLKFreq+0x168>
34008840:	d830      	bhi.n	340088a4 <RCCEx_GetSPICLKFreq+0x144>
34008842:	f5a3 33fa 	sub.w	r3, r3, #128000	@ 0x1f400
34008846:	4298      	cmp	r0, r3
34008848:	d0e6      	beq.n	34008818 <RCCEx_GetSPICLKFreq+0xb8>
3400884a:	d808      	bhi.n	3400885e <RCCEx_GetSPICLKFreq+0xfe>
3400884c:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
34008850:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
34008854:	429a      	cmp	r2, r3
34008856:	d079      	beq.n	3400894c <RCCEx_GetSPICLKFreq+0x1ec>
34008858:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400885c:	e7da      	b.n	34008814 <RCCEx_GetSPICLKFreq+0xb4>
3400885e:	4b53      	ldr	r3, [pc, #332]	@ (340089ac <RCCEx_GetSPICLKFreq+0x24c>)
34008860:	4298      	cmp	r0, r3
34008862:	d00d      	beq.n	34008880 <RCCEx_GetSPICLKFreq+0x120>
34008864:	d814      	bhi.n	34008890 <RCCEx_GetSPICLKFreq+0x130>
34008866:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400886a:	4298      	cmp	r0, r3
3400886c:	d008      	beq.n	34008880 <RCCEx_GetSPICLKFreq+0x120>
3400886e:	d80d      	bhi.n	3400888c <RCCEx_GetSPICLKFreq+0x12c>
34008870:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
34008874:	4298      	cmp	r0, r3
34008876:	d003      	beq.n	34008880 <RCCEx_GetSPICLKFreq+0x120>
34008878:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400887c:	4298      	cmp	r0, r3
3400887e:	d18b      	bne.n	34008798 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_MSI_IsReady() != 0U)
34008880:	f7fd fcfc 	bl	3400627c <LL_RCC_MSI_IsReady>
34008884:	2800      	cmp	r0, #0
34008886:	d087      	beq.n	34008798 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = MSI_VALUE;
34008888:	4849      	ldr	r0, [pc, #292]	@ (340089b0 <RCCEx_GetSPICLKFreq+0x250>)
  return spi_frequency;
3400888a:	e786      	b.n	3400879a <RCCEx_GetSPICLKFreq+0x3a>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400888c:	4b49      	ldr	r3, [pc, #292]	@ (340089b4 <RCCEx_GetSPICLKFreq+0x254>)
3400888e:	e7f5      	b.n	3400887c <RCCEx_GetSPICLKFreq+0x11c>
34008890:	4b49      	ldr	r3, [pc, #292]	@ (340089b8 <RCCEx_GetSPICLKFreq+0x258>)
34008892:	4298      	cmp	r0, r3
34008894:	d018      	beq.n	340088c8 <RCCEx_GetSPICLKFreq+0x168>
34008896:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400889a:	4298      	cmp	r0, r3
3400889c:	d014      	beq.n	340088c8 <RCCEx_GetSPICLKFreq+0x168>
3400889e:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
340088a2:	e7eb      	b.n	3400887c <RCCEx_GetSPICLKFreq+0x11c>
340088a4:	4b45      	ldr	r3, [pc, #276]	@ (340089bc <RCCEx_GetSPICLKFreq+0x25c>)
340088a6:	4298      	cmp	r0, r3
340088a8:	d069      	beq.n	3400897e <RCCEx_GetSPICLKFreq+0x21e>
340088aa:	d81e      	bhi.n	340088ea <RCCEx_GetSPICLKFreq+0x18a>
340088ac:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
340088b0:	4298      	cmp	r0, r3
340088b2:	d018      	beq.n	340088e6 <RCCEx_GetSPICLKFreq+0x186>
340088b4:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
340088b8:	d811      	bhi.n	340088de <RCCEx_GetSPICLKFreq+0x17e>
340088ba:	4a41      	ldr	r2, [pc, #260]	@ (340089c0 <RCCEx_GetSPICLKFreq+0x260>)
340088bc:	4293      	cmp	r3, r2
340088be:	d003      	beq.n	340088c8 <RCCEx_GetSPICLKFreq+0x168>
340088c0:	4b40      	ldr	r3, [pc, #256]	@ (340089c4 <RCCEx_GetSPICLKFreq+0x264>)
340088c2:	4298      	cmp	r0, r3
340088c4:	f47f af68 	bne.w	34008798 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_HSI_IsReady() != 0U)
340088c8:	f7fd fcd0 	bl	3400626c <LL_RCC_HSI_IsReady>
340088cc:	2800      	cmp	r0, #0
340088ce:	f43f af63 	beq.w	34008798 <RCCEx_GetSPICLKFreq+0x38>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
340088d2:	4b30      	ldr	r3, [pc, #192]	@ (34008994 <RCCEx_GetSPICLKFreq+0x234>)
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340088d4:	483c      	ldr	r0, [pc, #240]	@ (340089c8 <RCCEx_GetSPICLKFreq+0x268>)
340088d6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340088d8:	f3c3 13c1 	ubfx	r3, r3, #7, #2
340088dc:	e014      	b.n	34008908 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
340088de:	4a3b      	ldr	r2, [pc, #236]	@ (340089cc <RCCEx_GetSPICLKFreq+0x26c>)
340088e0:	4293      	cmp	r3, r2
340088e2:	f47f af59 	bne.w	34008798 <RCCEx_GetSPICLKFreq+0x38>
340088e6:	483a      	ldr	r0, [pc, #232]	@ (340089d0 <RCCEx_GetSPICLKFreq+0x270>)
340088e8:	e757      	b.n	3400879a <RCCEx_GetSPICLKFreq+0x3a>
340088ea:	4b3a      	ldr	r3, [pc, #232]	@ (340089d4 <RCCEx_GetSPICLKFreq+0x274>)
340088ec:	4298      	cmp	r0, r3
340088ee:	d046      	beq.n	3400897e <RCCEx_GetSPICLKFreq+0x21e>
340088f0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
340088f4:	4298      	cmp	r0, r3
340088f6:	e7f4      	b.n	340088e2 <RCCEx_GetSPICLKFreq+0x182>
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340088f8:	f7fd fc8a 	bl	34006210 <HAL_RCC_GetSysClockFreq>
340088fc:	f7fd fd48 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
34008900:	4b24      	ldr	r3, [pc, #144]	@ (34008994 <RCCEx_GetSPICLKFreq+0x234>)
34008902:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008904:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
34008908:	40d8      	lsrs	r0, r3
      break;
3400890a:	e746      	b.n	3400879a <RCCEx_GetSPICLKFreq+0x3a>
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400890c:	f7fd fc80 	bl	34006210 <HAL_RCC_GetSysClockFreq>
34008910:	f7fd fd3e 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
34008914:	4b1f      	ldr	r3, [pc, #124]	@ (34008994 <RCCEx_GetSPICLKFreq+0x234>)
34008916:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
34008918:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400891c:	e7f4      	b.n	34008908 <RCCEx_GetSPICLKFreq+0x1a8>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400891e:	f7fd fcef 	bl	34006300 <LL_RCC_IC8_IsEnabled>
34008922:	2800      	cmp	r0, #0
34008924:	f43f af38 	beq.w	34008798 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC8_GetDivider();
34008928:	f7fd fcf2 	bl	34006310 <LL_RCC_IC8_GetDivider>
3400892c:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400892e:	4b19      	ldr	r3, [pc, #100]	@ (34008994 <RCCEx_GetSPICLKFreq+0x234>)
34008930:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
34008934:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
34008938:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400893c:	d01c      	beq.n	34008978 <RCCEx_GetSPICLKFreq+0x218>
3400893e:	d811      	bhi.n	34008964 <RCCEx_GetSPICLKFreq+0x204>
34008940:	b9bb      	cbnz	r3, 34008972 <RCCEx_GetSPICLKFreq+0x212>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008942:	f7ff f9fd 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            spi_frequency = spi_frequency / ic_divider;
34008946:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400894a:	e726      	b.n	3400879a <RCCEx_GetSPICLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400894c:	f7fd fcfc 	bl	34006348 <LL_RCC_IC14_IsEnabled>
34008950:	2800      	cmp	r0, #0
34008952:	f43f af21 	beq.w	34008798 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC14_GetDivider();
34008956:	f7fd fcff 	bl	34006358 <LL_RCC_IC14_GetDivider>
3400895a:	4b0e      	ldr	r3, [pc, #56]	@ (34008994 <RCCEx_GetSPICLKFreq+0x234>)
3400895c:	4604      	mov	r4, r0
3400895e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34008962:	e7e7      	b.n	34008934 <RCCEx_GetSPICLKFreq+0x1d4>
        switch (LL_RCC_IC14_GetSource())
34008964:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008968:	f47f af16 	bne.w	34008798 <RCCEx_GetSPICLKFreq+0x38>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400896c:	f7ff faa8 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
34008970:	e7e9      	b.n	34008946 <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008972:	f7ff fa25 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
34008976:	e7e6      	b.n	34008946 <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008978:	f7ff fa62 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
3400897c:	e7e3      	b.n	34008946 <RCCEx_GetSPICLKFreq+0x1e6>
      if (LL_RCC_HSE_IsReady() != 0U)
3400897e:	f7fd fc6d 	bl	3400625c <LL_RCC_HSE_IsReady>
34008982:	2800      	cmp	r0, #0
34008984:	f43f af08 	beq.w	34008798 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = HSE_VALUE;
34008988:	4813      	ldr	r0, [pc, #76]	@ (340089d8 <RCCEx_GetSPICLKFreq+0x278>)
3400898a:	e706      	b.n	3400879a <RCCEx_GetSPICLKFreq+0x3a>
3400898c:	07030820 	.word	0x07030820
34008990:	07001020 	.word	0x07001020
34008994:	56028000 	.word	0x56028000
34008998:	07020820 	.word	0x07020820
3400899c:	07011820 	.word	0x07011820
340089a0:	07021420 	.word	0x07021420
340089a4:	07021820 	.word	0x07021820
340089a8:	07050c20 	.word	0x07050c20
340089ac:	07041420 	.word	0x07041420
340089b0:	003d0900 	.word	0x003d0900
340089b4:	07041020 	.word	0x07041020
340089b8:	07050420 	.word	0x07050420
340089bc:	07061020 	.word	0x07061020
340089c0:	07051020 	.word	0x07051020
340089c4:	07051820 	.word	0x07051820
340089c8:	03d09000 	.word	0x03d09000
340089cc:	07060820 	.word	0x07060820
340089d0:	00bb8000 	.word	0x00bb8000
340089d4:	07061420 	.word	0x07061420
340089d8:	02dc6c00 	.word	0x02dc6c00

340089dc <RCCEx_GetSAICLKFreq>:
{
340089dc:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
340089de:	f7fd fc6f 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
340089e2:	4b49      	ldr	r3, [pc, #292]	@ (34008b08 <RCCEx_GetSAICLKFreq+0x12c>)
340089e4:	4298      	cmp	r0, r3
340089e6:	d04a      	beq.n	34008a7e <RCCEx_GetSAICLKFreq+0xa2>
340089e8:	d839      	bhi.n	34008a5e <RCCEx_GetSAICLKFreq+0x82>
340089ea:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
340089ee:	4298      	cmp	r0, r3
340089f0:	d021      	beq.n	34008a36 <RCCEx_GetSAICLKFreq+0x5a>
340089f2:	d815      	bhi.n	34008a20 <RCCEx_GetSAICLKFreq+0x44>
340089f4:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
340089f8:	4298      	cmp	r0, r3
340089fa:	d00d      	beq.n	34008a18 <RCCEx_GetSAICLKFreq+0x3c>
340089fc:	d809      	bhi.n	34008a12 <RCCEx_GetSAICLKFreq+0x36>
340089fe:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008a02:	4298      	cmp	r0, r3
34008a04:	d04e      	beq.n	34008aa4 <RCCEx_GetSAICLKFreq+0xc8>
34008a06:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008a0a:	4298      	cmp	r0, r3
34008a0c:	d04a      	beq.n	34008aa4 <RCCEx_GetSAICLKFreq+0xc8>
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
34008a0e:	2000      	movs	r0, #0
}
34008a10:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
34008a12:	4b3e      	ldr	r3, [pc, #248]	@ (34008b0c <RCCEx_GetSAICLKFreq+0x130>)
34008a14:	4298      	cmp	r0, r3
34008a16:	d1fa      	bne.n	34008a0e <RCCEx_GetSAICLKFreq+0x32>
}
34008a18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008a1c:	f7ff ba90 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
34008a20:	4b3b      	ldr	r3, [pc, #236]	@ (34008b10 <RCCEx_GetSAICLKFreq+0x134>)
34008a22:	4298      	cmp	r0, r3
34008a24:	d04d      	beq.n	34008ac2 <RCCEx_GetSAICLKFreq+0xe6>
34008a26:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008a2a:	4298      	cmp	r0, r3
34008a2c:	d049      	beq.n	34008ac2 <RCCEx_GetSAICLKFreq+0xe6>
34008a2e:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008a32:	4298      	cmp	r0, r3
34008a34:	d1eb      	bne.n	34008a0e <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_IC7_IsEnabled() != 0U)
34008a36:	f7fd fc51 	bl	340062dc <LL_RCC_IC7_IsEnabled>
34008a3a:	2800      	cmp	r0, #0
34008a3c:	d0e7      	beq.n	34008a0e <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC7_GetDivider();
34008a3e:	f7fd fc55 	bl	340062ec <LL_RCC_IC7_GetDivider>
34008a42:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
34008a44:	4b33      	ldr	r3, [pc, #204]	@ (34008b14 <RCCEx_GetSAICLKFreq+0x138>)
34008a46:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
34008a4a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
34008a4e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008a52:	d047      	beq.n	34008ae4 <RCCEx_GetSAICLKFreq+0x108>
34008a54:	d840      	bhi.n	34008ad8 <RCCEx_GetSAICLKFreq+0xfc>
34008a56:	bb7b      	cbnz	r3, 34008ab8 <RCCEx_GetSAICLKFreq+0xdc>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008a58:	f7ff f972 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
34008a5c:	e02e      	b.n	34008abc <RCCEx_GetSAICLKFreq+0xe0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
34008a5e:	4b2e      	ldr	r3, [pc, #184]	@ (34008b18 <RCCEx_GetSAICLKFreq+0x13c>)
34008a60:	4298      	cmp	r0, r3
34008a62:	d01d      	beq.n	34008aa0 <RCCEx_GetSAICLKFreq+0xc4>
34008a64:	d811      	bhi.n	34008a8a <RCCEx_GetSAICLKFreq+0xae>
34008a66:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008a6a:	4298      	cmp	r0, r3
34008a6c:	d03d      	beq.n	34008aea <RCCEx_GetSAICLKFreq+0x10e>
34008a6e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008a72:	4298      	cmp	r0, r3
34008a74:	d039      	beq.n	34008aea <RCCEx_GetSAICLKFreq+0x10e>
34008a76:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008a7a:	4298      	cmp	r0, r3
34008a7c:	d1c7      	bne.n	34008a0e <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_MSI_IsReady() != 0U)
34008a7e:	f7fd fbfd 	bl	3400627c <LL_RCC_MSI_IsReady>
34008a82:	2800      	cmp	r0, #0
34008a84:	d0c3      	beq.n	34008a0e <RCCEx_GetSAICLKFreq+0x32>
        sai_frequency = MSI_VALUE;
34008a86:	4825      	ldr	r0, [pc, #148]	@ (34008b1c <RCCEx_GetSAICLKFreq+0x140>)
  return sai_frequency;
34008a88:	e7c2      	b.n	34008a10 <RCCEx_GetSAICLKFreq+0x34>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
34008a8a:	4b25      	ldr	r3, [pc, #148]	@ (34008b20 <RCCEx_GetSAICLKFreq+0x144>)
34008a8c:	4298      	cmp	r0, r3
34008a8e:	d036      	beq.n	34008afe <RCCEx_GetSAICLKFreq+0x122>
34008a90:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008a94:	4298      	cmp	r0, r3
34008a96:	d032      	beq.n	34008afe <RCCEx_GetSAICLKFreq+0x122>
34008a98:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008a9c:	4298      	cmp	r0, r3
34008a9e:	d1b6      	bne.n	34008a0e <RCCEx_GetSAICLKFreq+0x32>
34008aa0:	4820      	ldr	r0, [pc, #128]	@ (34008b24 <RCCEx_GetSAICLKFreq+0x148>)
34008aa2:	e7b5      	b.n	34008a10 <RCCEx_GetSAICLKFreq+0x34>
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34008aa4:	f7fd fbb4 	bl	34006210 <HAL_RCC_GetSysClockFreq>
34008aa8:	f7fd fc72 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
34008aac:	4b19      	ldr	r3, [pc, #100]	@ (34008b14 <RCCEx_GetSAICLKFreq+0x138>)
34008aae:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
34008ab0:	f3c3 1302 	ubfx	r3, r3, #4, #3
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34008ab4:	40d8      	lsrs	r0, r3
34008ab6:	e7ab      	b.n	34008a10 <RCCEx_GetSAICLKFreq+0x34>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008ab8:	f7ff f982 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
            sai_frequency = sai_frequency / ic_divider;
34008abc:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
34008ac0:	e7a6      	b.n	34008a10 <RCCEx_GetSAICLKFreq+0x34>
      if (LL_RCC_IC8_IsEnabled() != 0U)
34008ac2:	f7fd fc1d 	bl	34006300 <LL_RCC_IC8_IsEnabled>
34008ac6:	2800      	cmp	r0, #0
34008ac8:	d0a1      	beq.n	34008a0e <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC8_GetDivider();
34008aca:	f7fd fc21 	bl	34006310 <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
34008ace:	4b11      	ldr	r3, [pc, #68]	@ (34008b14 <RCCEx_GetSAICLKFreq+0x138>)
34008ad0:	4604      	mov	r4, r0
34008ad2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34008ad6:	e7b8      	b.n	34008a4a <RCCEx_GetSAICLKFreq+0x6e>
        switch (LL_RCC_IC8_GetSource())
34008ad8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008adc:	d197      	bne.n	34008a0e <RCCEx_GetSAICLKFreq+0x32>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008ade:	f7ff f9ef 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
34008ae2:	e7eb      	b.n	34008abc <RCCEx_GetSAICLKFreq+0xe0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008ae4:	f7ff f9ac 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
34008ae8:	e7e8      	b.n	34008abc <RCCEx_GetSAICLKFreq+0xe0>
      if (LL_RCC_HSI_IsReady() != 0U)
34008aea:	f7fd fbbf 	bl	3400626c <LL_RCC_HSI_IsReady>
34008aee:	2800      	cmp	r0, #0
34008af0:	d08d      	beq.n	34008a0e <RCCEx_GetSAICLKFreq+0x32>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34008af2:	4b08      	ldr	r3, [pc, #32]	@ (34008b14 <RCCEx_GetSAICLKFreq+0x138>)
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34008af4:	480c      	ldr	r0, [pc, #48]	@ (34008b28 <RCCEx_GetSAICLKFreq+0x14c>)
34008af6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34008af8:	f3c3 13c1 	ubfx	r3, r3, #7, #2
34008afc:	e7da      	b.n	34008ab4 <RCCEx_GetSAICLKFreq+0xd8>
}
34008afe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
34008b02:	f7ff baa3 	b.w	3400804c <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
34008b06:	bf00      	nop
34008b08:	07041418 	.word	0x07041418
34008b0c:	07011818 	.word	0x07011818
34008b10:	07031418 	.word	0x07031418
34008b14:	56028000 	.word	0x56028000
34008b18:	07061418 	.word	0x07061418
34008b1c:	003d0900 	.word	0x003d0900
34008b20:	07071418 	.word	0x07071418
34008b24:	00bb8000 	.word	0x00bb8000
34008b28:	03d09000 	.word	0x03d09000

34008b2c <RCCEx_GetI3CCLKFreq>:
{
34008b2c:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
34008b2e:	f7fd fbc7 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
34008b32:	4b3d      	ldr	r3, [pc, #244]	@ (34008c28 <RCCEx_GetI3CCLKFreq+0xfc>)
34008b34:	4298      	cmp	r0, r3
34008b36:	d060      	beq.n	34008bfa <RCCEx_GetI3CCLKFreq+0xce>
34008b38:	d830      	bhi.n	34008b9c <RCCEx_GetI3CCLKFreq+0x70>
34008b3a:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
34008b3e:	4298      	cmp	r0, r3
34008b40:	d057      	beq.n	34008bf2 <RCCEx_GetI3CCLKFreq+0xc6>
34008b42:	d80d      	bhi.n	34008b60 <RCCEx_GetI3CCLKFreq+0x34>
34008b44:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008b48:	4298      	cmp	r0, r3
34008b4a:	d048      	beq.n	34008bde <RCCEx_GetI3CCLKFreq+0xb2>
34008b4c:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
34008b50:	4298      	cmp	r0, r3
34008b52:	d04e      	beq.n	34008bf2 <RCCEx_GetI3CCLKFreq+0xc6>
34008b54:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008b58:	4298      	cmp	r0, r3
34008b5a:	d040      	beq.n	34008bde <RCCEx_GetI3CCLKFreq+0xb2>
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
34008b5c:	2000      	movs	r0, #0
}
34008b5e:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
34008b60:	4b32      	ldr	r3, [pc, #200]	@ (34008c2c <RCCEx_GetI3CCLKFreq+0x100>)
34008b62:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
34008b66:	4298      	cmp	r0, r3
34008b68:	d1f8      	bne.n	34008b5c <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
34008b6a:	4b31      	ldr	r3, [pc, #196]	@ (34008c30 <RCCEx_GetI3CCLKFreq+0x104>)
34008b6c:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
34008b70:	0592      	lsls	r2, r2, #22
34008b72:	d5f3      	bpl.n	34008b5c <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
34008b74:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
34008b78:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
34008b7c:	f3c0 4007 	ubfx	r0, r0, #16, #8
34008b80:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
34008b82:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
34008b86:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008b8a:	d04a      	beq.n	34008c22 <RCCEx_GetI3CCLKFreq+0xf6>
34008b8c:	d840      	bhi.n	34008c10 <RCCEx_GetI3CCLKFreq+0xe4>
34008b8e:	2b00      	cmp	r3, #0
34008b90:	d144      	bne.n	34008c1c <RCCEx_GetI3CCLKFreq+0xf0>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008b92:	f7ff f8d5 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            i3c_frequency = i3c_frequency / ic_divider;
34008b96:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
34008b9a:	e7e0      	b.n	34008b5e <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
34008b9c:	4b25      	ldr	r3, [pc, #148]	@ (34008c34 <RCCEx_GetI3CCLKFreq+0x108>)
34008b9e:	4298      	cmp	r0, r3
34008ba0:	d008      	beq.n	34008bb4 <RCCEx_GetI3CCLKFreq+0x88>
34008ba2:	d80d      	bhi.n	34008bc0 <RCCEx_GetI3CCLKFreq+0x94>
34008ba4:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008ba8:	4298      	cmp	r0, r3
34008baa:	d026      	beq.n	34008bfa <RCCEx_GetI3CCLKFreq+0xce>
34008bac:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
34008bb0:	4298      	cmp	r0, r3
34008bb2:	d1d3      	bne.n	34008b5c <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_MSI_IsReady() != 0U)
34008bb4:	f7fd fb62 	bl	3400627c <LL_RCC_MSI_IsReady>
34008bb8:	2800      	cmp	r0, #0
34008bba:	d0cf      	beq.n	34008b5c <RCCEx_GetI3CCLKFreq+0x30>
        i3c_frequency = MSI_VALUE;
34008bbc:	481e      	ldr	r0, [pc, #120]	@ (34008c38 <RCCEx_GetI3CCLKFreq+0x10c>)
  return i3c_frequency;
34008bbe:	e7ce      	b.n	34008b5e <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
34008bc0:	4b1e      	ldr	r3, [pc, #120]	@ (34008c3c <RCCEx_GetI3CCLKFreq+0x110>)
34008bc2:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
34008bc6:	4298      	cmp	r0, r3
34008bc8:	d1c8      	bne.n	34008b5c <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_HSI_IsReady() != 0U)
34008bca:	f7fd fb4f 	bl	3400626c <LL_RCC_HSI_IsReady>
34008bce:	2800      	cmp	r0, #0
34008bd0:	d0c4      	beq.n	34008b5c <RCCEx_GetI3CCLKFreq+0x30>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34008bd2:	4b17      	ldr	r3, [pc, #92]	@ (34008c30 <RCCEx_GetI3CCLKFreq+0x104>)
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34008bd4:	481a      	ldr	r0, [pc, #104]	@ (34008c40 <RCCEx_GetI3CCLKFreq+0x114>)
34008bd6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34008bd8:	f3c3 13c1 	ubfx	r3, r3, #7, #2
34008bdc:	e007      	b.n	34008bee <RCCEx_GetI3CCLKFreq+0xc2>
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34008bde:	f7fd fb17 	bl	34006210 <HAL_RCC_GetSysClockFreq>
34008be2:	f7fd fbd5 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
34008be6:	4b12      	ldr	r3, [pc, #72]	@ (34008c30 <RCCEx_GetI3CCLKFreq+0x104>)
34008be8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008bea:	f003 0307 	and.w	r3, r3, #7
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34008bee:	40d8      	lsrs	r0, r3
34008bf0:	e7b5      	b.n	34008b5e <RCCEx_GetI3CCLKFreq+0x32>
}
34008bf2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008bf6:	f7ff b9a3 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34008bfa:	f7fd fbb7 	bl	3400636c <LL_RCC_IC15_IsEnabled>
34008bfe:	2800      	cmp	r0, #0
34008c00:	d0ac      	beq.n	34008b5c <RCCEx_GetI3CCLKFreq+0x30>
        ic_divider = LL_RCC_IC15_GetDivider();
34008c02:	f7fd fbbb 	bl	3400637c <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
34008c06:	4b0a      	ldr	r3, [pc, #40]	@ (34008c30 <RCCEx_GetI3CCLKFreq+0x104>)
34008c08:	4604      	mov	r4, r0
34008c0a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34008c0e:	e7b8      	b.n	34008b82 <RCCEx_GetI3CCLKFreq+0x56>
        switch (LL_RCC_IC15_GetSource())
34008c10:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008c14:	d1a2      	bne.n	34008b5c <RCCEx_GetI3CCLKFreq+0x30>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008c16:	f7ff f953 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
34008c1a:	e7bc      	b.n	34008b96 <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008c1c:	f7ff f8d0 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
34008c20:	e7b9      	b.n	34008b96 <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008c22:	f7ff f90d 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
34008c26:	e7b6      	b.n	34008b96 <RCCEx_GetI3CCLKFreq+0x6a>
34008c28:	0703100c 	.word	0x0703100c
34008c2c:	0702100c 	.word	0x0702100c
34008c30:	56028000 	.word	0x56028000
34008c34:	0704140c 	.word	0x0704140c
34008c38:	003d0900 	.word	0x003d0900
34008c3c:	0705100c 	.word	0x0705100c
34008c40:	03d09000 	.word	0x03d09000

34008c44 <RCCEx_GetSDMMCCLKFreq>:
{
34008c44:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
34008c46:	f7fd fb3b 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
34008c4a:	4b2d      	ldr	r3, [pc, #180]	@ (34008d00 <RCCEx_GetSDMMCCLKFreq+0xbc>)
34008c4c:	4298      	cmp	r0, r3
34008c4e:	d01d      	beq.n	34008c8c <RCCEx_GetSDMMCCLKFreq+0x48>
34008c50:	d813      	bhi.n	34008c7a <RCCEx_GetSDMMCCLKFreq+0x36>
34008c52:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008c56:	4298      	cmp	r0, r3
34008c58:	d00b      	beq.n	34008c72 <RCCEx_GetSDMMCCLKFreq+0x2e>
34008c5a:	d807      	bhi.n	34008c6c <RCCEx_GetSDMMCCLKFreq+0x28>
34008c5c:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
34008c60:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
34008c64:	4298      	cmp	r0, r3
34008c66:	d02a      	beq.n	34008cbe <RCCEx_GetSDMMCCLKFreq+0x7a>
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
34008c68:	2000      	movs	r0, #0
}
34008c6a:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
34008c6c:	4b25      	ldr	r3, [pc, #148]	@ (34008d04 <RCCEx_GetSDMMCCLKFreq+0xc0>)
34008c6e:	4298      	cmp	r0, r3
34008c70:	d1fa      	bne.n	34008c68 <RCCEx_GetSDMMCCLKFreq+0x24>
}
34008c72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008c76:	f7ff b963 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
34008c7a:	4b23      	ldr	r3, [pc, #140]	@ (34008d08 <RCCEx_GetSDMMCCLKFreq+0xc4>)
34008c7c:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
34008c80:	429a      	cmp	r2, r3
34008c82:	d022      	beq.n	34008cca <RCCEx_GetSDMMCCLKFreq+0x86>
34008c84:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
34008c88:	4298      	cmp	r0, r3
34008c8a:	d1ed      	bne.n	34008c68 <RCCEx_GetSDMMCCLKFreq+0x24>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
34008c8c:	4b1f      	ldr	r3, [pc, #124]	@ (34008d0c <RCCEx_GetSDMMCCLKFreq+0xc8>)
34008c8e:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
34008c92:	f010 0008 	ands.w	r0, r0, #8
34008c96:	d0e8      	beq.n	34008c6a <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
34008c98:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
34008c9c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
34008ca0:	f3c0 4007 	ubfx	r0, r0, #16, #8
34008ca4:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
34008ca6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC5_GetSource())
34008caa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008cae:	d023      	beq.n	34008cf8 <RCCEx_GetSDMMCCLKFreq+0xb4>
34008cb0:	d819      	bhi.n	34008ce6 <RCCEx_GetSDMMCCLKFreq+0xa2>
34008cb2:	b9f3      	cbnz	r3, 34008cf2 <RCCEx_GetSDMMCCLKFreq+0xae>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008cb4:	f7ff f844 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34008cb8:	fbb0 f0f4 	udiv	r0, r0, r4
  return sdmmc_frequency;
34008cbc:	e7d5      	b.n	34008c6a <RCCEx_GetSDMMCCLKFreq+0x26>
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34008cbe:	f7fd faa7 	bl	34006210 <HAL_RCC_GetSysClockFreq>
}
34008cc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34008cc6:	f7fd bb63 	b.w	34006390 <RCCEx_GetHCLKFreq>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
34008cca:	4b10      	ldr	r3, [pc, #64]	@ (34008d0c <RCCEx_GetSDMMCCLKFreq+0xc8>)
34008ccc:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
34008cd0:	f010 0010 	ands.w	r0, r0, #16
34008cd4:	d0c9      	beq.n	34008c6a <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
34008cd6:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
34008cda:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
34008cde:	f3c0 4007 	ubfx	r0, r0, #16, #8
34008ce2:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
34008ce4:	e7df      	b.n	34008ca6 <RCCEx_GetSDMMCCLKFreq+0x62>
        switch (LL_RCC_IC5_GetSource())
34008ce6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008cea:	d1bd      	bne.n	34008c68 <RCCEx_GetSDMMCCLKFreq+0x24>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008cec:	f7ff f8e8 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
34008cf0:	e7e2      	b.n	34008cb8 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008cf2:	f7ff f865 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
34008cf6:	e7df      	b.n	34008cb8 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008cf8:	f7ff f8a2 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
34008cfc:	e7dc      	b.n	34008cb8 <RCCEx_GetSDMMCCLKFreq+0x74>
34008cfe:	bf00      	nop
34008d00:	0302001c 	.word	0x0302001c
34008d04:	0301041c 	.word	0x0301041c
34008d08:	0303001c 	.word	0x0303001c
34008d0c:	56028000 	.word	0x56028000

34008d10 <RCCEx_GetI2CCLKFreq>:
{
34008d10:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
34008d12:	f7fd fad5 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34008d16:	4b50      	ldr	r3, [pc, #320]	@ (34008e58 <RCCEx_GetI2CCLKFreq+0x148>)
34008d18:	4298      	cmp	r0, r3
34008d1a:	f000 8085 	beq.w	34008e28 <RCCEx_GetI2CCLKFreq+0x118>
34008d1e:	d84b      	bhi.n	34008db8 <RCCEx_GetI2CCLKFreq+0xa8>
34008d20:	f5a3 33fc 	sub.w	r3, r3, #129024	@ 0x1f800
34008d24:	4298      	cmp	r0, r3
34008d26:	d01a      	beq.n	34008d5e <RCCEx_GetI2CCLKFreq+0x4e>
34008d28:	d81d      	bhi.n	34008d66 <RCCEx_GetI2CCLKFreq+0x56>
34008d2a:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
34008d2e:	4298      	cmp	r0, r3
34008d30:	d008      	beq.n	34008d44 <RCCEx_GetI2CCLKFreq+0x34>
34008d32:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
34008d36:	d80f      	bhi.n	34008d58 <RCCEx_GetI2CCLKFreq+0x48>
34008d38:	4a48      	ldr	r2, [pc, #288]	@ (34008e5c <RCCEx_GetI2CCLKFreq+0x14c>)
34008d3a:	4293      	cmp	r3, r2
34008d3c:	d002      	beq.n	34008d44 <RCCEx_GetI2CCLKFreq+0x34>
34008d3e:	4b48      	ldr	r3, [pc, #288]	@ (34008e60 <RCCEx_GetI2CCLKFreq+0x150>)
34008d40:	4298      	cmp	r0, r3
34008d42:	d14a      	bne.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34008d44:	f7fd fa64 	bl	34006210 <HAL_RCC_GetSysClockFreq>
34008d48:	f7fd fb22 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
34008d4c:	4b45      	ldr	r3, [pc, #276]	@ (34008e64 <RCCEx_GetI2CCLKFreq+0x154>)
34008d4e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008d50:	f003 0307 	and.w	r3, r3, #7
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34008d54:	40d8      	lsrs	r0, r3
34008d56:	e041      	b.n	34008ddc <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34008d58:	4a43      	ldr	r2, [pc, #268]	@ (34008e68 <RCCEx_GetI2CCLKFreq+0x158>)
34008d5a:	4293      	cmp	r3, r2
34008d5c:	d13d      	bne.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
}
34008d5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008d62:	f7ff b8ed 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34008d66:	4b41      	ldr	r3, [pc, #260]	@ (34008e6c <RCCEx_GetI2CCLKFreq+0x15c>)
34008d68:	4298      	cmp	r0, r3
34008d6a:	d008      	beq.n	34008d7e <RCCEx_GetI2CCLKFreq+0x6e>
34008d6c:	d820      	bhi.n	34008db0 <RCCEx_GetI2CCLKFreq+0xa0>
34008d6e:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
34008d72:	4298      	cmp	r0, r3
34008d74:	d0f3      	beq.n	34008d5e <RCCEx_GetI2CCLKFreq+0x4e>
34008d76:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
34008d7a:	4298      	cmp	r0, r3
34008d7c:	d12d      	bne.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
34008d7e:	4b39      	ldr	r3, [pc, #228]	@ (34008e64 <RCCEx_GetI2CCLKFreq+0x154>)
34008d80:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
34008d84:	0592      	lsls	r2, r2, #22
34008d86:	d528      	bpl.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
34008d88:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
34008d8c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
34008d90:	f3c0 4007 	ubfx	r0, r0, #16, #8
34008d94:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
34008d96:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
34008d9a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008d9e:	d057      	beq.n	34008e50 <RCCEx_GetI2CCLKFreq+0x140>
34008da0:	d84d      	bhi.n	34008e3e <RCCEx_GetI2CCLKFreq+0x12e>
34008da2:	2b00      	cmp	r3, #0
34008da4:	d151      	bne.n	34008e4a <RCCEx_GetI2CCLKFreq+0x13a>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008da6:	f7fe ffcb 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            i2c_frequency = i2c_frequency / ic_divider;
34008daa:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
34008dae:	e015      	b.n	34008ddc <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34008db0:	4b2f      	ldr	r3, [pc, #188]	@ (34008e70 <RCCEx_GetI2CCLKFreq+0x160>)
34008db2:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
34008db6:	e7e0      	b.n	34008d7a <RCCEx_GetI2CCLKFreq+0x6a>
34008db8:	4b2e      	ldr	r3, [pc, #184]	@ (34008e74 <RCCEx_GetI2CCLKFreq+0x164>)
34008dba:	4298      	cmp	r0, r3
34008dbc:	d014      	beq.n	34008de8 <RCCEx_GetI2CCLKFreq+0xd8>
34008dbe:	d819      	bhi.n	34008df4 <RCCEx_GetI2CCLKFreq+0xe4>
34008dc0:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
34008dc4:	4298      	cmp	r0, r3
34008dc6:	d02f      	beq.n	34008e28 <RCCEx_GetI2CCLKFreq+0x118>
34008dc8:	d809      	bhi.n	34008dde <RCCEx_GetI2CCLKFreq+0xce>
34008dca:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
34008dce:	4298      	cmp	r0, r3
34008dd0:	d02a      	beq.n	34008e28 <RCCEx_GetI2CCLKFreq+0x118>
34008dd2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008dd6:	4298      	cmp	r0, r3
34008dd8:	d026      	beq.n	34008e28 <RCCEx_GetI2CCLKFreq+0x118>
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
34008dda:	2000      	movs	r0, #0
}
34008ddc:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34008dde:	4b26      	ldr	r3, [pc, #152]	@ (34008e78 <RCCEx_GetI2CCLKFreq+0x168>)
34008de0:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
34008de4:	4298      	cmp	r0, r3
34008de6:	d1f8      	bne.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_MSI_IsReady() != 0U)
34008de8:	f7fd fa48 	bl	3400627c <LL_RCC_MSI_IsReady>
34008dec:	2800      	cmp	r0, #0
34008dee:	d0f4      	beq.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
        i2c_frequency = MSI_VALUE;
34008df0:	4822      	ldr	r0, [pc, #136]	@ (34008e7c <RCCEx_GetI2CCLKFreq+0x16c>)
  return i2c_frequency;
34008df2:	e7f3      	b.n	34008ddc <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34008df4:	4b22      	ldr	r3, [pc, #136]	@ (34008e80 <RCCEx_GetI2CCLKFreq+0x170>)
34008df6:	4298      	cmp	r0, r3
34008df8:	d008      	beq.n	34008e0c <RCCEx_GetI2CCLKFreq+0xfc>
34008dfa:	d811      	bhi.n	34008e20 <RCCEx_GetI2CCLKFreq+0x110>
34008dfc:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
34008e00:	4298      	cmp	r0, r3
34008e02:	d0f1      	beq.n	34008de8 <RCCEx_GetI2CCLKFreq+0xd8>
34008e04:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
34008e08:	4298      	cmp	r0, r3
34008e0a:	d1e6      	bne.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_HSI_IsReady() != 0U)
34008e0c:	f7fd fa2e 	bl	3400626c <LL_RCC_HSI_IsReady>
34008e10:	2800      	cmp	r0, #0
34008e12:	d0e2      	beq.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34008e14:	4b13      	ldr	r3, [pc, #76]	@ (34008e64 <RCCEx_GetI2CCLKFreq+0x154>)
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34008e16:	481b      	ldr	r0, [pc, #108]	@ (34008e84 <RCCEx_GetI2CCLKFreq+0x174>)
34008e18:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34008e1a:	f3c3 13c1 	ubfx	r3, r3, #7, #2
34008e1e:	e799      	b.n	34008d54 <RCCEx_GetI2CCLKFreq+0x44>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34008e20:	4b19      	ldr	r3, [pc, #100]	@ (34008e88 <RCCEx_GetI2CCLKFreq+0x178>)
34008e22:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
34008e26:	e7ef      	b.n	34008e08 <RCCEx_GetI2CCLKFreq+0xf8>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34008e28:	f7fd faa0 	bl	3400636c <LL_RCC_IC15_IsEnabled>
34008e2c:	2800      	cmp	r0, #0
34008e2e:	d0d4      	beq.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
        ic_divider = LL_RCC_IC15_GetDivider();
34008e30:	f7fd faa4 	bl	3400637c <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
34008e34:	4b0b      	ldr	r3, [pc, #44]	@ (34008e64 <RCCEx_GetI2CCLKFreq+0x154>)
34008e36:	4604      	mov	r4, r0
34008e38:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34008e3c:	e7ab      	b.n	34008d96 <RCCEx_GetI2CCLKFreq+0x86>
        switch (LL_RCC_IC15_GetSource())
34008e3e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008e42:	d1ca      	bne.n	34008dda <RCCEx_GetI2CCLKFreq+0xca>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008e44:	f7ff f83c 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
34008e48:	e7af      	b.n	34008daa <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008e4a:	f7fe ffb9 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
34008e4e:	e7ac      	b.n	34008daa <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008e50:	f7fe fff6 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
34008e54:	e7a9      	b.n	34008daa <RCCEx_GetI2CCLKFreq+0x9a>
34008e56:	bf00      	nop
34008e58:	0703000c 	.word	0x0703000c
34008e5c:	0700000c 	.word	0x0700000c
34008e60:	0700080c 	.word	0x0700080c
34008e64:	56028000 	.word	0x56028000
34008e68:	0701000c 	.word	0x0701000c
34008e6c:	0702040c 	.word	0x0702040c
34008e70:	0702080c 	.word	0x0702080c
34008e74:	0704080c 	.word	0x0704080c
34008e78:	0704000c 	.word	0x0704000c
34008e7c:	003d0900 	.word	0x003d0900
34008e80:	0705040c 	.word	0x0705040c
34008e84:	03d09000 	.word	0x03d09000
34008e88:	0705080c 	.word	0x0705080c

34008e8c <RCCEx_GetLPTIMCLKFreq>:
{
34008e8c:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
34008e8e:	f7fd fa17 	bl	340062c0 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34008e92:	4b63      	ldr	r3, [pc, #396]	@ (34009020 <RCCEx_GetLPTIMCLKFreq+0x194>)
34008e94:	4298      	cmp	r0, r3
34008e96:	d03a      	beq.n	34008f0e <RCCEx_GetLPTIMCLKFreq+0x82>
34008e98:	d850      	bhi.n	34008f3c <RCCEx_GetLPTIMCLKFreq+0xb0>
34008e9a:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
34008e9e:	4298      	cmp	r0, r3
34008ea0:	f000 80a7 	beq.w	34008ff2 <RCCEx_GetLPTIMCLKFreq+0x166>
34008ea4:	d813      	bhi.n	34008ece <RCCEx_GetLPTIMCLKFreq+0x42>
34008ea6:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
34008eaa:	4298      	cmp	r0, r3
34008eac:	f000 8097 	beq.w	34008fde <RCCEx_GetLPTIMCLKFreq+0x152>
34008eb0:	3b01      	subs	r3, #1
34008eb2:	4298      	cmp	r0, r3
34008eb4:	d909      	bls.n	34008eca <RCCEx_GetLPTIMCLKFreq+0x3e>
34008eb6:	f203 4301 	addw	r3, r3, #1025	@ 0x401
34008eba:	4298      	cmp	r0, r3
34008ebc:	f000 8099 	beq.w	34008ff2 <RCCEx_GetLPTIMCLKFreq+0x166>
34008ec0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008ec4:	4298      	cmp	r0, r3
34008ec6:	f000 8094 	beq.w	34008ff2 <RCCEx_GetLPTIMCLKFreq+0x166>
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
34008eca:	2000      	movs	r0, #0
}
34008ecc:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34008ece:	4b55      	ldr	r3, [pc, #340]	@ (34009024 <RCCEx_GetLPTIMCLKFreq+0x198>)
34008ed0:	4298      	cmp	r0, r3
34008ed2:	d015      	beq.n	34008f00 <RCCEx_GetLPTIMCLKFreq+0x74>
34008ed4:	d808      	bhi.n	34008ee8 <RCCEx_GetLPTIMCLKFreq+0x5c>
34008ed6:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
34008eda:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
34008ede:	429a      	cmp	r2, r3
34008ee0:	d00e      	beq.n	34008f00 <RCCEx_GetLPTIMCLKFreq+0x74>
34008ee2:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
34008ee6:	e7ed      	b.n	34008ec4 <RCCEx_GetLPTIMCLKFreq+0x38>
34008ee8:	4b4f      	ldr	r3, [pc, #316]	@ (34009028 <RCCEx_GetLPTIMCLKFreq+0x19c>)
34008eea:	4298      	cmp	r0, r3
34008eec:	d00f      	beq.n	34008f0e <RCCEx_GetLPTIMCLKFreq+0x82>
34008eee:	d80b      	bhi.n	34008f08 <RCCEx_GetLPTIMCLKFreq+0x7c>
34008ef0:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
34008ef4:	4298      	cmp	r0, r3
34008ef6:	d003      	beq.n	34008f00 <RCCEx_GetLPTIMCLKFreq+0x74>
34008ef8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008efc:	4298      	cmp	r0, r3
34008efe:	d1e4      	bne.n	34008eca <RCCEx_GetLPTIMCLKFreq+0x3e>
}
34008f00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008f04:	f7ff b81c 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34008f08:	4b48      	ldr	r3, [pc, #288]	@ (3400902c <RCCEx_GetLPTIMCLKFreq+0x1a0>)
34008f0a:	4298      	cmp	r0, r3
34008f0c:	d1dd      	bne.n	34008eca <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34008f0e:	f7fd fa2d 	bl	3400636c <LL_RCC_IC15_IsEnabled>
34008f12:	2800      	cmp	r0, #0
34008f14:	d0d9      	beq.n	34008eca <RCCEx_GetLPTIMCLKFreq+0x3e>
        ic_divider = LL_RCC_IC15_GetDivider();
34008f16:	f7fd fa31 	bl	3400637c <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
34008f1a:	4b45      	ldr	r3, [pc, #276]	@ (34009030 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
34008f1c:	4604      	mov	r4, r0
34008f1e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34008f22:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
34008f26:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008f2a:	d075      	beq.n	34009018 <RCCEx_GetLPTIMCLKFreq+0x18c>
34008f2c:	d86a      	bhi.n	34009004 <RCCEx_GetLPTIMCLKFreq+0x178>
34008f2e:	2b00      	cmp	r3, #0
34008f30:	d16f      	bne.n	34009012 <RCCEx_GetLPTIMCLKFreq+0x186>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008f32:	f7fe ff05 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            lptim_frequency = lptim_frequency / ic_divider;
34008f36:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
34008f3a:	e7c7      	b.n	34008ecc <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34008f3c:	4b3d      	ldr	r3, [pc, #244]	@ (34009034 <RCCEx_GetLPTIMCLKFreq+0x1a8>)
34008f3e:	4298      	cmp	r0, r3
34008f40:	d034      	beq.n	34008fac <RCCEx_GetLPTIMCLKFreq+0x120>
34008f42:	d824      	bhi.n	34008f8e <RCCEx_GetLPTIMCLKFreq+0x102>
34008f44:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
34008f48:	4298      	cmp	r0, r3
34008f4a:	d00f      	beq.n	34008f6c <RCCEx_GetLPTIMCLKFreq+0xe0>
34008f4c:	d815      	bhi.n	34008f7a <RCCEx_GetLPTIMCLKFreq+0xee>
34008f4e:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
34008f52:	4298      	cmp	r0, r3
34008f54:	d00a      	beq.n	34008f6c <RCCEx_GetLPTIMCLKFreq+0xe0>
34008f56:	d806      	bhi.n	34008f66 <RCCEx_GetLPTIMCLKFreq+0xda>
34008f58:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
34008f5c:	4298      	cmp	r0, r3
34008f5e:	d0d6      	beq.n	34008f0e <RCCEx_GetLPTIMCLKFreq+0x82>
34008f60:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008f64:	e7d1      	b.n	34008f0a <RCCEx_GetLPTIMCLKFreq+0x7e>
34008f66:	4b34      	ldr	r3, [pc, #208]	@ (34009038 <RCCEx_GetLPTIMCLKFreq+0x1ac>)
34008f68:	4298      	cmp	r0, r3
34008f6a:	d1ae      	bne.n	34008eca <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_LSE_IsReady() != 0U)
34008f6c:	f7fd f98e 	bl	3400628c <LL_RCC_LSE_IsReady>
34008f70:	3800      	subs	r0, #0
34008f72:	bf18      	it	ne
34008f74:	2001      	movne	r0, #1
34008f76:	03c0      	lsls	r0, r0, #15
34008f78:	e7a8      	b.n	34008ecc <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34008f7a:	4b30      	ldr	r3, [pc, #192]	@ (3400903c <RCCEx_GetLPTIMCLKFreq+0x1b0>)
34008f7c:	4298      	cmp	r0, r3
34008f7e:	d0f5      	beq.n	34008f6c <RCCEx_GetLPTIMCLKFreq+0xe0>
34008f80:	f503 4370 	add.w	r3, r3, #61440	@ 0xf000
34008f84:	4298      	cmp	r0, r3
34008f86:	d011      	beq.n	34008fac <RCCEx_GetLPTIMCLKFreq+0x120>
34008f88:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
34008f8c:	e7ec      	b.n	34008f68 <RCCEx_GetLPTIMCLKFreq+0xdc>
34008f8e:	4b2c      	ldr	r3, [pc, #176]	@ (34009040 <RCCEx_GetLPTIMCLKFreq+0x1b4>)
34008f90:	4298      	cmp	r0, r3
34008f92:	d015      	beq.n	34008fc0 <RCCEx_GetLPTIMCLKFreq+0x134>
34008f94:	d81b      	bhi.n	34008fce <RCCEx_GetLPTIMCLKFreq+0x142>
34008f96:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
34008f9a:	4298      	cmp	r0, r3
34008f9c:	d006      	beq.n	34008fac <RCCEx_GetLPTIMCLKFreq+0x120>
34008f9e:	d80c      	bhi.n	34008fba <RCCEx_GetLPTIMCLKFreq+0x12e>
34008fa0:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
34008fa4:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
34008fa8:	4298      	cmp	r0, r3
34008faa:	d18e      	bne.n	34008eca <RCCEx_GetLPTIMCLKFreq+0x3e>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34008fac:	4b20      	ldr	r3, [pc, #128]	@ (34009030 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
34008fae:	685b      	ldr	r3, [r3, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
34008fb0:	07db      	lsls	r3, r3, #31
34008fb2:	d58a      	bpl.n	34008eca <RCCEx_GetLPTIMCLKFreq+0x3e>
        lptim_frequency = LSI_VALUE;
34008fb4:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return lptim_frequency;
34008fb8:	e788      	b.n	34008ecc <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34008fba:	4b22      	ldr	r3, [pc, #136]	@ (34009044 <RCCEx_GetLPTIMCLKFreq+0x1b8>)
34008fbc:	4298      	cmp	r0, r3
34008fbe:	d184      	bne.n	34008eca <RCCEx_GetLPTIMCLKFreq+0x3e>
      lptim_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34008fc0:	f7fd f926 	bl	34006210 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
34008fc4:	4b1a      	ldr	r3, [pc, #104]	@ (34009030 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
34008fc6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008fc8:	f3c3 6301 	ubfx	r3, r3, #24, #2
34008fcc:	e00f      	b.n	34008fee <RCCEx_GetLPTIMCLKFreq+0x162>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34008fce:	4b1e      	ldr	r3, [pc, #120]	@ (34009048 <RCCEx_GetLPTIMCLKFreq+0x1bc>)
34008fd0:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
34008fd4:	429a      	cmp	r2, r3
34008fd6:	d0f3      	beq.n	34008fc0 <RCCEx_GetLPTIMCLKFreq+0x134>
34008fd8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34008fdc:	e7ee      	b.n	34008fbc <RCCEx_GetLPTIMCLKFreq+0x130>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34008fde:	f7fd f917 	bl	34006210 <HAL_RCC_GetSysClockFreq>
34008fe2:	f7fd f9d5 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
34008fe6:	4b12      	ldr	r3, [pc, #72]	@ (34009030 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
34008fe8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008fea:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
34008fee:	40d8      	lsrs	r0, r3
      break;
34008ff0:	e76c      	b.n	34008ecc <RCCEx_GetLPTIMCLKFreq+0x40>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34008ff2:	f7fd f90d 	bl	34006210 <HAL_RCC_GetSysClockFreq>
34008ff6:	f7fd f9cb 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
34008ffa:	4b0d      	ldr	r3, [pc, #52]	@ (34009030 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
34008ffc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
34008ffe:	f3c3 3302 	ubfx	r3, r3, #12, #3
34009002:	e7f4      	b.n	34008fee <RCCEx_GetLPTIMCLKFreq+0x162>
        switch (LL_RCC_IC15_GetSource())
34009004:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009008:	f47f af5f 	bne.w	34008eca <RCCEx_GetLPTIMCLKFreq+0x3e>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400900c:	f7fe ff58 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
34009010:	e791      	b.n	34008f36 <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009012:	f7fe fed5 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
34009016:	e78e      	b.n	34008f36 <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009018:	f7fe ff12 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
3400901c:	e78b      	b.n	34008f36 <RCCEx_GetLPTIMCLKFreq+0xaa>
3400901e:	bf00      	nop
34009020:	0702102c 	.word	0x0702102c
34009024:	0701102c 	.word	0x0701102c
34009028:	0702082c 	.word	0x0702082c
3400902c:	07020c2c 	.word	0x07020c2c
34009030:	56028000 	.word	0x56028000
34009034:	07040c2c 	.word	0x07040c2c
34009038:	07030c2c 	.word	0x07030c2c
3400903c:	0703182c 	.word	0x0703182c
34009040:	07050c2c 	.word	0x07050c2c
34009044:	0705082c 	.word	0x0705082c
34009048:	0705102c 	.word	0x0705102c

3400904c <HAL_RCCEx_GetPeriphCLKFreq>:
{
3400904c:	b538      	push	{r3, r4, r5, lr}
  switch (PeriphClk)
3400904e:	f100 4360 	add.w	r3, r0, #3758096384	@ 0xe0000000
34009052:	430b      	orrs	r3, r1
34009054:	f000 8447 	beq.w	340098e6 <HAL_RCCEx_GetPeriphCLKFreq+0x89a>
34009058:	4bbf      	ldr	r3, [pc, #764]	@ (34009358 <HAL_RCCEx_GetPeriphCLKFreq+0x30c>)
3400905a:	4298      	cmp	r0, r3
3400905c:	f171 0300 	sbcs.w	r3, r1, #0
34009060:	f080 80e6 	bcs.w	34009230 <HAL_RCCEx_GetPeriphCLKFreq+0x1e4>
34009064:	f5a0 3380 	sub.w	r3, r0, #65536	@ 0x10000
34009068:	430b      	orrs	r3, r1
3400906a:	f000 835b 	beq.w	34009724 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
3400906e:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
34009072:	f171 0300 	sbcs.w	r3, r1, #0
34009076:	d26a      	bcs.n	3400914e <HAL_RCCEx_GetPeriphCLKFreq+0x102>
34009078:	f5a0 7300 	sub.w	r3, r0, #512	@ 0x200
3400907c:	430b      	orrs	r3, r1
3400907e:	f000 82b9 	beq.w	340095f4 <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
34009082:	f240 2301 	movw	r3, #513	@ 0x201
34009086:	4298      	cmp	r0, r3
34009088:	f171 0300 	sbcs.w	r3, r1, #0
3400908c:	d224      	bcs.n	340090d8 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
3400908e:	2809      	cmp	r0, #9
34009090:	f171 0300 	sbcs.w	r3, r1, #0
34009094:	d215      	bcs.n	340090c2 <HAL_RCCEx_GetPeriphCLKFreq+0x76>
34009096:	ea50 0301 	orrs.w	r3, r0, r1
3400909a:	d01b      	beq.n	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400909c:	3801      	subs	r0, #1
3400909e:	f141 31ff 	adc.w	r1, r1, #4294967295
340090a2:	2808      	cmp	r0, #8
340090a4:	f171 0100 	sbcs.w	r1, r1, #0
340090a8:	d214      	bcs.n	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
340090aa:	2807      	cmp	r0, #7
340090ac:	d812      	bhi.n	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
340090ae:	e8df f010 	tbh	[pc, r0, lsl #1]
340090b2:	01a6      	.short	0x01a6
340090b4:	0011020f 	.word	0x0011020f
340090b8:	00110285 	.word	0x00110285
340090bc:	00110011 	.word	0x00110011
340090c0:	0235      	.short	0x0235
340090c2:	f1a0 0310 	sub.w	r3, r0, #16
340090c6:	430b      	orrs	r3, r1
340090c8:	f000 8242 	beq.w	34009550 <HAL_RCCEx_GetPeriphCLKFreq+0x504>
340090cc:	3820      	subs	r0, #32
340090ce:	4308      	orrs	r0, r1
340090d0:	f000 8268 	beq.w	340095a4 <HAL_RCCEx_GetPeriphCLKFreq+0x558>
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
340090d4:	2000      	movs	r0, #0
340090d6:	e219      	b.n	3400950c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
340090d8:	f5a0 5300 	sub.w	r3, r0, #8192	@ 0x2000
340090dc:	430b      	orrs	r3, r1
340090de:	f000 831d 	beq.w	3400971c <HAL_RCCEx_GetPeriphCLKFreq+0x6d0>
340090e2:	f242 0301 	movw	r3, #8193	@ 0x2001
340090e6:	4298      	cmp	r0, r3
340090e8:	f171 0300 	sbcs.w	r3, r1, #0
340090ec:	d224      	bcs.n	34009138 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
340090ee:	f5a0 6300 	sub.w	r3, r0, #2048	@ 0x800
340090f2:	430b      	orrs	r3, r1
340090f4:	f000 82df 	beq.w	340096b6 <HAL_RCCEx_GetPeriphCLKFreq+0x66a>
340090f8:	f5a0 5380 	sub.w	r3, r0, #4096	@ 0x1000
340090fc:	430b      	orrs	r3, r1
340090fe:	f000 8308 	beq.w	34009712 <HAL_RCCEx_GetPeriphCLKFreq+0x6c6>
34009102:	f5a0 6080 	sub.w	r0, r0, #1024	@ 0x400
34009106:	4308      	orrs	r0, r1
34009108:	d1e4      	bne.n	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
3400910a:	4d94      	ldr	r5, [pc, #592]	@ (3400935c <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
3400910c:	f8d5 314c 	ldr.w	r3, [r5, #332]	@ 0x14c
34009110:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
34009114:	2b02      	cmp	r3, #2
34009116:	f000 82c1 	beq.w	3400969c <HAL_RCCEx_GetPeriphCLKFreq+0x650>
3400911a:	2b03      	cmp	r3, #3
3400911c:	f000 8256 	beq.w	340095cc <HAL_RCCEx_GetPeriphCLKFreq+0x580>
34009120:	2b01      	cmp	r3, #1
34009122:	f000 824b 	beq.w	340095bc <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34009126:	f7fd f873 	bl	34006210 <HAL_RCC_GetSysClockFreq>
3400912a:	f7fd f931 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400912e:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
34009130:	f003 0307 	and.w	r3, r3, #7
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34009134:	40d8      	lsrs	r0, r3
34009136:	e1e9      	b.n	3400950c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
34009138:	f5a0 4380 	sub.w	r3, r0, #16384	@ 0x4000
3400913c:	430b      	orrs	r3, r1
3400913e:	f000 82ef 	beq.w	34009720 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>
34009142:	f5a0 4000 	sub.w	r0, r0, #32768	@ 0x8000
34009146:	4308      	orrs	r0, r1
34009148:	d1c4      	bne.n	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
3400914a:	4885      	ldr	r0, [pc, #532]	@ (34009360 <HAL_RCCEx_GetPeriphCLKFreq+0x314>)
3400914c:	e2e2      	b.n	34009714 <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
  switch (PeriphClk)
3400914e:	f5a0 0300 	sub.w	r3, r0, #8388608	@ 0x800000
34009152:	430b      	orrs	r3, r1
34009154:	f000 82f6 	beq.w	34009744 <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>
34009158:	4b82      	ldr	r3, [pc, #520]	@ (34009364 <HAL_RCCEx_GetPeriphCLKFreq+0x318>)
3400915a:	4298      	cmp	r0, r3
3400915c:	f171 0300 	sbcs.w	r3, r1, #0
34009160:	d224      	bcs.n	340091ac <HAL_RCCEx_GetPeriphCLKFreq+0x160>
34009162:	f5a0 1380 	sub.w	r3, r0, #1048576	@ 0x100000
34009166:	430b      	orrs	r3, r1
34009168:	f000 82e8 	beq.w	3400973c <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>
3400916c:	4b7e      	ldr	r3, [pc, #504]	@ (34009368 <HAL_RCCEx_GetPeriphCLKFreq+0x31c>)
3400916e:	4298      	cmp	r0, r3
34009170:	f171 0300 	sbcs.w	r3, r1, #0
34009174:	d20f      	bcs.n	34009196 <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
34009176:	f5a0 2380 	sub.w	r3, r0, #262144	@ 0x40000
3400917a:	430b      	orrs	r3, r1
3400917c:	f000 82d7 	beq.w	3400972e <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
34009180:	f5a0 2300 	sub.w	r3, r0, #524288	@ 0x80000
34009184:	430b      	orrs	r3, r1
34009186:	f000 82d7 	beq.w	34009738 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
3400918a:	f5a0 3000 	sub.w	r0, r0, #131072	@ 0x20000
3400918e:	4308      	orrs	r0, r1
34009190:	d1a0      	bne.n	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
34009192:	4876      	ldr	r0, [pc, #472]	@ (3400936c <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
34009194:	e2c7      	b.n	34009726 <HAL_RCCEx_GetPeriphCLKFreq+0x6da>
  switch (PeriphClk)
34009196:	f5a0 1300 	sub.w	r3, r0, #2097152	@ 0x200000
3400919a:	430b      	orrs	r3, r1
3400919c:	f000 82d0 	beq.w	34009740 <HAL_RCCEx_GetPeriphCLKFreq+0x6f4>
340091a0:	f5a0 0080 	sub.w	r0, r0, #4194304	@ 0x400000
340091a4:	4308      	orrs	r0, r1
340091a6:	d195      	bne.n	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
340091a8:	4871      	ldr	r0, [pc, #452]	@ (34009370 <HAL_RCCEx_GetPeriphCLKFreq+0x324>)
340091aa:	e2c1      	b.n	34009730 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  switch (PeriphClk)
340091ac:	f100 437c 	add.w	r3, r0, #4227858432	@ 0xfc000000
340091b0:	430b      	orrs	r3, r1
340091b2:	f000 834d 	beq.w	34009850 <HAL_RCCEx_GetPeriphCLKFreq+0x804>
340091b6:	4b6f      	ldr	r3, [pc, #444]	@ (34009374 <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
340091b8:	4298      	cmp	r0, r3
340091ba:	f171 0300 	sbcs.w	r3, r1, #0
340091be:	d228      	bcs.n	34009212 <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
340091c0:	f100 437f 	add.w	r3, r0, #4278190080	@ 0xff000000
340091c4:	430b      	orrs	r3, r1
340091c6:	f000 8302 	beq.w	340097ce <HAL_RCCEx_GetPeriphCLKFreq+0x782>
340091ca:	f100 407e 	add.w	r0, r0, #4261412864	@ 0xfe000000
340091ce:	4308      	orrs	r0, r1
340091d0:	d180      	bne.n	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
340091d2:	4d62      	ldr	r5, [pc, #392]	@ (3400935c <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
340091d4:	f8d5 3154 	ldr.w	r3, [r5, #340]	@ 0x154
340091d8:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
340091dc:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
340091e0:	f000 8195 	beq.w	3400950e <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
340091e4:	f200 8319 	bhi.w	3400981a <HAL_RCCEx_GetPeriphCLKFreq+0x7ce>
340091e8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
340091ec:	f000 831f 	beq.w	3400982e <HAL_RCCEx_GetPeriphCLKFreq+0x7e2>
340091f0:	f240 81e1 	bls.w	340095b6 <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
340091f4:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340091f8:	f47f af6c 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_IC8_IsEnabled() != 0U)
340091fc:	f7fd f880 	bl	34006300 <LL_RCC_IC8_IsEnabled>
34009200:	2800      	cmp	r0, #0
34009202:	f43f af67 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC8_GetDivider();
34009206:	f7fd f883 	bl	34006310 <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400920a:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400920e:	4604      	mov	r4, r0
34009210:	e191      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (PeriphClk)
34009212:	f100 4378 	add.w	r3, r0, #4160749568	@ 0xf8000000
34009216:	430b      	orrs	r3, r1
34009218:	f000 8344 	beq.w	340098a4 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
3400921c:	f100 4070 	add.w	r0, r0, #4026531840	@ 0xf0000000
34009220:	4308      	orrs	r0, r1
34009222:	f47f af57 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
34009226:	4854      	ldr	r0, [pc, #336]	@ (34009378 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>)
}
34009228:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3400922c:	f7ff bbd6 	b.w	340089dc <RCCEx_GetSAICLKFreq>
  switch (PeriphClk)
34009230:	2300      	movs	r3, #0
34009232:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34009236:	4291      	cmp	r1, r2
34009238:	bf08      	it	eq
3400923a:	4298      	cmpeq	r0, r3
3400923c:	f000 836f 	beq.w	3400991e <HAL_RCCEx_GetPeriphCLKFreq+0x8d2>
34009240:	4283      	cmp	r3, r0
34009242:	418a      	sbcs	r2, r1
34009244:	d35f      	bcc.n	34009306 <HAL_RCCEx_GetPeriphCLKFreq+0x2ba>
34009246:	2210      	movs	r2, #16
34009248:	4291      	cmp	r1, r2
3400924a:	bf08      	it	eq
3400924c:	4298      	cmpeq	r0, r3
3400924e:	f000 8359 	beq.w	34009904 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>
34009252:	4283      	cmp	r3, r0
34009254:	418a      	sbcs	r2, r1
34009256:	d329      	bcc.n	340092ac <HAL_RCCEx_GetPeriphCLKFreq+0x260>
34009258:	2202      	movs	r2, #2
3400925a:	4291      	cmp	r1, r2
3400925c:	bf08      	it	eq
3400925e:	4298      	cmpeq	r0, r3
34009260:	f000 8349 	beq.w	340098f6 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
34009264:	4283      	cmp	r3, r0
34009266:	418a      	sbcs	r2, r1
34009268:	d314      	bcc.n	34009294 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
3400926a:	4299      	cmp	r1, r3
3400926c:	bf08      	it	eq
3400926e:	f1b0 4f00 	cmpeq.w	r0, #2147483648	@ 0x80000000
34009272:	f000 833a 	beq.w	340098ea <HAL_RCCEx_GetPeriphCLKFreq+0x89e>
34009276:	2901      	cmp	r1, #1
34009278:	bf08      	it	eq
3400927a:	4298      	cmpeq	r0, r3
3400927c:	f000 8337 	beq.w	340098ee <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
34009280:	f100 4040 	add.w	r0, r0, #3221225472	@ 0xc0000000
34009284:	4308      	orrs	r0, r1
34009286:	f47f af25 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
3400928a:	483c      	ldr	r0, [pc, #240]	@ (3400937c <HAL_RCCEx_GetPeriphCLKFreq+0x330>)
}
3400928c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
34009290:	f7ff bcd8 	b.w	34008c44 <RCCEx_GetSDMMCCLKFreq>
  switch (PeriphClk)
34009294:	2904      	cmp	r1, #4
34009296:	bf08      	it	eq
34009298:	4298      	cmpeq	r0, r3
3400929a:	f000 8331 	beq.w	34009900 <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>
3400929e:	2908      	cmp	r1, #8
340092a0:	bf08      	it	eq
340092a2:	4298      	cmpeq	r0, r3
340092a4:	f47f af16 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
340092a8:	4835      	ldr	r0, [pc, #212]	@ (34009380 <HAL_RCCEx_GetPeriphCLKFreq+0x334>)
340092aa:	e325      	b.n	340098f8 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
340092ac:	f44f 7200 	mov.w	r2, #512	@ 0x200
340092b0:	4291      	cmp	r1, r2
340092b2:	bf08      	it	eq
340092b4:	4298      	cmpeq	r0, r3
340092b6:	f000 832e 	beq.w	34009916 <HAL_RCCEx_GetPeriphCLKFreq+0x8ca>
340092ba:	4283      	cmp	r3, r0
340092bc:	418a      	sbcs	r2, r1
340092be:	d311      	bcc.n	340092e4 <HAL_RCCEx_GetPeriphCLKFreq+0x298>
340092c0:	2940      	cmp	r1, #64	@ 0x40
340092c2:	bf08      	it	eq
340092c4:	4298      	cmpeq	r0, r3
340092c6:	f000 831f 	beq.w	34009908 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>
340092ca:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
340092ce:	bf08      	it	eq
340092d0:	4298      	cmpeq	r0, r3
340092d2:	f000 831b 	beq.w	3400990c <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>
340092d6:	2920      	cmp	r1, #32
340092d8:	bf08      	it	eq
340092da:	2800      	cmpeq	r0, #0
340092dc:	f47f aefa 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
340092e0:	4828      	ldr	r0, [pc, #160]	@ (34009384 <HAL_RCCEx_GetPeriphCLKFreq+0x338>)
340092e2:	e309      	b.n	340098f8 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
340092e4:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
340092e8:	bf08      	it	eq
340092ea:	4298      	cmpeq	r0, r3
340092ec:	f000 8315 	beq.w	3400991a <HAL_RCCEx_GetPeriphCLKFreq+0x8ce>
340092f0:	f5b1 6f00 	cmp.w	r1, #2048	@ 0x800
340092f4:	bf08      	it	eq
340092f6:	4298      	cmpeq	r0, r3
340092f8:	f47f aeec 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
340092fc:	4822      	ldr	r0, [pc, #136]	@ (34009388 <HAL_RCCEx_GetPeriphCLKFreq+0x33c>)
}
340092fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
34009302:	f7ff b919 	b.w	34008538 <RCCEx_GetUARTCLKFreq>
  switch (PeriphClk)
34009306:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3400930a:	4291      	cmp	r1, r2
3400930c:	bf08      	it	eq
3400930e:	4298      	cmpeq	r0, r3
34009310:	f000 830f 	beq.w	34009932 <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
34009314:	4283      	cmp	r3, r0
34009316:	418a      	sbcs	r2, r1
34009318:	d34b      	bcc.n	340093b2 <HAL_RCCEx_GetPeriphCLKFreq+0x366>
3400931a:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400931e:	4291      	cmp	r1, r2
34009320:	bf08      	it	eq
34009322:	4298      	cmpeq	r0, r3
34009324:	f000 8301 	beq.w	3400992a <HAL_RCCEx_GetPeriphCLKFreq+0x8de>
34009328:	4283      	cmp	r3, r0
3400932a:	418a      	sbcs	r2, r1
3400932c:	d330      	bcc.n	34009390 <HAL_RCCEx_GetPeriphCLKFreq+0x344>
3400932e:	f5b1 4f80 	cmp.w	r1, #16384	@ 0x4000
34009332:	bf08      	it	eq
34009334:	4298      	cmpeq	r0, r3
34009336:	f000 82f4 	beq.w	34009922 <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
3400933a:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
3400933e:	bf08      	it	eq
34009340:	4298      	cmpeq	r0, r3
34009342:	f000 82f0 	beq.w	34009926 <HAL_RCCEx_GetPeriphCLKFreq+0x8da>
34009346:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
3400934a:	bf08      	it	eq
3400934c:	2800      	cmpeq	r0, #0
3400934e:	f47f aec1 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
34009352:	480e      	ldr	r0, [pc, #56]	@ (3400938c <HAL_RCCEx_GetPeriphCLKFreq+0x340>)
34009354:	e2db      	b.n	3400990e <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
34009356:	bf00      	nop
34009358:	20000001 	.word	0x20000001
3400935c:	56028000 	.word	0x56028000
34009360:	07000c0c 	.word	0x07000c0c
34009364:	00800001 	.word	0x00800001
34009368:	00100001 	.word	0x00100001
3400936c:	0700140c 	.word	0x0700140c
34009370:	0700182c 	.word	0x0700182c
34009374:	04000001 	.word	0x04000001
34009378:	07001418 	.word	0x07001418
3400937c:	0300001c 	.word	0x0300001c
34009380:	07000c20 	.word	0x07000c20
34009384:	07001420 	.word	0x07001420
34009388:	07000c30 	.word	0x07000c30
3400938c:	07001430 	.word	0x07001430
  switch (PeriphClk)
34009390:	f5b1 3f00 	cmp.w	r1, #131072	@ 0x20000
34009394:	bf08      	it	eq
34009396:	4298      	cmpeq	r0, r3
34009398:	f000 82c9 	beq.w	3400992e <HAL_RCCEx_GetPeriphCLKFreq+0x8e2>
3400939c:	f5b1 2f80 	cmp.w	r1, #262144	@ 0x40000
340093a0:	bf08      	it	eq
340093a2:	4298      	cmpeq	r0, r3
340093a4:	f47f ae96 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
340093a8:	48b4      	ldr	r0, [pc, #720]	@ (3400967c <HAL_RCCEx_GetPeriphCLKFreq+0x630>)
}
340093aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
340093ae:	f7fe bf8d 	b.w	340082cc <RCCEx_GetOTGPHYCKREFCLKFreq>
  switch (PeriphClk)
340093b2:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
340093b6:	4291      	cmp	r1, r2
340093b8:	bf08      	it	eq
340093ba:	4298      	cmpeq	r0, r3
340093bc:	f000 82c0 	beq.w	34009940 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>
340093c0:	4283      	cmp	r3, r0
340093c2:	418a      	sbcs	r2, r1
340093c4:	d30d      	bcc.n	340093e2 <HAL_RCCEx_GetPeriphCLKFreq+0x396>
340093c6:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
340093ca:	bf08      	it	eq
340093cc:	4298      	cmpeq	r0, r3
340093ce:	f000 82b5 	beq.w	3400993c <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>
340093d2:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
340093d6:	bf08      	it	eq
340093d8:	4298      	cmpeq	r0, r3
340093da:	f47f ae7b 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
340093de:	48a8      	ldr	r0, [pc, #672]	@ (34009680 <HAL_RCCEx_GetPeriphCLKFreq+0x634>)
340093e0:	e2a8      	b.n	34009934 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>
  switch (PeriphClk)
340093e2:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
340093e6:	bf08      	it	eq
340093e8:	4298      	cmpeq	r0, r3
340093ea:	f000 82ae 	beq.w	3400994a <HAL_RCCEx_GetPeriphCLKFreq+0x8fe>
340093ee:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
340093f2:	bf08      	it	eq
340093f4:	4298      	cmpeq	r0, r3
340093f6:	f47f ae6d 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
340093fa:	48a2      	ldr	r0, [pc, #648]	@ (34009684 <HAL_RCCEx_GetPeriphCLKFreq+0x638>)
340093fc:	e2a1      	b.n	34009942 <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
340093fe:	4da2      	ldr	r5, [pc, #648]	@ (34009688 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
34009400:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
34009404:	f003 0370 	and.w	r3, r3, #112	@ 0x70
  switch (LL_RCC_GetADCClockSource(ADCxSource))
34009408:	2b40      	cmp	r3, #64	@ 0x40
3400940a:	d053      	beq.n	340094b4 <HAL_RCCEx_GetPeriphCLKFreq+0x468>
3400940c:	d814      	bhi.n	34009438 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
3400940e:	2b20      	cmp	r3, #32
34009410:	d025      	beq.n	3400945e <HAL_RCCEx_GetPeriphCLKFreq+0x412>
34009412:	d805      	bhi.n	34009420 <HAL_RCCEx_GetPeriphCLKFreq+0x3d4>
34009414:	bb03      	cbnz	r3, 34009458 <HAL_RCCEx_GetPeriphCLKFreq+0x40c>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34009416:	f7fc fefb 	bl	34006210 <HAL_RCC_GetSysClockFreq>
3400941a:	f7fc ffb9 	bl	34006390 <RCCEx_GetHCLKFreq>
      break;
3400941e:	e002      	b.n	34009426 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
34009420:	2b30      	cmp	r3, #48	@ 0x30
34009422:	d034      	beq.n	3400948e <HAL_RCCEx_GetPeriphCLKFreq+0x442>
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
34009424:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
34009426:	4b98      	ldr	r3, [pc, #608]	@ (34009688 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
34009428:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400942c:	f3c3 2307 	ubfx	r3, r3, #8, #8
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
34009430:	3301      	adds	r3, #1
34009432:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
34009436:	e069      	b.n	3400950c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
34009438:	2b60      	cmp	r3, #96	@ 0x60
3400943a:	d047      	beq.n	340094cc <HAL_RCCEx_GetPeriphCLKFreq+0x480>
3400943c:	2b70      	cmp	r3, #112	@ 0x70
3400943e:	d03f      	beq.n	340094c0 <HAL_RCCEx_GetPeriphCLKFreq+0x474>
34009440:	2b50      	cmp	r3, #80	@ 0x50
34009442:	d1ef      	bne.n	34009424 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
      if (LL_RCC_HSI_IsReady() != 0U)
34009444:	f7fc ff12 	bl	3400626c <LL_RCC_HSI_IsReady>
34009448:	2800      	cmp	r0, #0
3400944a:	d0eb      	beq.n	34009424 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400944c:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400944e:	488f      	ldr	r0, [pc, #572]	@ (3400968c <HAL_RCCEx_GetPeriphCLKFreq+0x640>)
34009450:	f3c3 13c1 	ubfx	r3, r3, #7, #2
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34009454:	40d8      	lsrs	r0, r3
      break;
34009456:	e7e6      	b.n	34009426 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34009458:	f7fe fd72 	bl	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
3400945c:	e7e3      	b.n	34009426 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400945e:	f7fc ff3d 	bl	340062dc <LL_RCC_IC7_IsEnabled>
34009462:	2800      	cmp	r0, #0
34009464:	d0de      	beq.n	34009424 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC7_GetDivider();
34009466:	f7fc ff41 	bl	340062ec <LL_RCC_IC7_GetDivider>
3400946a:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400946c:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
34009470:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
34009474:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009478:	d019      	beq.n	340094ae <HAL_RCCEx_GetPeriphCLKFreq+0x462>
3400947a:	d812      	bhi.n	340094a2 <HAL_RCCEx_GetPeriphCLKFreq+0x456>
3400947c:	b913      	cbnz	r3, 34009484 <HAL_RCCEx_GetPeriphCLKFreq+0x438>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400947e:	f7fe fc5f 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
34009482:	e001      	b.n	34009488 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009484:	f7fe fc9c 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
            adc_frequency = adc_frequency / ic_divider;
34009488:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400948c:	e7cb      	b.n	34009426 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400948e:	f7fc ff37 	bl	34006300 <LL_RCC_IC8_IsEnabled>
34009492:	2800      	cmp	r0, #0
34009494:	d0c6      	beq.n	34009424 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC8_GetDivider();
34009496:	f7fc ff3b 	bl	34006310 <LL_RCC_IC8_GetDivider>
3400949a:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400949e:	4604      	mov	r4, r0
340094a0:	e7e6      	b.n	34009470 <HAL_RCCEx_GetPeriphCLKFreq+0x424>
        switch (LL_RCC_IC8_GetSource())
340094a2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340094a6:	d1bd      	bne.n	34009424 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340094a8:	f7fe fd0a 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
340094ac:	e7ec      	b.n	34009488 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340094ae:	f7fe fcc7 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
340094b2:	e7e9      	b.n	34009488 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
      if (LL_RCC_MSI_IsReady() != 0U)
340094b4:	f7fc fee2 	bl	3400627c <LL_RCC_MSI_IsReady>
340094b8:	2800      	cmp	r0, #0
340094ba:	d0b3      	beq.n	34009424 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        adc_frequency = MSI_VALUE;
340094bc:	4874      	ldr	r0, [pc, #464]	@ (34009690 <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
340094be:	e7b2      	b.n	34009426 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
340094c0:	f7fc fea6 	bl	34006210 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
340094c4:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
340094c6:	f3c3 6301 	ubfx	r3, r3, #24, #2
340094ca:	e7c3      	b.n	34009454 <HAL_RCCEx_GetPeriphCLKFreq+0x408>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
340094cc:	4871      	ldr	r0, [pc, #452]	@ (34009694 <HAL_RCCEx_GetPeriphCLKFreq+0x648>)
340094ce:	e7aa      	b.n	34009426 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
340094d0:	4d6d      	ldr	r5, [pc, #436]	@ (34009688 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
340094d2:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
340094d6:	f003 0307 	and.w	r3, r3, #7
  switch (LL_RCC_GetADFClockSource(ADFxSource))
340094da:	3b01      	subs	r3, #1
340094dc:	2b06      	cmp	r3, #6
340094de:	f200 80f5 	bhi.w	340096cc <HAL_RCCEx_GetPeriphCLKFreq+0x680>
340094e2:	a201      	add	r2, pc, #4	@ (adr r2, 340094e8 <HAL_RCCEx_GetPeriphCLKFreq+0x49c>)
340094e4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
340094e8:	340095bd 	.word	0x340095bd
340094ec:	3400982f 	.word	0x3400982f
340094f0:	340091fd 	.word	0x340091fd
340094f4:	3400950f 	.word	0x3400950f
340094f8:	3400957d 	.word	0x3400957d
340094fc:	3400994f 	.word	0x3400994f
34009500:	34009845 	.word	0x34009845
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009504:	f7fe fc5c 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
            adf_frequency = adf_frequency / ic_divider;
34009508:	fbb0 f0f4 	udiv	r0, r0, r4
}
3400950c:	bd38      	pop	{r3, r4, r5, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
3400950e:	f7fc feb5 	bl	3400627c <LL_RCC_MSI_IsReady>
34009512:	2800      	cmp	r0, #0
34009514:	f43f adde 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        adf_frequency = MSI_VALUE;
34009518:	485d      	ldr	r0, [pc, #372]	@ (34009690 <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
3400951a:	e7f7      	b.n	3400950c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
3400951c:	4b5a      	ldr	r3, [pc, #360]	@ (34009688 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400951e:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
34009522:	0395      	lsls	r5, r2, #14
34009524:	f57f add6 	bpl.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
34009528:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
3400952c:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
34009530:	f3c0 4007 	ubfx	r0, r0, #16, #8
34009534:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
34009536:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC20_GetSource())
3400953a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400953e:	f000 81ae 	beq.w	3400989e <HAL_RCCEx_GetPeriphCLKFreq+0x852>
34009542:	f200 81a5 	bhi.w	34009890 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
34009546:	2b00      	cmp	r3, #0
34009548:	d1dc      	bne.n	34009504 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400954a:	f7fe fbf9 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
3400954e:	e7db      	b.n	34009508 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
34009550:	4d4d      	ldr	r5, [pc, #308]	@ (34009688 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
34009552:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
34009556:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3400955a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400955e:	d014      	beq.n	3400958a <HAL_RCCEx_GetPeriphCLKFreq+0x53e>
34009560:	d808      	bhi.n	34009574 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
34009562:	bb5b      	cbnz	r3, 340095bc <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34009564:	f7fc fe54 	bl	34006210 <HAL_RCC_GetSysClockFreq>
34009568:	f7fc ff12 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
3400956c:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
3400956e:	f3c3 4302 	ubfx	r3, r3, #16, #3
34009572:	e5df      	b.n	34009134 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
34009574:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
34009578:	f47f adac 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400957c:	f7fc fe76 	bl	3400626c <LL_RCC_HSI_IsReady>
34009580:	2800      	cmp	r0, #0
34009582:	f43f ada7 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34009586:	6cab      	ldr	r3, [r5, #72]	@ 0x48
34009588:	e136      	b.n	340097f8 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
3400958a:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400958e:	03dc      	lsls	r4, r3, #15
34009590:	f57f ada0 	bpl.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
34009594:	f8d5 0104 	ldr.w	r0, [r5, #260]	@ 0x104
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
34009598:	f8d5 3104 	ldr.w	r3, [r5, #260]	@ 0x104
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3400959c:	f3c0 4007 	ubfx	r0, r0, #16, #8
340095a0:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
340095a2:	e7c8      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
340095a4:	4a38      	ldr	r2, [pc, #224]	@ (34009688 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
340095a6:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
340095aa:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
340095ae:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
340095b2:	d012      	beq.n	340095da <HAL_RCCEx_GetPeriphCLKFreq+0x58e>
340095b4:	d806      	bhi.n	340095c4 <HAL_RCCEx_GetPeriphCLKFreq+0x578>
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
340095b6:	2b00      	cmp	r3, #0
340095b8:	f000 8088 	beq.w	340096cc <HAL_RCCEx_GetPeriphCLKFreq+0x680>
}
340095bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340095c0:	f7fe bcbe 	b.w	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
340095c4:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
340095c8:	f47f ad84 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSE_IsReady() != 0U)
340095cc:	f7fc fe46 	bl	3400625c <LL_RCC_HSE_IsReady>
340095d0:	2800      	cmp	r0, #0
340095d2:	f43f ad7f 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        eth1_frequency = HSE_VALUE;
340095d6:	4830      	ldr	r0, [pc, #192]	@ (34009698 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
340095d8:	e798      	b.n	3400950c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
340095da:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
340095de:	0518      	lsls	r0, r3, #20
340095e0:	f57f ad78 	bpl.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
340095e4:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
340095e8:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
340095ec:	f3c0 4007 	ubfx	r0, r0, #16, #8
340095f0:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
340095f2:	e7a0      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
340095f4:	4a24      	ldr	r2, [pc, #144]	@ (34009688 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
340095f6:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
340095fa:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
340095fe:	2b02      	cmp	r3, #2
34009600:	d010      	beq.n	34009624 <HAL_RCCEx_GetPeriphCLKFreq+0x5d8>
34009602:	2b03      	cmp	r3, #3
34009604:	d034      	beq.n	34009670 <HAL_RCCEx_GetPeriphCLKFreq+0x624>
34009606:	2b01      	cmp	r3, #1
34009608:	d009      	beq.n	3400961e <HAL_RCCEx_GetPeriphCLKFreq+0x5d2>
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400960a:	f7fc fe01 	bl	34006210 <HAL_RCC_GetSysClockFreq>
3400960e:	f7fc febf 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
34009612:	4b1d      	ldr	r3, [pc, #116]	@ (34009688 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
34009614:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
34009618:	f3c3 1303 	ubfx	r3, r3, #4, #4
3400961c:	e708      	b.n	34009430 <HAL_RCCEx_GetPeriphCLKFreq+0x3e4>
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400961e:	f7fe fc8f 	bl	34007f40 <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
34009622:	e7f6      	b.n	34009612 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
34009624:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
34009628:	04d9      	lsls	r1, r3, #19
3400962a:	d516      	bpl.n	3400965a <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400962c:	f8d2 00f4 	ldr.w	r0, [r2, #244]	@ 0xf4
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
34009630:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
34009634:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
34009638:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC13_GetSource())
3400963c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
34009640:	f100 0401 	add.w	r4, r0, #1
34009644:	d00e      	beq.n	34009664 <HAL_RCCEx_GetPeriphCLKFreq+0x618>
34009646:	d805      	bhi.n	34009654 <HAL_RCCEx_GetPeriphCLKFreq+0x608>
34009648:	b94b      	cbnz	r3, 3400965e <HAL_RCCEx_GetPeriphCLKFreq+0x612>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400964a:	f7fe fb79 	bl	34007d40 <HAL_RCCEx_GetPLL1CLKFreq>
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3400964e:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
34009652:	e7de      	b.n	34009612 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
        switch (LL_RCC_IC13_GetSource())
34009654:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009658:	d007      	beq.n	3400966a <HAL_RCCEx_GetPeriphCLKFreq+0x61e>
        eth1ptp_frequency = HSE_VALUE;
3400965a:	2000      	movs	r0, #0
3400965c:	e7d9      	b.n	34009612 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400965e:	f7fe fbaf 	bl	34007dc0 <HAL_RCCEx_GetPLL2CLKFreq>
34009662:	e7f4      	b.n	3400964e <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009664:	f7fe fbec 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
34009668:	e7f1      	b.n	3400964e <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400966a:	f7fe fc29 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
3400966e:	e7ee      	b.n	3400964e <HAL_RCCEx_GetPeriphCLKFreq+0x602>
      if (LL_RCC_HSE_IsReady() != 0U)
34009670:	f7fc fdf4 	bl	3400625c <LL_RCC_HSE_IsReady>
34009674:	2800      	cmp	r0, #0
34009676:	d0f0      	beq.n	3400965a <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
        eth1ptp_frequency = HSE_VALUE;
34009678:	4807      	ldr	r0, [pc, #28]	@ (34009698 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
3400967a:	e7ca      	b.n	34009612 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
3400967c:	01001014 	.word	0x01001014
34009680:	03001414 	.word	0x03001414
34009684:	03000814 	.word	0x03000814
34009688:	56028000 	.word	0x56028000
3400968c:	03d09000 	.word	0x03d09000
34009690:	003d0900 	.word	0x003d0900
34009694:	00bb8000 	.word	0x00bb8000
34009698:	02dc6c00 	.word	0x02dc6c00
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3400969c:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
340096a0:	035b      	lsls	r3, r3, #13
340096a2:	f57f ad17 	bpl.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
340096a6:	f8d5 010c 	ldr.w	r0, [r5, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
340096aa:	f8d5 310c 	ldr.w	r3, [r5, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
340096ae:	f3c0 4007 	ubfx	r0, r0, #16, #8
340096b2:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
340096b4:	e73f      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
340096b6:	4ba7      	ldr	r3, [pc, #668]	@ (34009954 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
340096b8:	f8d3 214c 	ldr.w	r2, [r3, #332]	@ 0x14c
340096bc:	f002 0230 	and.w	r2, r2, #48	@ 0x30
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
340096c0:	2a20      	cmp	r2, #32
340096c2:	d019      	beq.n	340096f8 <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
340096c4:	d808      	bhi.n	340096d8 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>
340096c6:	2a00      	cmp	r2, #0
340096c8:	f47f af78 	bne.w	340095bc <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340096cc:	f7fc fda0 	bl	34006210 <HAL_RCC_GetSysClockFreq>
}
340096d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340096d4:	f7fc be5c 	b.w	34006390 <RCCEx_GetHCLKFreq>
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
340096d8:	2a30      	cmp	r2, #48	@ 0x30
340096da:	f47f acfb 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
340096de:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
340096e2:	0714      	lsls	r4, r2, #28
340096e4:	f57f acf6 	bpl.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
340096e8:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
340096ec:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
340096f0:	f3c0 4007 	ubfx	r0, r0, #16, #8
340096f4:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
340096f6:	e71e      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
340096f8:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
340096fc:	0755      	lsls	r5, r2, #29
340096fe:	f57f ace9 	bpl.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
34009702:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
34009706:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400970a:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400970e:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
34009710:	e711      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
34009712:	4891      	ldr	r0, [pc, #580]	@ (34009958 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
}
34009714:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
34009718:	f7ff bafa 	b.w	34008d10 <RCCEx_GetI2CCLKFreq>
3400971c:	488f      	ldr	r0, [pc, #572]	@ (3400995c <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
3400971e:	e7f9      	b.n	34009714 <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
34009720:	488f      	ldr	r0, [pc, #572]	@ (34009960 <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
34009722:	e7f7      	b.n	34009714 <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
34009724:	488f      	ldr	r0, [pc, #572]	@ (34009964 <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
}
34009726:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
3400972a:	f7ff b9ff 	b.w	34008b2c <RCCEx_GetI3CCLKFreq>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
3400972e:	488e      	ldr	r0, [pc, #568]	@ (34009968 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
}
34009730:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
34009734:	f7ff bbaa 	b.w	34008e8c <RCCEx_GetLPTIMCLKFreq>
34009738:	488c      	ldr	r0, [pc, #560]	@ (3400996c <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
3400973a:	e7f9      	b.n	34009730 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
3400973c:	488c      	ldr	r0, [pc, #560]	@ (34009970 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
3400973e:	e7f7      	b.n	34009730 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
34009740:	488c      	ldr	r0, [pc, #560]	@ (34009974 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
34009742:	e7f5      	b.n	34009730 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
34009744:	4a83      	ldr	r2, [pc, #524]	@ (34009954 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
34009746:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
3400974a:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3400974e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34009752:	d031      	beq.n	340097b8 <HAL_RCCEx_GetPeriphCLKFreq+0x76c>
34009754:	d812      	bhi.n	3400977c <HAL_RCCEx_GetPeriphCLKFreq+0x730>
34009756:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400975a:	f43f af2f 	beq.w	340095bc <HAL_RCCEx_GetPeriphCLKFreq+0x570>
3400975e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34009762:	d01d      	beq.n	340097a0 <HAL_RCCEx_GetPeriphCLKFreq+0x754>
34009764:	2b00      	cmp	r3, #0
34009766:	f47f acb5 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400976a:	f7fc fd51 	bl	34006210 <HAL_RCC_GetSysClockFreq>
3400976e:	f7fc fe0f 	bl	34006390 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
34009772:	4b78      	ldr	r3, [pc, #480]	@ (34009954 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
34009774:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
34009776:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400977a:	e4db      	b.n	34009134 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3400977c:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
34009780:	f43f aec5 	beq.w	3400950e <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
34009784:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
34009788:	d02f      	beq.n	340097ea <HAL_RCCEx_GetPeriphCLKFreq+0x79e>
3400978a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
  switch (LL_RCC_GetRTCClockSource())
3400978e:	f47f aca1 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_LSE_IsReady() != 0U)
34009792:	f7fc fd7b 	bl	3400628c <LL_RCC_LSE_IsReady>
34009796:	3800      	subs	r0, #0
34009798:	bf18      	it	ne
3400979a:	2001      	movne	r0, #1
3400979c:	03c0      	lsls	r0, r0, #15
3400979e:	e6b5      	b.n	3400950c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
340097a0:	f7fc fdc0 	bl	34006324 <LL_RCC_IC9_IsEnabled>
340097a4:	2800      	cmp	r0, #0
340097a6:	f43f ac95 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC9_GetDivider();
340097aa:	f7fc fdc3 	bl	34006334 <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
340097ae:	4b69      	ldr	r3, [pc, #420]	@ (34009954 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
340097b0:	4604      	mov	r4, r0
340097b2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340097b6:	e6be      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      if (LL_RCC_IC14_IsEnabled() != 0U)
340097b8:	f7fc fdc6 	bl	34006348 <LL_RCC_IC14_IsEnabled>
340097bc:	2800      	cmp	r0, #0
340097be:	f43f ac89 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC14_GetDivider();
340097c2:	f7fc fdc9 	bl	34006358 <LL_RCC_IC14_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
340097c6:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
340097ca:	4604      	mov	r4, r0
340097cc:	e6b3      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
340097ce:	4d61      	ldr	r5, [pc, #388]	@ (34009954 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
340097d0:	f8d5 3150 	ldr.w	r3, [r5, #336]	@ 0x150
340097d4:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
340097d8:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340097dc:	d010      	beq.n	34009800 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>
340097de:	f67f aec0 	bls.w	34009562 <HAL_RCCEx_GetPeriphCLKFreq+0x516>
340097e2:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
340097e6:	f47f ac75 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
340097ea:	f7fc fd3f 	bl	3400626c <LL_RCC_HSI_IsReady>
340097ee:	2800      	cmp	r0, #0
340097f0:	f43f ac70 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
340097f4:	4b57      	ldr	r3, [pc, #348]	@ (34009954 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
340097f6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340097f8:	485f      	ldr	r0, [pc, #380]	@ (34009978 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
340097fa:	f3c3 13c1 	ubfx	r3, r3, #7, #2
340097fe:	e499      	b.n	34009134 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
34009800:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
34009804:	0418      	lsls	r0, r3, #16
34009806:	f57f ac65 	bpl.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3400980a:	f8d5 0100 	ldr.w	r0, [r5, #256]	@ 0x100
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3400980e:	f8d5 3100 	ldr.w	r3, [r5, #256]	@ 0x100
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
34009812:	f3c0 4007 	ubfx	r0, r0, #16, #8
34009816:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
34009818:	e68d      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400981a:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3400981e:	f000 8096 	beq.w	3400994e <HAL_RCCEx_GetPeriphCLKFreq+0x902>
34009822:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34009826:	d00d      	beq.n	34009844 <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>
34009828:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3400982c:	e6a4      	b.n	34009578 <HAL_RCCEx_GetPeriphCLKFreq+0x52c>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400982e:	f7fc fd55 	bl	340062dc <LL_RCC_IC7_IsEnabled>
34009832:	2800      	cmp	r0, #0
34009834:	f43f ac4e 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC7_GetDivider();
34009838:	f7fc fd58 	bl	340062ec <LL_RCC_IC7_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400983c:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
34009840:	4604      	mov	r4, r0
34009842:	e678      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34009844:	f7fc fce4 	bl	34006210 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
34009848:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400984a:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400984e:	e471      	b.n	34009134 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
34009850:	4a40      	ldr	r2, [pc, #256]	@ (34009954 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
34009852:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
34009856:	f003 0330 	and.w	r3, r3, #48	@ 0x30
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3400985a:	2b20      	cmp	r3, #32
3400985c:	d00b      	beq.n	34009876 <HAL_RCCEx_GetPeriphCLKFreq+0x82a>
3400985e:	f67f aeaa 	bls.w	340095b6 <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
34009862:	2b30      	cmp	r3, #48	@ 0x30
34009864:	f47f ac36 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
34009868:	f7fc fd00 	bl	3400626c <LL_RCC_HSI_IsReady>
3400986c:	2800      	cmp	r0, #0
3400986e:	f43f ac31 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34009872:	6c93      	ldr	r3, [r2, #72]	@ 0x48
34009874:	e7c0      	b.n	340097f8 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
34009876:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400987a:	0319      	lsls	r1, r3, #12
3400987c:	f57f ac2a 	bpl.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
34009880:	f8d2 0110 	ldr.w	r0, [r2, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
34009884:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
34009888:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400988c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400988e:	e652      	b.n	34009536 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        switch (LL_RCC_IC20_GetSource())
34009890:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009894:	f47f ac1e 	bne.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009898:	f7fe fb12 	bl	34007ec0 <HAL_RCCEx_GetPLL4CLKFreq>
3400989c:	e634      	b.n	34009508 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400989e:	f7fe facf 	bl	34007e40 <HAL_RCCEx_GetPLL3CLKFreq>
340098a2:	e631      	b.n	34009508 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
340098a4:	4a2b      	ldr	r2, [pc, #172]	@ (34009954 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
340098a6:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
340098aa:	f403 7340 	and.w	r3, r3, #768	@ 0x300
  switch (LL_RCC_GetRTCClockSource())
340098ae:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340098b2:	d005      	beq.n	340098c0 <HAL_RCCEx_GetPeriphCLKFreq+0x874>
340098b4:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340098b8:	d009      	beq.n	340098ce <HAL_RCCEx_GetPeriphCLKFreq+0x882>
340098ba:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340098be:	e766      	b.n	3400978e <HAL_RCCEx_GetPeriphCLKFreq+0x742>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
340098c0:	6853      	ldr	r3, [r2, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
340098c2:	07db      	lsls	r3, r3, #31
340098c4:	f57f ac06 	bpl.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        rtc_frequency = LSI_VALUE;
340098c8:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return frequency;
340098cc:	e61e      	b.n	3400950c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_HSE_IsReady() != 0U)
340098ce:	f7fc fcc5 	bl	3400625c <LL_RCC_HSE_IsReady>
340098d2:	2800      	cmp	r0, #0
340098d4:	f43f abfe 	beq.w	340090d4 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
340098d8:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
        rtc_frequency = HSE_VALUE / prescaler;
340098dc:	4827      	ldr	r0, [pc, #156]	@ (3400997c <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
340098de:	f3c3 3305 	ubfx	r3, r3, #12, #6
340098e2:	3301      	adds	r3, #1
340098e4:	e5a5      	b.n	34009432 <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
340098e6:	4826      	ldr	r0, [pc, #152]	@ (34009980 <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
340098e8:	e49e      	b.n	34009228 <HAL_RCCEx_GetPeriphCLKFreq+0x1dc>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
340098ea:	4826      	ldr	r0, [pc, #152]	@ (34009984 <HAL_RCCEx_GetPeriphCLKFreq+0x938>)
340098ec:	e4ce      	b.n	3400928c <HAL_RCCEx_GetPeriphCLKFreq+0x240>
}
340098ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
340098f2:	f7fe bbab 	b.w	3400804c <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
340098f6:	4824      	ldr	r0, [pc, #144]	@ (34009988 <HAL_RCCEx_GetPeriphCLKFreq+0x93c>)
}
340098f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
340098fc:	f7fe bf30 	b.w	34008760 <RCCEx_GetSPICLKFreq>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
34009900:	4822      	ldr	r0, [pc, #136]	@ (3400998c <HAL_RCCEx_GetPeriphCLKFreq+0x940>)
34009902:	e7f9      	b.n	340098f8 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
34009904:	4822      	ldr	r0, [pc, #136]	@ (34009990 <HAL_RCCEx_GetPeriphCLKFreq+0x944>)
34009906:	e7f7      	b.n	340098f8 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
34009908:	4822      	ldr	r0, [pc, #136]	@ (34009994 <HAL_RCCEx_GetPeriphCLKFreq+0x948>)
3400990a:	e7f5      	b.n	340098f8 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
3400990c:	4822      	ldr	r0, [pc, #136]	@ (34009998 <HAL_RCCEx_GetPeriphCLKFreq+0x94c>)
}
3400990e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
34009912:	f7fe bd0d 	b.w	34008330 <RCCEx_GetUSARTCLKFreq>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
34009916:	4821      	ldr	r0, [pc, #132]	@ (3400999c <HAL_RCCEx_GetPeriphCLKFreq+0x950>)
34009918:	e7f9      	b.n	3400990e <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
3400991a:	4821      	ldr	r0, [pc, #132]	@ (340099a0 <HAL_RCCEx_GetPeriphCLKFreq+0x954>)
3400991c:	e7f7      	b.n	3400990e <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
3400991e:	4821      	ldr	r0, [pc, #132]	@ (340099a4 <HAL_RCCEx_GetPeriphCLKFreq+0x958>)
34009920:	e4ed      	b.n	340092fe <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
34009922:	4821      	ldr	r0, [pc, #132]	@ (340099a8 <HAL_RCCEx_GetPeriphCLKFreq+0x95c>)
34009924:	e4eb      	b.n	340092fe <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
34009926:	4821      	ldr	r0, [pc, #132]	@ (340099ac <HAL_RCCEx_GetPeriphCLKFreq+0x960>)
34009928:	e4e9      	b.n	340092fe <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
3400992a:	4821      	ldr	r0, [pc, #132]	@ (340099b0 <HAL_RCCEx_GetPeriphCLKFreq+0x964>)
3400992c:	e4e7      	b.n	340092fe <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3400992e:	4821      	ldr	r0, [pc, #132]	@ (340099b4 <HAL_RCCEx_GetPeriphCLKFreq+0x968>)
34009930:	e7ed      	b.n	3400990e <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34009932:	4821      	ldr	r0, [pc, #132]	@ (340099b8 <HAL_RCCEx_GetPeriphCLKFreq+0x96c>)
}
34009934:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
34009938:	f7fe bc62 	b.w	34008200 <RCCEx_GetOTGPHYCLKFreq>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3400993c:	481f      	ldr	r0, [pc, #124]	@ (340099bc <HAL_RCCEx_GetPeriphCLKFreq+0x970>)
3400993e:	e534      	b.n	340093aa <HAL_RCCEx_GetPeriphCLKFreq+0x35e>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
34009940:	481f      	ldr	r0, [pc, #124]	@ (340099c0 <HAL_RCCEx_GetPeriphCLKFreq+0x974>)
}
34009942:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
34009946:	f7fe bbe1 	b.w	3400810c <RCCEx_GetXSPICLKFreq>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
3400994a:	481e      	ldr	r0, [pc, #120]	@ (340099c4 <HAL_RCCEx_GetPeriphCLKFreq+0x978>)
3400994c:	e7f9      	b.n	34009942 <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400994e:	481e      	ldr	r0, [pc, #120]	@ (340099c8 <HAL_RCCEx_GetPeriphCLKFreq+0x97c>)
34009950:	e5dc      	b.n	3400950c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
34009952:	bf00      	nop
34009954:	56028000 	.word	0x56028000
34009958:	0700000c 	.word	0x0700000c
3400995c:	0700040c 	.word	0x0700040c
34009960:	0700080c 	.word	0x0700080c
34009964:	0700100c 	.word	0x0700100c
34009968:	0700082c 	.word	0x0700082c
3400996c:	07000c2c 	.word	0x07000c2c
34009970:	0700102c 	.word	0x0700102c
34009974:	0700142c 	.word	0x0700142c
34009978:	03d09000 	.word	0x03d09000
3400997c:	02dc6c00 	.word	0x02dc6c00
34009980:	07001818 	.word	0x07001818
34009984:	0300041c 	.word	0x0300041c
34009988:	07000420 	.word	0x07000420
3400998c:	07000820 	.word	0x07000820
34009990:	07001020 	.word	0x07001020
34009994:	07001820 	.word	0x07001820
34009998:	07000030 	.word	0x07000030
3400999c:	07000430 	.word	0x07000430
340099a0:	07000830 	.word	0x07000830
340099a4:	07001030 	.word	0x07001030
340099a8:	07001830 	.word	0x07001830
340099ac:	07001c30 	.word	0x07001c30
340099b0:	07000034 	.word	0x07000034
340099b4:	07000434 	.word	0x07000434
340099b8:	03000c14 	.word	0x03000c14
340099bc:	01001814 	.word	0x01001814
340099c0:	03000014 	.word	0x03000014
340099c4:	03000414 	.word	0x03000414
340099c8:	00bb8000 	.word	0x00bb8000

340099cc <HAL_RIF_RIMC_ConfigMasterAttributes>:
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
340099cc:	680b      	ldr	r3, [r1, #0]
340099ce:	fa93 f3a3 	rbit	r3, r3
  return __builtin_clz(value);
340099d2:	fab3 f283 	clz	r2, r3
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));

  master_cid = POSITION_VAL(pConfig->MasterCID);
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
340099d6:	0080      	lsls	r0, r0, #2
340099d8:	f100 40a8 	add.w	r0, r0, #1409286144	@ 0x54000000
340099dc:	f500 3010 	add.w	r0, r0, #147456	@ 0x24000
340099e0:	f8d0 3c10 	ldr.w	r3, [r0, #3088]	@ 0xc10
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
340099e4:	6849      	ldr	r1, [r1, #4]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
340099e6:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
340099ea:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
340099ee:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
340099f2:	f8c0 3c10 	str.w	r3, [r0, #3088]	@ 0xc10
}
340099f6:	4770      	bx	lr

340099f8 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
340099f8:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
340099fa:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
340099fc:	e852 3f00 	ldrex	r3, [r2]
34009a00:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34009a04:	e842 3100 	strex	r1, r3, [r2]
   return(result);
34009a08:	6802      	ldr	r2, [r0, #0]
34009a0a:	2900      	cmp	r1, #0
34009a0c:	d1f5      	bne.n	340099fa <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
34009a0e:	4c0f      	ldr	r4, [pc, #60]	@ (34009a4c <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34009a10:	f102 0308 	add.w	r3, r2, #8
34009a14:	e853 3f00 	ldrex	r3, [r3]
34009a18:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34009a1a:	f102 0c08 	add.w	ip, r2, #8
34009a1e:	e84c 3100 	strex	r1, r3, [ip]
34009a22:	2900      	cmp	r1, #0
34009a24:	d1f4      	bne.n	34009a10 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
34009a26:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
34009a28:	2b01      	cmp	r3, #1
34009a2a:	d107      	bne.n	34009a3c <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34009a2c:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
34009a30:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34009a34:	e842 3100 	strex	r1, r3, [r2]
34009a38:	2900      	cmp	r1, #0
34009a3a:	d1f7      	bne.n	34009a2c <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
34009a3c:	2320      	movs	r3, #32
34009a3e:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34009a42:	2300      	movs	r3, #0
34009a44:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
34009a46:	6743      	str	r3, [r0, #116]	@ 0x74
}
34009a48:	bd10      	pop	{r4, pc}
34009a4a:	bf00      	nop
34009a4c:	effffffe 	.word	0xeffffffe

34009a50 <UART_SetConfig>:
{
34009a50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34009a52:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
34009a54:	6921      	ldr	r1, [r4, #16]
34009a56:	68a2      	ldr	r2, [r4, #8]
  if (UART_INSTANCE_LOWPOWER(huart))
34009a58:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
34009a5a:	430a      	orrs	r2, r1
34009a5c:	6961      	ldr	r1, [r4, #20]
34009a5e:	69c5      	ldr	r5, [r0, #28]
34009a60:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
34009a62:	6818      	ldr	r0, [r3, #0]
34009a64:	4978      	ldr	r1, [pc, #480]	@ (34009c48 <UART_SetConfig+0x1f8>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
34009a66:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
34009a68:	4001      	ands	r1, r0
34009a6a:	430a      	orrs	r2, r1
34009a6c:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
34009a6e:	685a      	ldr	r2, [r3, #4]
34009a70:	68e1      	ldr	r1, [r4, #12]
34009a72:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
34009a76:	430a      	orrs	r2, r1
34009a78:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
34009a7a:	4a74      	ldr	r2, [pc, #464]	@ (34009c4c <UART_SetConfig+0x1fc>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
34009a7c:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
34009a7e:	4293      	cmp	r3, r2
34009a80:	d005      	beq.n	34009a8e <UART_SetConfig+0x3e>
34009a82:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34009a86:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
34009a88:	bf1c      	itt	ne
34009a8a:	6a22      	ldrne	r2, [r4, #32]
34009a8c:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
34009a8e:	689a      	ldr	r2, [r3, #8]
34009a90:	f022 426e 	bic.w	r2, r2, #3992977408	@ 0xee000000
34009a94:	f422 6230 	bic.w	r2, r2, #2816	@ 0xb00
34009a98:	430a      	orrs	r2, r1
34009a9a:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
34009a9c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34009a9e:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34009aa0:	f022 020f 	bic.w	r2, r2, #15
34009aa4:	430a      	orrs	r2, r1
34009aa6:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
34009aa8:	4a69      	ldr	r2, [pc, #420]	@ (34009c50 <UART_SetConfig+0x200>)
34009aaa:	4293      	cmp	r3, r2
34009aac:	d069      	beq.n	34009b82 <UART_SetConfig+0x132>
34009aae:	4a69      	ldr	r2, [pc, #420]	@ (34009c54 <UART_SetConfig+0x204>)
34009ab0:	4293      	cmp	r3, r2
34009ab2:	f000 808b 	beq.w	34009bcc <UART_SetConfig+0x17c>
34009ab6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
34009aba:	4293      	cmp	r3, r2
34009abc:	f000 808a 	beq.w	34009bd4 <UART_SetConfig+0x184>
34009ac0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
34009ac4:	4293      	cmp	r3, r2
34009ac6:	f000 8089 	beq.w	34009bdc <UART_SetConfig+0x18c>
34009aca:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34009ace:	f000 8089 	beq.w	34009be4 <UART_SetConfig+0x194>
34009ad2:	4a61      	ldr	r2, [pc, #388]	@ (34009c58 <UART_SetConfig+0x208>)
34009ad4:	4293      	cmp	r3, r2
34009ad6:	f000 8089 	beq.w	34009bec <UART_SetConfig+0x19c>
34009ada:	4a60      	ldr	r2, [pc, #384]	@ (34009c5c <UART_SetConfig+0x20c>)
34009adc:	4293      	cmp	r3, r2
34009ade:	f000 8089 	beq.w	34009bf4 <UART_SetConfig+0x1a4>
34009ae2:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
34009ae6:	4293      	cmp	r3, r2
34009ae8:	f000 8088 	beq.w	34009bfc <UART_SetConfig+0x1ac>
34009aec:	4a5c      	ldr	r2, [pc, #368]	@ (34009c60 <UART_SetConfig+0x210>)
34009aee:	4293      	cmp	r3, r2
34009af0:	f000 8088 	beq.w	34009c04 <UART_SetConfig+0x1b4>
34009af4:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
34009af8:	4293      	cmp	r3, r2
34009afa:	f000 8087 	beq.w	34009c0c <UART_SetConfig+0x1bc>
34009afe:	4a53      	ldr	r2, [pc, #332]	@ (34009c4c <UART_SetConfig+0x1fc>)
34009b00:	4293      	cmp	r3, r2
34009b02:	d01d      	beq.n	34009b40 <UART_SetConfig+0xf0>
  if (UART_INSTANCE_LOWPOWER(huart))
34009b04:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34009b08:	4293      	cmp	r3, r2
34009b0a:	f04f 0000 	mov.w	r0, #0
34009b0e:	f04f 0100 	mov.w	r1, #0
34009b12:	d139      	bne.n	34009b88 <UART_SetConfig+0x138>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
34009b14:	f7ff fa9a 	bl	3400904c <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
34009b18:	b388      	cbz	r0, 34009b7e <UART_SetConfig+0x12e>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
34009b1a:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34009b1c:	4a51      	ldr	r2, [pc, #324]	@ (34009c64 <UART_SetConfig+0x214>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
34009b1e:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
34009b20:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
34009b24:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
34009b28:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
34009b2c:	4299      	cmp	r1, r3
34009b2e:	d90b      	bls.n	34009b48 <UART_SetConfig+0xf8>
        ret = HAL_ERROR;
34009b30:	2001      	movs	r0, #1
  huart->NbRxDataToProcess = 1;
34009b32:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
34009b36:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
34009b38:	2300      	movs	r3, #0
  huart->TxISR = NULL;
34009b3a:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
}
34009b3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
34009b40:	f44f 0000 	mov.w	r0, #8388608	@ 0x800000
34009b44:	2100      	movs	r1, #0
34009b46:	e7e5      	b.n	34009b14 <UART_SetConfig+0xc4>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
34009b48:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
34009b4c:	d8f0      	bhi.n	34009b30 <UART_SetConfig+0xe0>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
34009b4e:	2300      	movs	r3, #0
34009b50:	4619      	mov	r1, r3
34009b52:	f7f7 fd43 	bl	340015dc <__aeabi_uldivmod>
34009b56:	4606      	mov	r6, r0
34009b58:	460f      	mov	r7, r1
34009b5a:	ea56 270f 	orrs.w	r7, r6, pc, lsl #8
34009b5e:	0868      	lsrs	r0, r5, #1
34009b60:	1830      	adds	r0, r6, r0
34009b62:	462a      	mov	r2, r5
34009b64:	f04f 0300 	mov.w	r3, #0
34009b68:	f147 0100 	adc.w	r1, r7, #0
34009b6c:	f7f7 fd36 	bl	340015dc <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
34009b70:	4b3d      	ldr	r3, [pc, #244]	@ (34009c68 <UART_SetConfig+0x218>)
34009b72:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
34009b76:	429a      	cmp	r2, r3
34009b78:	d8da      	bhi.n	34009b30 <UART_SetConfig+0xe0>
          huart->Instance->BRR = usartdiv;
34009b7a:	6823      	ldr	r3, [r4, #0]
34009b7c:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
34009b7e:	2000      	movs	r0, #0
34009b80:	e7d7      	b.n	34009b32 <UART_SetConfig+0xe2>
  UART_GETCLOCKSOURCE(huart, clocksource);
34009b82:	2000      	movs	r0, #0
34009b84:	f44f 7180 	mov.w	r1, #256	@ 0x100
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
34009b88:	f5b5 4f00 	cmp.w	r5, #32768	@ 0x8000
34009b8c:	d142      	bne.n	34009c14 <UART_SetConfig+0x1c4>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
34009b8e:	f7ff fa5d 	bl	3400904c <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
34009b92:	2800      	cmp	r0, #0
34009b94:	d0f3      	beq.n	34009b7e <UART_SetConfig+0x12e>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
34009b96:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34009b98:	4b32      	ldr	r3, [pc, #200]	@ (34009c64 <UART_SetConfig+0x214>)
34009b9a:	6862      	ldr	r2, [r4, #4]
34009b9c:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
34009ba0:	fbb0 f0f3 	udiv	r0, r0, r3
34009ba4:	0853      	lsrs	r3, r2, #1
34009ba6:	eb03 0340 	add.w	r3, r3, r0, lsl #1
34009baa:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
34009bae:	f64f 72ef 	movw	r2, #65519	@ 0xffef
34009bb2:	f1a3 0110 	sub.w	r1, r3, #16
34009bb6:	4291      	cmp	r1, r2
34009bb8:	d8ba      	bhi.n	34009b30 <UART_SetConfig+0xe0>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
34009bba:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
34009bbe:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
34009bc0:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
34009bc2:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
34009bc6:	4313      	orrs	r3, r2
34009bc8:	60cb      	str	r3, [r1, #12]
34009bca:	e7d8      	b.n	34009b7e <UART_SetConfig+0x12e>
  UART_GETCLOCKSOURCE(huart, clocksource);
34009bcc:	2000      	movs	r0, #0
34009bce:	f44f 7100 	mov.w	r1, #512	@ 0x200
34009bd2:	e7d9      	b.n	34009b88 <UART_SetConfig+0x138>
34009bd4:	2000      	movs	r0, #0
34009bd6:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34009bda:	e7d5      	b.n	34009b88 <UART_SetConfig+0x138>
34009bdc:	2000      	movs	r0, #0
34009bde:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34009be2:	e7d1      	b.n	34009b88 <UART_SetConfig+0x138>
34009be4:	2000      	movs	r0, #0
34009be6:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34009bea:	e7cd      	b.n	34009b88 <UART_SetConfig+0x138>
34009bec:	2000      	movs	r0, #0
34009bee:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34009bf2:	e7c9      	b.n	34009b88 <UART_SetConfig+0x138>
34009bf4:	2000      	movs	r0, #0
34009bf6:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
34009bfa:	e7c5      	b.n	34009b88 <UART_SetConfig+0x138>
34009bfc:	2000      	movs	r0, #0
34009bfe:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34009c02:	e7c1      	b.n	34009b88 <UART_SetConfig+0x138>
34009c04:	2000      	movs	r0, #0
34009c06:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
34009c0a:	e7bd      	b.n	34009b88 <UART_SetConfig+0x138>
34009c0c:	2000      	movs	r0, #0
34009c0e:	f44f 3100 	mov.w	r1, #131072	@ 0x20000
34009c12:	e7b9      	b.n	34009b88 <UART_SetConfig+0x138>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
34009c14:	f7ff fa1a 	bl	3400904c <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
34009c18:	2800      	cmp	r0, #0
34009c1a:	d0b0      	beq.n	34009b7e <UART_SetConfig+0x12e>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
34009c1c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34009c1e:	4b11      	ldr	r3, [pc, #68]	@ (34009c64 <UART_SetConfig+0x214>)
34009c20:	6862      	ldr	r2, [r4, #4]
34009c22:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
34009c26:	fbb0 f3f3 	udiv	r3, r0, r3
34009c2a:	eb03 0352 	add.w	r3, r3, r2, lsr #1
34009c2e:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
34009c32:	f64f 72ef 	movw	r2, #65519	@ 0xffef
34009c36:	f1a3 0110 	sub.w	r1, r3, #16
34009c3a:	4291      	cmp	r1, r2
34009c3c:	f63f af78 	bhi.w	34009b30 <UART_SetConfig+0xe0>
        huart->Instance->BRR = (uint16_t)usartdiv;
34009c40:	6822      	ldr	r2, [r4, #0]
34009c42:	60d3      	str	r3, [r2, #12]
34009c44:	e79b      	b.n	34009b7e <UART_SetConfig+0x12e>
34009c46:	bf00      	nop
34009c48:	cfff69f3 	.word	0xcfff69f3
34009c4c:	56000c00 	.word	0x56000c00
34009c50:	52001000 	.word	0x52001000
34009c54:	50004400 	.word	0x50004400
34009c58:	52001400 	.word	0x52001400
34009c5c:	50007800 	.word	0x50007800
34009c60:	52001800 	.word	0x52001800
34009c64:	340103d6 	.word	0x340103d6
34009c68:	000ffcff 	.word	0x000ffcff

34009c6c <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
34009c6c:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
34009c6e:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
34009c70:	071a      	lsls	r2, r3, #28
34009c72:	d506      	bpl.n	34009c82 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
34009c74:	6801      	ldr	r1, [r0, #0]
34009c76:	6b84      	ldr	r4, [r0, #56]	@ 0x38
34009c78:	684a      	ldr	r2, [r1, #4]
34009c7a:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34009c7e:	4322      	orrs	r2, r4
34009c80:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
34009c82:	07dc      	lsls	r4, r3, #31
34009c84:	d506      	bpl.n	34009c94 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
34009c86:	6801      	ldr	r1, [r0, #0]
34009c88:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
34009c8a:	684a      	ldr	r2, [r1, #4]
34009c8c:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
34009c90:	4322      	orrs	r2, r4
34009c92:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
34009c94:	0799      	lsls	r1, r3, #30
34009c96:	d506      	bpl.n	34009ca6 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
34009c98:	6801      	ldr	r1, [r0, #0]
34009c9a:	6b04      	ldr	r4, [r0, #48]	@ 0x30
34009c9c:	684a      	ldr	r2, [r1, #4]
34009c9e:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
34009ca2:	4322      	orrs	r2, r4
34009ca4:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
34009ca6:	075a      	lsls	r2, r3, #29
34009ca8:	d506      	bpl.n	34009cb8 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
34009caa:	6801      	ldr	r1, [r0, #0]
34009cac:	6b44      	ldr	r4, [r0, #52]	@ 0x34
34009cae:	684a      	ldr	r2, [r1, #4]
34009cb0:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
34009cb4:	4322      	orrs	r2, r4
34009cb6:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
34009cb8:	06dc      	lsls	r4, r3, #27
34009cba:	d506      	bpl.n	34009cca <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
34009cbc:	6801      	ldr	r1, [r0, #0]
34009cbe:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
34009cc0:	688a      	ldr	r2, [r1, #8]
34009cc2:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34009cc6:	4322      	orrs	r2, r4
34009cc8:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
34009cca:	0699      	lsls	r1, r3, #26
34009ccc:	d506      	bpl.n	34009cdc <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
34009cce:	6801      	ldr	r1, [r0, #0]
34009cd0:	6c04      	ldr	r4, [r0, #64]	@ 0x40
34009cd2:	688a      	ldr	r2, [r1, #8]
34009cd4:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
34009cd8:	4322      	orrs	r2, r4
34009cda:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
34009cdc:	065a      	lsls	r2, r3, #25
34009cde:	d510      	bpl.n	34009d02 <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
34009ce0:	6801      	ldr	r1, [r0, #0]
34009ce2:	6c44      	ldr	r4, [r0, #68]	@ 0x44
34009ce4:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
34009ce6:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
34009cea:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
34009cee:	ea42 0204 	orr.w	r2, r2, r4
34009cf2:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
34009cf4:	d105      	bne.n	34009d02 <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
34009cf6:	684a      	ldr	r2, [r1, #4]
34009cf8:	6c84      	ldr	r4, [r0, #72]	@ 0x48
34009cfa:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
34009cfe:	4322      	orrs	r2, r4
34009d00:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
34009d02:	061b      	lsls	r3, r3, #24
34009d04:	d506      	bpl.n	34009d14 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
34009d06:	6802      	ldr	r2, [r0, #0]
34009d08:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
34009d0a:	6853      	ldr	r3, [r2, #4]
34009d0c:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
34009d10:	430b      	orrs	r3, r1
34009d12:	6053      	str	r3, [r2, #4]
}
34009d14:	bd10      	pop	{r4, pc}

34009d16 <UART_WaitOnFlagUntilTimeout>:
{
34009d16:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34009d1a:	4604      	mov	r4, r0
34009d1c:	460d      	mov	r5, r1
34009d1e:	4617      	mov	r7, r2
34009d20:	4698      	mov	r8, r3
34009d22:	f8dd 9020 	ldr.w	r9, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
34009d26:	6822      	ldr	r2, [r4, #0]
34009d28:	69d3      	ldr	r3, [r2, #28]
34009d2a:	ea35 0303 	bics.w	r3, r5, r3
34009d2e:	bf0c      	ite	eq
34009d30:	2301      	moveq	r3, #1
34009d32:	2300      	movne	r3, #0
34009d34:	42bb      	cmp	r3, r7
34009d36:	d001      	beq.n	34009d3c <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
34009d38:	2000      	movs	r0, #0
34009d3a:	e022      	b.n	34009d82 <UART_WaitOnFlagUntilTimeout+0x6c>
    if (Timeout != HAL_MAX_DELAY)
34009d3c:	f1b9 3fff 	cmp.w	r9, #4294967295
34009d40:	d0f2      	beq.n	34009d28 <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34009d42:	f7f9 fcb1 	bl	340036a8 <HAL_GetTick>
34009d46:	eba0 0008 	sub.w	r0, r0, r8
34009d4a:	4548      	cmp	r0, r9
34009d4c:	d829      	bhi.n	34009da2 <UART_WaitOnFlagUntilTimeout+0x8c>
34009d4e:	f1b9 0f00 	cmp.w	r9, #0
34009d52:	d026      	beq.n	34009da2 <UART_WaitOnFlagUntilTimeout+0x8c>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
34009d54:	6821      	ldr	r1, [r4, #0]
34009d56:	680b      	ldr	r3, [r1, #0]
34009d58:	075a      	lsls	r2, r3, #29
34009d5a:	d5e4      	bpl.n	34009d26 <UART_WaitOnFlagUntilTimeout+0x10>
34009d5c:	2d80      	cmp	r5, #128	@ 0x80
34009d5e:	d0e2      	beq.n	34009d26 <UART_WaitOnFlagUntilTimeout+0x10>
34009d60:	2d40      	cmp	r5, #64	@ 0x40
34009d62:	d0e0      	beq.n	34009d26 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
34009d64:	69ce      	ldr	r6, [r1, #28]
34009d66:	f016 0608 	ands.w	r6, r6, #8
34009d6a:	d00c      	beq.n	34009d86 <UART_WaitOnFlagUntilTimeout+0x70>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
34009d6c:	2508      	movs	r5, #8
          UART_EndRxTransfer(huart);
34009d6e:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
34009d70:	620d      	str	r5, [r1, #32]
          UART_EndRxTransfer(huart);
34009d72:	f7ff fe41 	bl	340099f8 <UART_EndRxTransfer>
          __HAL_UNLOCK(huart);
34009d76:	2300      	movs	r3, #0
          return HAL_ERROR;
34009d78:	2001      	movs	r0, #1
          huart->ErrorCode = HAL_UART_ERROR_ORE;
34009d7a:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
          __HAL_UNLOCK(huart);
34009d7e:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
34009d82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
34009d86:	69cb      	ldr	r3, [r1, #28]
34009d88:	051b      	lsls	r3, r3, #20
34009d8a:	d5cc      	bpl.n	34009d26 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
34009d8c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
          UART_EndRxTransfer(huart);
34009d90:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
34009d92:	620b      	str	r3, [r1, #32]
          UART_EndRxTransfer(huart);
34009d94:	f7ff fe30 	bl	340099f8 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
34009d98:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
34009d9a:	f884 6084 	strb.w	r6, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
34009d9e:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        return HAL_TIMEOUT;
34009da2:	2003      	movs	r0, #3
34009da4:	e7ed      	b.n	34009d82 <UART_WaitOnFlagUntilTimeout+0x6c>

34009da6 <UART_CheckIdleState>:
{
34009da6:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
34009da8:	2600      	movs	r6, #0
{
34009daa:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
34009dac:	f8c0 6090 	str.w	r6, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
34009db0:	f7f9 fc7a 	bl	340036a8 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
34009db4:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
34009db6:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
34009db8:	681b      	ldr	r3, [r3, #0]
34009dba:	071a      	lsls	r2, r3, #28
34009dbc:	d51c      	bpl.n	34009df8 <UART_CheckIdleState+0x52>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
34009dbe:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
34009dc2:	4632      	mov	r2, r6
34009dc4:	9300      	str	r3, [sp, #0]
34009dc6:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
34009dca:	4603      	mov	r3, r0
34009dcc:	4620      	mov	r0, r4
34009dce:	f7ff ffa2 	bl	34009d16 <UART_WaitOnFlagUntilTimeout>
34009dd2:	b188      	cbz	r0, 34009df8 <UART_CheckIdleState+0x52>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
34009dd4:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34009dd6:	e852 3f00 	ldrex	r3, [r2]
34009dda:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34009dde:	e842 3100 	strex	r1, r3, [r2]
34009de2:	2900      	cmp	r1, #0
34009de4:	d1f6      	bne.n	34009dd4 <UART_CheckIdleState+0x2e>
      huart->gState = HAL_UART_STATE_READY;
34009de6:	2320      	movs	r3, #32
34009de8:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
34009dec:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
34009dee:	2300      	movs	r3, #0
34009df0:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
34009df4:	b002      	add	sp, #8
34009df6:	bd70      	pop	{r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
34009df8:	6823      	ldr	r3, [r4, #0]
34009dfa:	681b      	ldr	r3, [r3, #0]
34009dfc:	075b      	lsls	r3, r3, #29
34009dfe:	d524      	bpl.n	34009e4a <UART_CheckIdleState+0xa4>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
34009e00:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
34009e04:	2200      	movs	r2, #0
34009e06:	9300      	str	r3, [sp, #0]
34009e08:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
34009e0c:	462b      	mov	r3, r5
34009e0e:	4620      	mov	r0, r4
34009e10:	f7ff ff81 	bl	34009d16 <UART_WaitOnFlagUntilTimeout>
34009e14:	b1c8      	cbz	r0, 34009e4a <UART_CheckIdleState+0xa4>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
34009e16:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34009e18:	e852 3f00 	ldrex	r3, [r2]
34009e1c:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34009e20:	e842 3100 	strex	r1, r3, [r2]
   return(result);
34009e24:	6822      	ldr	r2, [r4, #0]
34009e26:	2900      	cmp	r1, #0
34009e28:	d1f5      	bne.n	34009e16 <UART_CheckIdleState+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34009e2a:	f102 0308 	add.w	r3, r2, #8
34009e2e:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
34009e32:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34009e36:	f102 0008 	add.w	r0, r2, #8
34009e3a:	e840 3100 	strex	r1, r3, [r0]
34009e3e:	2900      	cmp	r1, #0
34009e40:	d1f3      	bne.n	34009e2a <UART_CheckIdleState+0x84>
      huart->RxState = HAL_UART_STATE_READY;
34009e42:	2320      	movs	r3, #32
34009e44:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
34009e48:	e7d0      	b.n	34009dec <UART_CheckIdleState+0x46>
  huart->gState = HAL_UART_STATE_READY;
34009e4a:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34009e4c:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
34009e4e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
34009e52:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34009e56:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
34009e58:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
34009e5a:	e7c8      	b.n	34009dee <UART_CheckIdleState+0x48>

34009e5c <HAL_UART_Init>:
{
34009e5c:	b510      	push	{r4, lr}
  if (huart == NULL)
34009e5e:	4604      	mov	r4, r0
34009e60:	b350      	cbz	r0, 34009eb8 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
34009e62:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
34009e66:	b91b      	cbnz	r3, 34009e70 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
34009e68:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
34009e6c:	f7f8 ff28 	bl	34002cc0 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
34009e70:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
34009e72:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
34009e74:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
34009e78:	6813      	ldr	r3, [r2, #0]
34009e7a:	f023 0301 	bic.w	r3, r3, #1
34009e7e:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
34009e80:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34009e82:	b113      	cbz	r3, 34009e8a <HAL_UART_Init+0x2e>
    UART_AdvFeatureConfig(huart);
34009e84:	4620      	mov	r0, r4
34009e86:	f7ff fef1 	bl	34009c6c <UART_AdvFeatureConfig>
  if (UART_SetConfig(huart) == HAL_ERROR)
34009e8a:	4620      	mov	r0, r4
34009e8c:	f7ff fde0 	bl	34009a50 <UART_SetConfig>
34009e90:	2801      	cmp	r0, #1
34009e92:	d011      	beq.n	34009eb8 <HAL_UART_Init+0x5c>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
34009e94:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
34009e96:	4620      	mov	r0, r4
}
34009e98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
34009e9c:	685a      	ldr	r2, [r3, #4]
34009e9e:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
34009ea2:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
34009ea4:	689a      	ldr	r2, [r3, #8]
34009ea6:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
34009eaa:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
34009eac:	681a      	ldr	r2, [r3, #0]
34009eae:	f042 0201 	orr.w	r2, r2, #1
34009eb2:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
34009eb4:	f7ff bf77 	b.w	34009da6 <UART_CheckIdleState>
}
34009eb8:	2001      	movs	r0, #1
34009eba:	bd10      	pop	{r4, pc}

34009ebc <UARTEx_SetNbDataToProcess>:
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
34009ebc:	6e43      	ldr	r3, [r0, #100]	@ 0x64
{
34009ebe:	b530      	push	{r4, r5, lr}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
34009ec0:	b92b      	cbnz	r3, 34009ece <UARTEx_SetNbDataToProcess+0x12>
  {
    huart->NbTxDataToProcess = 1U;
34009ec2:	2301      	movs	r3, #1
34009ec4:	f8a0 306a 	strh.w	r3, [r0, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
34009ec8:	f8a0 3068 	strh.w	r3, [r0, #104]	@ 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
34009ecc:	bd30      	pop	{r4, r5, pc}
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
34009ece:	6803      	ldr	r3, [r0, #0]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
34009ed0:	4d09      	ldr	r5, [pc, #36]	@ (34009ef8 <UARTEx_SetNbDataToProcess+0x3c>)
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
34009ed2:	689a      	ldr	r2, [r3, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
34009ed4:	6899      	ldr	r1, [r3, #8]
                               (uint16_t)denominator[tx_fifo_threshold];
34009ed6:	4c09      	ldr	r4, [pc, #36]	@ (34009efc <UARTEx_SetNbDataToProcess+0x40>)
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
34009ed8:	0f49      	lsrs	r1, r1, #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
34009eda:	5c6b      	ldrb	r3, [r5, r1]
                               (uint16_t)denominator[tx_fifo_threshold];
34009edc:	5c61      	ldrb	r1, [r4, r1]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
34009ede:	011b      	lsls	r3, r3, #4
34009ee0:	fbb3 f3f1 	udiv	r3, r3, r1
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
34009ee4:	f3c2 6242 	ubfx	r2, r2, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
34009ee8:	f8a0 306a 	strh.w	r3, [r0, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
34009eec:	5cab      	ldrb	r3, [r5, r2]
                               (uint16_t)denominator[rx_fifo_threshold];
34009eee:	5ca2      	ldrb	r2, [r4, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
34009ef0:	011b      	lsls	r3, r3, #4
34009ef2:	fbb3 f3f2 	udiv	r3, r3, r2
}
34009ef6:	e7e7      	b.n	34009ec8 <UARTEx_SetNbDataToProcess+0xc>
34009ef8:	340103f6 	.word	0x340103f6
34009efc:	340103ee 	.word	0x340103ee

34009f00 <HAL_UARTEx_DisableFifoMode>:
  __HAL_LOCK(huart);
34009f00:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
34009f04:	2b01      	cmp	r3, #1
34009f06:	d014      	beq.n	34009f32 <HAL_UARTEx_DisableFifoMode+0x32>
  huart->gState = HAL_UART_STATE_BUSY;
34009f08:	2324      	movs	r3, #36	@ 0x24
  tmpcr1 = READ_REG(huart->Instance->CR1);
34009f0a:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
34009f0c:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
34009f10:	6811      	ldr	r1, [r2, #0]
  __HAL_UART_DISABLE(huart);
34009f12:	6813      	ldr	r3, [r2, #0]
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
34009f14:	f021 5100 	bic.w	r1, r1, #536870912	@ 0x20000000
  __HAL_UART_DISABLE(huart);
34009f18:	f023 0301 	bic.w	r3, r3, #1
34009f1c:	6013      	str	r3, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
34009f1e:	2300      	movs	r3, #0
34009f20:	6643      	str	r3, [r0, #100]	@ 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
34009f22:	6011      	str	r1, [r2, #0]
  huart->gState = HAL_UART_STATE_READY;
34009f24:	2220      	movs	r2, #32
  __HAL_UNLOCK(huart);
34009f26:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_READY;
34009f2a:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
  return HAL_OK;
34009f2e:	4618      	mov	r0, r3
34009f30:	4770      	bx	lr
  __HAL_LOCK(huart);
34009f32:	2002      	movs	r0, #2
}
34009f34:	4770      	bx	lr

34009f36 <HAL_UARTEx_SetTxFifoThreshold>:
{
34009f36:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(huart);
34009f38:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
{
34009f3c:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
34009f3e:	2b01      	cmp	r3, #1
34009f40:	d017      	beq.n	34009f72 <HAL_UARTEx_SetTxFifoThreshold+0x3c>
  huart->gState = HAL_UART_STATE_BUSY;
34009f42:	2324      	movs	r3, #36	@ 0x24
  tmpcr1 = READ_REG(huart->Instance->CR1);
34009f44:	6805      	ldr	r5, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
34009f46:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
34009f4a:	682e      	ldr	r6, [r5, #0]
  __HAL_UART_DISABLE(huart);
34009f4c:	682b      	ldr	r3, [r5, #0]
34009f4e:	f023 0301 	bic.w	r3, r3, #1
34009f52:	602b      	str	r3, [r5, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
34009f54:	68ab      	ldr	r3, [r5, #8]
34009f56:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
34009f5a:	4319      	orrs	r1, r3
34009f5c:	60a9      	str	r1, [r5, #8]
  UARTEx_SetNbDataToProcess(huart);
34009f5e:	f7ff ffad 	bl	34009ebc <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
34009f62:	2320      	movs	r3, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
34009f64:	602e      	str	r6, [r5, #0]
  huart->gState = HAL_UART_STATE_READY;
34009f66:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UNLOCK(huart);
34009f6a:	2000      	movs	r0, #0
34009f6c:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
34009f70:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(huart);
34009f72:	2002      	movs	r0, #2
34009f74:	e7fc      	b.n	34009f70 <HAL_UARTEx_SetTxFifoThreshold+0x3a>

34009f76 <HAL_UARTEx_SetRxFifoThreshold>:
{
34009f76:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(huart);
34009f78:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
{
34009f7c:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
34009f7e:	2b01      	cmp	r3, #1
34009f80:	d017      	beq.n	34009fb2 <HAL_UARTEx_SetRxFifoThreshold+0x3c>
  huart->gState = HAL_UART_STATE_BUSY;
34009f82:	2324      	movs	r3, #36	@ 0x24
  tmpcr1 = READ_REG(huart->Instance->CR1);
34009f84:	6805      	ldr	r5, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
34009f86:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
34009f8a:	682e      	ldr	r6, [r5, #0]
  __HAL_UART_DISABLE(huart);
34009f8c:	682b      	ldr	r3, [r5, #0]
34009f8e:	f023 0301 	bic.w	r3, r3, #1
34009f92:	602b      	str	r3, [r5, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
34009f94:	68ab      	ldr	r3, [r5, #8]
34009f96:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
34009f9a:	4319      	orrs	r1, r3
34009f9c:	60a9      	str	r1, [r5, #8]
  UARTEx_SetNbDataToProcess(huart);
34009f9e:	f7ff ff8d 	bl	34009ebc <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
34009fa2:	2320      	movs	r3, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
34009fa4:	602e      	str	r6, [r5, #0]
  huart->gState = HAL_UART_STATE_READY;
34009fa6:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UNLOCK(huart);
34009faa:	2000      	movs	r0, #0
34009fac:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
34009fb0:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(huart);
34009fb2:	2002      	movs	r0, #2
34009fb4:	e7fc      	b.n	34009fb0 <HAL_UARTEx_SetRxFifoThreshold+0x3a>

34009fb6 <XSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_WaitFlagStateUntilTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
34009fb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34009fba:	4604      	mov	r4, r0
34009fbc:	460e      	mov	r6, r1
34009fbe:	4615      	mov	r5, r2
34009fc0:	461f      	mov	r7, r3
34009fc2:	f8dd 8018 	ldr.w	r8, [sp, #24]
  /* Wait until flag is in expected state */
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34009fc6:	6822      	ldr	r2, [r4, #0]
34009fc8:	6a13      	ldr	r3, [r2, #32]
34009fca:	4233      	tst	r3, r6
34009fcc:	bf14      	ite	ne
34009fce:	2301      	movne	r3, #1
34009fd0:	2300      	moveq	r3, #0
34009fd2:	42ab      	cmp	r3, r5
34009fd4:	d101      	bne.n	34009fda <XSPI_WaitFlagStateUntilTimeout+0x24>

        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
34009fd6:	2000      	movs	r0, #0
34009fd8:	e00e      	b.n	34009ff8 <XSPI_WaitFlagStateUntilTimeout+0x42>
    if (Timeout != HAL_MAX_DELAY)
34009fda:	f1b8 3fff 	cmp.w	r8, #4294967295
34009fde:	d0f3      	beq.n	34009fc8 <XSPI_WaitFlagStateUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34009fe0:	f7f9 fb62 	bl	340036a8 <HAL_GetTick>
34009fe4:	1bc0      	subs	r0, r0, r7
34009fe6:	4540      	cmp	r0, r8
34009fe8:	d908      	bls.n	34009ffc <XSPI_WaitFlagStateUntilTimeout+0x46>
        hxspi->State     = HAL_XSPI_STATE_READY;
34009fea:	2302      	movs	r3, #2
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
34009fec:	2003      	movs	r0, #3
        hxspi->State     = HAL_XSPI_STATE_READY;
34009fee:	65a3      	str	r3, [r4, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
34009ff0:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
34009ff2:	f043 0301 	orr.w	r3, r3, #1
34009ff6:	65e3      	str	r3, [r4, #92]	@ 0x5c
}
34009ff8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34009ffc:	f1b8 0f00 	cmp.w	r8, #0
3400a000:	d1e1      	bne.n	34009fc6 <XSPI_WaitFlagStateUntilTimeout+0x10>
3400a002:	e7f2      	b.n	34009fea <XSPI_WaitFlagStateUntilTimeout+0x34>

3400a004 <HAL_XSPI_Init>:
{
3400a004:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400a006:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
3400a008:	f7f9 fb4e 	bl	340036a8 <HAL_GetTick>
3400a00c:	4606      	mov	r6, r0
  if (hxspi == NULL)
3400a00e:	2c00      	cmp	r4, #0
3400a010:	f000 8099 	beq.w	3400a146 <HAL_XSPI_Init+0x142>
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3400a014:	2300      	movs	r3, #0
3400a016:	65e3      	str	r3, [r4, #92]	@ 0x5c
    if (hxspi->State == HAL_XSPI_STATE_RESET)
3400a018:	6da7      	ldr	r7, [r4, #88]	@ 0x58
3400a01a:	2f00      	cmp	r7, #0
3400a01c:	f040 8085 	bne.w	3400a12a <HAL_XSPI_Init+0x126>
      HAL_XSPI_MspInit(hxspi);
3400a020:	4620      	mov	r0, r4
3400a022:	f7f8 ff1d 	bl	34002e60 <HAL_XSPI_MspInit>
  hxspi->Timeout = Timeout;
3400a026:	f241 3288 	movw	r2, #5000	@ 0x1388
      MODIFY_REG(hxspi->Instance->DCR1,
3400a02a:	69e3      	ldr	r3, [r4, #28]
3400a02c:	68e5      	ldr	r5, [r4, #12]
3400a02e:	6821      	ldr	r1, [r4, #0]
3400a030:	431d      	orrs	r5, r3
3400a032:	6923      	ldr	r3, [r4, #16]
3400a034:	6888      	ldr	r0, [r1, #8]
3400a036:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
3400a03a:	4b44      	ldr	r3, [pc, #272]	@ (3400a14c <HAL_XSPI_Init+0x148>)
  hxspi->Timeout = Timeout;
3400a03c:	6622      	str	r2, [r4, #96]	@ 0x60
      MODIFY_REG(hxspi->Instance->DCR1,
3400a03e:	4003      	ands	r3, r0
3400a040:	431d      	orrs	r5, r3
3400a042:	6963      	ldr	r3, [r4, #20]
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3400a044:	6a20      	ldr	r0, [r4, #32]
      MODIFY_REG(hxspi->Instance->DCR1,
3400a046:	3b01      	subs	r3, #1
3400a048:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
3400a04c:	608d      	str	r5, [r1, #8]
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3400a04e:	68cb      	ldr	r3, [r1, #12]
3400a050:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400a054:	4303      	orrs	r3, r0
3400a056:	60cb      	str	r3, [r1, #12]
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
3400a058:	690b      	ldr	r3, [r1, #16]
3400a05a:	6b20      	ldr	r0, [r4, #48]	@ 0x30
3400a05c:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
3400a060:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400a064:	610b      	str	r3, [r1, #16]
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
3400a066:	690b      	ldr	r3, [r1, #16]
3400a068:	6b60      	ldr	r0, [r4, #52]	@ 0x34
3400a06a:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3400a06e:	4303      	orrs	r3, r0
3400a070:	610b      	str	r3, [r1, #16]
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3400a072:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3400a074:	6860      	ldr	r0, [r4, #4]
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3400a076:	614b      	str	r3, [r1, #20]
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3400a078:	680b      	ldr	r3, [r1, #0]
3400a07a:	3801      	subs	r0, #1
3400a07c:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3400a080:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
3400a084:	600b      	str	r3, [r1, #0]
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3400a086:	4620      	mov	r0, r4
3400a088:	9200      	str	r2, [sp, #0]
3400a08a:	4633      	mov	r3, r6
3400a08c:	463a      	mov	r2, r7
3400a08e:	2120      	movs	r1, #32
3400a090:	f7ff ff91 	bl	34009fb6 <XSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
3400a094:	2800      	cmp	r0, #0
3400a096:	d154      	bne.n	3400a142 <HAL_XSPI_Init+0x13e>
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
3400a098:	6823      	ldr	r3, [r4, #0]
3400a09a:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400a09c:	68da      	ldr	r2, [r3, #12]
3400a09e:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
3400a0a2:	430a      	orrs	r2, r1
3400a0a4:	60da      	str	r2, [r3, #12]
        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
3400a0a6:	4a2a      	ldr	r2, [pc, #168]	@ (3400a150 <HAL_XSPI_Init+0x14c>)
3400a0a8:	4293      	cmp	r3, r2
3400a0aa:	d040      	beq.n	3400a12e <HAL_XSPI_Init+0x12a>
3400a0ac:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400a0b0:	4293      	cmp	r3, r2
3400a0b2:	d03c      	beq.n	3400a12e <HAL_XSPI_Init+0x12a>
3400a0b4:	4a27      	ldr	r2, [pc, #156]	@ (3400a154 <HAL_XSPI_Init+0x150>)
3400a0b6:	4293      	cmp	r3, r2
3400a0b8:	d039      	beq.n	3400a12e <HAL_XSPI_Init+0x12a>
3400a0ba:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400a0be:	4293      	cmp	r3, r2
3400a0c0:	d035      	beq.n	3400a12e <HAL_XSPI_Init+0x12a>
3400a0c2:	4a25      	ldr	r2, [pc, #148]	@ (3400a158 <HAL_XSPI_Init+0x154>)
3400a0c4:	4293      	cmp	r3, r2
3400a0c6:	d032      	beq.n	3400a12e <HAL_XSPI_Init+0x12a>
3400a0c8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400a0cc:	4293      	cmp	r3, r2
3400a0ce:	d02e      	beq.n	3400a12e <HAL_XSPI_Init+0x12a>
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
3400a0d0:	6823      	ldr	r3, [r4, #0]
3400a0d2:	68a2      	ldr	r2, [r4, #8]
3400a0d4:	6819      	ldr	r1, [r3, #0]
3400a0d6:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
3400a0d8:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
3400a0dc:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
3400a0e0:	4302      	orrs	r2, r0
3400a0e2:	430a      	orrs	r2, r1
3400a0e4:	601a      	str	r2, [r3, #0]
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT), hxspi->Init.SampleShifting);
3400a0e6:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400a0ea:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
3400a0ec:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
3400a0f0:	430a      	orrs	r2, r1
3400a0f2:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
        HAL_XSPI_ENABLE(hxspi);
3400a0f6:	681a      	ldr	r2, [r3, #0]
3400a0f8:	f042 0201 	orr.w	r2, r2, #1
3400a0fc:	601a      	str	r2, [r3, #0]
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
3400a0fe:	69a2      	ldr	r2, [r4, #24]
3400a100:	2a02      	cmp	r2, #2
3400a102:	d103      	bne.n	3400a10c <HAL_XSPI_Init+0x108>
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
3400a104:	689a      	ldr	r2, [r3, #8]
3400a106:	f042 0202 	orr.w	r2, r2, #2
3400a10a:	609a      	str	r2, [r3, #8]
        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
3400a10c:	6c22      	ldr	r2, [r4, #64]	@ 0x40
3400a10e:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
3400a112:	bf02      	ittt	eq
3400a114:	689a      	ldreq	r2, [r3, #8]
3400a116:	f442 1200 	orreq.w	r2, r2, #2097152	@ 0x200000
3400a11a:	609a      	streq	r2, [r3, #8]
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3400a11c:	68e3      	ldr	r3, [r4, #12]
3400a11e:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
3400a122:	bf0c      	ite	eq
3400a124:	2301      	moveq	r3, #1
          hxspi->State = HAL_XSPI_STATE_READY;
3400a126:	2302      	movne	r3, #2
3400a128:	65a3      	str	r3, [r4, #88]	@ 0x58
  HAL_StatusTypeDef status = HAL_OK;
3400a12a:	2000      	movs	r0, #0
3400a12c:	e009      	b.n	3400a142 <HAL_XSPI_Init+0x13e>
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3400a12e:	6e23      	ldr	r3, [r4, #96]	@ 0x60
3400a130:	2200      	movs	r2, #0
3400a132:	9300      	str	r3, [sp, #0]
3400a134:	2120      	movs	r1, #32
3400a136:	4633      	mov	r3, r6
3400a138:	4620      	mov	r0, r4
3400a13a:	f7ff ff3c 	bl	34009fb6 <XSPI_WaitFlagStateUntilTimeout>
          if (status != HAL_OK)
3400a13e:	2800      	cmp	r0, #0
3400a140:	d0c6      	beq.n	3400a0d0 <HAL_XSPI_Init+0xcc>
}
3400a142:	b003      	add	sp, #12
3400a144:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = HAL_ERROR;
3400a146:	2001      	movs	r0, #1
3400a148:	e7fb      	b.n	3400a142 <HAL_XSPI_Init+0x13e>
3400a14a:	bf00      	nop
3400a14c:	f8e0c0fc 	.word	0xf8e0c0fc
3400a150:	58025000 	.word	0x58025000
3400a154:	5802a000 	.word	0x5802a000
3400a158:	5802d000 	.word	0x5802d000

3400a15c <HAL_XSPI_HyperbusCfg>:
{
3400a15c:	b573      	push	{r0, r1, r4, r5, r6, lr}
3400a15e:	4604      	mov	r4, r0
3400a160:	4616      	mov	r6, r2
3400a162:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
3400a164:	f7f9 faa0 	bl	340036a8 <HAL_GetTick>
  state = hxspi->State;
3400a168:	6da2      	ldr	r2, [r4, #88]	@ 0x58
  uint32_t tickstart = HAL_GetTick();
3400a16a:	4603      	mov	r3, r0
  if ((state == HAL_XSPI_STATE_HYPERBUS_INIT) || (state == HAL_XSPI_STATE_READY))
3400a16c:	3a01      	subs	r2, #1
3400a16e:	2a01      	cmp	r2, #1
3400a170:	d816      	bhi.n	3400a1a0 <HAL_XSPI_HyperbusCfg+0x44>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3400a172:	2200      	movs	r2, #0
3400a174:	2120      	movs	r1, #32
3400a176:	4620      	mov	r0, r4
3400a178:	9600      	str	r6, [sp, #0]
3400a17a:	f7ff ff1c 	bl	34009fb6 <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
3400a17e:	b998      	cbnz	r0, 3400a1a8 <HAL_XSPI_HyperbusCfg+0x4c>
      WRITE_REG(hxspi->Instance->HLCR, ((pCfg->RWRecoveryTimeCycle << XSPI_HLCR_TRWR_Pos) |
3400a180:	e9d5 3102 	ldrd	r3, r1, [r5, #8]
3400a184:	430b      	orrs	r3, r1
3400a186:	6829      	ldr	r1, [r5, #0]
3400a188:	6822      	ldr	r2, [r4, #0]
3400a18a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a18e:	6869      	ldr	r1, [r5, #4]
3400a190:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
3400a194:	f8c2 3200 	str.w	r3, [r2, #512]	@ 0x200
      hxspi->State = HAL_XSPI_STATE_READY;
3400a198:	2302      	movs	r3, #2
3400a19a:	65a3      	str	r3, [r4, #88]	@ 0x58
}
3400a19c:	b002      	add	sp, #8
3400a19e:	bd70      	pop	{r4, r5, r6, pc}
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3400a1a0:	2310      	movs	r3, #16
    status = HAL_ERROR;
3400a1a2:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3400a1a4:	65e3      	str	r3, [r4, #92]	@ 0x5c
3400a1a6:	e7f9      	b.n	3400a19c <HAL_XSPI_HyperbusCfg+0x40>
      status = HAL_BUSY;
3400a1a8:	2002      	movs	r0, #2
3400a1aa:	e7f7      	b.n	3400a19c <HAL_XSPI_HyperbusCfg+0x40>

3400a1ac <HAL_XSPIM_Config>:
{
3400a1ac:	b5f0      	push	{r4, r5, r6, r7, lr}
3400a1ae:	b08b      	sub	sp, #44	@ 0x2c
  XSPIM_CfgTypeDef IOM_cfg[XSPI_NB_INSTANCE] = {0};
3400a1b0:	2224      	movs	r2, #36	@ 0x24
{
3400a1b2:	4605      	mov	r5, r0
3400a1b4:	460c      	mov	r4, r1
  XSPIM_CfgTypeDef IOM_cfg[XSPI_NB_INSTANCE] = {0};
3400a1b6:	a801      	add	r0, sp, #4
3400a1b8:	2100      	movs	r1, #0
3400a1ba:	f003 fbab 	bl	3400d914 <memset>
  uint32_t mux;
  uint32_t mode;

  if (instance_nb == 1U)
  {
    if ((XSPIM->CR & XSPIM_CR_MODE) == 0U)
3400a1be:	4b5d      	ldr	r3, [pc, #372]	@ (3400a334 <HAL_XSPIM_Config+0x188>)
3400a1c0:	f8d3 2400 	ldr.w	r2, [r3, #1024]	@ 0x400
3400a1c4:	f3c2 0240 	ubfx	r2, r2, #1, #1
3400a1c8:	9202      	str	r2, [sp, #8]
    else
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
    }

    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
3400a1ca:	f8d3 2400 	ldr.w	r2, [r3, #1024]	@ 0x400
3400a1ce:	06d2      	lsls	r2, r2, #27
3400a1d0:	d501      	bpl.n	3400a1d6 <HAL_XSPIM_Config+0x2a>
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
    }
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O1) == XSPIM_CR_CSSEL_OVR_O1)
3400a1d2:	f8d3 3400 	ldr.w	r3, [r3, #1024]	@ 0x400
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
    }
    else
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
3400a1d6:	2201      	movs	r2, #1
3400a1d8:	260c      	movs	r6, #12
    }
  }
  else
  {
    mux = (XSPIM->CR & XSPIM_CR_MUXEN);
3400a1da:	4956      	ldr	r1, [pc, #344]	@ (3400a334 <HAL_XSPIM_Config+0x188>)
3400a1dc:	f8d1 3400 	ldr.w	r3, [r1, #1024]	@ 0x400
3400a1e0:	4610      	mov	r0, r2
    mode = ((XSPIM->CR & XSPIM_CR_MODE) >> XSPIM_CR_MODE_Pos);
3400a1e2:	f8d1 7400 	ldr.w	r7, [r1, #1024]	@ 0x400
3400a1e6:	f10d 0c28 	add.w	ip, sp, #40	@ 0x28
3400a1ea:	ea83 0357 	eor.w	r3, r3, r7, lsr #1
3400a1ee:	43db      	mvns	r3, r3
3400a1f0:	fb06 c000 	mla	r0, r6, r0, ip
3400a1f4:	f003 0301 	and.w	r3, r3, #1
3400a1f8:	f840 3c20 	str.w	r3, [r0, #-32]
    }
    else
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
    }
    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
3400a1fc:	f8d1 3400 	ldr.w	r3, [r1, #1024]	@ 0x400
    XSPIM_GetConfig(index + 1U, &(IOM_cfg[index]));
3400a200:	3201      	adds	r2, #1
    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
3400a202:	06db      	lsls	r3, r3, #27
    XSPIM_GetConfig(index + 1U, &(IOM_cfg[index]));
3400a204:	b2d2      	uxtb	r2, r2
    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
3400a206:	d501      	bpl.n	3400a20c <HAL_XSPIM_Config+0x60>
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
    }
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O2) == XSPIM_CR_CSSEL_OVR_O2)
3400a208:	f8d1 3400 	ldr.w	r3, [r1, #1024]	@ 0x400
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
3400a20c:	2a03      	cmp	r2, #3
3400a20e:	d1e5      	bne.n	3400a1dc <HAL_XSPIM_Config+0x30>
  return ((READ_BIT(RCC->AHB5ENR, Periphs) == Periphs) ? 1UL : 0UL);
3400a210:	4b49      	ldr	r3, [pc, #292]	@ (3400a338 <HAL_XSPIM_Config+0x18c>)
3400a212:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
3400a216:	f013 0320 	ands.w	r3, r3, #32
3400a21a:	d009      	beq.n	3400a230 <HAL_XSPIM_Config+0x84>
    if ((XSPI1->CR & XSPI_CR_EN) != 0U)
3400a21c:	4a47      	ldr	r2, [pc, #284]	@ (3400a33c <HAL_XSPIM_Config+0x190>)
3400a21e:	6813      	ldr	r3, [r2, #0]
3400a220:	f013 0301 	ands.w	r3, r3, #1
      CLEAR_BIT(XSPI1->CR, XSPI_CR_EN);
3400a224:	bf1f      	itttt	ne
3400a226:	6813      	ldrne	r3, [r2, #0]
3400a228:	f023 0301 	bicne.w	r3, r3, #1
3400a22c:	6013      	strne	r3, [r2, #0]
      xspi_enabled |= 0x1U;
3400a22e:	2301      	movne	r3, #1
3400a230:	4841      	ldr	r0, [pc, #260]	@ (3400a338 <HAL_XSPIM_Config+0x18c>)
3400a232:	f8d0 2260 	ldr.w	r2, [r0, #608]	@ 0x260
3400a236:	04d7      	lsls	r7, r2, #19
3400a238:	d509      	bpl.n	3400a24e <HAL_XSPIM_Config+0xa2>
    if ((XSPI2->CR & XSPI_CR_EN) != 0U)
3400a23a:	4a41      	ldr	r2, [pc, #260]	@ (3400a340 <HAL_XSPIM_Config+0x194>)
3400a23c:	6811      	ldr	r1, [r2, #0]
3400a23e:	07ce      	lsls	r6, r1, #31
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
3400a240:	bf41      	itttt	mi
3400a242:	6811      	ldrmi	r1, [r2, #0]
      xspi_enabled |= 0x2U;
3400a244:	f043 0302 	orrmi.w	r3, r3, #2
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
3400a248:	f021 0101 	bicmi.w	r1, r1, #1
3400a24c:	6011      	strmi	r1, [r2, #0]
3400a24e:	f8d0 2260 	ldr.w	r2, [r0, #608]	@ 0x260
3400a252:	0390      	lsls	r0, r2, #14
3400a254:	d50a      	bpl.n	3400a26c <HAL_XSPIM_Config+0xc0>
    if ((XSPI3->CR & XSPI_CR_EN) != 0U)
3400a256:	4a3b      	ldr	r2, [pc, #236]	@ (3400a344 <HAL_XSPIM_Config+0x198>)
3400a258:	6812      	ldr	r2, [r2, #0]
3400a25a:	07d1      	lsls	r1, r2, #31
3400a25c:	d506      	bpl.n	3400a26c <HAL_XSPIM_Config+0xc0>
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
3400a25e:	4938      	ldr	r1, [pc, #224]	@ (3400a340 <HAL_XSPIM_Config+0x194>)
      xspi_enabled |= 0x4U;
3400a260:	f043 0304 	orr.w	r3, r3, #4
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
3400a264:	680a      	ldr	r2, [r1, #0]
3400a266:	f022 0201 	bic.w	r2, r2, #1
3400a26a:	600a      	str	r2, [r1, #0]
  CLEAR_REG(XSPIM->CR);
3400a26c:	2000      	movs	r0, #0
3400a26e:	4a31      	ldr	r2, [pc, #196]	@ (3400a334 <HAL_XSPIM_Config+0x188>)
3400a270:	f8c2 0400 	str.w	r0, [r2, #1024]	@ 0x400
  MODIFY_REG(XSPIM->CR, XSPIM_CR_REQ2ACK_TIME, ((pCfg->Req2AckTime - 1U) << XSPIM_CR_REQ2ACK_TIME_Pos));
3400a274:	f8d2 1400 	ldr.w	r1, [r2, #1024]	@ 0x400
3400a278:	68a6      	ldr	r6, [r4, #8]
3400a27a:	f421 017f 	bic.w	r1, r1, #16711680	@ 0xff0000
3400a27e:	3e01      	subs	r6, #1
3400a280:	ea41 4106 	orr.w	r1, r1, r6, lsl #16
3400a284:	f8c2 1400 	str.w	r1, [r2, #1024]	@ 0x400
  if (hxspi->Instance == XSPI1)
3400a288:	4e2c      	ldr	r6, [pc, #176]	@ (3400a33c <HAL_XSPIM_Config+0x190>)
3400a28a:	6829      	ldr	r1, [r5, #0]
3400a28c:	42b1      	cmp	r1, r6
3400a28e:	d129      	bne.n	3400a2e4 <HAL_XSPIM_Config+0x138>
    IOM_cfg[0].IOPort = pCfg->IOPort ;
3400a290:	6861      	ldr	r1, [r4, #4]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
3400a292:	6820      	ldr	r0, [r4, #0]
    IOM_cfg[0].IOPort = pCfg->IOPort ;
3400a294:	9102      	str	r1, [sp, #8]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
3400a296:	b130      	cbz	r0, 3400a2a6 <HAL_XSPIM_Config+0xfa>
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O1 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
3400a298:	f8d2 1400 	ldr.w	r1, [r2, #1024]	@ 0x400
3400a29c:	f021 0130 	bic.w	r1, r1, #48	@ 0x30
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O2 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
3400a2a0:	4301      	orrs	r1, r0
3400a2a2:	f8c2 1400 	str.w	r1, [r2, #1024]	@ 0x400
    if (IOM_cfg[index].IOPort == IOM_cfg[index + 1U].IOPort)
3400a2a6:	9902      	ldr	r1, [sp, #8]
3400a2a8:	9a05      	ldr	r2, [sp, #20]
3400a2aa:	4291      	cmp	r1, r2
3400a2ac:	d106      	bne.n	3400a2bc <HAL_XSPIM_Config+0x110>
      SET_BIT(XSPIM->CR, XSPIM_CR_MUXEN);
3400a2ae:	4821      	ldr	r0, [pc, #132]	@ (3400a334 <HAL_XSPIM_Config+0x188>)
3400a2b0:	f8d0 2400 	ldr.w	r2, [r0, #1024]	@ 0x400
3400a2b4:	f042 0201 	orr.w	r2, r2, #1
3400a2b8:	f8c0 2400 	str.w	r2, [r0, #1024]	@ 0x400
    if (IOM_cfg[0].IOPort == HAL_XSPIM_IOPORT_2)
3400a2bc:	2901      	cmp	r1, #1
3400a2be:	d106      	bne.n	3400a2ce <HAL_XSPIM_Config+0x122>
      SET_BIT(XSPIM->CR, XSPIM_CR_MODE);
3400a2c0:	491c      	ldr	r1, [pc, #112]	@ (3400a334 <HAL_XSPIM_Config+0x188>)
3400a2c2:	f8d1 2400 	ldr.w	r2, [r1, #1024]	@ 0x400
3400a2c6:	f042 0202 	orr.w	r2, r2, #2
3400a2ca:	f8c1 2400 	str.w	r2, [r1, #1024]	@ 0x400
  if ((xspi_enabled & 0x1U) != 0U)
3400a2ce:	07da      	lsls	r2, r3, #31
    SET_BIT(XSPI1->CR, XSPI_CR_EN);
3400a2d0:	bf41      	itttt	mi
3400a2d2:	491a      	ldrmi	r1, [pc, #104]	@ (3400a33c <HAL_XSPIM_Config+0x190>)
3400a2d4:	680a      	ldrmi	r2, [r1, #0]
3400a2d6:	f042 0201 	orrmi.w	r2, r2, #1
3400a2da:	600a      	strmi	r2, [r1, #0]
  if ((xspi_enabled & 0x2U) != 0U)
3400a2dc:	079b      	lsls	r3, r3, #30
3400a2de:	d423      	bmi.n	3400a328 <HAL_XSPIM_Config+0x17c>
  return status;
3400a2e0:	2000      	movs	r0, #0
3400a2e2:	e01f      	b.n	3400a324 <HAL_XSPIM_Config+0x178>
  else if (hxspi->Instance == XSPI2)
3400a2e4:	4e16      	ldr	r6, [pc, #88]	@ (3400a340 <HAL_XSPIM_Config+0x194>)
3400a2e6:	42b1      	cmp	r1, r6
3400a2e8:	d109      	bne.n	3400a2fe <HAL_XSPIM_Config+0x152>
    IOM_cfg[1].IOPort = pCfg->IOPort ;
3400a2ea:	6861      	ldr	r1, [r4, #4]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
3400a2ec:	6820      	ldr	r0, [r4, #0]
    IOM_cfg[1].IOPort = pCfg->IOPort ;
3400a2ee:	9105      	str	r1, [sp, #20]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
3400a2f0:	2800      	cmp	r0, #0
3400a2f2:	d0d8      	beq.n	3400a2a6 <HAL_XSPIM_Config+0xfa>
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O2 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
3400a2f4:	f8d2 1400 	ldr.w	r1, [r2, #1024]	@ 0x400
3400a2f8:	f021 0150 	bic.w	r1, r1, #80	@ 0x50
3400a2fc:	e7d0      	b.n	3400a2a0 <HAL_XSPIM_Config+0xf4>
  else if (hxspi->Instance == XSPI3)
3400a2fe:	4a11      	ldr	r2, [pc, #68]	@ (3400a344 <HAL_XSPIM_Config+0x198>)
3400a300:	4291      	cmp	r1, r2
3400a302:	d10a      	bne.n	3400a31a <HAL_XSPIM_Config+0x16e>
    if (pCfg->IOPort == HAL_XSPIM_IOPORT_1)
3400a304:	6862      	ldr	r2, [r4, #4]
3400a306:	b91a      	cbnz	r2, 3400a310 <HAL_XSPIM_Config+0x164>
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_2 ;
3400a308:	2201      	movs	r2, #1
3400a30a:	9202      	str	r2, [sp, #8]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_2 ;
3400a30c:	9205      	str	r2, [sp, #20]
3400a30e:	e7ca      	b.n	3400a2a6 <HAL_XSPIM_Config+0xfa>
    else if (pCfg->IOPort == HAL_XSPIM_IOPORT_2)
3400a310:	2a01      	cmp	r2, #1
3400a312:	d1c8      	bne.n	3400a2a6 <HAL_XSPIM_Config+0xfa>
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_1 ;
3400a314:	9002      	str	r0, [sp, #8]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_1 ;
3400a316:	9005      	str	r0, [sp, #20]
3400a318:	e7c5      	b.n	3400a2a6 <HAL_XSPIM_Config+0xfa>
    return HAL_ERROR;
3400a31a:	2001      	movs	r0, #1
    hxspi->ErrorCode |= HAL_XSPI_ERROR_INVALID_PARAM;
3400a31c:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
3400a31e:	f043 0308 	orr.w	r3, r3, #8
3400a322:	65eb      	str	r3, [r5, #92]	@ 0x5c
}
3400a324:	b00b      	add	sp, #44	@ 0x2c
3400a326:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SET_BIT(XSPI2->CR, XSPI_CR_EN);
3400a328:	4a05      	ldr	r2, [pc, #20]	@ (3400a340 <HAL_XSPIM_Config+0x194>)
3400a32a:	6813      	ldr	r3, [r2, #0]
3400a32c:	f043 0301 	orr.w	r3, r3, #1
3400a330:	6013      	str	r3, [r2, #0]
3400a332:	e7d5      	b.n	3400a2e0 <HAL_XSPIM_Config+0x134>
3400a334:	5802b000 	.word	0x5802b000
3400a338:	56028000 	.word	0x56028000
3400a33c:	58025000 	.word	0x58025000
3400a340:	5802a000 	.word	0x5802a000
3400a344:	5802d000 	.word	0x5802d000

3400a348 <npu_cache_init>:

static CACHEAXI_HandleTypeDef hcacheaxi_s;

void npu_cache_init(void)
{
  hcacheaxi_s.Instance = CACHEAXI;
3400a348:	4802      	ldr	r0, [pc, #8]	@ (3400a354 <npu_cache_init+0xc>)
3400a34a:	4b03      	ldr	r3, [pc, #12]	@ (3400a358 <npu_cache_init+0x10>)
3400a34c:	6003      	str	r3, [r0, #0]
  HAL_CACHEAXI_Init(&hcacheaxi_s);      // Side effect: cacheaxi should be enabled (but one should call npu_enable_cache to be sure)
3400a34e:	f7f9 b9e6 	b.w	3400371e <HAL_CACHEAXI_Init>
3400a352:	bf00      	nop
3400a354:	340cfba4 	.word	0x340cfba4
3400a358:	580dfc00 	.word	0x580dfc00

3400a35c <EpochBlock_EpochControllerUnit>:
  {
    return ((eb->flags & EpochBlock_Flags_internal) != 0);
  }

  static inline uint32_t EpochBlock_EpochControllerUnit(const EpochBlock_ItemTypeDef *eb)
  {
3400a35c:	b508      	push	{r3, lr}
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
3400a35e:	8a03      	ldrh	r3, [r0, #16]
3400a360:	075b      	lsls	r3, r3, #29
3400a362:	d406      	bmi.n	3400a372 <EpochBlock_EpochControllerUnit+0x16>
3400a364:	f240 11d5 	movw	r1, #469	@ 0x1d5
3400a368:	4b03      	ldr	r3, [pc, #12]	@ (3400a378 <EpochBlock_EpochControllerUnit+0x1c>)
3400a36a:	4a04      	ldr	r2, [pc, #16]	@ (3400a37c <EpochBlock_EpochControllerUnit+0x20>)
3400a36c:	4804      	ldr	r0, [pc, #16]	@ (3400a380 <EpochBlock_EpochControllerUnit+0x24>)
3400a36e:	f002 febf 	bl	3400d0f0 <__assert_func>
    return eb->wait_mask;
  }
3400a372:	68c0      	ldr	r0, [r0, #12]
3400a374:	bd08      	pop	{r3, pc}
3400a376:	bf00      	nop
3400a378:	34010428 	.word	0x34010428
3400a37c:	34011111 	.word	0x34011111
3400a380:	34010443 	.word	0x34010443

3400a384 <dump_dma_state>:
#error current ATON runtime supports only up to 32 epoch controllers!
#endif // (ATON_EPOCHCTRL_NUM > 32)

#endif // `ATON_INT_NR` and `ATON_STRENG_NUM` are defined

LL_ATON_WEAK void dump_dma_state(void){};
3400a384:	4770      	bx	lr
	...

3400a388 <__LL_ATON_RT_IrqErr>:
#if (ATON_INT_NR > 32)
static void __LL_ATON_RT_IrqErr(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static void __LL_ATON_RT_IrqErr(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3400a388:	b538      	push	{r3, r4, r5, lr}
  extern void dump_dma_state(void);
  int32_t i;

  if (!irqs)
3400a38a:	4604      	mov	r4, r0
3400a38c:	2800      	cmp	r0, #0
3400a38e:	d05b      	beq.n	3400a448 <__LL_ATON_RT_IrqErr+0xc0>
    return;

#ifdef ATON_STRENG_NUM
  /* Streaming Engine Error interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM))
3400a390:	4b2e      	ldr	r3, [pc, #184]	@ (3400a44c <__LL_ATON_RT_IrqErr+0xc4>)
3400a392:	4003      	ands	r3, r0
3400a394:	d007      	beq.n	3400a3a6 <__LL_ATON_RT_IrqErr+0x1e>

    masked_irqs = (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM));

    // assumes that stream engine interrupts are assigned in the order of their engine number and to consecutive bits
    // within the `INTREG` register
    uint32_t streaming_engine_nr = (uint32_t)(masked_irqs & (-masked_irqs));
3400a396:	4259      	negs	r1, r3
3400a398:	4019      	ands	r1, r3
    streaming_engine_nr -= ATON_STRENG_INT(0);

#ifndef NDEBUG
    uint32_t streng_err = ATON_STRENG_IRQ_GET(streaming_engine_nr);
3400a39a:	4b2d      	ldr	r3, [pc, #180]	@ (3400a450 <__LL_ATON_RT_IrqErr+0xc8>)
3400a39c:	030a      	lsls	r2, r1, #12
3400a39e:	58d2      	ldr	r2, [r2, r3]
    LL_ATON_PRINTF("Streaming engine #%" PRIu32 " error interrupt: 0x%" PRIx32 "\n", streaming_engine_nr, streng_err);
3400a3a0:	482c      	ldr	r0, [pc, #176]	@ (3400a454 <__LL_ATON_RT_IrqErr+0xcc>)
3400a3a2:	f003 f91f 	bl	3400d5e4 <iprintf>
#endif // NDEBUG
  }
  /* Streaming Engine interrupts */
  if (irqs & ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0))
3400a3a6:	f3c4 0309 	ubfx	r3, r4, #0, #10
3400a3aa:	b113      	cbz	r3, 3400a3b2 <__LL_ATON_RT_IrqErr+0x2a>
  {
    LL_ATON_PRINTF("Streaming engine completion interrupt\n");
3400a3ac:	482a      	ldr	r0, [pc, #168]	@ (3400a458 <__LL_ATON_RT_IrqErr+0xd0>)
3400a3ae:	f003 f981 	bl	3400d6b4 <puts>
  }
#endif // ATON_STRENG_NUM

#ifdef ATON_CONVACC_NUM
  /* Convolutional accelerators interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_CONVACC_INT_MASK, ATON_CONVACC_NUM))
3400a3b2:	f414 0f70 	tst.w	r4, #15728640	@ 0xf00000
3400a3b6:	d002      	beq.n	3400a3be <__LL_ATON_RT_IrqErr+0x36>
  {
    LL_ATON_PRINTF("Convolutional accelerator interrupt\n");
3400a3b8:	4828      	ldr	r0, [pc, #160]	@ (3400a45c <__LL_ATON_RT_IrqErr+0xd4>)
3400a3ba:	f003 f97b 	bl	3400d6b4 <puts>
  }
#endif // ATON_CONVACC_NUM

#if defined(ATON_RECBUF_NUM)
  /* Reconfigurable buffer interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_RECBUF_INT_MASK, ATON_RECBUF_NUM))
3400a3be:	01e5      	lsls	r5, r4, #7
3400a3c0:	d502      	bpl.n	3400a3c8 <__LL_ATON_RT_IrqErr+0x40>
  {
    LL_ATON_PRINTF("Reconfigurable buffer interrupt\n");
3400a3c2:	4827      	ldr	r0, [pc, #156]	@ (3400a460 <__LL_ATON_RT_IrqErr+0xd8>)
3400a3c4:	f003 f976 	bl	3400d6b4 <puts>
  }
#endif // ATON_RECBUF_NUM

#ifdef ATON_BUSIF_NUM
  /* Bus interface interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_BUSIF_INT_MASK, ATON_BUSIF_NUM))
3400a3c8:	f014 6fc0 	tst.w	r4, #100663296	@ 0x6000000
3400a3cc:	d00e      	beq.n	3400a3ec <__LL_ATON_RT_IrqErr+0x64>
  {
    LL_ATON_PRINTF("Bus interface interrupt\n");
3400a3ce:	4825      	ldr	r0, [pc, #148]	@ (3400a464 <__LL_ATON_RT_IrqErr+0xdc>)
3400a3d0:	f003 f970 	bl	3400d6b4 <puts>

    /* Report offending stream engine */
    for (i = 0; i < ATON_BUSIF_NUM; i++)
      LL_ATON_PRINTF("BUSIF%" PRId32 " ERR: 0x%" PRIx32 "\n", i, ATON_BUSIF_ERR_GET(i));
3400a3d4:	4b24      	ldr	r3, [pc, #144]	@ (3400a468 <__LL_ATON_RT_IrqErr+0xe0>)
3400a3d6:	2100      	movs	r1, #0
3400a3d8:	691a      	ldr	r2, [r3, #16]
3400a3da:	4824      	ldr	r0, [pc, #144]	@ (3400a46c <__LL_ATON_RT_IrqErr+0xe4>)
3400a3dc:	f003 f902 	bl	3400d5e4 <iprintf>
3400a3e0:	4b23      	ldr	r3, [pc, #140]	@ (3400a470 <__LL_ATON_RT_IrqErr+0xe8>)
3400a3e2:	2101      	movs	r1, #1
3400a3e4:	691a      	ldr	r2, [r3, #16]
3400a3e6:	4821      	ldr	r0, [pc, #132]	@ (3400a46c <__LL_ATON_RT_IrqErr+0xe4>)
3400a3e8:	f003 f8fc 	bl	3400d5e4 <iprintf>
  }
#endif // ATON_BUSIF_NUM

#if defined(ATON_STRSWITCH_NUM)
  /* Stream switch interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRSWITCH_INT_MASK, ATON_STRSWITCH_NUM))
3400a3ec:	0120      	lsls	r0, r4, #4
3400a3ee:	d502      	bpl.n	3400a3f6 <__LL_ATON_RT_IrqErr+0x6e>
  {
    LL_ATON_PRINTF("Stream switch interrupt\n");
3400a3f0:	4820      	ldr	r0, [pc, #128]	@ (3400a474 <__LL_ATON_RT_IrqErr+0xec>)
3400a3f2:	f003 f95f 	bl	3400d6b4 <puts>
  }
#endif // ATON_STRSWITCH_NUM

#if defined(ATON_EPOCHCTRL_NUM)
  /* Epoch Controller interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_ERR_INT_MASK, ATON_EPOCHCTRL_NUM))
3400a3f6:	0061      	lsls	r1, r4, #1
3400a3f8:	d50c      	bpl.n	3400a414 <__LL_ATON_RT_IrqErr+0x8c>
  {
    LL_ATON_PRINTF("Epoch Controller ERROR interrupt: EC_IRQ = 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_IRQ_GET(0));
3400a3fa:	4d1f      	ldr	r5, [pc, #124]	@ (3400a478 <__LL_ATON_RT_IrqErr+0xf0>)
3400a3fc:	481f      	ldr	r0, [pc, #124]	@ (3400a47c <__LL_ATON_RT_IrqErr+0xf4>)
3400a3fe:	68e9      	ldr	r1, [r5, #12]
3400a400:	f003 f8f0 	bl	3400d5e4 <iprintf>
    LL_ATON_PRINTF("Epoch Controller opcode counter: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_BC_GET(0));
3400a404:	6a29      	ldr	r1, [r5, #32]
3400a406:	481e      	ldr	r0, [pc, #120]	@ (3400a480 <__LL_ATON_RT_IrqErr+0xf8>)
3400a408:	f003 f8ec 	bl	3400d5e4 <iprintf>
    LL_ATON_PRINTF("Epoch Controller label: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_LABEL_GET(0));
3400a40c:	69e9      	ldr	r1, [r5, #28]
3400a40e:	481d      	ldr	r0, [pc, #116]	@ (3400a484 <__LL_ATON_RT_IrqErr+0xfc>)
3400a410:	f003 f8e8 	bl	3400d5e4 <iprintf>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_NOACK_INT_MASK, ATON_EPOCHCTRL_NUM))
3400a414:	00a2      	lsls	r2, r4, #2
3400a416:	d502      	bpl.n	3400a41e <__LL_ATON_RT_IrqErr+0x96>
  {
    LL_ATON_PRINTF("Epoch Controller NOACK interrupt\n");
3400a418:	481b      	ldr	r0, [pc, #108]	@ (3400a488 <__LL_ATON_RT_IrqErr+0x100>)
3400a41a:	f003 f94b 	bl	3400d6b4 <puts>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ATON_EPOCHCTRL_NUM))
3400a41e:	00e3      	lsls	r3, r4, #3
3400a420:	d502      	bpl.n	3400a428 <__LL_ATON_RT_IrqErr+0xa0>
  {
    LL_ATON_PRINTF("Epoch Controller interrupt\n");
3400a422:	481a      	ldr	r0, [pc, #104]	@ (3400a48c <__LL_ATON_RT_IrqErr+0x104>)
3400a424:	f003 f946 	bl	3400d6b4 <puts>
  }
#endif // ATON_EPOCHCTRL_NUM

  /* default error handling */
  dump_dma_state();
3400a428:	f7ff ffac 	bl	3400a384 <dump_dma_state>
  IRQ_ERR_MSG(); // just for debug
3400a42c:	4622      	mov	r2, r4
3400a42e:	2300      	movs	r3, #0
3400a430:	f240 3153 	movw	r1, #851	@ 0x353
3400a434:	4816      	ldr	r0, [pc, #88]	@ (3400a490 <__LL_ATON_RT_IrqErr+0x108>)
3400a436:	f003 f8d5 	bl	3400d5e4 <iprintf>
#if (ATON_PLAT_HAS_FFLUSH)
  LL_ATON_FFLUSH(stdout);
#endif
  LL_ATON_ASSERT(false); // may never happen
3400a43a:	f240 3157 	movw	r1, #855	@ 0x357
3400a43e:	4b15      	ldr	r3, [pc, #84]	@ (3400a494 <__LL_ATON_RT_IrqErr+0x10c>)
3400a440:	4a15      	ldr	r2, [pc, #84]	@ (3400a498 <__LL_ATON_RT_IrqErr+0x110>)
3400a442:	4816      	ldr	r0, [pc, #88]	@ (3400a49c <__LL_ATON_RT_IrqErr+0x114>)
3400a444:	f002 fe54 	bl	3400d0f0 <__assert_func>
  // All of the above not handled interrupts should be changed in a way that allows both a return from
  // this IRQ handler (w/o immediate re-entry) and to return control back to the user's main loop e.g. by using an
  // internal flag/variable to signal the error, then performing a `LL_ATON_RT_RuntimeDeInit()`, and returning with a
  // respective (new) return value (of type `LL_ATON_RT_RetValues_t`), reporting about the error, from the latest
  // call to `LL_ATON_RT_RunEpochBlock()`
}
3400a448:	bd38      	pop	{r3, r4, r5, pc}
3400a44a:	bf00      	nop
3400a44c:	000ffc00 	.word	0x000ffc00
3400a450:	580e503c 	.word	0x580e503c
3400a454:	3401054f 	.word	0x3401054f
3400a458:	3401057d 	.word	0x3401057d
3400a45c:	340105a3 	.word	0x340105a3
3400a460:	340105c7 	.word	0x340105c7
3400a464:	340105e7 	.word	0x340105e7
3400a468:	580e2000 	.word	0x580e2000
3400a46c:	340105ff 	.word	0x340105ff
3400a470:	580e3000 	.word	0x580e3000
3400a474:	34010614 	.word	0x34010614
3400a478:	580fe000 	.word	0x580fe000
3400a47c:	3401062c 	.word	0x3401062c
3400a480:	34010660 	.word	0x34010660
3400a484:	3401068a 	.word	0x3401068a
3400a488:	340106ab 	.word	0x340106ab
3400a48c:	340106cc 	.word	0x340106cc
3400a490:	340106e7 	.word	0x340106e7
3400a494:	3401070e 	.word	0x3401070e
3400a498:	340110ed 	.word	0x340110ed
3400a49c:	34010484 	.word	0x34010484

3400a4a0 <NPU0_IRQHandler>:
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

/* ATON ISR
 * ll_aton routes all interrupts to `ATON_STD_IRQ_LINE` interrupt line */
void ATON_STD_IRQHandler(void)
{
3400a4a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if (ATON_INT_NR > 32)
  uint32_t irqs_l = ATON_INTCTRL_INTREG_GET(0);
  uint32_t irqs_h = ATON_INTCTRL_INTREG_H_GET(0);
  uint64_t irqs = irqs_l | (irqs_h << 32);
#else  //(ATON_INT_NR <= 32)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
3400a4a2:	4b38      	ldr	r3, [pc, #224]	@ (3400a584 <NPU0_IRQHandler+0xe4>)
#endif //(ATON_INT_NR <= 32)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  if (__ll_current_aton_ip_owner != NULL)
3400a4a4:	4c38      	ldr	r4, [pc, #224]	@ (3400a588 <NPU0_IRQHandler+0xe8>)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
3400a4a6:	689d      	ldr	r5, [r3, #8]
  if (__ll_current_aton_ip_owner != NULL)
3400a4a8:	6823      	ldr	r3, [r4, #0]
3400a4aa:	b343      	cbz	r3, 3400a4fe <NPU0_IRQHandler+0x5e>
  {
    LL_ATON_ASSERT(__ll_current_aton_ip_owner->exec_state.current_epoch_block != NULL);
3400a4ac:	6823      	ldr	r3, [r4, #0]
3400a4ae:	685b      	ldr	r3, [r3, #4]
3400a4b0:	b933      	cbnz	r3, 3400a4c0 <NPU0_IRQHandler+0x20>
3400a4b2:	f240 31ba 	movw	r1, #954	@ 0x3ba
3400a4b6:	4b35      	ldr	r3, [pc, #212]	@ (3400a58c <NPU0_IRQHandler+0xec>)
3400a4b8:	4a35      	ldr	r2, [pc, #212]	@ (3400a590 <NPU0_IRQHandler+0xf0>)
    }
    else // epoch blob handling based on epoch controller
    {
#if defined(ATON_EPOCHCTRL_NUM)
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3400a4ba:	4836      	ldr	r0, [pc, #216]	@ (3400a594 <NPU0_IRQHandler+0xf4>)
3400a4bc:	f002 fe18 	bl	3400d0f0 <__assert_func>
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
3400a4c0:	6823      	ldr	r3, [r4, #0]
                                    .current_epoch_block)) // standard epoch block handling based on streaming engines
3400a4c2:	685b      	ldr	r3, [r3, #4]
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
3400a4c4:	8a1b      	ldrh	r3, [r3, #16]
3400a4c6:	075b      	lsls	r3, r3, #29
3400a4c8:	d40c      	bmi.n	3400a4e4 <NPU0_IRQHandler+0x44>
      __LL_ATON_RT_IrqErr(
3400a4ca:	f425 707f 	bic.w	r0, r5, #1020	@ 0x3fc
3400a4ce:	f020 0003 	bic.w	r0, r0, #3
#endif                                      // !ATON_EPOCHCTRL_NUM
    }
  }
  else // `__ll_current_aton_ip_owner == NULL`
  {
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
3400a4d2:	f7ff ff59 	bl	3400a388 <__LL_ATON_RT_IrqErr>
#else  // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3400a4d6:	6823      	ldr	r3, [r4, #0]
3400a4d8:	b99b      	cbnz	r3, 3400a502 <NPU0_IRQHandler+0x62>
3400a4da:	f240 31db 	movw	r1, #987	@ 0x3db
3400a4de:	4b2e      	ldr	r3, [pc, #184]	@ (3400a598 <NPU0_IRQHandler+0xf8>)
3400a4e0:	4a2b      	ldr	r2, [pc, #172]	@ (3400a590 <NPU0_IRQHandler+0xf0>)
3400a4e2:	e7ea      	b.n	3400a4ba <NPU0_IRQHandler+0x1a>
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
3400a4e4:	6823      	ldr	r3, [r4, #0]
3400a4e6:	6858      	ldr	r0, [r3, #4]
3400a4e8:	f7ff ff38 	bl	3400a35c <EpochBlock_EpochControllerUnit>
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3400a4ec:	b120      	cbz	r0, 3400a4f8 <NPU0_IRQHandler+0x58>
3400a4ee:	f240 31c7 	movw	r1, #967	@ 0x3c7
3400a4f2:	4b2a      	ldr	r3, [pc, #168]	@ (3400a59c <NPU0_IRQHandler+0xfc>)
3400a4f4:	4a26      	ldr	r2, [pc, #152]	@ (3400a590 <NPU0_IRQHandler+0xf0>)
3400a4f6:	e7e0      	b.n	3400a4ba <NPU0_IRQHandler+0x1a>
      __LL_ATON_RT_IrqErr(
3400a4f8:	f025 5080 	bic.w	r0, r5, #268435456	@ 0x10000000
3400a4fc:	e7e9      	b.n	3400a4d2 <NPU0_IRQHandler+0x32>
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
3400a4fe:	4628      	mov	r0, r5
3400a500:	e7e7      	b.n	3400a4d2 <NPU0_IRQHandler+0x32>

  if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state.current_epoch_block))
3400a502:	6823      	ldr	r3, [r4, #0]
3400a504:	685b      	ldr	r3, [r3, #4]
3400a506:	8a1b      	ldrh	r3, [r3, #16]
3400a508:	f013 0304 	ands.w	r3, r3, #4
3400a50c:	d123      	bne.n	3400a556 <NPU0_IRQHandler+0xb6>
      __ll_current_aton_ip_owner->exec_state.current_epoch_block
3400a50e:	6822      	ldr	r2, [r4, #0]
3400a510:	6852      	ldr	r2, [r2, #4]
  wait_irqs =
3400a512:	68d2      	ldr	r2, [r2, #12]
  if (wait_irqs)
3400a514:	402a      	ands	r2, r5
3400a516:	d017      	beq.n	3400a548 <NPU0_IRQHandler+0xa8>
        _tmp_triggered_events |= (1 << i);
3400a518:	f04f 0c01 	mov.w	ip, #1
3400a51c:	200a      	movs	r0, #10
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3400a51e:	6821      	ldr	r1, [r4, #0]
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
3400a520:	4e1f      	ldr	r6, [pc, #124]	@ (3400a5a0 <NPU0_IRQHandler+0x100>)
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3400a522:	69c9      	ldr	r1, [r1, #28]
      if ((wait_irqs >> i) & 1)
3400a524:	fa22 f703 	lsr.w	r7, r2, r3
3400a528:	07ff      	lsls	r7, r7, #31
3400a52a:	d507      	bpl.n	3400a53c <NPU0_IRQHandler+0x9c>
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
3400a52c:	031f      	lsls	r7, r3, #12
3400a52e:	f857 e006 	ldr.w	lr, [r7, r6]
        ATON_STRENG_IRQ_SET(
3400a532:	f847 e006 	str.w	lr, [r7, r6]
        _tmp_triggered_events |= (1 << i);
3400a536:	fa0c f703 	lsl.w	r7, ip, r3
3400a53a:	4339      	orrs	r1, r7
    for (i = 0; i < ATON_STRENG_NUM; i++)
3400a53c:	3801      	subs	r0, #1
3400a53e:	f103 0301 	add.w	r3, r3, #1
3400a542:	d1ef      	bne.n	3400a524 <NPU0_IRQHandler+0x84>
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3400a544:	6823      	ldr	r3, [r4, #0]
3400a546:	61d9      	str	r1, [r3, #28]
  __ASM volatile ("dsb 0xF":::"memory");
3400a548:	f3bf 8f4f 	dsb	sy
   */
#if (ATON_INT_NR > 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs_l);
  ATON_INTCTRL_INTCLR_H_SET(0, irqs_h);
#else  //(ATON_INT_NR <= 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs);
3400a54c:	4b0d      	ldr	r3, [pc, #52]	@ (3400a584 <NPU0_IRQHandler+0xe4>)
3400a54e:	611d      	str	r5, [r3, #16]
3400a550:	f3bf 8f4f 	dsb	sy
  LL_ATON_OSAL_SIGNAL_EVENT();

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  return;
}
3400a554:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
3400a556:	6823      	ldr	r3, [r4, #0]
3400a558:	6858      	ldr	r0, [r3, #4]
3400a55a:	f7ff feff 	bl	3400a35c <EpochBlock_EpochControllerUnit>
  LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3400a55e:	b120      	cbz	r0, 3400a56a <NPU0_IRQHandler+0xca>
3400a560:	f240 319a 	movw	r1, #922	@ 0x39a
3400a564:	4b0d      	ldr	r3, [pc, #52]	@ (3400a59c <NPU0_IRQHandler+0xfc>)
3400a566:	4a0f      	ldr	r2, [pc, #60]	@ (3400a5a4 <NPU0_IRQHandler+0x104>)
3400a568:	e7a7      	b.n	3400a4ba <NPU0_IRQHandler+0x1a>
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ecId))
3400a56a:	00eb      	lsls	r3, r5, #3
3400a56c:	d5ec      	bpl.n	3400a548 <NPU0_IRQHandler+0xa8>
    uint32_t ecIrqs = ATON_EPOCHCTRL_IRQ_GET(ecId);
3400a56e:	4b0e      	ldr	r3, [pc, #56]	@ (3400a5a8 <NPU0_IRQHandler+0x108>)
3400a570:	68da      	ldr	r2, [r3, #12]
    ATON_EPOCHCTRL_IRQ_SET(ecId, ecIrqs);
3400a572:	60da      	str	r2, [r3, #12]
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3400a574:	6823      	ldr	r3, [r4, #0]
3400a576:	69db      	ldr	r3, [r3, #28]
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3400a578:	6822      	ldr	r2, [r4, #0]
    _tmp_triggered_events |= (1 << ecId);
3400a57a:	f043 0301 	orr.w	r3, r3, #1
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3400a57e:	61d3      	str	r3, [r2, #28]
3400a580:	e7e2      	b.n	3400a548 <NPU0_IRQHandler+0xa8>
3400a582:	bf00      	nop
3400a584:	580e1000 	.word	0x580e1000
3400a588:	340cfbb0 	.word	0x340cfbb0
3400a58c:	34010710 	.word	0x34010710
3400a590:	34011101 	.word	0x34011101
3400a594:	34010484 	.word	0x34010484
3400a598:	340103fe 	.word	0x340103fe
3400a59c:	3401047b 	.word	0x3401047b
3400a5a0:	580e503c 	.word	0x580e503c
3400a5a4:	340110d3 	.word	0x340110d3
3400a5a8:	580fe000 	.word	0x580fe000

3400a5ac <ISP_Algo_BadPixel_Init>:
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Init(void *hIsp, void *pAlgo)
{
  (void)hIsp; /* unused */

  ((ISP_AlgoTypeDef *)pAlgo)->state = ISP_ALGO_STATE_INIT;
3400a5ac:	2000      	movs	r0, #0
3400a5ae:	7048      	strb	r0, [r1, #1]

  return ISP_OK;
}
3400a5b0:	4770      	bx	lr

3400a5b2 <ISP_Algo_BadPixel_DeInit>:
{
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  return ISP_OK;
}
3400a5b2:	2000      	movs	r0, #0
3400a5b4:	4770      	bx	lr

3400a5b6 <ISP_Algo_AEC_StatCb>:
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_StatCb(ISP_AlgoTypeDef *pAlgo)
{
  /* Update State */
  pAlgo->state = ISP_ALGO_STATE_STAT_READY;
3400a5b6:	2303      	movs	r3, #3
3400a5b8:	7043      	strb	r3, [r0, #1]

  return ISP_OK;
}
3400a5ba:	2000      	movs	r0, #0
3400a5bc:	4770      	bx	lr

3400a5be <ISP_Algo_AWB_StatCb>:
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_StatCb(ISP_AlgoTypeDef *pAlgo)
{
  /* Update State */
  if (pAlgo->state != ISP_ALGO_STATE_INIT)
3400a5be:	7843      	ldrb	r3, [r0, #1]
3400a5c0:	b10b      	cbz	r3, 3400a5c6 <ISP_Algo_AWB_StatCb+0x8>
  {
    pAlgo->state = ISP_ALGO_STATE_STAT_READY;
3400a5c2:	2303      	movs	r3, #3
3400a5c4:	7043      	strb	r3, [r0, #1]
  }

  return ISP_OK;
}
3400a5c6:	2000      	movs	r0, #0
3400a5c8:	4770      	bx	lr
	...

3400a5cc <ISP_Algo_BadPixel_Process>:
{
3400a5cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400a5ce:	4604      	mov	r4, r0
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3400a5d0:	f001 fb20 	bl	3400bc14 <ISP_SVC_IQParam_Get>
  if (IQParamConfig->badPixelAlgo.enable == false)
3400a5d4:	f890 3054 	ldrb.w	r3, [r0, #84]	@ 0x54
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3400a5d8:	4607      	mov	r7, r0
  if (IQParamConfig->badPixelAlgo.enable == false)
3400a5da:	b913      	cbnz	r3, 3400a5e2 <ISP_Algo_BadPixel_Process+0x16>
    return ISP_OK;
3400a5dc:	2000      	movs	r0, #0
}
3400a5de:	b003      	add	sp, #12
3400a5e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  CurrentFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
3400a5e2:	4620      	mov	r0, r4
3400a5e4:	f001 face 	bl	3400bb84 <ISP_SVC_Misc_GetMainFrameId>
  if (CurrentFrameId == LastFrameId)
3400a5e8:	4b1e      	ldr	r3, [pc, #120]	@ (3400a664 <ISP_Algo_BadPixel_Process+0x98>)
3400a5ea:	681a      	ldr	r2, [r3, #0]
3400a5ec:	4282      	cmp	r2, r0
3400a5ee:	d0f5      	beq.n	3400a5dc <ISP_Algo_BadPixel_Process+0x10>
  if (Step++ >= 0)
3400a5f0:	4d1d      	ldr	r5, [pc, #116]	@ (3400a668 <ISP_Algo_BadPixel_Process+0x9c>)
  LastFrameId = CurrentFrameId;
3400a5f2:	6018      	str	r0, [r3, #0]
  if (Step++ >= 0)
3400a5f4:	f995 3000 	ldrsb.w	r3, [r5]
3400a5f8:	1c5a      	adds	r2, r3, #1
3400a5fa:	2b00      	cmp	r3, #0
3400a5fc:	702a      	strb	r2, [r5, #0]
3400a5fe:	db0a      	blt.n	3400a616 <ISP_Algo_BadPixel_Process+0x4a>
    ret  = ISP_SVC_ISP_GetBadPixel(hIsp, &BadPixelConfig);
3400a600:	4669      	mov	r1, sp
3400a602:	4620      	mov	r0, r4
3400a604:	f001 f849 	bl	3400b69a <ISP_SVC_ISP_GetBadPixel>
    if (ret != ISP_OK)
3400a608:	2800      	cmp	r0, #0
3400a60a:	d1e8      	bne.n	3400a5de <ISP_Algo_BadPixel_Process+0x12>
    BadPixelCount += BadPixelConfig.count;
3400a60c:	4a17      	ldr	r2, [pc, #92]	@ (3400a66c <ISP_Algo_BadPixel_Process+0xa0>)
3400a60e:	9b01      	ldr	r3, [sp, #4]
3400a610:	6811      	ldr	r1, [r2, #0]
3400a612:	440b      	add	r3, r1
3400a614:	6013      	str	r3, [r2, #0]
  if (Step == 10)
3400a616:	f995 2000 	ldrsb.w	r2, [r5]
3400a61a:	2a0a      	cmp	r2, #10
3400a61c:	d1de      	bne.n	3400a5dc <ISP_Algo_BadPixel_Process+0x10>
    BadPixelCount /= 10;
3400a61e:	4e13      	ldr	r6, [pc, #76]	@ (3400a66c <ISP_Algo_BadPixel_Process+0xa0>)
3400a620:	6833      	ldr	r3, [r6, #0]
3400a622:	fbb3 f3f2 	udiv	r3, r3, r2
    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
3400a626:	6dba      	ldr	r2, [r7, #88]	@ 0x58
    BadPixelCount /= 10;
3400a628:	6033      	str	r3, [r6, #0]
    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
3400a62a:	4293      	cmp	r3, r2
3400a62c:	d912      	bls.n	3400a654 <ISP_Algo_BadPixel_Process+0x88>
3400a62e:	f89d 3001 	ldrb.w	r3, [sp, #1]
3400a632:	b113      	cbz	r3, 3400a63a <ISP_Algo_BadPixel_Process+0x6e>
      BadPixelConfig.strength--;
3400a634:	3b01      	subs	r3, #1
      BadPixelConfig.strength++;
3400a636:	f88d 3001 	strb.w	r3, [sp, #1]
    BadPixelConfig.enable = 1;
3400a63a:	2301      	movs	r3, #1
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
3400a63c:	4669      	mov	r1, sp
3400a63e:	4620      	mov	r0, r4
    BadPixelConfig.enable = 1;
3400a640:	f88d 3000 	strb.w	r3, [sp]
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
3400a644:	f001 f80e 	bl	3400b664 <ISP_SVC_ISP_SetBadPixel>
    if (ret != ISP_OK)
3400a648:	2800      	cmp	r0, #0
3400a64a:	d1c8      	bne.n	3400a5de <ISP_Algo_BadPixel_Process+0x12>
    Step = -1;
3400a64c:	23ff      	movs	r3, #255	@ 0xff
    BadPixelCount = 0;
3400a64e:	6030      	str	r0, [r6, #0]
    Step = -1;
3400a650:	702b      	strb	r3, [r5, #0]
    BadPixelCount = 0;
3400a652:	e7c4      	b.n	3400a5de <ISP_Algo_BadPixel_Process+0x12>
    else if ((BadPixelCount < IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength < ISP_BADPIXEL_STRENGTH_MAX - 1))
3400a654:	d2f1      	bcs.n	3400a63a <ISP_Algo_BadPixel_Process+0x6e>
3400a656:	f89d 3001 	ldrb.w	r3, [sp, #1]
3400a65a:	2b05      	cmp	r3, #5
3400a65c:	d8ed      	bhi.n	3400a63a <ISP_Algo_BadPixel_Process+0x6e>
      BadPixelConfig.strength++;
3400a65e:	3301      	adds	r3, #1
3400a660:	e7e9      	b.n	3400a636 <ISP_Algo_BadPixel_Process+0x6a>
3400a662:	bf00      	nop
3400a664:	340cfe44 	.word	0x340cfe44
3400a668:	340cfe40 	.word	0x340cfe40
3400a66c:	340cfe3c 	.word	0x340cfe3c

3400a670 <ISP_Algo_AEC_DeInit>:
{
3400a670:	b508      	push	{r3, lr}
  if (pIspAEprocess != NULL)
3400a672:	4b03      	ldr	r3, [pc, #12]	@ (3400a680 <ISP_Algo_AEC_DeInit+0x10>)
3400a674:	6818      	ldr	r0, [r3, #0]
3400a676:	b108      	cbz	r0, 3400a67c <ISP_Algo_AEC_DeInit+0xc>
    evision_api_st_ae_delete(pIspAEprocess);
3400a678:	f7f6 f8a4 	bl	340007c4 <evision_api_st_ae_delete>
}
3400a67c:	2000      	movs	r0, #0
3400a67e:	bd08      	pop	{r3, pc}
3400a680:	340cfe64 	.word	0x340cfe64

3400a684 <ISP_Algo_AEC_Init>:
{
3400a684:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400a686:	4604      	mov	r4, r0
3400a688:	460e      	mov	r6, r1
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3400a68a:	f001 fac3 	bl	3400bc14 <ISP_SVC_IQParam_Get>
  if (IQParamConfig->sensorDelay.delay == 0)
3400a68e:	f890 3252 	ldrb.w	r3, [r0, #594]	@ 0x252
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3400a692:	4605      	mov	r5, r0
  if (IQParamConfig->sensorDelay.delay == 0)
3400a694:	b913      	cbnz	r3, 3400a69c <ISP_Algo_AEC_Init+0x18>
    IQParamConfig->sensorDelay.delay = 1;
3400a696:	2301      	movs	r3, #1
3400a698:	f880 3252 	strb.w	r3, [r0, #594]	@ 0x252
  pIspAEprocess = evision_api_st_ae_new(log_cb);
3400a69c:	4819      	ldr	r0, [pc, #100]	@ (3400a704 <ISP_Algo_AEC_Init+0x80>)
3400a69e:	f7f6 f877 	bl	34000790 <evision_api_st_ae_new>
3400a6a2:	4f19      	ldr	r7, [pc, #100]	@ (3400a708 <ISP_Algo_AEC_Init+0x84>)
3400a6a4:	6038      	str	r0, [r7, #0]
  if (pIspAEprocess == NULL)
3400a6a6:	b130      	cbz	r0, 3400a6b6 <ISP_Algo_AEC_Init+0x32>
  e_ret = evision_api_st_ae_init(pIspAEprocess);
3400a6a8:	f7f6 f8c6 	bl	34000838 <evision_api_st_ae_init>
  if (e_ret != EVISION_RET_SUCCESS)
3400a6ac:	2801      	cmp	r0, #1
3400a6ae:	d004      	beq.n	3400a6ba <ISP_Algo_AEC_Init+0x36>
    evision_api_st_ae_delete(pIspAEprocess);
3400a6b0:	6838      	ldr	r0, [r7, #0]
3400a6b2:	f7f6 f887 	bl	340007c4 <evision_api_st_ae_delete>
    return ISP_ERR_ALGO;
3400a6b6:	20be      	movs	r0, #190	@ 0xbe
3400a6b8:	e012      	b.n	3400a6e0 <ISP_Algo_AEC_Init+0x5c>
  pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
3400a6ba:	683b      	ldr	r3, [r7, #0]
3400a6bc:	6eea      	ldr	r2, [r5, #108]	@ 0x6c
  pIspAEprocess->hyper_params.exposure_min = pIsp_handle->sensorInfo.exposure_min;
3400a6be:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
  pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
3400a6c2:	611a      	str	r2, [r3, #16]
  pIspAEprocess->hyper_params.exposure_max = pIsp_handle->sensorInfo.exposure_max;
3400a6c4:	f8d4 2084 	ldr.w	r2, [r4, #132]	@ 0x84
  pIspAEprocess->hyper_params.gain_max = pIsp_handle->sensorInfo.gain_max;
3400a6c8:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
  pIspAEprocess->hyper_params.exposure_max = pIsp_handle->sensorInfo.exposure_max;
3400a6ca:	645a      	str	r2, [r3, #68]	@ 0x44
  pIspAEprocess->hyper_params.gain_min = pIsp_handle->sensorInfo.gain_min;
3400a6cc:	6fa2      	ldr	r2, [r4, #120]	@ 0x78
  pIspAEprocess->hyper_params.exposure_min = pIsp_handle->sensorInfo.exposure_min;
3400a6ce:	6419      	str	r1, [r3, #64]	@ 0x40
  pIspAEprocess->hyper_params.gain_min = pIsp_handle->sensorInfo.gain_min;
3400a6d0:	649a      	str	r2, [r3, #72]	@ 0x48
  pIspAEprocess->hyper_params.gain_max = pIsp_handle->sensorInfo.gain_max;
3400a6d2:	64d8      	str	r0, [r3, #76]	@ 0x4c
  if (IQParamConfig->AECAlgo.enable == true)
3400a6d4:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
3400a6d8:	2b01      	cmp	r3, #1
3400a6da:	d003      	beq.n	3400a6e4 <ISP_Algo_AEC_Init+0x60>
  algo->state = ISP_ALGO_STATE_INIT;
3400a6dc:	2000      	movs	r0, #0
3400a6de:	7070      	strb	r0, [r6, #1]
}
3400a6e0:	b003      	add	sp, #12
3400a6e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    gainConfig.gain = pIsp_handle->sensorInfo.gain_min;
3400a6e4:	e9cd 1200 	strd	r1, r2, [sp]
    if ((ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig) != ISP_OK) || (ISP_SVC_Sensor_SetGain(hIsp, &gainConfig)!= ISP_OK))
3400a6e8:	4620      	mov	r0, r4
3400a6ea:	4669      	mov	r1, sp
3400a6ec:	f001 fa16 	bl	3400bb1c <ISP_SVC_Sensor_SetExposure>
3400a6f0:	2800      	cmp	r0, #0
3400a6f2:	d1e0      	bne.n	3400a6b6 <ISP_Algo_AEC_Init+0x32>
3400a6f4:	4620      	mov	r0, r4
3400a6f6:	a901      	add	r1, sp, #4
3400a6f8:	f001 f9ec 	bl	3400bad4 <ISP_SVC_Sensor_SetGain>
3400a6fc:	2800      	cmp	r0, #0
3400a6fe:	d0ed      	beq.n	3400a6dc <ISP_Algo_AEC_Init+0x58>
3400a700:	e7d9      	b.n	3400a6b6 <ISP_Algo_AEC_Init+0x32>
3400a702:	bf00      	nop
3400a704:	3400a70d 	.word	0x3400a70d
3400a708:	340cfe64 	.word	0x340cfe64

3400a70c <log_cb>:
{
3400a70c:	b508      	push	{r3, lr}
3400a70e:	4601      	mov	r1, r0
  printf("%s", msg);
3400a710:	4803      	ldr	r0, [pc, #12]	@ (3400a720 <log_cb+0x14>)
3400a712:	f002 ff67 	bl	3400d5e4 <iprintf>
}
3400a716:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("\r\n");
3400a71a:	4802      	ldr	r0, [pc, #8]	@ (3400a724 <log_cb+0x18>)
3400a71c:	f002 bfca 	b.w	3400d6b4 <puts>
3400a720:	34010a1e 	.word	0x34010a1e
3400a724:	34010916 	.word	0x34010916

3400a728 <ISP_Algo_AEC_Process>:
{
3400a728:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400a72c:	b086      	sub	sp, #24
3400a72e:	4605      	mov	r5, r0
3400a730:	460c      	mov	r4, r1
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3400a732:	f001 fa6f 	bl	3400bc14 <ISP_SVC_IQParam_Get>
3400a736:	4606      	mov	r6, r0
  if (IQParamConfig->AECAlgo.enable == false)
3400a738:	f890 0068 	ldrb.w	r0, [r0, #104]	@ 0x68
3400a73c:	b128      	cbz	r0, 3400a74a <ISP_Algo_AEC_Process+0x22>
  switch(algo->state)
3400a73e:	7863      	ldrb	r3, [r4, #1]
3400a740:	2b01      	cmp	r3, #1
3400a742:	d905      	bls.n	3400a750 <ISP_Algo_AEC_Process+0x28>
3400a744:	2b03      	cmp	r3, #3
3400a746:	d014      	beq.n	3400a772 <ISP_Algo_AEC_Process+0x4a>
    return ISP_OK;
3400a748:	2000      	movs	r0, #0
}
3400a74a:	b006      	add	sp, #24
3400a74c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400a750:	f896 3252 	ldrb.w	r3, [r6, #594]	@ 0x252
3400a754:	2602      	movs	r6, #2
3400a756:	9302      	str	r3, [sp, #8]
3400a758:	2301      	movs	r3, #1
3400a75a:	4622      	mov	r2, r4
3400a75c:	e9cd 6300 	strd	r6, r3, [sp]
3400a760:	4628      	mov	r0, r5
3400a762:	4b28      	ldr	r3, [pc, #160]	@ (3400a804 <ISP_Algo_AEC_Process+0xdc>)
3400a764:	4928      	ldr	r1, [pc, #160]	@ (3400a808 <ISP_Algo_AEC_Process+0xe0>)
3400a766:	f001 fc99 	bl	3400c09c <ISP_SVC_Stats_GetNext>
    if (ret != ISP_OK)
3400a76a:	2800      	cmp	r0, #0
3400a76c:	d1ed      	bne.n	3400a74a <ISP_Algo_AEC_Process+0x22>
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3400a76e:	7066      	strb	r6, [r4, #1]
    break;
3400a770:	e7eb      	b.n	3400a74a <ISP_Algo_AEC_Process+0x22>
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
3400a772:	4f26      	ldr	r7, [pc, #152]	@ (3400a80c <ISP_Algo_AEC_Process+0xe4>)
3400a774:	6ef2      	ldr	r2, [r6, #108]	@ 0x6c
3400a776:	683b      	ldr	r3, [r7, #0]
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
3400a778:	4628      	mov	r0, r5
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
3400a77a:	611a      	str	r2, [r3, #16]
    avgL = stats.down.averageL;
3400a77c:	4b21      	ldr	r3, [pc, #132]	@ (3400a804 <ISP_Algo_AEC_Process+0xdc>)
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
3400a77e:	a904      	add	r1, sp, #16
    avgL = stats.down.averageL;
3400a780:	f893 8037 	ldrb.w	r8, [r3, #55]	@ 0x37
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
3400a784:	f001 f9bc 	bl	3400bb00 <ISP_SVC_Sensor_GetGain>
    if (ret != ISP_OK)
3400a788:	2800      	cmp	r0, #0
3400a78a:	d1de      	bne.n	3400a74a <ISP_Algo_AEC_Process+0x22>
    ret = ISP_SVC_Sensor_GetExposure(hIsp, &exposureConfig);
3400a78c:	4628      	mov	r0, r5
3400a78e:	a905      	add	r1, sp, #20
3400a790:	f001 f9da 	bl	3400bb48 <ISP_SVC_Sensor_GetExposure>
    if (ret != ISP_OK)
3400a794:	2800      	cmp	r0, #0
3400a796:	d1d8      	bne.n	3400a74a <ISP_Algo_AEC_Process+0x22>
    Meta.averageL = avgL;
3400a798:	4b1d      	ldr	r3, [pc, #116]	@ (3400a810 <ISP_Algo_AEC_Process+0xe8>)
    Meta.exposureTarget = IQParamConfig->AECAlgo.exposureTarget;
3400a79a:	6ef2      	ldr	r2, [r6, #108]	@ 0x6c
    Meta.averageL = avgL;
3400a79c:	f883 8001 	strb.w	r8, [r3, #1]
    Meta.exposureTarget = IQParamConfig->AECAlgo.exposureTarget;
3400a7a0:	605a      	str	r2, [r3, #4]
    e_ret = evision_api_st_ae_process(pIspAEprocess, gainConfig.gain, exposureConfig.exposure, avgL);
3400a7a2:	6838      	ldr	r0, [r7, #0]
3400a7a4:	4643      	mov	r3, r8
3400a7a6:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
3400a7aa:	f7f6 f850 	bl	3400084e <evision_api_st_ae_process>
    if (e_ret == EVISION_RET_SUCCESS)
3400a7ae:	2801      	cmp	r0, #1
3400a7b0:	d00d      	beq.n	3400a7ce <ISP_Algo_AEC_Process+0xa6>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400a7b2:	f896 3252 	ldrb.w	r3, [r6, #594]	@ 0x252
3400a7b6:	2602      	movs	r6, #2
3400a7b8:	9302      	str	r3, [sp, #8]
3400a7ba:	2301      	movs	r3, #1
3400a7bc:	4622      	mov	r2, r4
3400a7be:	e9cd 6300 	strd	r6, r3, [sp]
3400a7c2:	4628      	mov	r0, r5
3400a7c4:	4b0f      	ldr	r3, [pc, #60]	@ (3400a804 <ISP_Algo_AEC_Process+0xdc>)
3400a7c6:	4910      	ldr	r1, [pc, #64]	@ (3400a808 <ISP_Algo_AEC_Process+0xe0>)
3400a7c8:	f001 fc68 	bl	3400c09c <ISP_SVC_Stats_GetNext>
3400a7cc:	e7cf      	b.n	3400a76e <ISP_Algo_AEC_Process+0x46>
      if (gainConfig.gain != pIspAEprocess->new_gain)
3400a7ce:	683b      	ldr	r3, [r7, #0]
3400a7d0:	9a04      	ldr	r2, [sp, #16]
3400a7d2:	689b      	ldr	r3, [r3, #8]
3400a7d4:	429a      	cmp	r2, r3
3400a7d6:	d10c      	bne.n	3400a7f2 <ISP_Algo_AEC_Process+0xca>
      if (exposureConfig.exposure != pIspAEprocess->new_exposure)
3400a7d8:	683b      	ldr	r3, [r7, #0]
3400a7da:	9a05      	ldr	r2, [sp, #20]
3400a7dc:	685b      	ldr	r3, [r3, #4]
3400a7de:	429a      	cmp	r2, r3
3400a7e0:	d0e7      	beq.n	3400a7b2 <ISP_Algo_AEC_Process+0x8a>
        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
3400a7e2:	4628      	mov	r0, r5
3400a7e4:	a905      	add	r1, sp, #20
        exposureConfig.exposure = pIspAEprocess->new_exposure;
3400a7e6:	9305      	str	r3, [sp, #20]
        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
3400a7e8:	f001 f998 	bl	3400bb1c <ISP_SVC_Sensor_SetExposure>
        if (ret != ISP_OK)
3400a7ec:	2800      	cmp	r0, #0
3400a7ee:	d0e0      	beq.n	3400a7b2 <ISP_Algo_AEC_Process+0x8a>
3400a7f0:	e7ab      	b.n	3400a74a <ISP_Algo_AEC_Process+0x22>
        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
3400a7f2:	4628      	mov	r0, r5
3400a7f4:	a904      	add	r1, sp, #16
        gainConfig.gain = pIspAEprocess->new_gain;
3400a7f6:	9304      	str	r3, [sp, #16]
        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
3400a7f8:	f001 f96c 	bl	3400bad4 <ISP_SVC_Sensor_SetGain>
        if (ret != ISP_OK)
3400a7fc:	2800      	cmp	r0, #0
3400a7fe:	d0eb      	beq.n	3400a7d8 <ISP_Algo_AEC_Process+0xb0>
3400a800:	e7a3      	b.n	3400a74a <ISP_Algo_AEC_Process+0x22>
3400a802:	bf00      	nop
3400a804:	340cfdc4 	.word	0x340cfdc4
3400a808:	3400a5b7 	.word	0x3400a5b7
3400a80c:	340cfe64 	.word	0x340cfe64
3400a810:	340cfe48 	.word	0x340cfe48

3400a814 <ISP_Algo_AWB_Init>:
{
3400a814:	b510      	push	{r4, lr}
  pIspAWBestimator = evision_api_awb_new(log_cb);
3400a816:	4806      	ldr	r0, [pc, #24]	@ (3400a830 <ISP_Algo_AWB_Init+0x1c>)
{
3400a818:	460c      	mov	r4, r1
  pIspAWBestimator = evision_api_awb_new(log_cb);
3400a81a:	f7f6 fb83 	bl	34000f24 <evision_api_awb_new>
3400a81e:	4b05      	ldr	r3, [pc, #20]	@ (3400a834 <ISP_Algo_AWB_Init+0x20>)
3400a820:	6018      	str	r0, [r3, #0]
  if (pIspAWBestimator == NULL)
3400a822:	b110      	cbz	r0, 3400a82a <ISP_Algo_AWB_Init+0x16>
  algo->state = ISP_ALGO_STATE_INIT;
3400a824:	2000      	movs	r0, #0
3400a826:	7060      	strb	r0, [r4, #1]
}
3400a828:	bd10      	pop	{r4, pc}
    return ISP_ERR_ALGO;
3400a82a:	20be      	movs	r0, #190	@ 0xbe
3400a82c:	e7fc      	b.n	3400a828 <ISP_Algo_AWB_Init+0x14>
3400a82e:	bf00      	nop
3400a830:	3400a70d 	.word	0x3400a70d
3400a834:	340cfe60 	.word	0x340cfe60

3400a838 <ISP_Algo_AWB_DeInit>:
{
3400a838:	b508      	push	{r3, lr}
  if (pIspAWBestimator != NULL)
3400a83a:	4b03      	ldr	r3, [pc, #12]	@ (3400a848 <ISP_Algo_AWB_DeInit+0x10>)
3400a83c:	6818      	ldr	r0, [r3, #0]
3400a83e:	b108      	cbz	r0, 3400a844 <ISP_Algo_AWB_DeInit+0xc>
    evision_api_awb_delete(pIspAWBestimator);
3400a840:	f7f6 fb8c 	bl	34000f5c <evision_api_awb_delete>
}
3400a844:	2000      	movs	r0, #0
3400a846:	bd08      	pop	{r3, pc}
3400a848:	340cfe60 	.word	0x340cfe60
3400a84c:	00000000 	.word	0x00000000

3400a850 <ISP_Algo_ApplyGammaInverse>:
{
3400a850:	b508      	push	{r3, lr}
3400a852:	ed2d 8b02 	vpush	{d8}
3400a856:	ee08 1a10 	vmov	s16, r1
  if (ISP_SVC_Misc_IsGammaEnabled(hIsp, 1 /*main pipe*/) != 0) {
3400a85a:	2101      	movs	r1, #1
3400a85c:	f001 f99c 	bl	3400bb98 <ISP_SVC_Misc_IsGammaEnabled>
3400a860:	b190      	cbz	r0, 3400a888 <ISP_Algo_ApplyGammaInverse+0x38>
    out = 255 * pow((float)comp / 255, 1.0 / 2.2);
3400a862:	eddf 7a0f 	vldr	s15, [pc, #60]	@ 3400a8a0 <ISP_Algo_ApplyGammaInverse+0x50>
3400a866:	eeb8 8a48 	vcvt.f32.u32	s16, s16
3400a86a:	ee88 0a27 	vdiv.f32	s0, s16, s15
3400a86e:	ed9f 1b08 	vldr	d1, [pc, #32]	@ 3400a890 <ISP_Algo_ApplyGammaInverse+0x40>
3400a872:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
3400a876:	f003 ff4f 	bl	3400e718 <pow>
3400a87a:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 3400a898 <ISP_Algo_ApplyGammaInverse+0x48>
3400a87e:	ee20 0b07 	vmul.f64	d0, d0, d7
}
3400a882:	ecbd 8b02 	vpop	{d8}
3400a886:	bd08      	pop	{r3, pc}
    out = (double) comp;
3400a888:	eeb8 0b48 	vcvt.f64.u32	d0, s16
  return out;
3400a88c:	e7f9      	b.n	3400a882 <ISP_Algo_ApplyGammaInverse+0x32>
3400a88e:	bf00      	nop
3400a890:	d1745d17 	.word	0xd1745d17
3400a894:	3fdd1745 	.word	0x3fdd1745
3400a898:	00000000 	.word	0x00000000
3400a89c:	406fe000 	.word	0x406fe000
3400a8a0:	437f0000 	.word	0x437f0000

3400a8a4 <ISP_Algo_GetUpStat>:
{
3400a8a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
3400a8a8:	b087      	sub	sp, #28
3400a8aa:	460c      	mov	r4, r1
  if ((ISP_SVC_ISP_GetGain(hIsp, &ISPGain) == ISP_OK) && (ISPGain.enable == 1))
3400a8ac:	a902      	add	r1, sp, #8
{
3400a8ae:	4680      	mov	r8, r0
  if ((ISP_SVC_ISP_GetGain(hIsp, &ISPGain) == ISP_OK) && (ISPGain.enable == 1))
3400a8b0:	f000 ffe8 	bl	3400b884 <ISP_SVC_ISP_GetGain>
3400a8b4:	f894 7036 	ldrb.w	r7, [r4, #54]	@ 0x36
3400a8b8:	4606      	mov	r6, r0
3400a8ba:	2800      	cmp	r0, #0
3400a8bc:	d13b      	bne.n	3400a936 <ISP_Algo_GetUpStat+0x92>
3400a8be:	f89d 3008 	ldrb.w	r3, [sp, #8]
3400a8c2:	2b01      	cmp	r3, #1
3400a8c4:	d137      	bne.n	3400a936 <ISP_Algo_GetUpStat+0x92>
    upG = (int64_t) pStats->down.averageG * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainG;
3400a8c6:	4d1e      	ldr	r5, [pc, #120]	@ (3400a940 <ISP_Algo_GetUpStat+0x9c>)
3400a8c8:	f894 1035 	ldrb.w	r1, [r4, #53]	@ 0x35
3400a8cc:	4603      	mov	r3, r0
3400a8ce:	9a04      	ldr	r2, [sp, #16]
3400a8d0:	fba1 0105 	umull	r0, r1, r1, r5
3400a8d4:	f7f6 fe32 	bl	3400153c <__aeabi_ldivmod>
    upB = (int64_t) pStats->down.averageB * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainB;
3400a8d8:	4633      	mov	r3, r6
    upG = (int64_t) pStats->down.averageG * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainG;
3400a8da:	4681      	mov	r9, r0
    upB = (int64_t) pStats->down.averageB * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainB;
3400a8dc:	9a05      	ldr	r2, [sp, #20]
3400a8de:	fba7 0105 	umull	r0, r1, r7, r5
3400a8e2:	f7f6 fe2b 	bl	3400153c <__aeabi_ldivmod>
    upR = (int64_t) pStats->down.averageR * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainR;
3400a8e6:	f894 1034 	ldrb.w	r1, [r4, #52]	@ 0x34
    upB = (int64_t) pStats->down.averageB * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainB;
3400a8ea:	4607      	mov	r7, r0
    upR = (int64_t) pStats->down.averageR * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainR;
3400a8ec:	4633      	mov	r3, r6
3400a8ee:	fba1 0105 	umull	r0, r1, r1, r5
3400a8f2:	9a03      	ldr	r2, [sp, #12]
3400a8f4:	f7f6 fe22 	bl	3400153c <__aeabi_ldivmod>
    pStats->up.averageG = (uint32_t) upG;
3400a8f8:	f884 9001 	strb.w	r9, [r4, #1]
    pStats->up.averageR = (uint32_t) upR;
3400a8fc:	7020      	strb	r0, [r4, #0]
    pStats->up.averageB = (uint32_t) upB;
3400a8fe:	70a7      	strb	r7, [r4, #2]
    if ((ISP_SVC_ISP_GetBlackLevel(hIsp, &BlackLevel) == ISP_OK) && (BlackLevel.enable == 1))
3400a900:	4640      	mov	r0, r8
3400a902:	a901      	add	r1, sp, #4
3400a904:	f000 ff07 	bl	3400b716 <ISP_SVC_ISP_GetBlackLevel>
3400a908:	b990      	cbnz	r0, 3400a930 <ISP_Algo_GetUpStat+0x8c>
3400a90a:	f89d 3004 	ldrb.w	r3, [sp, #4]
3400a90e:	2b01      	cmp	r3, #1
3400a910:	d10e      	bne.n	3400a930 <ISP_Algo_GetUpStat+0x8c>
    pStats->up.averageR += BlackLevel.BLCR;
3400a912:	7823      	ldrb	r3, [r4, #0]
3400a914:	f89d 2005 	ldrb.w	r2, [sp, #5]
3400a918:	4413      	add	r3, r2
3400a91a:	7023      	strb	r3, [r4, #0]
    pStats->up.averageG += BlackLevel.BLCG;
3400a91c:	f89d 2006 	ldrb.w	r2, [sp, #6]
3400a920:	7863      	ldrb	r3, [r4, #1]
3400a922:	4413      	add	r3, r2
3400a924:	7063      	strb	r3, [r4, #1]
    pStats->up.averageB += BlackLevel.BLCB;
3400a926:	f89d 2007 	ldrb.w	r2, [sp, #7]
3400a92a:	78a3      	ldrb	r3, [r4, #2]
3400a92c:	4413      	add	r3, r2
3400a92e:	70a3      	strb	r3, [r4, #2]
}
3400a930:	b007      	add	sp, #28
3400a932:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    pStats->up.averageR = pStats->down.averageR;
3400a936:	8ea3      	ldrh	r3, [r4, #52]	@ 0x34
    pStats->up.averageB = pStats->down.averageB;
3400a938:	70a7      	strb	r7, [r4, #2]
    pStats->up.averageR = pStats->down.averageR;
3400a93a:	8023      	strh	r3, [r4, #0]
}
3400a93c:	e7f8      	b.n	3400a930 <ISP_Algo_GetUpStat+0x8c>
3400a93e:	bf00      	nop
3400a940:	05f5e100 	.word	0x05f5e100
3400a944:	00000000 	.word	0x00000000

3400a948 <ISP_Algo_ApplyCConv>:
{
3400a948:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
3400a94c:	b08b      	sub	sp, #44	@ 0x2c
3400a94e:	460e      	mov	r6, r1
  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
3400a950:	4669      	mov	r1, sp
{
3400a952:	4615      	mov	r5, r2
3400a954:	461c      	mov	r4, r3
  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
3400a956:	f001 f867 	bl	3400ba28 <ISP_SVC_ISP_GetColorConv>
3400a95a:	4602      	mov	r2, r0
3400a95c:	2800      	cmp	r0, #0
3400a95e:	f040 8096 	bne.w	3400aa8e <ISP_Algo_ApplyCConv+0x146>
3400a962:	f89d 3000 	ldrb.w	r3, [sp]
3400a966:	2b01      	cmp	r3, #1
3400a968:	f040 8091 	bne.w	3400aa8e <ISP_Algo_ApplyCConv+0x146>
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
3400a96c:	9b01      	ldr	r3, [sp, #4]
3400a96e:	17d9      	asrs	r1, r3, #31
3400a970:	fba3 3706 	umull	r3, r7, r3, r6
3400a974:	fb06 7701 	mla	r7, r6, r1, r7
3400a978:	9902      	ldr	r1, [sp, #8]
3400a97a:	ea4f 7ce1 	mov.w	ip, r1, asr #31
3400a97e:	fba1 1005 	umull	r1, r0, r1, r5
3400a982:	fb05 000c 	mla	r0, r5, ip, r0
3400a986:	185b      	adds	r3, r3, r1
3400a988:	eb47 0700 	adc.w	r7, r7, r0
3400a98c:	9803      	ldr	r0, [sp, #12]
3400a98e:	ea4f 7ce0 	mov.w	ip, r0, asr #31
3400a992:	fba0 0104 	umull	r0, r1, r0, r4
3400a996:	fb04 110c 	mla	r1, r4, ip, r1
3400a99a:	1818      	adds	r0, r3, r0
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
3400a99c:	9b04      	ldr	r3, [sp, #16]
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
3400a99e:	eb41 0107 	adc.w	r1, r1, r7
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
3400a9a2:	17df      	asrs	r7, r3, #31
3400a9a4:	fba3 8306 	umull	r8, r3, r3, r6
3400a9a8:	fb06 3307 	mla	r3, r6, r7, r3
3400a9ac:	9f05      	ldr	r7, [sp, #20]
3400a9ae:	fba7 ce05 	umull	ip, lr, r7, r5
3400a9b2:	ea4f 79e7 	mov.w	r9, r7, asr #31
3400a9b6:	fb05 ee09 	mla	lr, r5, r9, lr
3400a9ba:	eb18 070c 	adds.w	r7, r8, ip
3400a9be:	f8dd c018 	ldr.w	ip, [sp, #24]
3400a9c2:	eb43 030e 	adc.w	r3, r3, lr
3400a9c6:	ea4f 7eec 	mov.w	lr, ip, asr #31
3400a9ca:	fbac c804 	umull	ip, r8, ip, r4
3400a9ce:	fb04 880e 	mla	r8, r4, lr, r8
3400a9d2:	eb17 070c 	adds.w	r7, r7, ip
3400a9d6:	eb48 0803 	adc.w	r8, r8, r3
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
3400a9da:	9b07      	ldr	r3, [sp, #28]
3400a9dc:	ea4f 7ce3 	mov.w	ip, r3, asr #31
3400a9e0:	fba3 e306 	umull	lr, r3, r3, r6
3400a9e4:	fb06 3c0c 	mla	ip, r6, ip, r3
3400a9e8:	9b08      	ldr	r3, [sp, #32]
3400a9ea:	ea4f 79e3 	mov.w	r9, r3, asr #31
3400a9ee:	fba3 3605 	umull	r3, r6, r3, r5
3400a9f2:	fb05 6509 	mla	r5, r5, r9, r6
3400a9f6:	eb1e 0303 	adds.w	r3, lr, r3
3400a9fa:	eb4c 0c05 	adc.w	ip, ip, r5
3400a9fe:	9d09      	ldr	r5, [sp, #36]	@ 0x24
3400aa00:	ea4f 7ee5 	mov.w	lr, r5, asr #31
3400aa04:	fba5 5604 	umull	r5, r6, r5, r4
3400aa08:	fb04 660e 	mla	r6, r4, lr, r6
3400aa0c:	195c      	adds	r4, r3, r5
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
3400aa0e:	f04f 33ff 	mov.w	r3, #4294967295
3400aa12:	4d29      	ldr	r5, [pc, #164]	@ (3400aab8 <ISP_Algo_ApplyCConv+0x170>)
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
3400aa14:	eb46 060c 	adc.w	r6, r6, ip
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
3400aa18:	42a8      	cmp	r0, r5
3400aa1a:	eb71 0303 	sbcs.w	r3, r1, r3
3400aa1e:	db3f      	blt.n	3400aaa0 <ISP_Algo_ApplyCConv+0x158>
    ccR /= ISP_CCM_PRECISION_FACTOR;
3400aa20:	a323      	add	r3, pc, #140	@ (adr r3, 3400aab0 <ISP_Algo_ApplyCConv+0x168>)
3400aa22:	e9d3 2300 	ldrd	r2, r3, [r3]
3400aa26:	f7f6 fd89 	bl	3400153c <__aeabi_ldivmod>
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
3400aa2a:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
3400aa2e:	f171 0100 	sbcs.w	r1, r1, #0
3400aa32:	4681      	mov	r9, r0
3400aa34:	db01      	blt.n	3400aa3a <ISP_Algo_ApplyCConv+0xf2>
3400aa36:	f04f 09ff 	mov.w	r9, #255	@ 0xff
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
3400aa3a:	f04f 33ff 	mov.w	r3, #4294967295
3400aa3e:	42af      	cmp	r7, r5
3400aa40:	eb78 0303 	sbcs.w	r3, r8, r3
3400aa44:	db2e      	blt.n	3400aaa4 <ISP_Algo_ApplyCConv+0x15c>
    ccG /= ISP_CCM_PRECISION_FACTOR;
3400aa46:	a31a      	add	r3, pc, #104	@ (adr r3, 3400aab0 <ISP_Algo_ApplyCConv+0x168>)
3400aa48:	e9d3 2300 	ldrd	r2, r3, [r3]
3400aa4c:	4638      	mov	r0, r7
3400aa4e:	4641      	mov	r1, r8
3400aa50:	f7f6 fd74 	bl	3400153c <__aeabi_ldivmod>
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
3400aa54:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
3400aa58:	f171 0100 	sbcs.w	r1, r1, #0
3400aa5c:	4607      	mov	r7, r0
3400aa5e:	db00      	blt.n	3400aa62 <ISP_Algo_ApplyCConv+0x11a>
3400aa60:	27ff      	movs	r7, #255	@ 0xff
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
3400aa62:	f04f 33ff 	mov.w	r3, #4294967295
3400aa66:	42ac      	cmp	r4, r5
3400aa68:	eb76 0303 	sbcs.w	r3, r6, r3
3400aa6c:	db1c      	blt.n	3400aaa8 <ISP_Algo_ApplyCConv+0x160>
    ccB /= ISP_CCM_PRECISION_FACTOR;
3400aa6e:	a310      	add	r3, pc, #64	@ (adr r3, 3400aab0 <ISP_Algo_ApplyCConv+0x168>)
3400aa70:	e9d3 2300 	ldrd	r2, r3, [r3]
3400aa74:	4620      	mov	r0, r4
3400aa76:	4631      	mov	r1, r6
3400aa78:	f7f6 fd60 	bl	3400153c <__aeabi_ldivmod>
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
3400aa7c:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
3400aa80:	f171 0100 	sbcs.w	r1, r1, #0
3400aa84:	4604      	mov	r4, r0
3400aa86:	db00      	blt.n	3400aa8a <ISP_Algo_ApplyCConv+0x142>
3400aa88:	24ff      	movs	r4, #255	@ 0xff
    *outR = (uint32_t) ccR;
3400aa8a:	464e      	mov	r6, r9
    *outG = (uint32_t) ccG;
3400aa8c:	463d      	mov	r5, r7
    *outR = (uint32_t) ccR;
3400aa8e:	9b12      	ldr	r3, [sp, #72]	@ 0x48
3400aa90:	601e      	str	r6, [r3, #0]
    *outG = (uint32_t) ccG;
3400aa92:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
3400aa94:	601d      	str	r5, [r3, #0]
    *outB = (uint32_t) ccB;
3400aa96:	9b14      	ldr	r3, [sp, #80]	@ 0x50
3400aa98:	601c      	str	r4, [r3, #0]
}
3400aa9a:	b00b      	add	sp, #44	@ 0x2c
3400aa9c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
3400aaa0:	4691      	mov	r9, r2
3400aaa2:	e7ca      	b.n	3400aa3a <ISP_Algo_ApplyCConv+0xf2>
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
3400aaa4:	2700      	movs	r7, #0
3400aaa6:	e7dc      	b.n	3400aa62 <ISP_Algo_ApplyCConv+0x11a>
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
3400aaa8:	2400      	movs	r4, #0
3400aaaa:	e7ee      	b.n	3400aa8a <ISP_Algo_ApplyCConv+0x142>
3400aaac:	f3af 8000 	nop.w
3400aab0:	05f5e100 	.word	0x05f5e100
3400aab4:	00000000 	.word	0x00000000
3400aab8:	fa0a1f01 	.word	0xfa0a1f01
3400aabc:	00000000 	.word	0x00000000

3400aac0 <ISP_Algo_AWB_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Process(void *hIsp, void *pAlgo)
{
3400aac0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400aac4:	ed2d 8b02 	vpush	{d8}
  ISP_ISPGainTypeDef ISPGainConfig;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
  ISP_StatusTypeDef ret_stat, ret = ISP_OK;
  evision_return_t e_ret;
  uint32_t ccAvgR, ccAvgG, ccAvgB, colorTemp, i, j, profId, profNb;
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
3400aac8:	2300      	movs	r3, #0
{
3400aaca:	b0a1      	sub	sp, #132	@ 0x84
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
3400aacc:	e9cd 3309 	strd	r3, r3, [sp, #36]	@ 0x24
3400aad0:	930b      	str	r3, [sp, #44]	@ 0x2c
{
3400aad2:	4680      	mov	r8, r0
3400aad4:	4689      	mov	r9, r1
  double meas[3];
  static uint32_t statsHistory[3][3] = { 0 };
  static uint32_t colorTempHistory[2] = { 0 };
  static uint8_t skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_INIT;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3400aad6:	f001 f89d 	bl	3400bc14 <ISP_SVC_IQParam_Get>

  if (IQParamConfig->AWBAlgo.enable == false)
3400aada:	f890 2070 	ldrb.w	r2, [r0, #112]	@ 0x70
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3400aade:	4606      	mov	r6, r0
  if (IQParamConfig->AWBAlgo.enable == false)
3400aae0:	4b6d      	ldr	r3, [pc, #436]	@ (3400ac98 <ISP_Algo_AWB_Process+0x1d8>)
3400aae2:	b932      	cbnz	r2, 3400aaf2 <ISP_Algo_AWB_Process+0x32>
  {
    enableCurrent = false;
3400aae4:	701a      	strb	r2, [r3, #0]
    return ISP_OK;
3400aae6:	2000      	movs	r0, #0
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
    break;
  }

  return ret;
}
3400aae8:	b021      	add	sp, #132	@ 0x84
3400aaea:	ecbd 8b02 	vpop	{d8}
3400aaee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else if ((enableCurrent == false) || (IQParamConfig->AWBAlgo.enable == ISP_AWB_ENABLE_RECONFIGURE))
3400aaf2:	7819      	ldrb	r1, [r3, #0]
3400aaf4:	b111      	cbz	r1, 3400aafc <ISP_Algo_AWB_Process+0x3c>
3400aaf6:	2aff      	cmp	r2, #255	@ 0xff
3400aaf8:	f040 80b1 	bne.w	3400ac5e <ISP_Algo_AWB_Process+0x19e>
    algo->state = ISP_ALGO_STATE_INIT;
3400aafc:	2200      	movs	r2, #0
3400aafe:	f889 2001 	strb.w	r2, [r9, #1]
    IQParamConfig->AWBAlgo.enable = true;
3400ab02:	2201      	movs	r2, #1
    reconfigureRequest = true;
3400ab04:	4965      	ldr	r1, [pc, #404]	@ (3400ac9c <ISP_Algo_AWB_Process+0x1dc>)
    IQParamConfig->AWBAlgo.enable = true;
3400ab06:	f886 2070 	strb.w	r2, [r6, #112]	@ 0x70
    reconfigureRequest = true;
3400ab0a:	700a      	strb	r2, [r1, #0]
    enableCurrent = true;
3400ab0c:	701a      	strb	r2, [r3, #0]
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3400ab0e:	2400      	movs	r4, #0
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
3400ab10:	ed9f 8a63 	vldr	s16, [pc, #396]	@ 3400aca0 <ISP_Algo_AWB_Process+0x1e0>
3400ab14:	4f63      	ldr	r7, [pc, #396]	@ (3400aca4 <ISP_Algo_AWB_Process+0x1e4>)
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
3400ab16:	f8df a194 	ldr.w	sl, [pc, #404]	@ 3400acac <ISP_Algo_AWB_Process+0x1ec>
3400ab1a:	f506 7588 	add.w	r5, r6, #272	@ 0x110
      colorTemp = IQParamConfig->AWBAlgo.referenceColorTemp[profId];
3400ab1e:	6868      	ldr	r0, [r5, #4]
      if (colorTemp == 0)
3400ab20:	2800      	cmp	r0, #0
3400ab22:	f000 80ac 	beq.w	3400ac7e <ISP_Algo_AWB_Process+0x1be>
      if (profNb > 0)
3400ab26:	b154      	cbz	r4, 3400ab3e <ISP_Algo_AWB_Process+0x7e>
        colorTempThresholds[profNb - 1] = (float) ((colorTemp + 3 * IQParamConfig->AWBAlgo.referenceColorTemp[profId - 1]) /4 );
3400ab28:	682b      	ldr	r3, [r5, #0]
3400ab2a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
3400ab2e:	4403      	add	r3, r0
3400ab30:	089b      	lsrs	r3, r3, #2
3400ab32:	ee07 3a90 	vmov	s15, r3
3400ab36:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3400ab3a:	ed47 7a01 	vstr	s15, [r7, #-4]
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
3400ab3e:	edd5 7a06 	vldr	s15, [r5, #24]
3400ab42:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400ab46:	ee87 7a88 	vdiv.f32	s14, s15, s16
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
3400ab4a:	edd5 7a0b 	vldr	s15, [r5, #44]	@ 0x2c
3400ab4e:	eef8 7a67 	vcvt.f32.u32	s15, s15
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
3400ab52:	ed8d 7a10 	vstr	s14, [sp, #64]	@ 0x40
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
3400ab56:	ee87 7a88 	vdiv.f32	s14, s15, s16
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
3400ab5a:	edd5 7a10 	vldr	s15, [r5, #64]	@ 0x40
3400ab5e:	eef8 7a67 	vcvt.f32.u32	s15, s15
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
3400ab62:	ed8d 7a11 	vstr	s14, [sp, #68]	@ 0x44
      cfaGains[2] = cfaGains[1];
3400ab66:	ed8d 7a12 	vstr	s14, [sp, #72]	@ 0x48
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
3400ab6a:	ee87 7a88 	vdiv.f32	s14, s15, s16
3400ab6e:	2324      	movs	r3, #36	@ 0x24
3400ab70:	a916      	add	r1, sp, #88	@ 0x58
3400ab72:	ed8d 7a13 	vstr	s14, [sp, #76]	@ 0x4c
      for (i = 0; i < 3; i++)
3400ab76:	f04f 0c00 	mov.w	ip, #0
3400ab7a:	460a      	mov	r2, r1
3400ab7c:	fb03 6304 	mla	r3, r3, r4, r6
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
3400ab80:	edd3 7a59 	vldr	s15, [r3, #356]	@ 0x164
3400ab84:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3400ab88:	ee87 7a88 	vdiv.f32	s14, s15, s16
3400ab8c:	edd3 7a5a 	vldr	s15, [r3, #360]	@ 0x168
3400ab90:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3400ab94:	ed81 7a00 	vstr	s14, [r1]
3400ab98:	ee87 7a88 	vdiv.f32	s14, s15, s16
3400ab9c:	edd3 7a5b 	vldr	s15, [r3, #364]	@ 0x16c
3400aba0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3400aba4:	ed81 7a01 	vstr	s14, [r1, #4]
3400aba8:	ee87 7a88 	vdiv.f32	s14, s15, s16
      for (i = 0; i < 3; i++)
3400abac:	f10c 0c01 	add.w	ip, ip, #1
3400abb0:	f1bc 0f03 	cmp.w	ip, #3
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
3400abb4:	ed81 7a02 	vstr	s14, [r1, #8]
      for (i = 0; i < 3; i++)
3400abb8:	f103 030c 	add.w	r3, r3, #12
3400abbc:	f101 010c 	add.w	r1, r1, #12
3400abc0:	d1de      	bne.n	3400ab80 <ISP_Algo_AWB_Process+0xc0>
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
3400abc2:	ee07 0a90 	vmov	s15, r0
3400abc6:	2044      	movs	r0, #68	@ 0x44
3400abc8:	eeb8 0a67 	vcvt.f32.u32	s0, s15
3400abcc:	fb00 a004 	mla	r0, r0, r4, sl
3400abd0:	ab09      	add	r3, sp, #36	@ 0x24
3400abd2:	a910      	add	r1, sp, #64	@ 0x40
      profNb++;
3400abd4:	3401      	adds	r4, #1
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
3400abd6:	f7f6 f9c7 	bl	34000f68 <evision_api_awb_set_profile>
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3400abda:	2c05      	cmp	r4, #5
3400abdc:	f105 0504 	add.w	r5, r5, #4
3400abe0:	f107 0704 	add.w	r7, r7, #4
3400abe4:	d19b      	bne.n	3400ab1e <ISP_Algo_AWB_Process+0x5e>
                                          (double) IQParamConfig->AWBAlgo.referenceColorTemp[profNb - 1], profNb,
3400abe6:	eb06 0384 	add.w	r3, r6, r4, lsl #2
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
3400abea:	ed93 1a44 	vldr	s2, [r3, #272]	@ 0x110
3400abee:	ed96 0a45 	vldr	s0, [r6, #276]	@ 0x114
3400abf2:	4d2d      	ldr	r5, [pc, #180]	@ (3400aca8 <ISP_Algo_AWB_Process+0x1e8>)
3400abf4:	eeb8 1b41 	vcvt.f64.u32	d1, s2
3400abf8:	eeb8 0b40 	vcvt.f64.u32	d0, s0
3400abfc:	4b2b      	ldr	r3, [pc, #172]	@ (3400acac <ISP_Algo_AWB_Process+0x1ec>)
3400abfe:	4a29      	ldr	r2, [pc, #164]	@ (3400aca4 <ISP_Algo_AWB_Process+0x1e4>)
3400ac00:	6828      	ldr	r0, [r5, #0]
3400ac02:	b2a1      	uxth	r1, r4
3400ac04:	f7f6 f9d0 	bl	34000fa8 <evision_api_awb_init_profiles>
    if (e_ret != EVISION_RET_SUCCESS)
3400ac08:	2801      	cmp	r0, #1
3400ac0a:	f040 814b 	bne.w	3400aea4 <ISP_Algo_AWB_Process+0x3e4>
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
3400ac0e:	a71e      	add	r7, pc, #120	@ (adr r7, 3400ac88 <ISP_Algo_AWB_Process+0x1c8>)
3400ac10:	e9d7 6700 	ldrd	r6, r7, [r7]
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
3400ac14:	eeb0 7b00 	vmov.f64	d7, #0	@ 0x40000000  2.0
3400ac18:	ed9f 6b1d 	vldr	d6, [pc, #116]	@ 3400ac90 <ISP_Algo_AWB_Process+0x1d0>
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
3400ac1c:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
3400ac20:	2c03      	cmp	r4, #3
3400ac22:	bf98      	it	ls
3400ac24:	eeb0 7b46 	vmovls.f64	d7, d6
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
3400ac28:	682b      	ldr	r3, [r5, #0]
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
3400ac2a:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
    pIspAWBestimator->hyper_params.conv_criterion = 3;
3400ac2e:	4a20      	ldr	r2, [pc, #128]	@ (3400acb0 <ISP_Algo_AWB_Process+0x1f0>)
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
3400ac30:	ed83 7ba8 	vstr	d7, [r3, #672]	@ 0x2a0
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
3400ac34:	e9c3 67a6 	strd	r6, r7, [r3, #664]	@ 0x298
    pIspAWBestimator->hyper_params.conv_criterion = 3;
3400ac38:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400ac3c:	2305      	movs	r3, #5
3400ac3e:	e9cd 0301 	strd	r0, r3, [sp, #4]
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400ac42:	2402      	movs	r4, #2
3400ac44:	464a      	mov	r2, r9
3400ac46:	4640      	mov	r0, r8
3400ac48:	4b1a      	ldr	r3, [pc, #104]	@ (3400acb4 <ISP_Algo_AWB_Process+0x1f4>)
3400ac4a:	491b      	ldr	r1, [pc, #108]	@ (3400acb8 <ISP_Algo_AWB_Process+0x1f8>)
3400ac4c:	9400      	str	r4, [sp, #0]
3400ac4e:	f001 fa25 	bl	3400c09c <ISP_SVC_Stats_GetNext>
    if (ret != ISP_OK)
3400ac52:	2800      	cmp	r0, #0
3400ac54:	f47f af48 	bne.w	3400aae8 <ISP_Algo_AWB_Process+0x28>
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3400ac58:	f889 4001 	strb.w	r4, [r9, #1]
    break;
3400ac5c:	e744      	b.n	3400aae8 <ISP_Algo_AWB_Process+0x28>
  switch(algo->state)
3400ac5e:	f899 3001 	ldrb.w	r3, [r9, #1]
3400ac62:	2b03      	cmp	r3, #3
3400ac64:	d02a      	beq.n	3400acbc <ISP_Algo_AWB_Process+0x1fc>
3400ac66:	f63f af3e 	bhi.w	3400aae6 <ISP_Algo_AWB_Process+0x26>
3400ac6a:	2b00      	cmp	r3, #0
3400ac6c:	f43f af4f 	beq.w	3400ab0e <ISP_Algo_AWB_Process+0x4e>
3400ac70:	2b01      	cmp	r3, #1
3400ac72:	f47f af38 	bne.w	3400aae6 <ISP_Algo_AWB_Process+0x26>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400ac76:	2205      	movs	r2, #5
3400ac78:	e9cd 3201 	strd	r3, r2, [sp, #4]
3400ac7c:	e7e1      	b.n	3400ac42 <ISP_Algo_AWB_Process+0x182>
      return ISP_ERR_WB_COLORTEMP;
3400ac7e:	2096      	movs	r0, #150	@ 0x96
    if (profNb == 0)
3400ac80:	2c00      	cmp	r4, #0
3400ac82:	f43f af31 	beq.w	3400aae8 <ISP_Algo_AWB_Process+0x28>
3400ac86:	e7ae      	b.n	3400abe6 <ISP_Algo_AWB_Process+0x126>
3400ac88:	9999999a 	.word	0x9999999a
3400ac8c:	3ff59999 	.word	0x3ff59999
3400ac90:	cccccccd 	.word	0xcccccccd
3400ac94:	3ffccccc 	.word	0x3ffccccc
3400ac98:	340cfdc1 	.word	0x340cfdc1
3400ac9c:	340cfdc0 	.word	0x340cfdc0
3400aca0:	4cbebc20 	.word	0x4cbebc20
3400aca4:	340cfdb0 	.word	0x340cfdb0
3400aca8:	340cfe60 	.word	0x340cfe60
3400acac:	340cfc5c 	.word	0x340cfc5c
3400acb0:	40400000 	.word	0x40400000
3400acb4:	340cfbe4 	.word	0x340cfbe4
3400acb8:	3400a5bf 	.word	0x3400a5bf
    ISP_Algo_GetUpStat(hIsp, &stats);
3400acbc:	4f9c      	ldr	r7, [pc, #624]	@ (3400af30 <ISP_Algo_AWB_Process+0x470>)
    if (!(!skip_stat_check_count && (abs(stats.up.averageR - statsHistory[0][0]) <= 2) && (abs(stats.up.averageG - statsHistory[0][1]) <= 2) && (abs(stats.up.averageB - statsHistory[0][2]) <= 2)
3400acbe:	f8df a290 	ldr.w	sl, [pc, #656]	@ 3400af50 <ISP_Algo_AWB_Process+0x490>
    ISP_Algo_GetUpStat(hIsp, &stats);
3400acc2:	4639      	mov	r1, r7
3400acc4:	4640      	mov	r0, r8
3400acc6:	f7ff fded 	bl	3400a8a4 <ISP_Algo_GetUpStat>
    if (!(!skip_stat_check_count && (abs(stats.up.averageR - statsHistory[0][0]) <= 2) && (abs(stats.up.averageG - statsHistory[0][1]) <= 2) && (abs(stats.up.averageB - statsHistory[0][2]) <= 2)
3400acca:	f89a 3000 	ldrb.w	r3, [sl]
3400acce:	4d99      	ldr	r5, [pc, #612]	@ (3400af34 <ISP_Algo_AWB_Process+0x474>)
3400acd0:	f8df b280 	ldr.w	fp, [pc, #640]	@ 3400af54 <ISP_Algo_AWB_Process+0x494>
3400acd4:	2b00      	cmp	r3, #0
3400acd6:	d141      	bne.n	3400ad5c <ISP_Algo_AWB_Process+0x29c>
3400acd8:	7839      	ldrb	r1, [r7, #0]
3400acda:	682b      	ldr	r3, [r5, #0]
3400acdc:	1acb      	subs	r3, r1, r3
3400acde:	2b00      	cmp	r3, #0
3400ace0:	bfb8      	it	lt
3400ace2:	425b      	neglt	r3, r3
3400ace4:	2b02      	cmp	r3, #2
3400ace6:	dc39      	bgt.n	3400ad5c <ISP_Algo_AWB_Process+0x29c>
3400ace8:	787a      	ldrb	r2, [r7, #1]
3400acea:	686b      	ldr	r3, [r5, #4]
3400acec:	1ad3      	subs	r3, r2, r3
3400acee:	2b00      	cmp	r3, #0
3400acf0:	bfb8      	it	lt
3400acf2:	425b      	neglt	r3, r3
3400acf4:	2b02      	cmp	r3, #2
3400acf6:	dc31      	bgt.n	3400ad5c <ISP_Algo_AWB_Process+0x29c>
3400acf8:	78bb      	ldrb	r3, [r7, #2]
3400acfa:	68a8      	ldr	r0, [r5, #8]
3400acfc:	1a18      	subs	r0, r3, r0
3400acfe:	2800      	cmp	r0, #0
3400ad00:	bfb8      	it	lt
3400ad02:	4240      	neglt	r0, r0
3400ad04:	2802      	cmp	r0, #2
3400ad06:	dc29      	bgt.n	3400ad5c <ISP_Algo_AWB_Process+0x29c>
        && (abs(stats.up.averageR - statsHistory[1][0]) <= 2) && (abs(stats.up.averageG - statsHistory[1][1]) <= 2) && (abs(stats.up.averageB - statsHistory[1][2]) <= 2)
3400ad08:	68e8      	ldr	r0, [r5, #12]
3400ad0a:	1a08      	subs	r0, r1, r0
3400ad0c:	2800      	cmp	r0, #0
3400ad0e:	bfb8      	it	lt
3400ad10:	4240      	neglt	r0, r0
3400ad12:	2802      	cmp	r0, #2
3400ad14:	dc22      	bgt.n	3400ad5c <ISP_Algo_AWB_Process+0x29c>
3400ad16:	6928      	ldr	r0, [r5, #16]
3400ad18:	1a10      	subs	r0, r2, r0
3400ad1a:	2800      	cmp	r0, #0
3400ad1c:	bfb8      	it	lt
3400ad1e:	4240      	neglt	r0, r0
3400ad20:	2802      	cmp	r0, #2
3400ad22:	dc1b      	bgt.n	3400ad5c <ISP_Algo_AWB_Process+0x29c>
3400ad24:	6968      	ldr	r0, [r5, #20]
3400ad26:	1a18      	subs	r0, r3, r0
3400ad28:	2800      	cmp	r0, #0
3400ad2a:	bfb8      	it	lt
3400ad2c:	4240      	neglt	r0, r0
3400ad2e:	2802      	cmp	r0, #2
3400ad30:	dc14      	bgt.n	3400ad5c <ISP_Algo_AWB_Process+0x29c>
        && (abs(stats.up.averageR - statsHistory[2][0]) <= 2) && (abs(stats.up.averageG - statsHistory[2][1]) <= 2) && (abs(stats.up.averageB - statsHistory[2][2]) <= 2)))
3400ad32:	69a8      	ldr	r0, [r5, #24]
3400ad34:	1a09      	subs	r1, r1, r0
3400ad36:	2900      	cmp	r1, #0
3400ad38:	bfb8      	it	lt
3400ad3a:	4249      	neglt	r1, r1
3400ad3c:	2902      	cmp	r1, #2
3400ad3e:	dc0d      	bgt.n	3400ad5c <ISP_Algo_AWB_Process+0x29c>
3400ad40:	69e9      	ldr	r1, [r5, #28]
3400ad42:	1a52      	subs	r2, r2, r1
3400ad44:	2a00      	cmp	r2, #0
3400ad46:	bfb8      	it	lt
3400ad48:	4252      	neglt	r2, r2
3400ad4a:	2a02      	cmp	r2, #2
3400ad4c:	dc06      	bgt.n	3400ad5c <ISP_Algo_AWB_Process+0x29c>
3400ad4e:	6a2a      	ldr	r2, [r5, #32]
3400ad50:	1a9b      	subs	r3, r3, r2
3400ad52:	2b00      	cmp	r3, #0
3400ad54:	bfb8      	it	lt
3400ad56:	425b      	neglt	r3, r3
    if (!(!skip_stat_check_count && (abs(stats.up.averageR - statsHistory[0][0]) <= 2) && (abs(stats.up.averageG - statsHistory[0][1]) <= 2) && (abs(stats.up.averageB - statsHistory[0][2]) <= 2)
3400ad58:	2b02      	cmp	r3, #2
3400ad5a:	dd50      	ble.n	3400adfe <ISP_Algo_AWB_Process+0x33e>
        statsHistory[2][0] = stats.up.averageR;
3400ad5c:	783b      	ldrb	r3, [r7, #0]
        ISP_Algo_ApplyCConv(hIsp, stats.down.averageR, stats.down.averageG, stats.down.averageB, &ccAvgR, &ccAvgG, &ccAvgB);
3400ad5e:	4640      	mov	r0, r8
        statsHistory[2][0] = stats.up.averageR;
3400ad60:	61ab      	str	r3, [r5, #24]
        statsHistory[2][1] = stats.up.averageG;
3400ad62:	787b      	ldrb	r3, [r7, #1]
3400ad64:	61eb      	str	r3, [r5, #28]
        statsHistory[2][2] = stats.up.averageB;
3400ad66:	78bb      	ldrb	r3, [r7, #2]
3400ad68:	622b      	str	r3, [r5, #32]
        ISP_Algo_ApplyCConv(hIsp, stats.down.averageR, stats.down.averageG, stats.down.averageB, &ccAvgR, &ccAvgG, &ccAvgB);
3400ad6a:	ab08      	add	r3, sp, #32
3400ad6c:	9302      	str	r3, [sp, #8]
3400ad6e:	ab07      	add	r3, sp, #28
3400ad70:	9301      	str	r3, [sp, #4]
3400ad72:	ab06      	add	r3, sp, #24
3400ad74:	9300      	str	r3, [sp, #0]
3400ad76:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3400ad7a:	f897 2035 	ldrb.w	r2, [r7, #53]	@ 0x35
3400ad7e:	f897 1034 	ldrb.w	r1, [r7, #52]	@ 0x34
3400ad82:	f7ff fde1 	bl	3400a948 <ISP_Algo_ApplyCConv>
        meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
3400ad86:	4640      	mov	r0, r8
3400ad88:	9906      	ldr	r1, [sp, #24]
3400ad8a:	f7ff fd61 	bl	3400a850 <ISP_Algo_ApplyGammaInverse>
        meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
3400ad8e:	4640      	mov	r0, r8
3400ad90:	9907      	ldr	r1, [sp, #28]
        meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
3400ad92:	ed8d 0b10 	vstr	d0, [sp, #64]	@ 0x40
        meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
3400ad96:	f7ff fd5b 	bl	3400a850 <ISP_Algo_ApplyGammaInverse>
        meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
3400ad9a:	4640      	mov	r0, r8
3400ad9c:	9908      	ldr	r1, [sp, #32]
        meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
3400ad9e:	ed8d 0b12 	vstr	d0, [sp, #72]	@ 0x48
        meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
3400ada2:	f7ff fd55 	bl	3400a850 <ISP_Algo_ApplyGammaInverse>
        e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
3400ada6:	4864      	ldr	r0, [pc, #400]	@ (3400af38 <ISP_Algo_AWB_Process+0x478>)
3400ada8:	2201      	movs	r2, #1
3400adaa:	2100      	movs	r1, #0
3400adac:	6800      	ldr	r0, [r0, #0]
3400adae:	ab10      	add	r3, sp, #64	@ 0x40
        meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
3400adb0:	ed8d 0b14 	vstr	d0, [sp, #80]	@ 0x50
        e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
3400adb4:	f7f6 face 	bl	34001354 <evision_api_awb_run_average>
        if (e_ret == EVISION_RET_SUCCESS)
3400adb8:	2801      	cmp	r0, #1
3400adba:	d171      	bne.n	3400aea0 <ISP_Algo_AWB_Process+0x3e0>
          if (pIspAWBestimator->out_temp != currentColorTemp || reconfigureRequest == true)
3400adbc:	4b5e      	ldr	r3, [pc, #376]	@ (3400af38 <ISP_Algo_AWB_Process+0x478>)
3400adbe:	4a5f      	ldr	r2, [pc, #380]	@ (3400af3c <ISP_Algo_AWB_Process+0x47c>)
3400adc0:	681b      	ldr	r3, [r3, #0]
3400adc2:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
3400adc6:	4b5e      	ldr	r3, [pc, #376]	@ (3400af40 <ISP_Algo_AWB_Process+0x480>)
3400adc8:	681b      	ldr	r3, [r3, #0]
3400adca:	ee06 3a90 	vmov	s13, r3
3400adce:	eeb8 6b66 	vcvt.f64.u32	d6, s13
3400add2:	eeb4 7b46 	vcmp.f64	d7, d6
3400add6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400adda:	9305      	str	r3, [sp, #20]
3400addc:	d102      	bne.n	3400ade4 <ISP_Algo_AWB_Process+0x324>
3400adde:	7813      	ldrb	r3, [r2, #0]
3400ade0:	2b01      	cmp	r3, #1
3400ade2:	d10c      	bne.n	3400adfe <ISP_Algo_AWB_Process+0x33e>
            if (pIspAWBestimator->out_temp == colorTempHistory[1])
3400ade4:	eddb 6a01 	vldr	s13, [fp, #4]
3400ade8:	eeb8 6b66 	vcvt.f64.u32	d6, s13
3400adec:	eeb4 7b46 	vcmp.f64	d7, d6
            reconfigureRequest = false;
3400adf0:	2300      	movs	r3, #0
            if (pIspAWBestimator->out_temp == colorTempHistory[1])
3400adf2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            reconfigureRequest = false;
3400adf6:	7013      	strb	r3, [r2, #0]
            if (pIspAWBestimator->out_temp == colorTempHistory[1])
3400adf8:	d12e      	bne.n	3400ae58 <ISP_Algo_AWB_Process+0x398>
              skip_stat_check_count = 0; //oscillation detected
3400adfa:	f88a 3000 	strb.w	r3, [sl]
  ISP_StatusTypeDef ret_stat, ret = ISP_OK;
3400adfe:	2400      	movs	r4, #0
    if (skip_stat_check_count > 0) skip_stat_check_count--;
3400ae00:	f89a 3000 	ldrb.w	r3, [sl]
3400ae04:	b113      	cbz	r3, 3400ae0c <ISP_Algo_AWB_Process+0x34c>
3400ae06:	3b01      	subs	r3, #1
3400ae08:	f88a 3000 	strb.w	r3, [sl]
    statsHistory[1][0] = statsHistory[0][0];
3400ae0c:	682b      	ldr	r3, [r5, #0]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400ae0e:	2205      	movs	r2, #5
    statsHistory[1][0] = statsHistory[0][0];
3400ae10:	60eb      	str	r3, [r5, #12]
    statsHistory[1][1] = statsHistory[0][1];
3400ae12:	686b      	ldr	r3, [r5, #4]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400ae14:	4640      	mov	r0, r8
    statsHistory[1][1] = statsHistory[0][1];
3400ae16:	612b      	str	r3, [r5, #16]
    statsHistory[1][2] = statsHistory[0][2];
3400ae18:	68ab      	ldr	r3, [r5, #8]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400ae1a:	494a      	ldr	r1, [pc, #296]	@ (3400af44 <ISP_Algo_AWB_Process+0x484>)
    statsHistory[1][2] = statsHistory[0][2];
3400ae1c:	616b      	str	r3, [r5, #20]
    statsHistory[0][0] = stats.up.averageR;
3400ae1e:	783b      	ldrb	r3, [r7, #0]
3400ae20:	602b      	str	r3, [r5, #0]
    statsHistory[0][1] = stats.up.averageG;
3400ae22:	787b      	ldrb	r3, [r7, #1]
3400ae24:	606b      	str	r3, [r5, #4]
    statsHistory[0][2] = stats.up.averageB;
3400ae26:	78bb      	ldrb	r3, [r7, #2]
3400ae28:	60ab      	str	r3, [r5, #8]
    colorTempHistory[1] = colorTempHistory[0];
3400ae2a:	f8db 3000 	ldr.w	r3, [fp]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400ae2e:	2502      	movs	r5, #2
    colorTempHistory[1] = colorTempHistory[0];
3400ae30:	f8cb 3004 	str.w	r3, [fp, #4]
    colorTempHistory[0] = currentColorTemp;
3400ae34:	4b42      	ldr	r3, [pc, #264]	@ (3400af40 <ISP_Algo_AWB_Process+0x480>)
3400ae36:	681b      	ldr	r3, [r3, #0]
3400ae38:	f8cb 3000 	str.w	r3, [fp]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3400ae3c:	2301      	movs	r3, #1
3400ae3e:	9500      	str	r5, [sp, #0]
3400ae40:	e9cd 3201 	strd	r3, r2, [sp, #4]
3400ae44:	464a      	mov	r2, r9
3400ae46:	4b3a      	ldr	r3, [pc, #232]	@ (3400af30 <ISP_Algo_AWB_Process+0x470>)
3400ae48:	f001 f928 	bl	3400c09c <ISP_SVC_Stats_GetNext>
    ret = (ret != ISP_OK) ? ret : ret_stat;
3400ae4c:	2c00      	cmp	r4, #0
3400ae4e:	bf18      	it	ne
3400ae50:	4620      	movne	r0, r4
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3400ae52:	f889 5001 	strb.w	r5, [r9, #1]
    break;
3400ae56:	e647      	b.n	3400aae8 <ISP_Algo_AWB_Process+0x28>
              if (skip_stat_check_count <= ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION) skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
3400ae58:	f89a 3000 	ldrb.w	r3, [sl]
              Meta.colorTemp = (uint32_t) pIspAWBestimator->out_temp;
3400ae5c:	eefc 6bc7 	vcvt.u32.f64	s13, d7
              if (skip_stat_check_count <= ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION) skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
3400ae60:	2b04      	cmp	r3, #4
3400ae62:	bf9c      	itt	ls
3400ae64:	2304      	movls	r3, #4
3400ae66:	f88a 3000 	strbls.w	r3, [sl]
              for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3400ae6a:	2300      	movs	r3, #0
3400ae6c:	9305      	str	r3, [sp, #20]
3400ae6e:	2305      	movs	r3, #5
              Meta.colorTemp = (uint32_t) pIspAWBestimator->out_temp;
3400ae70:	4a35      	ldr	r2, [pc, #212]	@ (3400af48 <ISP_Algo_AWB_Process+0x488>)
3400ae72:	edc2 6a04 	vstr	s13, [r2, #16]
              for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3400ae76:	f506 7288 	add.w	r2, r6, #272	@ 0x110
                if (pIspAWBestimator->out_temp == IQParamConfig->AWBAlgo.referenceColorTemp[profId])
3400ae7a:	ed92 6a01 	vldr	s12, [r2, #4]
3400ae7e:	eeb8 6b46 	vcvt.f64.u32	d6, s12
3400ae82:	eeb4 7b46 	vcmp.f64	d7, d6
3400ae86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400ae8a:	f102 0204 	add.w	r2, r2, #4
3400ae8e:	d00b      	beq.n	3400aea8 <ISP_Algo_AWB_Process+0x3e8>
              for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3400ae90:	9905      	ldr	r1, [sp, #20]
3400ae92:	3b01      	subs	r3, #1
3400ae94:	f101 0101 	add.w	r1, r1, #1
3400ae98:	9105      	str	r1, [sp, #20]
3400ae9a:	d1ee      	bne.n	3400ae7a <ISP_Algo_AWB_Process+0x3ba>
                ret  = ISP_ERR_WB_COLORTEMP;
3400ae9c:	2496      	movs	r4, #150	@ 0x96
3400ae9e:	e7af      	b.n	3400ae00 <ISP_Algo_AWB_Process+0x340>
          ret = ISP_ERR_ALGO;
3400aea0:	24be      	movs	r4, #190	@ 0xbe
3400aea2:	e7ad      	b.n	3400ae00 <ISP_Algo_AWB_Process+0x340>
      return ISP_ERR_ALGO;
3400aea4:	20be      	movs	r0, #190	@ 0xbe
3400aea6:	e61f      	b.n	3400aae8 <ISP_Algo_AWB_Process+0x28>
                ColorConvConfig.enable = 1;
3400aea8:	2301      	movs	r3, #1
                memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
3400aeaa:	f04f 0e04 	mov.w	lr, #4
                ColorConvConfig.enable = 1;
3400aeae:	f88d 3058 	strb.w	r3, [sp, #88]	@ 0x58
                memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
3400aeb2:	2324      	movs	r3, #36	@ 0x24
3400aeb4:	f04e e001 	dls	lr, lr
3400aeb8:	9a05      	ldr	r2, [sp, #20]
3400aeba:	fb03 6302 	mla	r3, r3, r2, r6
3400aebe:	aa17      	add	r2, sp, #92	@ 0x5c
3400aec0:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
3400aec4:	4614      	mov	r4, r2
3400aec6:	6818      	ldr	r0, [r3, #0]
3400aec8:	6859      	ldr	r1, [r3, #4]
3400aeca:	3308      	adds	r3, #8
3400aecc:	c403      	stmia	r4!, {r0, r1}
3400aece:	4622      	mov	r2, r4
3400aed0:	f00f c009 	le	lr, 3400aec4 <ISP_Algo_AWB_Process+0x404>
3400aed4:	6818      	ldr	r0, [r3, #0]
                ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
3400aed6:	a916      	add	r1, sp, #88	@ 0x58
                memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
3400aed8:	6020      	str	r0, [r4, #0]
                ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
3400aeda:	4640      	mov	r0, r8
3400aedc:	f000 fd1c 	bl	3400b918 <ISP_SVC_ISP_SetColorConv>
                if (ret == ISP_OK)
3400aee0:	4604      	mov	r4, r0
3400aee2:	2800      	cmp	r0, #0
3400aee4:	d18c      	bne.n	3400ae00 <ISP_Algo_AWB_Process+0x340>
                  ISPGainConfig.enable = 1;
3400aee6:	2301      	movs	r3, #1
3400aee8:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
                  ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
3400aeec:	9b05      	ldr	r3, [sp, #20]
                  ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
3400aeee:	4640      	mov	r0, r8
3400aef0:	eb06 0683 	add.w	r6, r6, r3, lsl #2
                  ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
3400aef4:	f8d6 3128 	ldr.w	r3, [r6, #296]	@ 0x128
                  ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
3400aef8:	a90c      	add	r1, sp, #48	@ 0x30
                  ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
3400aefa:	930d      	str	r3, [sp, #52]	@ 0x34
                  ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
3400aefc:	f8d6 313c 	ldr.w	r3, [r6, #316]	@ 0x13c
3400af00:	930e      	str	r3, [sp, #56]	@ 0x38
                  ISPGainConfig.ispGainB = IQParamConfig->AWBAlgo.ispGainB[profId];
3400af02:	f8d6 3150 	ldr.w	r3, [r6, #336]	@ 0x150
3400af06:	930f      	str	r3, [sp, #60]	@ 0x3c
                  ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
3400af08:	f000 fc22 	bl	3400b750 <ISP_SVC_ISP_SetGain>
                  if (ret == ISP_OK)
3400af0c:	4604      	mov	r4, r0
3400af0e:	2800      	cmp	r0, #0
3400af10:	f47f af76 	bne.w	3400ae00 <ISP_Algo_AWB_Process+0x340>
                    currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
3400af14:	4b08      	ldr	r3, [pc, #32]	@ (3400af38 <ISP_Algo_AWB_Process+0x478>)
                    current_awb_profId = profId;
3400af16:	9a05      	ldr	r2, [sp, #20]
                    currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
3400af18:	681b      	ldr	r3, [r3, #0]
3400af1a:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
3400af1e:	eebc 7bc7 	vcvt.u32.f64	s14, d7
3400af22:	4b07      	ldr	r3, [pc, #28]	@ (3400af40 <ISP_Algo_AWB_Process+0x480>)
3400af24:	ed83 7a00 	vstr	s14, [r3]
                    current_awb_profId = profId;
3400af28:	4b08      	ldr	r3, [pc, #32]	@ (3400af4c <ISP_Algo_AWB_Process+0x48c>)
3400af2a:	601a      	str	r2, [r3, #0]
3400af2c:	e768      	b.n	3400ae00 <ISP_Algo_AWB_Process+0x340>
3400af2e:	bf00      	nop
3400af30:	340cfbe4 	.word	0x340cfbe4
3400af34:	340cfbc0 	.word	0x340cfbc0
3400af38:	340cfe60 	.word	0x340cfe60
3400af3c:	340cfdc0 	.word	0x340cfdc0
3400af40:	340cfbbc 	.word	0x340cfbbc
3400af44:	3400a5bf 	.word	0x3400a5bf
3400af48:	340cfe48 	.word	0x340cfe48
3400af4c:	340cfe5c 	.word	0x340cfe5c
3400af50:	34013b24 	.word	0x34013b24
3400af54:	340cfbb4 	.word	0x340cfbb4

3400af58 <ISP_Algo_Init>:
  *         Register and initialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Init(ISP_HandleTypeDef *hIsp)
{
3400af58:	b538      	push	{r3, r4, r5, lr}
3400af5a:	4604      	mov	r4, r0
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  hIsp->algorithm = ISP_Algo_List;
3400af5c:	2500      	movs	r5, #0
3400af5e:	4b09      	ldr	r3, [pc, #36]	@ (3400af84 <ISP_Algo_Init+0x2c>)
3400af60:	6183      	str	r3, [r0, #24]

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
3400af62:	69a3      	ldr	r3, [r4, #24]
3400af64:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->Init != NULL))
3400af66:	b921      	cbnz	r1, 3400af72 <ISP_Algo_Init+0x1a>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3400af68:	3504      	adds	r5, #4
3400af6a:	2d0c      	cmp	r5, #12
3400af6c:	d1f9      	bne.n	3400af62 <ISP_Algo_Init+0xa>
        return ret;
      }
    }
  }

  return ISP_OK;
3400af6e:	2000      	movs	r0, #0
}
3400af70:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->Init != NULL))
3400af72:	684b      	ldr	r3, [r1, #4]
3400af74:	2b00      	cmp	r3, #0
3400af76:	d0f7      	beq.n	3400af68 <ISP_Algo_Init+0x10>
      ret = algo->Init((void*)hIsp, (void*)algo);
3400af78:	4620      	mov	r0, r4
3400af7a:	4798      	blx	r3
      if (ret != ISP_OK)
3400af7c:	2800      	cmp	r0, #0
3400af7e:	d0f3      	beq.n	3400af68 <ISP_Algo_Init+0x10>
3400af80:	e7f6      	b.n	3400af70 <ISP_Algo_Init+0x18>
3400af82:	bf00      	nop
3400af84:	34013b28 	.word	0x34013b28

3400af88 <ISP_Algo_DeInit>:
  *         Deinitialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_DeInit(ISP_HandleTypeDef *hIsp)
{
3400af88:	b538      	push	{r3, r4, r5, lr}
3400af8a:	4604      	mov	r4, r0
3400af8c:	2500      	movs	r5, #0
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
3400af8e:	69a3      	ldr	r3, [r4, #24]
3400af90:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->DeInit != NULL))
3400af92:	b921      	cbnz	r1, 3400af9e <ISP_Algo_DeInit+0x16>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3400af94:	3504      	adds	r5, #4
3400af96:	2d0c      	cmp	r5, #12
3400af98:	d1f9      	bne.n	3400af8e <ISP_Algo_DeInit+0x6>
        return ret;
      }
    }
  }

  return ISP_OK;
3400af9a:	2000      	movs	r0, #0
}
3400af9c:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->DeInit != NULL))
3400af9e:	688b      	ldr	r3, [r1, #8]
3400afa0:	2b00      	cmp	r3, #0
3400afa2:	d0f7      	beq.n	3400af94 <ISP_Algo_DeInit+0xc>
      ret = algo->DeInit((void*)hIsp, (void*)algo);
3400afa4:	4620      	mov	r0, r4
3400afa6:	4798      	blx	r3
      if (ret != ISP_OK)
3400afa8:	2800      	cmp	r0, #0
3400afaa:	d0f3      	beq.n	3400af94 <ISP_Algo_DeInit+0xc>
3400afac:	e7f6      	b.n	3400af9c <ISP_Algo_DeInit+0x14>

3400afae <ISP_Algo_Process>:
  *         Process all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Process(ISP_HandleTypeDef *hIsp)
{
3400afae:	b538      	push	{r3, r4, r5, lr}
3400afb0:	4604      	mov	r4, r0
3400afb2:	2500      	movs	r5, #0
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
3400afb4:	69a3      	ldr	r3, [r4, #24]
3400afb6:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->Process != NULL))
3400afb8:	b921      	cbnz	r1, 3400afc4 <ISP_Algo_Process+0x16>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3400afba:	3504      	adds	r5, #4
3400afbc:	2d0c      	cmp	r5, #12
3400afbe:	d1f9      	bne.n	3400afb4 <ISP_Algo_Process+0x6>
      }
#endif
    }
  }

  return ISP_OK;
3400afc0:	2000      	movs	r0, #0
}
3400afc2:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->Process != NULL))
3400afc4:	68cb      	ldr	r3, [r1, #12]
3400afc6:	2b00      	cmp	r3, #0
3400afc8:	d0f7      	beq.n	3400afba <ISP_Algo_Process+0xc>
      ret = algo->Process((void*)hIsp, (void*)algo);
3400afca:	4620      	mov	r0, r4
3400afcc:	4798      	blx	r3
      if (ret != ISP_OK)
3400afce:	2800      	cmp	r0, #0
3400afd0:	d0f3      	beq.n	3400afba <ISP_Algo_Process+0xc>
3400afd2:	e7f6      	b.n	3400afc2 <ISP_Algo_Process+0x14>

3400afd4 <HAL_DCMIPP_PIPE_VsyncEventCallback>:
 */
void HAL_DCMIPP_PIPE_VsyncEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
  UNUSED(hdcmipp);
  /* Update the frame counter and call the ISP statistics handler */
  if (Pipe == DCMIPP_PIPE1 )
3400afd4:	2901      	cmp	r1, #1
{
3400afd6:	b508      	push	{r3, lr}
  if (Pipe == DCMIPP_PIPE1 )
3400afd8:	d10a      	bne.n	3400aff0 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x1c>
  {
    /* Call the IPS statistics handler */
    ISP_IncMainFrameId(&hIsp);
3400afda:	4806      	ldr	r0, [pc, #24]	@ (3400aff4 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x20>)
3400afdc:	f000 f956 	bl	3400b28c <ISP_IncMainFrameId>
    ISP_GatherStatistics(&hIsp);
3400afe0:	4804      	ldr	r0, [pc, #16]	@ (3400aff4 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x20>)
3400afe2:	f000 f951 	bl	3400b288 <ISP_GatherStatistics>
    ISP_OutputMeta(&hIsp);
  }
  /* Additional applicative processing can be implemented from here */
}
3400afe6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    ISP_OutputMeta(&hIsp);
3400afea:	4802      	ldr	r0, [pc, #8]	@ (3400aff4 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x20>)
3400afec:	f000 b954 	b.w	3400b298 <ISP_OutputMeta>
}
3400aff0:	bd08      	pop	{r3, pc}
3400aff2:	bf00      	nop
3400aff4:	340cfe68 	.word	0x340cfe68

3400aff8 <HAL_DCMIPP_PIPE_FrameEventCallback>:
 */
void HAL_DCMIPP_PIPE_FrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
  UNUSED(hdcmipp);
  /* Update the frame counter for the pipes used to dump the frame */
  switch (Pipe)
3400aff8:	b111      	cbz	r1, 3400b000 <HAL_DCMIPP_PIPE_FrameEventCallback+0x8>
3400affa:	2902      	cmp	r1, #2
3400affc:	d003      	beq.n	3400b006 <HAL_DCMIPP_PIPE_FrameEventCallback+0xe>
3400affe:	4770      	bx	lr
  {
    case DCMIPP_PIPE0 :
      ISP_IncDumpFrameId(&hIsp);
3400b000:	4802      	ldr	r0, [pc, #8]	@ (3400b00c <HAL_DCMIPP_PIPE_FrameEventCallback+0x14>)
3400b002:	f000 b947 	b.w	3400b294 <ISP_IncDumpFrameId>
      break;
    case DCMIPP_PIPE2 :
      ISP_IncAncillaryFrameId(&hIsp);
3400b006:	4801      	ldr	r0, [pc, #4]	@ (3400b00c <HAL_DCMIPP_PIPE_FrameEventCallback+0x14>)
3400b008:	f000 b942 	b.w	3400b290 <ISP_IncAncillaryFrameId>
3400b00c:	340cfe68 	.word	0x340cfe68

3400b010 <ISP_Init>:
ISP_StatusTypeDef ISP_Init(ISP_HandleTypeDef *hIsp,
                           void *hDcmipp,
                           uint32_t CameraInstance,
                           ISP_AppliHelpersTypeDef *pAppliHelpers,
                           const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
3400b010:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400b012:	460e      	mov	r6, r1
3400b014:	4617      	mov	r7, r2
3400b016:	461c      	mov	r4, r3
  ISP_StatusTypeDef ret;

  if ((hIsp == NULL) || (hDcmipp == NULL) || (pAppliHelpers == NULL))
3400b018:	4605      	mov	r5, r0
3400b01a:	2800      	cmp	r0, #0
3400b01c:	d066      	beq.n	3400b0ec <ISP_Init+0xdc>
3400b01e:	2900      	cmp	r1, #0
3400b020:	d064      	beq.n	3400b0ec <ISP_Init+0xdc>
3400b022:	2b00      	cmp	r3, #0
3400b024:	d062      	beq.n	3400b0ec <ISP_Init+0xdc>
  {
    return ISP_ERR_EINVAL;
  }

  memset(hIsp, 0, sizeof(*hIsp));
3400b026:	2280      	movs	r2, #128	@ 0x80
3400b028:	2100      	movs	r1, #0
3400b02a:	3008      	adds	r0, #8
3400b02c:	f002 fc72 	bl	3400d914 <memset>
  hIsp->cameraInstance = CameraInstance;
  hIsp->MainPipe_FrameCount = 0;
  hIsp->AncillaryPipe_FrameCount = 0;
  hIsp->DumpPipe_FrameCount = 0;

  hIsp->appliHelpers = *pAppliHelpers;
3400b030:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  hIsp->cameraInstance = CameraInstance;
3400b032:	e9c5 6700 	strd	r6, r7, [r5]
  hIsp->appliHelpers = *pAppliHelpers;
3400b036:	f105 061c 	add.w	r6, r5, #28
3400b03a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
3400b03c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
3400b03e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
3400b040:	6823      	ldr	r3, [r4, #0]
3400b042:	6033      	str	r3, [r6, #0]
  /* Appli CB is mandatory for the sensor get/set exp/gain function */
  if (hIsp->appliHelpers.GetSensorInfo == NULL)
3400b044:	6aab      	ldr	r3, [r5, #40]	@ 0x28
3400b046:	b933      	cbnz	r3, 3400b056 <ISP_Init+0x46>
  {
     printf("INFO: GetSensorInfo helper function is not implemented\r\n");
3400b048:	4829      	ldr	r0, [pc, #164]	@ (3400b0f0 <ISP_Init+0xe0>)
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
      return ISP_ERR_APP_HELPER_UNDEFINED;
  }
  if (hIsp->appliHelpers.GetSensorGain == NULL)
  {
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
3400b04a:	f002 fb33 	bl	3400d6b4 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
3400b04e:	24b4      	movs	r4, #180	@ 0xb4

  /* Initialize the statistic engine */
  ISP_SVC_Stats_Init(hIsp);

  return ISP_OK;
}
3400b050:	4620      	mov	r0, r4
3400b052:	b003      	add	sp, #12
3400b054:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (hIsp->appliHelpers.SetSensorGain == NULL)
3400b056:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
3400b058:	b90b      	cbnz	r3, 3400b05e <ISP_Init+0x4e>
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
3400b05a:	4826      	ldr	r0, [pc, #152]	@ (3400b0f4 <ISP_Init+0xe4>)
3400b05c:	e7f5      	b.n	3400b04a <ISP_Init+0x3a>
  if (hIsp->appliHelpers.GetSensorGain == NULL)
3400b05e:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
3400b060:	b90b      	cbnz	r3, 3400b066 <ISP_Init+0x56>
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
3400b062:	4825      	ldr	r0, [pc, #148]	@ (3400b0f8 <ISP_Init+0xe8>)
3400b064:	e7f1      	b.n	3400b04a <ISP_Init+0x3a>
  if (hIsp->appliHelpers.SetSensorExposure == NULL)
3400b066:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
3400b068:	b90b      	cbnz	r3, 3400b06e <ISP_Init+0x5e>
      printf("INFO: SetSensorExposure helper function is not implemented\r\n");
3400b06a:	4824      	ldr	r0, [pc, #144]	@ (3400b0fc <ISP_Init+0xec>)
3400b06c:	e7ed      	b.n	3400b04a <ISP_Init+0x3a>
  if (hIsp->appliHelpers.GetSensorExposure == NULL)
3400b06e:	6bab      	ldr	r3, [r5, #56]	@ 0x38
3400b070:	b90b      	cbnz	r3, 3400b076 <ISP_Init+0x66>
     printf("INFO: GetSensorExposure helper function is not implemented\r\n");
3400b072:	4823      	ldr	r0, [pc, #140]	@ (3400b100 <ISP_Init+0xf0>)
3400b074:	e7e9      	b.n	3400b04a <ISP_Init+0x3a>
  ret = ISP_SVC_IQParam_Init(hIsp, ISP_IQParamCacheInit);
3400b076:	4628      	mov	r0, r5
3400b078:	9908      	ldr	r1, [sp, #32]
3400b07a:	f000 fdc1 	bl	3400bc00 <ISP_SVC_IQParam_Init>
  if (ret != ISP_OK)
3400b07e:	4604      	mov	r4, r0
3400b080:	2800      	cmp	r0, #0
3400b082:	d1e5      	bne.n	3400b050 <ISP_Init+0x40>
  ret = ISP_SVC_Sensor_GetInfo(hIsp, &hIsp->sensorInfo);
3400b084:	4628      	mov	r0, r5
3400b086:	f105 014c 	add.w	r1, r5, #76	@ 0x4c
3400b08a:	f000 fd15 	bl	3400bab8 <ISP_SVC_Sensor_GetInfo>
  if (ret != ISP_OK)
3400b08e:	4604      	mov	r4, r0
3400b090:	2800      	cmp	r0, #0
3400b092:	d1dd      	bne.n	3400b050 <ISP_Init+0x40>
  if ((hIsp->sensorInfo.width / ISP_DECIM_FACTOR_1) < ISP_RAW_MAX_WIDTH)
3400b094:	6f2a      	ldr	r2, [r5, #112]	@ 0x70
3400b096:	f5b2 6f28 	cmp.w	r2, #2688	@ 0xa80
3400b09a:	d30f      	bcc.n	3400b0bc <ISP_Init+0xac>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_2) < ISP_RAW_MAX_WIDTH)
3400b09c:	f5b2 5fa8 	cmp.w	r2, #5376	@ 0x1500
3400b0a0:	d320      	bcc.n	3400b0e4 <ISP_Init+0xd4>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_4) < ISP_RAW_MAX_WIDTH)
3400b0a2:	f5b2 5f28 	cmp.w	r2, #10752	@ 0x2a00
3400b0a6:	d31f      	bcc.n	3400b0e8 <ISP_Init+0xd8>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_8) < ISP_RAW_MAX_WIDTH)
3400b0a8:	f5b2 4fa8 	cmp.w	r2, #21504	@ 0x5400
3400b0ac:	f04f 0308 	mov.w	r3, #8
3400b0b0:	d305      	bcc.n	3400b0be <ISP_Init+0xae>
    printf("ERROR: No possible decimation factor to target ISP RAW width constraint\r\n");
3400b0b2:	4814      	ldr	r0, [pc, #80]	@ (3400b104 <ISP_Init+0xf4>)
3400b0b4:	f002 fafe 	bl	3400d6b4 <puts>
    return ISP_ERR_DECIMATION_EINVAL;
3400b0b8:	241e      	movs	r4, #30
3400b0ba:	e7c9      	b.n	3400b050 <ISP_Init+0x40>
3400b0bc:	2301      	movs	r3, #1
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
3400b0be:	4628      	mov	r0, r5
3400b0c0:	a901      	add	r1, sp, #4
    decimation.factor = ISP_DECIM_FACTOR_1;
3400b0c2:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
3400b0c6:	f000 f9d3 	bl	3400b470 <ISP_SVC_ISP_SetDecimation>
  if (ret != ISP_OK)
3400b0ca:	4604      	mov	r4, r0
3400b0cc:	2800      	cmp	r0, #0
3400b0ce:	d1bf      	bne.n	3400b050 <ISP_Init+0x40>
  ret = ISP_Algo_Init(hIsp);
3400b0d0:	4628      	mov	r0, r5
3400b0d2:	f7ff ff41 	bl	3400af58 <ISP_Algo_Init>
  if (ret != ISP_OK)
3400b0d6:	4604      	mov	r4, r0
3400b0d8:	2800      	cmp	r0, #0
3400b0da:	d1b9      	bne.n	3400b050 <ISP_Init+0x40>
  ISP_SVC_Stats_Init(hIsp);
3400b0dc:	4628      	mov	r0, r5
3400b0de:	f000 fd9d 	bl	3400bc1c <ISP_SVC_Stats_Init>
  return ISP_OK;
3400b0e2:	e7b5      	b.n	3400b050 <ISP_Init+0x40>
3400b0e4:	2302      	movs	r3, #2
3400b0e6:	e7ea      	b.n	3400b0be <ISP_Init+0xae>
3400b0e8:	2304      	movs	r3, #4
3400b0ea:	e7e8      	b.n	3400b0be <ISP_Init+0xae>
    return ISP_ERR_EINVAL;
3400b0ec:	2401      	movs	r4, #1
3400b0ee:	e7af      	b.n	3400b050 <ISP_Init+0x40>
3400b0f0:	3401075a 	.word	0x3401075a
3400b0f4:	34010792 	.word	0x34010792
3400b0f8:	340107ca 	.word	0x340107ca
3400b0fc:	34010802 	.word	0x34010802
3400b100:	3401083e 	.word	0x3401083e
3400b104:	3401087a 	.word	0x3401087a

3400b108 <ISP_DeInit>:
  *         Deinitializes the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_DeInit(ISP_HandleTypeDef *hIsp)
{
3400b108:	b538      	push	{r3, r4, r5, lr}
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
3400b10a:	4605      	mov	r5, r0
3400b10c:	b150      	cbz	r0, 3400b124 <ISP_DeInit+0x1c>
  {
    return ISP_ERR_EINVAL;
  }

  /* DeInitialize algorithms */
  ret = ISP_Algo_DeInit(hIsp);
3400b10e:	f7ff ff3b 	bl	3400af88 <ISP_Algo_DeInit>
  if (ret != ISP_OK)
3400b112:	4604      	mov	r4, r0
3400b114:	b920      	cbnz	r0, 3400b120 <ISP_DeInit+0x18>
  {
    return ret;
  }

  /* Re-initialized the hIsp structure */
  memset(hIsp, 0, sizeof(*hIsp));
3400b116:	4601      	mov	r1, r0
3400b118:	2288      	movs	r2, #136	@ 0x88
3400b11a:	4628      	mov	r0, r5
3400b11c:	f002 fbfa 	bl	3400d914 <memset>

  return ISP_OK;
}
3400b120:	4620      	mov	r0, r4
3400b122:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_EINVAL;
3400b124:	2401      	movs	r4, #1
3400b126:	e7fb      	b.n	3400b120 <ISP_DeInit+0x18>

3400b128 <ISP_Start>:
  *         Configures the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_Start(ISP_HandleTypeDef *hIsp)
{
3400b128:	b567      	push	{r0, r1, r2, r5, r6, lr}
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
3400b12a:	4605      	mov	r5, r0
3400b12c:	2800      	cmp	r0, #0
3400b12e:	f000 8095 	beq.w	3400b25c <ISP_Start+0x134>
  {
    return ISP_ERR_EINVAL;
  }

  ret = ISP_SVC_Misc_IsDCMIPPReady(hIsp);
3400b132:	f000 fd17 	bl	3400bb64 <ISP_SVC_Misc_IsDCMIPPReady>
  if (ret != ISP_OK)
3400b136:	2800      	cmp	r0, #0
3400b138:	d149      	bne.n	3400b1ce <ISP_Start+0xa6>
  {
    return ret;
  }

  /* Get IQ Param config */
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3400b13a:	4628      	mov	r0, r5
3400b13c:	f000 fd6a 	bl	3400bc14 <ISP_SVC_IQParam_Get>
3400b140:	4606      	mov	r6, r0

  /* Set static configurations */
  ret = ISP_SVC_ISP_SetDemosaicing(hIsp, &IQParamConfig->demosaicing);
3400b142:	f100 010c 	add.w	r1, r0, #12
3400b146:	4628      	mov	r0, r5
3400b148:	f000 f932 	bl	3400b3b0 <ISP_SVC_ISP_SetDemosaicing>
  if (ret != ISP_OK)
3400b14c:	2800      	cmp	r0, #0
3400b14e:	d13e      	bne.n	3400b1ce <ISP_Start+0xa6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetStatRemoval(hIsp, &IQParamConfig->statRemoval);
3400b150:	4631      	mov	r1, r6
3400b152:	4628      	mov	r0, r5
3400b154:	f000 f96b 	bl	3400b42e <ISP_SVC_ISP_SetStatRemoval>
  if (ret != ISP_OK)
3400b158:	2800      	cmp	r0, #0
3400b15a:	d138      	bne.n	3400b1ce <ISP_Start+0xa6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetContrast(hIsp, &IQParamConfig->contrast);
3400b15c:	4628      	mov	r0, r5
3400b15e:	f106 0114 	add.w	r1, r6, #20
3400b162:	f000 f9b9 	bl	3400b4d8 <ISP_SVC_ISP_SetContrast>
  if (ret != ISP_OK)
3400b166:	bb90      	cbnz	r0, 3400b1ce <ISP_Start+0xa6>
  {
    return ret;
  }

  /* Set optional static configurations */
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
3400b168:	6cf3      	ldr	r3, [r6, #76]	@ 0x4c
3400b16a:	bb2b      	cbnz	r3, 3400b1b8 <ISP_Start+0x90>
    {
      return ret;
    }
  }

  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
3400b16c:	6d33      	ldr	r3, [r6, #80]	@ 0x50
3400b16e:	bb83      	cbnz	r3, 3400b1d2 <ISP_Start+0xaa>
    {
      return ret;
    }
  }

  if (IQParamConfig->badPixelStatic.enable != 0)
3400b170:	f896 305c 	ldrb.w	r3, [r6, #92]	@ 0x5c
3400b174:	b12b      	cbz	r3, 3400b182 <ISP_Start+0x5a>
  {
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &IQParamConfig->badPixelStatic);
3400b176:	4628      	mov	r0, r5
3400b178:	f106 015c 	add.w	r1, r6, #92	@ 0x5c
3400b17c:	f000 fa72 	bl	3400b664 <ISP_SVC_ISP_SetBadPixel>
    if (ret != ISP_OK)
3400b180:	bb28      	cbnz	r0, 3400b1ce <ISP_Start+0xa6>
    {
      return ret;
    }
  }

  if (IQParamConfig->blackLevelStatic.enable != 0)
3400b182:	f896 3064 	ldrb.w	r3, [r6, #100]	@ 0x64
3400b186:	b12b      	cbz	r3, 3400b194 <ISP_Start+0x6c>
  {
    ret = ISP_SVC_ISP_SetBlackLevel(hIsp, &IQParamConfig->blackLevelStatic);
3400b188:	4628      	mov	r0, r5
3400b18a:	f106 0164 	add.w	r1, r6, #100	@ 0x64
3400b18e:	f000 fa9e 	bl	3400b6ce <ISP_SVC_ISP_SetBlackLevel>
    if (ret != ISP_OK)
3400b192:	b9e0      	cbnz	r0, 3400b1ce <ISP_Start+0xa6>
    {
      return ret;
    }
  }

  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3400b194:	f896 3218 	ldrb.w	r3, [r6, #536]	@ 0x218
3400b198:	bb3b      	cbnz	r3, 3400b1ea <ISP_Start+0xc2>
    {
      return ret;
    }
  }

  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3400b19a:	f896 3228 	ldrb.w	r3, [r6, #552]	@ 0x228
3400b19e:	2b00      	cmp	r3, #0
3400b1a0:	d12f      	bne.n	3400b202 <ISP_Start+0xda>
      return ret;
    }
  }

  /* Configure statistic area if not already configured by ISP_SetStatArea() */
  if ((hIsp->statArea.XSize == 0) || (hIsp->statArea.YSize == 0))
3400b1a2:	692b      	ldr	r3, [r5, #16]
3400b1a4:	2b00      	cmp	r3, #0
3400b1a6:	d138      	bne.n	3400b21a <ISP_Start+0xf2>
  {
    /* Configure statistic area from IQ params */
    ret = ISP_SVC_ISP_SetStatArea(hIsp, &IQParamConfig->statAreaStatic);
3400b1a8:	4628      	mov	r0, r5
3400b1aa:	f106 013c 	add.w	r1, r6, #60	@ 0x3c
3400b1ae:	f000 fa0d 	bl	3400b5cc <ISP_SVC_ISP_SetStatArea>
    if (ret != ISP_OK)
3400b1b2:	2800      	cmp	r0, #0
3400b1b4:	d034      	beq.n	3400b220 <ISP_Start+0xf8>
3400b1b6:	e00a      	b.n	3400b1ce <ISP_Start+0xa6>
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
3400b1b8:	f896 3068 	ldrb.w	r3, [r6, #104]	@ 0x68
3400b1bc:	2b00      	cmp	r3, #0
3400b1be:	d1d5      	bne.n	3400b16c <ISP_Start+0x44>
    ret = ISP_SVC_Sensor_SetGain(hIsp, &IQParamConfig->sensorGainStatic);
3400b1c0:	4628      	mov	r0, r5
3400b1c2:	f106 014c 	add.w	r1, r6, #76	@ 0x4c
3400b1c6:	f000 fc85 	bl	3400bad4 <ISP_SVC_Sensor_SetGain>
    if (ret != ISP_OK)
3400b1ca:	2800      	cmp	r0, #0
3400b1cc:	d0ce      	beq.n	3400b16c <ISP_Start+0x44>

  /* Initialize the exposure target based on the selected exposure compensation */
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));

  return ISP_OK;
}
3400b1ce:	b003      	add	sp, #12
3400b1d0:	bd60      	pop	{r5, r6, pc}
  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
3400b1d2:	f896 3068 	ldrb.w	r3, [r6, #104]	@ 0x68
3400b1d6:	2b00      	cmp	r3, #0
3400b1d8:	d1ca      	bne.n	3400b170 <ISP_Start+0x48>
    ret = ISP_SVC_Sensor_SetExposure(hIsp, &IQParamConfig->sensorExposureStatic);
3400b1da:	4628      	mov	r0, r5
3400b1dc:	f106 0150 	add.w	r1, r6, #80	@ 0x50
3400b1e0:	f000 fc9c 	bl	3400bb1c <ISP_SVC_Sensor_SetExposure>
    if (ret != ISP_OK)
3400b1e4:	2800      	cmp	r0, #0
3400b1e6:	d0c3      	beq.n	3400b170 <ISP_Start+0x48>
3400b1e8:	e7f1      	b.n	3400b1ce <ISP_Start+0xa6>
  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3400b1ea:	f896 3070 	ldrb.w	r3, [r6, #112]	@ 0x70
3400b1ee:	2b00      	cmp	r3, #0
3400b1f0:	d1d3      	bne.n	3400b19a <ISP_Start+0x72>
    ret = ISP_SVC_ISP_SetGain(hIsp, &IQParamConfig->ispGainStatic);
3400b1f2:	4628      	mov	r0, r5
3400b1f4:	f506 7106 	add.w	r1, r6, #536	@ 0x218
3400b1f8:	f000 faaa 	bl	3400b750 <ISP_SVC_ISP_SetGain>
    if (ret != ISP_OK)
3400b1fc:	2800      	cmp	r0, #0
3400b1fe:	d0cc      	beq.n	3400b19a <ISP_Start+0x72>
3400b200:	e7e5      	b.n	3400b1ce <ISP_Start+0xa6>
  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3400b202:	f896 3070 	ldrb.w	r3, [r6, #112]	@ 0x70
3400b206:	2b00      	cmp	r3, #0
3400b208:	d1cb      	bne.n	3400b1a2 <ISP_Start+0x7a>
    ret = ISP_SVC_ISP_SetColorConv(hIsp, &IQParamConfig->colorConvStatic);
3400b20a:	4628      	mov	r0, r5
3400b20c:	f506 710a 	add.w	r1, r6, #552	@ 0x228
3400b210:	f000 fb82 	bl	3400b918 <ISP_SVC_ISP_SetColorConv>
    if (ret != ISP_OK)
3400b214:	2800      	cmp	r0, #0
3400b216:	d0c4      	beq.n	3400b1a2 <ISP_Start+0x7a>
3400b218:	e7d9      	b.n	3400b1ce <ISP_Start+0xa6>
  if ((hIsp->statArea.XSize == 0) || (hIsp->statArea.YSize == 0))
3400b21a:	696b      	ldr	r3, [r5, #20]
3400b21c:	2b00      	cmp	r3, #0
3400b21e:	d0c3      	beq.n	3400b1a8 <ISP_Start+0x80>
  ret = ISP_SVC_ISP_SetGamma(hIsp, &IQParamConfig->gamma);
3400b220:	4628      	mov	r0, r5
3400b222:	f506 7114 	add.w	r1, r6, #592	@ 0x250
3400b226:	f000 fcc9 	bl	3400bbbc <ISP_SVC_ISP_SetGamma>
  if (ret != ISP_OK)
3400b22a:	2800      	cmp	r0, #0
3400b22c:	d1cf      	bne.n	3400b1ce <ISP_Start+0xa6>
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
3400b22e:	f996 3069 	ldrsb.w	r3, [r6, #105]	@ 0x69
3400b232:	eeb0 0b00 	vmov.f64	d0, #0	@ 0x40000000  2.0
3400b236:	ee01 3a10 	vmov	s2, r3
3400b23a:	eeba 1aef 	vcvt.f32.s32	s2, s2, #1
3400b23e:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
3400b242:	9001      	str	r0, [sp, #4]
3400b244:	f003 fa68 	bl	3400e718 <pow>
3400b248:	ed9f 7b05 	vldr	d7, [pc, #20]	@ 3400b260 <ISP_Start+0x138>
3400b24c:	ee20 0b07 	vmul.f64	d0, d0, d7
3400b250:	eebc 0bc0 	vcvt.u32.f64	s0, d0
  return ISP_OK;
3400b254:	9801      	ldr	r0, [sp, #4]
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
3400b256:	ed86 0a1b 	vstr	s0, [r6, #108]	@ 0x6c
  return ISP_OK;
3400b25a:	e7b8      	b.n	3400b1ce <ISP_Start+0xa6>
    return ISP_ERR_EINVAL;
3400b25c:	2001      	movs	r0, #1
3400b25e:	e7b6      	b.n	3400b1ce <ISP_Start+0xa6>
3400b260:	00000000 	.word	0x00000000
3400b264:	404c0000 	.word	0x404c0000

3400b268 <ISP_BackgroundProcess>:
  *         Run the background process of the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_BackgroundProcess(ISP_HandleTypeDef *hIsp)
{
3400b268:	b538      	push	{r3, r4, r5, lr}
#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_StatusTypeDef retCmdParser = ISP_OK;
  uint8_t *cmd;
#endif

  if (hIsp == NULL)
3400b26a:	4605      	mov	r5, r0
3400b26c:	b150      	cbz	r0, 3400b284 <ISP_BackgroundProcess+0x1c>
    retCmdParser = ISP_CmdParser_ProcessCommand(hIsp, cmd);
  }
#endif

  /* Check if a statistics gathering cycle has been completed to call the statistic callbacks */
  retStats = ISP_SVC_Stats_ProcessCallbacks(hIsp);
3400b26e:	f000 fed7 	bl	3400c020 <ISP_SVC_Stats_ProcessCallbacks>
3400b272:	4604      	mov	r4, r0

  /* Process the algorithms */
  retAlgo = ISP_Algo_Process(hIsp);
3400b274:	4628      	mov	r0, r5
3400b276:	f7ff fe9a 	bl	3400afae <ISP_Algo_Process>
  else if (retAlgo != ISP_OK)
  {
    return retAlgo;
  }

  return ISP_OK;
3400b27a:	2c00      	cmp	r4, #0
3400b27c:	bf08      	it	eq
3400b27e:	4604      	moveq	r4, r0
}
3400b280:	4620      	mov	r0, r4
3400b282:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_EINVAL;
3400b284:	2401      	movs	r4, #1
3400b286:	e7fb      	b.n	3400b280 <ISP_BackgroundProcess+0x18>

3400b288 <ISP_GatherStatistics>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_GatherStatistics(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Stats_Gather(hIsp);
3400b288:	f000 bcd0 	b.w	3400bc2c <ISP_SVC_Stats_Gather>

3400b28c <ISP_IncMainFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Misc_IncMainFrameId(hIsp);
3400b28c:	f000 bc76 	b.w	3400bb7c <ISP_SVC_Misc_IncMainFrameId>

3400b290 <ISP_IncAncillaryFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
	ISP_SVC_Misc_IncAncillaryFrameId(hIsp);
3400b290:	f000 bc7a 	b.w	3400bb88 <ISP_SVC_Misc_IncAncillaryFrameId>

3400b294 <ISP_IncDumpFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Misc_IncDumpFrameId(hIsp);
3400b294:	f000 bc7c 	b.w	3400bb90 <ISP_SVC_Misc_IncDumpFrameId>

3400b298 <ISP_OutputMeta>:
  *         Print out ISP Meta data for test or debug purpose
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_OutputMeta(ISP_HandleTypeDef *hIsp)
{
3400b298:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  extern ISP_MetaTypeDef Meta;

  if (Meta.outputEnable)
3400b29a:	4a09      	ldr	r2, [pc, #36]	@ (3400b2c0 <ISP_OutputMeta+0x28>)
3400b29c:	7813      	ldrb	r3, [r2, #0]
3400b29e:	b15b      	cbz	r3, 3400b2b8 <ISP_OutputMeta+0x20>
  {
    printf("Meta[%ld]: L = %d, TG = %ld, G = %ld, E = %ld, CT = %ld\r\n", hIsp->MainPipe_FrameCount, Meta.averageL, Meta.exposureTarget, Meta.gain, Meta.exposure, Meta.colorTemp);
3400b2a0:	6913      	ldr	r3, [r2, #16]
3400b2a2:	9302      	str	r3, [sp, #8]
3400b2a4:	68d3      	ldr	r3, [r2, #12]
3400b2a6:	9301      	str	r3, [sp, #4]
3400b2a8:	6893      	ldr	r3, [r2, #8]
3400b2aa:	9300      	str	r3, [sp, #0]
3400b2ac:	6853      	ldr	r3, [r2, #4]
3400b2ae:	6c01      	ldr	r1, [r0, #64]	@ 0x40
3400b2b0:	7852      	ldrb	r2, [r2, #1]
3400b2b2:	4804      	ldr	r0, [pc, #16]	@ (3400b2c4 <ISP_OutputMeta+0x2c>)
3400b2b4:	f002 f996 	bl	3400d5e4 <iprintf>
  }
}
3400b2b8:	b005      	add	sp, #20
3400b2ba:	f85d fb04 	ldr.w	pc, [sp], #4
3400b2be:	bf00      	nop
3400b2c0:	340cfe48 	.word	0x340cfe48
3400b2c4:	340108c3 	.word	0x340108c3

3400b2c8 <GetAvgStats>:

  return (int32_t) Val;
}

static uint8_t GetAvgStats(ISP_HandleTypeDef *hIsp, ISP_SVC_StatLocation location, ISP_SVC_Component component, uint32_t accu)
{
3400b2c8:	b510      	push	{r4, lr}
  uint32_t nb_comp_pix, comp_divider;

  /* Number of pixels computed from Stat Area and considering decimation */
  nb_comp_pix = hIsp->statArea.XSize * hIsp->statArea.YSize;
3400b2ca:	e9d0 4004 	ldrd	r4, r0, [r0, #16]
3400b2ce:	4360      	muls	r0, r4
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
3400b2d0:	4c0d      	ldr	r4, [pc, #52]	@ (3400b308 <GetAvgStats+0x40>)

  if (location == ISP_STAT_LOC_DOWN)
3400b2d2:	2902      	cmp	r1, #2
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
3400b2d4:	7824      	ldrb	r4, [r4, #0]
3400b2d6:	fb04 f404 	mul.w	r4, r4, r4
3400b2da:	fbb0 f0f4 	udiv	r0, r0, r4
  if (location == ISP_STAT_LOC_DOWN)
3400b2de:	d010      	beq.n	3400b302 <GetAvgStats+0x3a>
  }
  else
  {
    /* Only raw bayer sensor expected */
    /* raw bayer: RGB component not present for all pixels */
    comp_divider = (component == ISP_GREEN) ? 2 : 4;
3400b2e0:	2a01      	cmp	r2, #1
3400b2e2:	bf14      	ite	ne
3400b2e4:	2204      	movne	r2, #4
3400b2e6:	2202      	moveq	r2, #2

  /* Number of pixels per component */
  nb_comp_pix /= comp_divider;

  /* Compute average (rounding to closest integer) */
  if (nb_comp_pix == 0)
3400b2e8:	4282      	cmp	r2, r0
  nb_comp_pix /= comp_divider;
3400b2ea:	bf9f      	itttt	ls
3400b2ec:	fbb0 f0f2 	udivls	r0, r0, r2
  {
    return 0;
  }

  return ((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix;
3400b2f0:	0842      	lsrls	r2, r0, #1
3400b2f2:	eb02 2303 	addls.w	r3, r2, r3, lsl #8
3400b2f6:	fbb3 f0f0 	udivls	r0, r3, r0
    return 0;
3400b2fa:	bf8c      	ite	hi
3400b2fc:	2000      	movhi	r0, #0
  return ((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix;
3400b2fe:	b2c0      	uxtbls	r0, r0
}
3400b300:	bd10      	pop	{r4, pc}
    comp_divider = 1;
3400b302:	2201      	movs	r2, #1
3400b304:	e7f0      	b.n	3400b2e8 <GetAvgStats+0x20>
3400b306:	bf00      	nop
3400b308:	34013bea 	.word	0x34013bea

3400b30c <SetStatConfig>:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
  }
}

static void SetStatConfig(DCMIPP_StatisticExtractionConfTypeDef *statConf, const DCMIPP_StatisticExtractionConfTypeDef *refConfig)
{
3400b30c:	b5f0      	push	{r4, r5, r6, r7, lr}
3400b30e:	460b      	mov	r3, r1
3400b310:	4606      	mov	r6, r0
  for (int i = 0; i < 3; i++)
3400b312:	2400      	movs	r4, #0
  {
    statConf[i] = *refConfig;
3400b314:	270c      	movs	r7, #12
3400b316:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
3400b31a:	fb07 6504 	mla	r5, r7, r4, r6
  for (int i = 0; i < 3; i++)
3400b31e:	3401      	adds	r4, #1
3400b320:	2c03      	cmp	r4, #3
    statConf[i] = *refConfig;
3400b322:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  for (int i = 0; i < 3; i++)
3400b326:	d1f6      	bne.n	3400b316 <SetStatConfig+0xa>
  }
}
3400b328:	bdf0      	pop	{r4, r5, r6, r7, pc}

3400b32a <ReadStatHistogram>:
{
3400b32a:	b570      	push	{r4, r5, r6, lr}
3400b32c:	4606      	mov	r6, r0
3400b32e:	460c      	mov	r4, r1
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3400b330:	2501      	movs	r5, #1
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
3400b332:	4623      	mov	r3, r4
3400b334:	b2ea      	uxtb	r2, r5
3400b336:	2101      	movs	r1, #1
3400b338:	6830      	ldr	r0, [r6, #0]
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3400b33a:	3501      	adds	r5, #1
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
3400b33c:	f7f9 fb83 	bl	34004a46 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3400b340:	2d04      	cmp	r5, #4
3400b342:	f104 0404 	add.w	r4, r4, #4
3400b346:	d1f4      	bne.n	3400b332 <ReadStatHistogram+0x8>
}
3400b348:	bd70      	pop	{r4, r5, r6, pc}
3400b34a:	0000      	movs	r0, r0
3400b34c:	0000      	movs	r0, r0
	...

3400b350 <LuminanceFromRGB>:
  }
  return stage;
}

uint8_t LuminanceFromRGB(uint8_t r, uint8_t g, uint8_t b)
{
3400b350:	ee07 1a10 	vmov	s14, r1
3400b354:	ee05 0a10 	vmov	s10, r0
  /* Compute luminance from RGB components (BT.601) */
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
3400b358:	ed9f 4b0f 	vldr	d4, [pc, #60]	@ 3400b398 <LuminanceFromRGB+0x48>
3400b35c:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
{
3400b360:	ee06 2a10 	vmov	s12, r2
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
3400b364:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
3400b368:	ee27 7b04 	vmul.f64	d7, d7, d4
3400b36c:	ed9f 4b0c 	vldr	d4, [pc, #48]	@ 3400b3a0 <LuminanceFromRGB+0x50>
3400b370:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
3400b374:	eea5 7b04 	vfma.f64	d7, d5, d4
3400b378:	ed9f 5b0b 	vldr	d5, [pc, #44]	@ 3400b3a8 <LuminanceFromRGB+0x58>
3400b37c:	eea6 7b05 	vfma.f64	d7, d6, d5
3400b380:	eefc 7bc7 	vcvt.u32.f64	s15, d7
{
3400b384:	b082      	sub	sp, #8
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
3400b386:	edcd 7a01 	vstr	s15, [sp, #4]
}
3400b38a:	f89d 0004 	ldrb.w	r0, [sp, #4]
3400b38e:	b002      	add	sp, #8
3400b390:	4770      	bx	lr
3400b392:	bf00      	nop
3400b394:	f3af 8000 	nop.w
3400b398:	39581062 	.word	0x39581062
3400b39c:	3fe2c8b4 	.word	0x3fe2c8b4
3400b3a0:	e5604189 	.word	0xe5604189
3400b3a4:	3fd322d0 	.word	0x3fd322d0
3400b3a8:	9fbe76c9 	.word	0x9fbe76c9
3400b3ac:	3fbd2f1a 	.word	0x3fbd2f1a

3400b3b0 <ISP_SVC_ISP_SetDemosaicing>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the demosaicing configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDemosaicing(ISP_HandleTypeDef *hIsp, ISP_DemosaicingTypeDef *pConfig)
{
3400b3b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_RawBayer2RGBConfTypeDef rawBayerCfg;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b3b2:	4604      	mov	r4, r0
{
3400b3b4:	b087      	sub	sp, #28
  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b3b6:	2800      	cmp	r0, #0
3400b3b8:	d037      	beq.n	3400b42a <ISP_SVC_ISP_SetDemosaicing+0x7a>
3400b3ba:	2900      	cmp	r1, #0
3400b3bc:	d035      	beq.n	3400b42a <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
3400b3be:	788f      	ldrb	r7, [r1, #2]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b3c0:	2f07      	cmp	r7, #7
3400b3c2:	d832      	bhi.n	3400b42a <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
3400b3c4:	78ce      	ldrb	r6, [r1, #3]
3400b3c6:	2e07      	cmp	r6, #7
3400b3c8:	d82f      	bhi.n	3400b42a <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
3400b3ca:	790d      	ldrb	r5, [r1, #4]
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
3400b3cc:	2d07      	cmp	r5, #7
3400b3ce:	d82c      	bhi.n	3400b42a <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
3400b3d0:	7948      	ldrb	r0, [r1, #5]
3400b3d2:	2807      	cmp	r0, #7
3400b3d4:	d829      	bhi.n	3400b42a <ISP_SVC_ISP_SetDemosaicing+0x7a>
  {
    return ISP_ERR_DEMOSAICING_EINVAL;
  }

  /* Do not enable demosaicing if the camera sensor is a monochrome sensor */
  if ((pConfig->enable == 0) || (pConfig->type == ISP_DEMOS_TYPE_MONO))
3400b3d6:	780b      	ldrb	r3, [r1, #0]
3400b3d8:	b113      	cbz	r3, 3400b3e0 <ISP_SVC_ISP_SetDemosaicing+0x30>
3400b3da:	784a      	ldrb	r2, [r1, #1]
3400b3dc:	2a04      	cmp	r2, #4
3400b3de:	d107      	bne.n	3400b3f0 <ISP_SVC_ISP_SetDemosaicing+0x40>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b3e0:	2101      	movs	r1, #1
3400b3e2:	6820      	ldr	r0, [r4, #0]
3400b3e4:	f7f8 fff0 	bl	340043c8 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3400b3e8:	b100      	cbz	r0, 3400b3ec <ISP_SVC_ISP_SetDemosaicing+0x3c>
  {
    return ISP_ERR_DEMOSAICING_HAL;
3400b3ea:	200b      	movs	r0, #11
  }

  return ISP_OK;
}
3400b3ec:	b007      	add	sp, #28
3400b3ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(pConfig->type)
3400b3f0:	2a02      	cmp	r2, #2
3400b3f2:	d018      	beq.n	3400b426 <ISP_SVC_ISP_SetDemosaicing+0x76>
3400b3f4:	1e51      	subs	r1, r2, #1
3400b3f6:	424b      	negs	r3, r1
3400b3f8:	414b      	adcs	r3, r1
3400b3fa:	2a03      	cmp	r2, #3
3400b3fc:	ea4f 0343 	mov.w	r3, r3, lsl #1
3400b400:	bf08      	it	eq
3400b402:	2306      	moveq	r3, #6
    rawBayerCfg.EdgeStrength = (uint32_t) pConfig->edge;
3400b404:	9005      	str	r0, [sp, #20]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
3400b406:	2101      	movs	r1, #1
3400b408:	6820      	ldr	r0, [r4, #0]
3400b40a:	aa01      	add	r2, sp, #4
    rawBayerCfg.PeakStrength = (uint32_t) pConfig->peak;
3400b40c:	e9cd 3703 	strd	r3, r7, [sp, #12]
    rawBayerCfg.HLineStrength = (uint32_t) pConfig->lineH;
3400b410:	e9cd 6501 	strd	r6, r5, [sp, #4]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
3400b414:	f7f8 ffaa 	bl	3400436c <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>
    if (halStatus == HAL_OK)
3400b418:	2800      	cmp	r0, #0
3400b41a:	d1e6      	bne.n	3400b3ea <ISP_SVC_ISP_SetDemosaicing+0x3a>
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b41c:	2101      	movs	r1, #1
3400b41e:	6820      	ldr	r0, [r4, #0]
3400b420:	f7f8 ffc4 	bl	340043ac <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>
3400b424:	e7e0      	b.n	3400b3e8 <ISP_SVC_ISP_SetDemosaicing+0x38>
    switch(pConfig->type)
3400b426:	2304      	movs	r3, #4
3400b428:	e7ec      	b.n	3400b404 <ISP_SVC_ISP_SetDemosaicing+0x54>
    return ISP_ERR_DEMOSAICING_EINVAL;
3400b42a:	200a      	movs	r0, #10
3400b42c:	e7de      	b.n	3400b3ec <ISP_SVC_ISP_SetDemosaicing+0x3c>

3400b42e <ISP_SVC_ISP_SetStatRemoval>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Stat Removal configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatRemoval(ISP_HandleTypeDef *hIsp, ISP_StatRemovalTypeDef *pConfig)
{
3400b42e:	b510      	push	{r4, lr}
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b430:	4604      	mov	r4, r0
3400b432:	b1d8      	cbz	r0, 3400b46c <ISP_SVC_ISP_SetStatRemoval+0x3e>
3400b434:	b1d1      	cbz	r1, 3400b46c <ISP_SVC_ISP_SetStatRemoval+0x3e>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
3400b436:	684a      	ldr	r2, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b438:	2a07      	cmp	r2, #7
3400b43a:	d817      	bhi.n	3400b46c <ISP_SVC_ISP_SetStatRemoval+0x3e>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
3400b43c:	f640 70fe 	movw	r0, #4094	@ 0xffe
3400b440:	688b      	ldr	r3, [r1, #8]
3400b442:	4283      	cmp	r3, r0
3400b444:	d812      	bhi.n	3400b46c <ISP_SVC_ISP_SetStatRemoval+0x3e>
  {
    return ISP_ERR_STATREMOVAL_EINVAL;
  }

  if (pConfig->enable == 0)
3400b446:	7809      	ldrb	r1, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b448:	6820      	ldr	r0, [r4, #0]
  if (pConfig->enable == 0)
3400b44a:	b921      	cbnz	r1, 3400b456 <ISP_SVC_ISP_SetStatRemoval+0x28>
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b44c:	2101      	movs	r1, #1
3400b44e:	f7f8 ffea 	bl	34004426 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3400b452:	b128      	cbz	r0, 3400b460 <ISP_SVC_ISP_SetStatRemoval+0x32>
3400b454:	e003      	b.n	3400b45e <ISP_SVC_ISP_SetStatRemoval+0x30>
    halStatus = HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->nbHeadLines, pConfig->nbValidLines);
3400b456:	2101      	movs	r1, #1
3400b458:	f7f8 ffc4 	bl	340043e4 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>
    if (halStatus == HAL_OK)
3400b45c:	b108      	cbz	r0, 3400b462 <ISP_SVC_ISP_SetStatRemoval+0x34>
  {
    return ISP_ERR_STATREMOVAL_HAL;
3400b45e:	2015      	movs	r0, #21
  }

  return ISP_OK;
}
3400b460:	bd10      	pop	{r4, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b462:	2101      	movs	r1, #1
3400b464:	6820      	ldr	r0, [r4, #0]
3400b466:	f7f8 ffd0 	bl	3400440a <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>
3400b46a:	e7f2      	b.n	3400b452 <ISP_SVC_ISP_SetStatRemoval+0x24>
    return ISP_ERR_STATREMOVAL_EINVAL;
3400b46c:	2014      	movs	r0, #20
3400b46e:	e7f7      	b.n	3400b460 <ISP_SVC_ISP_SetStatRemoval+0x32>

3400b470 <ISP_SVC_ISP_SetDecimation>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the decimation configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDecimation(ISP_HandleTypeDef *hIsp, ISP_DecimationTypeDef *pConfig)
{
3400b470:	b537      	push	{r0, r1, r2, r4, r5, lr}
3400b472:	460c      	mov	r4, r1
  DCMIPP_DecimationConfTypeDef decimationCfg;
  ISP_StatusTypeDef ret = ISP_OK;

  /* Check handles validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400b474:	4605      	mov	r5, r0
3400b476:	b350      	cbz	r0, 3400b4ce <ISP_SVC_ISP_SetDecimation+0x5e>
3400b478:	b349      	cbz	r1, 3400b4ce <ISP_SVC_ISP_SetDecimation+0x5e>
  {
    return ISP_ERR_DECIMATION_EINVAL;
  }

  switch (pConfig->factor)
3400b47a:	780b      	ldrb	r3, [r1, #0]
3400b47c:	3b01      	subs	r3, #1
3400b47e:	2b07      	cmp	r3, #7
3400b480:	d825      	bhi.n	3400b4ce <ISP_SVC_ISP_SetDecimation+0x5e>
3400b482:	e8df f003 	tbb	[pc, r3]
3400b486:	0417      	.short	0x0417
3400b488:	24241124 	.word	0x24241124
3400b48c:	1424      	.short	0x1424
3400b48e:	2308      	movs	r3, #8
3400b490:	2202      	movs	r2, #2
  {
  case ISP_DECIM_FACTOR_1:
    decimationCfg.VRatio = DCMIPP_VDEC_ALL;
    decimationCfg.HRatio = DCMIPP_HDEC_ALL;
3400b492:	e9cd 3200 	strd	r3, r2, [sp]

  default:
    return ISP_ERR_DECIMATION_EINVAL;
  }

  if (HAL_DCMIPP_PIPE_SetISPDecimationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &decimationCfg) != HAL_OK)
3400b496:	2101      	movs	r1, #1
3400b498:	466a      	mov	r2, sp
3400b49a:	6828      	ldr	r0, [r5, #0]
3400b49c:	f7f8 fe4b 	bl	34004136 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>
3400b4a0:	b158      	cbz	r0, 3400b4ba <ISP_SVC_ISP_SetDecimation+0x4a>
  {
    return ISP_ERR_DECIMATION_HAL;
3400b4a2:	201f      	movs	r0, #31

  /* Save decimation value */
  ISP_DecimationValue.factor = pConfig->factor;

  return ret;
}
3400b4a4:	b003      	add	sp, #12
3400b4a6:	bd30      	pop	{r4, r5, pc}
    break;
3400b4a8:	2310      	movs	r3, #16
3400b4aa:	2204      	movs	r2, #4
3400b4ac:	e7f1      	b.n	3400b492 <ISP_SVC_ISP_SetDecimation+0x22>
    break;
3400b4ae:	2318      	movs	r3, #24
3400b4b0:	2206      	movs	r2, #6
3400b4b2:	e7ee      	b.n	3400b492 <ISP_SVC_ISP_SetDecimation+0x22>
  switch (pConfig->factor)
3400b4b4:	2300      	movs	r3, #0
3400b4b6:	461a      	mov	r2, r3
3400b4b8:	e7eb      	b.n	3400b492 <ISP_SVC_ISP_SetDecimation+0x22>
  if (HAL_DCMIPP_PIPE_EnableISPDecimation(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3400b4ba:	2101      	movs	r1, #1
3400b4bc:	6828      	ldr	r0, [r5, #0]
3400b4be:	f7f8 fe50 	bl	34004162 <HAL_DCMIPP_PIPE_EnableISPDecimation>
3400b4c2:	2800      	cmp	r0, #0
3400b4c4:	d1ed      	bne.n	3400b4a2 <ISP_SVC_ISP_SetDecimation+0x32>
  ISP_DecimationValue.factor = pConfig->factor;
3400b4c6:	7822      	ldrb	r2, [r4, #0]
3400b4c8:	4b02      	ldr	r3, [pc, #8]	@ (3400b4d4 <ISP_SVC_ISP_SetDecimation+0x64>)
3400b4ca:	701a      	strb	r2, [r3, #0]
  return ret;
3400b4cc:	e7ea      	b.n	3400b4a4 <ISP_SVC_ISP_SetDecimation+0x34>
  switch (pConfig->factor)
3400b4ce:	201e      	movs	r0, #30
3400b4d0:	e7e8      	b.n	3400b4a4 <ISP_SVC_ISP_SetDecimation+0x34>
3400b4d2:	bf00      	nop
3400b4d4:	34013bea 	.word	0x34013bea

3400b4d8 <ISP_SVC_ISP_SetContrast>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the contrast configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetContrast(ISP_HandleTypeDef *hIsp, ISP_ContrastTypeDef *pConfig)
{
3400b4d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_ContrastConfTypeDef contrast;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b4dc:	4605      	mov	r5, r0
{
3400b4de:	b085      	sub	sp, #20
  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b4e0:	2800      	cmp	r0, #0
3400b4e2:	d071      	beq.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
3400b4e4:	2900      	cmp	r1, #0
3400b4e6:	d06f      	beq.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b4e8:	684b      	ldr	r3, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b4ea:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3400b4ee:	d86b      	bhi.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b4f0:	f8d1 9008 	ldr.w	r9, [r1, #8]
3400b4f4:	f5b9 7fc5 	cmp.w	r9, #394	@ 0x18a
3400b4f8:	d866      	bhi.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b4fa:	f8d1 800c 	ldr.w	r8, [r1, #12]
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b4fe:	f5b8 7fc5 	cmp.w	r8, #394	@ 0x18a
3400b502:	d861      	bhi.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b504:	f8d1 e010 	ldr.w	lr, [r1, #16]
3400b508:	f5be 7fc5 	cmp.w	lr, #394	@ 0x18a
3400b50c:	d85c      	bhi.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b50e:	f8d1 c014 	ldr.w	ip, [r1, #20]
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b512:	f5bc 7fc5 	cmp.w	ip, #394	@ 0x18a
3400b516:	d857      	bhi.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b518:	698f      	ldr	r7, [r1, #24]
3400b51a:	f5b7 7fc5 	cmp.w	r7, #394	@ 0x18a
3400b51e:	d853      	bhi.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b520:	69ce      	ldr	r6, [r1, #28]
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b522:	f5b6 7fc5 	cmp.w	r6, #394	@ 0x18a
3400b526:	d84f      	bhi.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b528:	6a0c      	ldr	r4, [r1, #32]
3400b52a:	f5b4 7fc5 	cmp.w	r4, #394	@ 0x18a
3400b52e:	d84b      	bhi.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_256 > ISP_CONTAST_LUMCOEFF_MAX))
3400b530:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3400b532:	f5b2 7fc5 	cmp.w	r2, #394	@ 0x18a
3400b536:	d847      	bhi.n	3400b5c8 <ISP_SVC_ISP_SetContrast+0xf0>
  {
    return ISP_ERR_CONTRAST_EINVAL;
  }

  if (pConfig->enable == 0)
3400b538:	7809      	ldrb	r1, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b53a:	6800      	ldr	r0, [r0, #0]
  if (pConfig->enable == 0)
3400b53c:	b921      	cbnz	r1, 3400b548 <ISP_SVC_ISP_SetContrast+0x70>
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b53e:	2101      	movs	r1, #1
3400b540:	f7f9 f9d1 	bl	340048e6 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3400b544:	b3c0      	cbz	r0, 3400b5b8 <ISP_SVC_ISP_SetContrast+0xe0>
3400b546:	e036      	b.n	3400b5b6 <ISP_SVC_ISP_SetContrast+0xde>
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
3400b548:	0119      	lsls	r1, r3, #4
3400b54a:	2364      	movs	r3, #100	@ 0x64
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
3400b54c:	0112      	lsls	r2, r2, #4
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
3400b54e:	fbb1 f1f3 	udiv	r1, r1, r3
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
3400b552:	fbb2 f2f3 	udiv	r2, r2, r3
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
3400b556:	ea4f 1909 	mov.w	r9, r9, lsl #4
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
3400b55a:	ea4f 1808 	mov.w	r8, r8, lsl #4
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
3400b55e:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
3400b562:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
3400b566:	013f      	lsls	r7, r7, #4
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
3400b568:	0136      	lsls	r6, r6, #4
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
3400b56a:	0124      	lsls	r4, r4, #4
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
3400b56c:	fbb9 f9f3 	udiv	r9, r9, r3
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
3400b570:	fbb8 f8f3 	udiv	r8, r8, r3
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
3400b574:	fbbe fef3 	udiv	lr, lr, r3
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
3400b578:	fbbc fcf3 	udiv	ip, ip, r3
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
3400b57c:	fbb7 f7f3 	udiv	r7, r7, r3
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
3400b580:	fbb6 f6f3 	udiv	r6, r6, r3
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
3400b584:	fbb4 f4f3 	udiv	r4, r4, r3
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
3400b588:	f88d 1004 	strb.w	r1, [sp, #4]
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
3400b58c:	f88d 200c 	strb.w	r2, [sp, #12]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
3400b590:	2101      	movs	r1, #1
3400b592:	aa01      	add	r2, sp, #4
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
3400b594:	f88d 9005 	strb.w	r9, [sp, #5]
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
3400b598:	f88d 8006 	strb.w	r8, [sp, #6]
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
3400b59c:	f88d e007 	strb.w	lr, [sp, #7]
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
3400b5a0:	f88d c008 	strb.w	ip, [sp, #8]
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
3400b5a4:	f88d 7009 	strb.w	r7, [sp, #9]
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
3400b5a8:	f88d 600a 	strb.w	r6, [sp, #10]
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
3400b5ac:	f88d 400b 	strb.w	r4, [sp, #11]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
3400b5b0:	f7f9 f95f 	bl	34004872 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>
    if (halStatus == HAL_OK)
3400b5b4:	b118      	cbz	r0, 3400b5be <ISP_SVC_ISP_SetContrast+0xe6>
  {
    return ISP_ERR_CONTRAST_HAL;
3400b5b6:	2029      	movs	r0, #41	@ 0x29
  }

  return ISP_OK;
}
3400b5b8:	b005      	add	sp, #20
3400b5ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b5be:	2101      	movs	r1, #1
3400b5c0:	6828      	ldr	r0, [r5, #0]
3400b5c2:	f7f9 f982 	bl	340048ca <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>
3400b5c6:	e7bd      	b.n	3400b544 <ISP_SVC_ISP_SetContrast+0x6c>
    return ISP_ERR_CONTRAST_EINVAL;
3400b5c8:	2028      	movs	r0, #40	@ 0x28
3400b5ca:	e7f5      	b.n	3400b5b8 <ISP_SVC_ISP_SetContrast+0xe0>

3400b5cc <ISP_SVC_ISP_SetStatArea>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to statistic area used by the IQ algorithms
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatArea(ISP_HandleTypeDef *hIsp, ISP_StatAreaTypeDef *pConfig)
{
3400b5cc:	b5f0      	push	{r4, r5, r6, r7, lr}
3400b5ce:	460e      	mov	r6, r1
  HAL_StatusTypeDef halStatus;
  DCMIPP_StatisticExtractionAreaConfTypeDef currentStatAreaCfg;
  ISP_StatusTypeDef ret = ISP_OK;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b5d0:	4605      	mov	r5, r0
{
3400b5d2:	b085      	sub	sp, #20
  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b5d4:	2800      	cmp	r0, #0
3400b5d6:	d041      	beq.n	3400b65c <ISP_SVC_ISP_SetStatArea+0x90>
3400b5d8:	2900      	cmp	r1, #0
3400b5da:	d03f      	beq.n	3400b65c <ISP_SVC_ISP_SetStatArea+0x90>
3400b5dc:	f640 72fe 	movw	r2, #4094	@ 0xffe
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
3400b5e0:	6808      	ldr	r0, [r1, #0]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b5e2:	4290      	cmp	r0, r2
3400b5e4:	d83a      	bhi.n	3400b65c <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
3400b5e6:	6849      	ldr	r1, [r1, #4]
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
3400b5e8:	4291      	cmp	r1, r2
3400b5ea:	d837      	bhi.n	3400b65c <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
3400b5ec:	68b3      	ldr	r3, [r6, #8]
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
3400b5ee:	4293      	cmp	r3, r2
3400b5f0:	d834      	bhi.n	3400b65c <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
3400b5f2:	f640 74fa 	movw	r4, #4090	@ 0xffa
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
3400b5f6:	68f2      	ldr	r2, [r6, #12]
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
3400b5f8:	1f17      	subs	r7, r2, #4
3400b5fa:	42a7      	cmp	r7, r4
3400b5fc:	d82e      	bhi.n	3400b65c <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
3400b5fe:	2b03      	cmp	r3, #3
3400b600:	d92c      	bls.n	3400b65c <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
3400b602:	6f2f      	ldr	r7, [r5, #112]	@ 0x70
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
3400b604:	18c4      	adds	r4, r0, r3
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
3400b606:	42bc      	cmp	r4, r7
3400b608:	d828      	bhi.n	3400b65c <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
3400b60a:	6f6f      	ldr	r7, [r5, #116]	@ 0x74
      (pConfig->Y0 + pConfig->YSize > hIsp->sensorInfo.height))
3400b60c:	188c      	adds	r4, r1, r2
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
3400b60e:	42bc      	cmp	r4, r7
3400b610:	d824      	bhi.n	3400b65c <ISP_SVC_ISP_SetStatArea+0x90>
  {
    return ISP_ERR_STATAREA_EINVAL;
  }

  /* Set coordinates in the 'decimated' referential */
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
3400b612:	4c13      	ldr	r4, [pc, #76]	@ (3400b660 <ISP_SVC_ISP_SetStatArea+0x94>)
3400b614:	7824      	ldrb	r4, [r4, #0]
3400b616:	fbb0 f0f4 	udiv	r0, r0, r4
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
3400b61a:	fbb1 f1f4 	udiv	r1, r1, r4
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
3400b61e:	fbb2 f2f4 	udiv	r2, r2, r4
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
3400b622:	fbb3 f3f4 	udiv	r3, r3, r4
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
3400b626:	9001      	str	r0, [sp, #4]
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
3400b628:	9100      	str	r1, [sp, #0]
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
3400b62a:	9202      	str	r2, [sp, #8]

  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
3400b62c:	2101      	movs	r1, #1
3400b62e:	466a      	mov	r2, sp
3400b630:	6828      	ldr	r0, [r5, #0]
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
3400b632:	9303      	str	r3, [sp, #12]
  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
3400b634:	f7f9 f890 	bl	34004758 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>
3400b638:	b118      	cbz	r0, 3400b642 <ISP_SVC_ISP_SetStatArea+0x76>
                                                          &currentStatAreaCfg) != HAL_OK)
  {
    return ISP_ERR_STATAREA_HAL;
3400b63a:	2433      	movs	r4, #51	@ 0x33

  /* Update internal state */
  hIsp->statArea = *pConfig;

  return ret;
}
3400b63c:	4620      	mov	r0, r4
3400b63e:	b005      	add	sp, #20
3400b640:	bdf0      	pop	{r4, r5, r6, r7, pc}
    halStatus = HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b642:	2101      	movs	r1, #1
3400b644:	6828      	ldr	r0, [r5, #0]
3400b646:	f7f9 f8c7 	bl	340047d8 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>
  if (halStatus != HAL_OK)
3400b64a:	4604      	mov	r4, r0
3400b64c:	2800      	cmp	r0, #0
3400b64e:	d1f4      	bne.n	3400b63a <ISP_SVC_ISP_SetStatArea+0x6e>
  hIsp->statArea = *pConfig;
3400b650:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
3400b654:	3508      	adds	r5, #8
3400b656:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  return ret;
3400b65a:	e7ef      	b.n	3400b63c <ISP_SVC_ISP_SetStatArea+0x70>
    return ISP_ERR_STATAREA_EINVAL;
3400b65c:	2432      	movs	r4, #50	@ 0x32
3400b65e:	e7ed      	b.n	3400b63c <ISP_SVC_ISP_SetStatArea+0x70>
3400b660:	34013bea 	.word	0x34013bea

3400b664 <ISP_SVC_ISP_SetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
3400b664:	b510      	push	{r4, lr}
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) || (pConfig->strength > ISP_BADPIXEL_STRENGTH_MAX))
3400b666:	4604      	mov	r4, r0
3400b668:	b1a8      	cbz	r0, 3400b696 <ISP_SVC_ISP_SetBadPixel+0x32>
3400b66a:	b1a1      	cbz	r1, 3400b696 <ISP_SVC_ISP_SetBadPixel+0x32>
3400b66c:	784a      	ldrb	r2, [r1, #1]
3400b66e:	2a07      	cmp	r2, #7
3400b670:	d811      	bhi.n	3400b696 <ISP_SVC_ISP_SetBadPixel+0x32>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
  }

  if (pConfig->enable == 0)
3400b672:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b674:	6800      	ldr	r0, [r0, #0]
3400b676:	2101      	movs	r1, #1
  if (pConfig->enable == 0)
3400b678:	b91b      	cbnz	r3, 3400b682 <ISP_SVC_ISP_SetBadPixel+0x1e>
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b67a:	f7f8 ff00 	bl	3400447e <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>
    }

    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
  }

  if (halStatus != HAL_OK)
3400b67e:	b120      	cbz	r0, 3400b68a <ISP_SVC_ISP_SetBadPixel+0x26>
3400b680:	e002      	b.n	3400b688 <ISP_SVC_ISP_SetBadPixel+0x24>
    halStatus = HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->strength);
3400b682:	f7f8 fede 	bl	34004442 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>
    if (halStatus != HAL_OK)
3400b686:	b108      	cbz	r0, 3400b68c <ISP_SVC_ISP_SetBadPixel+0x28>
      return ISP_ERR_BADPIXEL_HAL;
3400b688:	203d      	movs	r0, #61	@ 0x3d
  {
    return ISP_ERR_BADPIXEL_HAL;
  }

  return ISP_OK;
}
3400b68a:	bd10      	pop	{r4, pc}
    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b68c:	2101      	movs	r1, #1
3400b68e:	6820      	ldr	r0, [r4, #0]
3400b690:	f7f8 fee7 	bl	34004462 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>
3400b694:	e7f3      	b.n	3400b67e <ISP_SVC_ISP_SetBadPixel+0x1a>
    return ISP_ERR_BADPIXEL_EINVAL;
3400b696:	203c      	movs	r0, #60	@ 0x3c
3400b698:	e7f7      	b.n	3400b68a <ISP_SVC_ISP_SetBadPixel+0x26>

3400b69a <ISP_SVC_ISP_GetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
3400b69a:	b538      	push	{r3, r4, r5, lr}
3400b69c:	460d      	mov	r5, r1
  HAL_StatusTypeDef halStatus;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400b69e:	4604      	mov	r4, r0
3400b6a0:	b198      	cbz	r0, 3400b6ca <ISP_SVC_ISP_GetBadPixel+0x30>
3400b6a2:	b191      	cbz	r1, 3400b6ca <ISP_SVC_ISP_GetBadPixel+0x30>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b6a4:	2101      	movs	r1, #1
3400b6a6:	6800      	ldr	r0, [r0, #0]
3400b6a8:	f7f8 fefd 	bl	340044a6 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>
3400b6ac:	7028      	strb	r0, [r5, #0]
  pConfig->strength = (uint8_t) HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b6ae:	2101      	movs	r1, #1
3400b6b0:	6820      	ldr	r0, [r4, #0]
3400b6b2:	f7f8 fef2 	bl	3400449a <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>
3400b6b6:	7068      	strb	r0, [r5, #1]

  halStatus = HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(hIsp->hDcmipp, DCMIPP_PIPE1, &pConfig->count);
3400b6b8:	2101      	movs	r1, #1
3400b6ba:	6820      	ldr	r0, [r4, #0]
3400b6bc:	1d2a      	adds	r2, r5, #4
3400b6be:	f7f8 fefb 	bl	340044b8 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>

  if (halStatus != HAL_OK)
  {
    return ISP_ERR_BADPIXEL_HAL;
3400b6c2:	2800      	cmp	r0, #0
3400b6c4:	bf18      	it	ne
3400b6c6:	203d      	movne	r0, #61	@ 0x3d
  }

  return ISP_OK;
}
3400b6c8:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_BADPIXEL_EINVAL;
3400b6ca:	203c      	movs	r0, #60	@ 0x3c
3400b6cc:	e7fc      	b.n	3400b6c8 <ISP_SVC_ISP_GetBadPixel+0x2e>

3400b6ce <ISP_SVC_ISP_SetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
3400b6ce:	b513      	push	{r0, r1, r4, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400b6d0:	4604      	mov	r4, r0
3400b6d2:	b1f0      	cbz	r0, 3400b712 <ISP_SVC_ISP_SetBlackLevel+0x44>
3400b6d4:	b1e9      	cbz	r1, 3400b712 <ISP_SVC_ISP_SetBlackLevel+0x44>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
  }

  if (pConfig->enable == 0)
3400b6d6:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b6d8:	6800      	ldr	r0, [r0, #0]
  if (pConfig->enable == 0)
3400b6da:	b923      	cbnz	r3, 3400b6e6 <ISP_SVC_ISP_SetBlackLevel+0x18>
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b6dc:	2101      	movs	r1, #1
3400b6de:	f7f8 ffed 	bl	340046bc <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3400b6e2:	b178      	cbz	r0, 3400b704 <ISP_SVC_ISP_SetBlackLevel+0x36>
3400b6e4:	e00d      	b.n	3400b702 <ISP_SVC_ISP_SetBlackLevel+0x34>
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
3400b6e6:	784b      	ldrb	r3, [r1, #1]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
3400b6e8:	aa01      	add	r2, sp, #4
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
3400b6ea:	f88d 3004 	strb.w	r3, [sp, #4]
    blackLevelConfig.GreenCompBlackLevel = pConfig->BLCG;
3400b6ee:	788b      	ldrb	r3, [r1, #2]
3400b6f0:	f88d 3005 	strb.w	r3, [sp, #5]
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
3400b6f4:	78cb      	ldrb	r3, [r1, #3]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
3400b6f6:	2101      	movs	r1, #1
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
3400b6f8:	f88d 3006 	strb.w	r3, [sp, #6]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
3400b6fc:	f7f8 ffb8 	bl	34004670 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>
    if (halStatus == HAL_OK)
3400b700:	b110      	cbz	r0, 3400b708 <ISP_SVC_ISP_SetBlackLevel+0x3a>
  {
    return ISP_ERR_BLACKLEVEL_HAL;
3400b702:	2047      	movs	r0, #71	@ 0x47
  }

  return ISP_OK;
}
3400b704:	b002      	add	sp, #8
3400b706:	bd10      	pop	{r4, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b708:	2101      	movs	r1, #1
3400b70a:	6820      	ldr	r0, [r4, #0]
3400b70c:	f7f8 ffc8 	bl	340046a0 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>
3400b710:	e7e7      	b.n	3400b6e2 <ISP_SVC_ISP_SetBlackLevel+0x14>
    return ISP_ERR_BLACKLEVEL_EINVAL;
3400b712:	2046      	movs	r0, #70	@ 0x46
3400b714:	e7f6      	b.n	3400b704 <ISP_SVC_ISP_SetBlackLevel+0x36>

3400b716 <ISP_SVC_ISP_GetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
3400b716:	b537      	push	{r0, r1, r2, r4, r5, lr}
3400b718:	460c      	mov	r4, r1
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400b71a:	4605      	mov	r5, r0
3400b71c:	b1b0      	cbz	r0, 3400b74c <ISP_SVC_ISP_GetBlackLevel+0x36>
3400b71e:	b1a9      	cbz	r1, 3400b74c <ISP_SVC_ISP_GetBlackLevel+0x36>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b720:	2101      	movs	r1, #1
3400b722:	6800      	ldr	r0, [r0, #0]
3400b724:	f7f8 ffe4 	bl	340046f0 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration>
3400b728:	7020      	strb	r0, [r4, #0]

  HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
3400b72a:	6828      	ldr	r0, [r5, #0]
3400b72c:	2101      	movs	r1, #1
3400b72e:	aa01      	add	r2, sp, #4
3400b730:	f7f8 ffd2 	bl	340046d8 <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig>

  pConfig->BLCR = blackLevelConfig.RedCompBlackLevel;
  pConfig->BLCG = blackLevelConfig.GreenCompBlackLevel;
  pConfig->BLCB = blackLevelConfig.BlueCompBlackLevel;

  return ISP_OK;
3400b734:	2000      	movs	r0, #0
  pConfig->BLCR = blackLevelConfig.RedCompBlackLevel;
3400b736:	f89d 3004 	ldrb.w	r3, [sp, #4]
3400b73a:	7063      	strb	r3, [r4, #1]
  pConfig->BLCG = blackLevelConfig.GreenCompBlackLevel;
3400b73c:	f89d 3005 	ldrb.w	r3, [sp, #5]
3400b740:	70a3      	strb	r3, [r4, #2]
  pConfig->BLCB = blackLevelConfig.BlueCompBlackLevel;
3400b742:	f89d 3006 	ldrb.w	r3, [sp, #6]
3400b746:	70e3      	strb	r3, [r4, #3]
}
3400b748:	b003      	add	sp, #12
3400b74a:	bd30      	pop	{r4, r5, pc}
    return ISP_ERR_BLACKLEVEL_EINVAL;
3400b74c:	2046      	movs	r0, #70	@ 0x46
3400b74e:	e7fb      	b.n	3400b748 <ISP_SVC_ISP_GetBlackLevel+0x32>

3400b750 <ISP_SVC_ISP_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
3400b750:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_ExposureConfTypeDef exposureConfig;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b754:	4605      	mov	r5, r0
3400b756:	2800      	cmp	r0, #0
3400b758:	f000 808b 	beq.w	3400b872 <ISP_SVC_ISP_SetGain+0x122>
3400b75c:	2900      	cmp	r1, #0
3400b75e:	f000 8088 	beq.w	3400b872 <ISP_SVC_ISP_SetGain+0x122>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
3400b762:	684a      	ldr	r2, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3400b764:	4b46      	ldr	r3, [pc, #280]	@ (3400b880 <ISP_SVC_ISP_SetGain+0x130>)
3400b766:	429a      	cmp	r2, r3
3400b768:	f200 8083 	bhi.w	3400b872 <ISP_SVC_ISP_SetGain+0x122>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
3400b76c:	f8d1 8008 	ldr.w	r8, [r1, #8]
3400b770:	4598      	cmp	r8, r3
3400b772:	d87e      	bhi.n	3400b872 <ISP_SVC_ISP_SetGain+0x122>
3400b774:	68cf      	ldr	r7, [r1, #12]
3400b776:	429f      	cmp	r7, r3
3400b778:	d87b      	bhi.n	3400b872 <ISP_SVC_ISP_SetGain+0x122>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
  }

  if (pConfig->enable == 0)
3400b77a:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b77c:	6806      	ldr	r6, [r0, #0]
  if (pConfig->enable == 0)
3400b77e:	b933      	cbnz	r3, 3400b78e <ISP_SVC_ISP_SetGain+0x3e>
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b780:	2101      	movs	r1, #1
3400b782:	4630      	mov	r0, r6
3400b784:	f7f9 f867 	bl	34004856 <HAL_DCMIPP_PIPE_DisableISPExposure>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3400b788:	2800      	cmp	r0, #0
3400b78a:	d05b      	beq.n	3400b844 <ISP_SVC_ISP_SetGain+0xf4>
3400b78c:	e059      	b.n	3400b842 <ISP_SVC_ISP_SetGain+0xf2>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b78e:	2400      	movs	r4, #0
3400b790:	4610      	mov	r0, r2
3400b792:	a339      	add	r3, pc, #228	@ (adr r3, 3400b878 <ISP_SVC_ISP_SetGain+0x128>)
3400b794:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b798:	4621      	mov	r1, r4
3400b79a:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
3400b79e:	f7f5 ff1d 	bl	340015dc <__aeabi_uldivmod>
  while (Val >= 256)
3400b7a2:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b7a4:	4682      	mov	sl, r0
3400b7a6:	468b      	mov	fp, r1
  while (Val >= 256)
3400b7a8:	4622      	mov	r2, r4
3400b7aa:	f5ba 7f80 	cmp.w	sl, #256	@ 0x100
3400b7ae:	f17b 0000 	sbcs.w	r0, fp, #0
3400b7b2:	f103 0101 	add.w	r1, r3, #1
3400b7b6:	d248      	bcs.n	3400b84a <ISP_SVC_ISP_SetGain+0xfa>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b7b8:	2400      	movs	r4, #0
  *pShift = 0;
3400b7ba:	2a00      	cmp	r2, #0
3400b7bc:	bf08      	it	eq
3400b7be:	4613      	moveq	r3, r2
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b7c0:	4640      	mov	r0, r8
3400b7c2:	4621      	mov	r1, r4
  *pShift = 0;
3400b7c4:	f88d 3000 	strb.w	r3, [sp]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b7c8:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
3400b7cc:	a32a      	add	r3, pc, #168	@ (adr r3, 3400b878 <ISP_SVC_ISP_SetGain+0x128>)
3400b7ce:	e9d3 2300 	ldrd	r2, r3, [r3]
  *pMultiplier = Val;
3400b7d2:	f88d a001 	strb.w	sl, [sp, #1]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b7d6:	f7f5 ff01 	bl	340015dc <__aeabi_uldivmod>
  while (Val >= 256)
3400b7da:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b7dc:	4680      	mov	r8, r0
3400b7de:	4689      	mov	r9, r1
  while (Val >= 256)
3400b7e0:	4622      	mov	r2, r4
3400b7e2:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
3400b7e6:	f179 0000 	sbcs.w	r0, r9, #0
3400b7ea:	f103 0101 	add.w	r1, r3, #1
3400b7ee:	d231      	bcs.n	3400b854 <ISP_SVC_ISP_SetGain+0x104>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b7f0:	2400      	movs	r4, #0
  *pShift = 0;
3400b7f2:	2a00      	cmp	r2, #0
3400b7f4:	bf08      	it	eq
3400b7f6:	4613      	moveq	r3, r2
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b7f8:	4638      	mov	r0, r7
3400b7fa:	4621      	mov	r1, r4
  *pShift = 0;
3400b7fc:	f88d 3002 	strb.w	r3, [sp, #2]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b800:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
3400b804:	a31c      	add	r3, pc, #112	@ (adr r3, 3400b878 <ISP_SVC_ISP_SetGain+0x128>)
3400b806:	e9d3 2300 	ldrd	r2, r3, [r3]
  *pMultiplier = Val;
3400b80a:	f88d 8003 	strb.w	r8, [sp, #3]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b80e:	f7f5 fee5 	bl	340015dc <__aeabi_uldivmod>
  while (Val >= 256)
3400b812:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3400b814:	4680      	mov	r8, r0
3400b816:	4689      	mov	r9, r1
  while (Val >= 256)
3400b818:	4622      	mov	r2, r4
3400b81a:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
3400b81e:	f179 0000 	sbcs.w	r0, r9, #0
3400b822:	f103 0101 	add.w	r1, r3, #1
3400b826:	d21a      	bcs.n	3400b85e <ISP_SVC_ISP_SetGain+0x10e>
  *pShift = 0;
3400b828:	2a00      	cmp	r2, #0
3400b82a:	bf08      	it	eq
3400b82c:	4613      	moveq	r3, r2
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
3400b82e:	2101      	movs	r1, #1
3400b830:	466a      	mov	r2, sp
3400b832:	4630      	mov	r0, r6
  *pShift = 0;
3400b834:	f88d 3004 	strb.w	r3, [sp, #4]
  *pMultiplier = Val;
3400b838:	f88d 8005 	strb.w	r8, [sp, #5]
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
3400b83c:	f7f8 ffda 	bl	340047f4 <HAL_DCMIPP_PIPE_SetISPExposureConfig>
    if (halStatus == HAL_OK)
3400b840:	b190      	cbz	r0, 3400b868 <ISP_SVC_ISP_SetGain+0x118>
  {
    return ISP_ERR_ISPGAIN_HAL;
3400b842:	2051      	movs	r0, #81	@ 0x51
  }

  return ISP_OK;
}
3400b844:	b003      	add	sp, #12
3400b846:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Val /= 2;
3400b84a:	ea5a 0b5f 	orrs.w	fp, sl, pc, lsr #1
3400b84e:	460b      	mov	r3, r1
3400b850:	2201      	movs	r2, #1
3400b852:	e7aa      	b.n	3400b7aa <ISP_SVC_ISP_SetGain+0x5a>
3400b854:	ea58 095f 	orrs.w	r9, r8, pc, lsr #1
3400b858:	460b      	mov	r3, r1
3400b85a:	2201      	movs	r2, #1
3400b85c:	e7c1      	b.n	3400b7e2 <ISP_SVC_ISP_SetGain+0x92>
3400b85e:	ea58 095f 	orrs.w	r9, r8, pc, lsr #1
3400b862:	460b      	mov	r3, r1
3400b864:	2201      	movs	r2, #1
3400b866:	e7d8      	b.n	3400b81a <ISP_SVC_ISP_SetGain+0xca>
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b868:	2101      	movs	r1, #1
3400b86a:	6828      	ldr	r0, [r5, #0]
3400b86c:	f7f8 ffe5 	bl	3400483a <HAL_DCMIPP_PIPE_EnableISPExposure>
3400b870:	e78a      	b.n	3400b788 <ISP_SVC_ISP_SetGain+0x38>
    return ISP_ERR_ISPGAIN_EINVAL;
3400b872:	2050      	movs	r0, #80	@ 0x50
3400b874:	e7e6      	b.n	3400b844 <ISP_SVC_ISP_SetGain+0xf4>
3400b876:	bf00      	nop
3400b878:	05f5e100 	.word	0x05f5e100
3400b87c:	00000000 	.word	0x00000000
3400b880:	5f5e1000 	.word	0x5f5e1000

3400b884 <ISP_SVC_ISP_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
3400b884:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400b886:	460c      	mov	r4, r1
  DCMIPP_ExposureConfTypeDef exposureConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400b888:	4605      	mov	r5, r0
3400b88a:	2800      	cmp	r0, #0
3400b88c:	d03f      	beq.n	3400b90e <ISP_SVC_ISP_GetGain+0x8a>
3400b88e:	2900      	cmp	r1, #0
3400b890:	d03d      	beq.n	3400b90e <ISP_SVC_ISP_GetGain+0x8a>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b892:	2101      	movs	r1, #1
3400b894:	6800      	ldr	r0, [r0, #0]
3400b896:	f7f9 f9a1 	bl	34004bdc <HAL_DCMIPP_PIPE_IsEnabledISPExposure>
3400b89a:	7020      	strb	r0, [r4, #0]
  HAL_DCMIPP_PIPE_GetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
3400b89c:	6828      	ldr	r0, [r5, #0]
3400b89e:	466a      	mov	r2, sp
3400b8a0:	2101      	movs	r1, #1
3400b8a2:	f7f9 f8ed 	bl	34004a80 <HAL_DCMIPP_PIPE_GetISPExposureConfig>
  uint64_t Val = (1 << Shift);
3400b8a6:	2301      	movs	r3, #1
3400b8a8:	f89d 1000 	ldrb.w	r1, [sp]
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
3400b8ac:	f89d 2001 	ldrb.w	r2, [sp, #1]
  uint64_t Val = (1 << Shift);
3400b8b0:	fa03 f101 	lsl.w	r1, r3, r1
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
3400b8b4:	fb81 1002 	smull	r1, r0, r1, r2
3400b8b8:	4a16      	ldr	r2, [pc, #88]	@ (3400b914 <ISP_SVC_ISP_GetGain+0x90>)
3400b8ba:	fba1 1502 	umull	r1, r5, r1, r2
3400b8be:	460e      	mov	r6, r1
3400b8c0:	fb02 5700 	mla	r7, r2, r0, r5
3400b8c4:	ea56 17df 	orrs.w	r7, r6, pc, lsr #7
  uint64_t Val = (1 << Shift);
3400b8c8:	f89d 0002 	ldrb.w	r0, [sp, #2]
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
3400b8cc:	f89d 1003 	ldrb.w	r1, [sp, #3]
  uint64_t Val = (1 << Shift);
3400b8d0:	fa03 f000 	lsl.w	r0, r3, r0
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
3400b8d4:	fb80 0101 	smull	r0, r1, r0, r1
3400b8d8:	fba0 0502 	umull	r0, r5, r0, r2
  return (uint32_t) Val;
3400b8dc:	6066      	str	r6, [r4, #4]
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
3400b8de:	4606      	mov	r6, r0
3400b8e0:	fb02 5701 	mla	r7, r2, r1, r5
3400b8e4:	ea56 17df 	orrs.w	r7, r6, pc, lsr #7
  uint64_t Val = (1 << Shift);
3400b8e8:	f89d 1004 	ldrb.w	r1, [sp, #4]
  return (uint32_t) Val;
3400b8ec:	60a6      	str	r6, [r4, #8]
  uint64_t Val = (1 << Shift);
3400b8ee:	408b      	lsls	r3, r1
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
3400b8f0:	f89d 1005 	ldrb.w	r1, [sp, #5]
3400b8f4:	fb83 3501 	smull	r3, r5, r3, r1
3400b8f8:	fba3 3602 	umull	r3, r6, r3, r2
3400b8fc:	4618      	mov	r0, r3
3400b8fe:	fb02 6105 	mla	r1, r2, r5, r6
3400b902:	ea50 11df 	orrs.w	r1, r0, pc, lsr #7
  return (uint32_t) Val;
3400b906:	60e0      	str	r0, [r4, #12]

  pConfig->ispGainR = From_Shift_Multiplier(exposureConfig.ShiftRed, exposureConfig.MultiplierRed);
  pConfig->ispGainG = From_Shift_Multiplier(exposureConfig.ShiftGreen, exposureConfig.MultiplierGreen);
  pConfig->ispGainB = From_Shift_Multiplier(exposureConfig.ShiftBlue, exposureConfig.MultiplierBlue);

  return ISP_OK;
3400b908:	2000      	movs	r0, #0
}
3400b90a:	b003      	add	sp, #12
3400b90c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ISP_ERR_ISPGAIN_EINVAL;
3400b90e:	2050      	movs	r0, #80	@ 0x50
3400b910:	e7fb      	b.n	3400b90a <ISP_SVC_ISP_GetGain+0x86>
3400b912:	bf00      	nop
3400b914:	05f5e100 	.word	0x05f5e100

3400b918 <ISP_SVC_ISP_SetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
3400b918:	b570      	push	{r4, r5, r6, lr}
3400b91a:	4605      	mov	r5, r0
3400b91c:	b088      	sub	sp, #32
3400b91e:	460c      	mov	r4, r1
  HAL_StatusTypeDef halStatus;
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;
  uint32_t i, j;

  memset(&colorConvConfig, 0, sizeof(colorConvConfig));
3400b920:	221a      	movs	r2, #26
3400b922:	2100      	movs	r1, #0
3400b924:	a801      	add	r0, sp, #4
3400b926:	f001 fff5 	bl	3400d914 <memset>

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400b92a:	b16d      	cbz	r5, 3400b948 <ISP_SVC_ISP_SetColorConv+0x30>
3400b92c:	b164      	cbz	r4, 3400b948 <ISP_SVC_ISP_SetColorConv+0x30>
3400b92e:	4623      	mov	r3, r4

  for (i = 0; i < 3; i++)
  {
    for (j = 0; j < 3; j++)
    {
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
3400b930:	483a      	ldr	r0, [pc, #232]	@ (3400ba1c <ISP_SVC_ISP_SetColorConv+0x104>)
3400b932:	4a3b      	ldr	r2, [pc, #236]	@ (3400ba20 <ISP_SVC_ISP_SetColorConv+0x108>)
3400b934:	f104 0624 	add.w	r6, r4, #36	@ 0x24
3400b938:	6859      	ldr	r1, [r3, #4]
3400b93a:	4401      	add	r1, r0
3400b93c:	4291      	cmp	r1, r2
3400b93e:	d803      	bhi.n	3400b948 <ISP_SVC_ISP_SetColorConv+0x30>
3400b940:	6899      	ldr	r1, [r3, #8]
3400b942:	4401      	add	r1, r0
3400b944:	4291      	cmp	r1, r2
3400b946:	d901      	bls.n	3400b94c <ISP_SVC_ISP_SetColorConv+0x34>
    return ISP_ERR_COLORCONV_EINVAL;
3400b948:	205a      	movs	r0, #90	@ 0x5a
3400b94a:	e05f      	b.n	3400ba0c <ISP_SVC_ISP_SetColorConv+0xf4>
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
3400b94c:	68d9      	ldr	r1, [r3, #12]
3400b94e:	4401      	add	r1, r0
3400b950:	4291      	cmp	r1, r2
3400b952:	d8f9      	bhi.n	3400b948 <ISP_SVC_ISP_SetColorConv+0x30>
  for (i = 0; i < 3; i++)
3400b954:	330c      	adds	r3, #12
3400b956:	42b3      	cmp	r3, r6
3400b958:	d1ee      	bne.n	3400b938 <ISP_SVC_ISP_SetColorConv+0x20>
        return ISP_ERR_COLORCONV_EINVAL;
      }
    }
  }

  if (pConfig->enable == 0)
3400b95a:	7823      	ldrb	r3, [r4, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b95c:	682e      	ldr	r6, [r5, #0]
  if (pConfig->enable == 0)
3400b95e:	b933      	cbnz	r3, 3400b96e <ISP_SVC_ISP_SetColorConv+0x56>
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3400b960:	2101      	movs	r1, #1
3400b962:	4630      	mov	r0, r6
3400b964:	f7f8 fe76 	bl	34004654 <HAL_DCMIPP_PIPE_DisableISPColorConversion>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3400b968:	2800      	cmp	r0, #0
3400b96a:	d04f      	beq.n	3400ba0c <ISP_SVC_ISP_SetColorConv+0xf4>
3400b96c:	e04d      	b.n	3400ba0a <ISP_SVC_ISP_SetColorConv+0xf2>
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3400b96e:	6860      	ldr	r0, [r4, #4]
3400b970:	2300      	movs	r3, #0
3400b972:	4a2c      	ldr	r2, [pc, #176]	@ (3400ba24 <ISP_SVC_ISP_SetColorConv+0x10c>)
3400b974:	17c1      	asrs	r1, r0, #31
3400b976:	f7f5 fde1 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
3400b97a:	f8ad 0006 	strh.w	r0, [sp, #6]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3400b97e:	68a0      	ldr	r0, [r4, #8]
3400b980:	2300      	movs	r3, #0
3400b982:	4a28      	ldr	r2, [pc, #160]	@ (3400ba24 <ISP_SVC_ISP_SetColorConv+0x10c>)
3400b984:	17c1      	asrs	r1, r0, #31
3400b986:	f7f5 fdd9 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
3400b98a:	f8ad 0008 	strh.w	r0, [sp, #8]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3400b98e:	68e0      	ldr	r0, [r4, #12]
3400b990:	2300      	movs	r3, #0
3400b992:	4a24      	ldr	r2, [pc, #144]	@ (3400ba24 <ISP_SVC_ISP_SetColorConv+0x10c>)
3400b994:	17c1      	asrs	r1, r0, #31
3400b996:	f7f5 fdd1 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
3400b99a:	f8ad 000a 	strh.w	r0, [sp, #10]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3400b99e:	6920      	ldr	r0, [r4, #16]
3400b9a0:	2300      	movs	r3, #0
3400b9a2:	4a20      	ldr	r2, [pc, #128]	@ (3400ba24 <ISP_SVC_ISP_SetColorConv+0x10c>)
3400b9a4:	17c1      	asrs	r1, r0, #31
3400b9a6:	f7f5 fdc9 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
3400b9aa:	f8ad 000e 	strh.w	r0, [sp, #14]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3400b9ae:	6960      	ldr	r0, [r4, #20]
3400b9b0:	2300      	movs	r3, #0
3400b9b2:	4a1c      	ldr	r2, [pc, #112]	@ (3400ba24 <ISP_SVC_ISP_SetColorConv+0x10c>)
3400b9b4:	17c1      	asrs	r1, r0, #31
3400b9b6:	f7f5 fdc1 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
3400b9ba:	f8ad 0010 	strh.w	r0, [sp, #16]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3400b9be:	69a0      	ldr	r0, [r4, #24]
3400b9c0:	2300      	movs	r3, #0
3400b9c2:	4a18      	ldr	r2, [pc, #96]	@ (3400ba24 <ISP_SVC_ISP_SetColorConv+0x10c>)
3400b9c4:	17c1      	asrs	r1, r0, #31
3400b9c6:	f7f5 fdb9 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
3400b9ca:	f8ad 0012 	strh.w	r0, [sp, #18]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3400b9ce:	69e0      	ldr	r0, [r4, #28]
3400b9d0:	2300      	movs	r3, #0
3400b9d2:	4a14      	ldr	r2, [pc, #80]	@ (3400ba24 <ISP_SVC_ISP_SetColorConv+0x10c>)
3400b9d4:	17c1      	asrs	r1, r0, #31
3400b9d6:	f7f5 fdb1 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
3400b9da:	f8ad 0016 	strh.w	r0, [sp, #22]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3400b9de:	6a20      	ldr	r0, [r4, #32]
3400b9e0:	2300      	movs	r3, #0
3400b9e2:	4a10      	ldr	r2, [pc, #64]	@ (3400ba24 <ISP_SVC_ISP_SetColorConv+0x10c>)
3400b9e4:	17c1      	asrs	r1, r0, #31
3400b9e6:	f7f5 fda9 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
3400b9ea:	f8ad 0018 	strh.w	r0, [sp, #24]
  int64_t Val = Coeff;
3400b9ee:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3400b9f0:	4a0c      	ldr	r2, [pc, #48]	@ (3400ba24 <ISP_SVC_ISP_SetColorConv+0x10c>)
3400b9f2:	2300      	movs	r3, #0
3400b9f4:	17c1      	asrs	r1, r0, #31
3400b9f6:	f7f5 fda1 	bl	3400153c <__aeabi_ldivmod>
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
3400b9fa:	2101      	movs	r1, #1
  return (int16_t) Val;
3400b9fc:	f8ad 001a 	strh.w	r0, [sp, #26]
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
3400ba00:	aa01      	add	r2, sp, #4
3400ba02:	4630      	mov	r0, r6
3400ba04:	f7f8 fd68 	bl	340044d8 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>
    if (halStatus == HAL_OK)
3400ba08:	b110      	cbz	r0, 3400ba10 <ISP_SVC_ISP_SetColorConv+0xf8>
  {
    return ISP_ERR_COLORCONV_HAL;
3400ba0a:	205b      	movs	r0, #91	@ 0x5b
  }

  return ISP_OK;
}
3400ba0c:	b008      	add	sp, #32
3400ba0e:	bd70      	pop	{r4, r5, r6, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3400ba10:	2101      	movs	r1, #1
3400ba12:	6828      	ldr	r0, [r5, #0]
3400ba14:	f7f8 fe10 	bl	34004638 <HAL_DCMIPP_PIPE_EnableISPColorConversion>
3400ba18:	e7a6      	b.n	3400b968 <ISP_SVC_ISP_SetColorConv+0x50>
3400ba1a:	bf00      	nop
3400ba1c:	17c841c0 	.word	0x17c841c0
3400ba20:	2f908380 	.word	0x2f908380
3400ba24:	0005f5e1 	.word	0x0005f5e1

3400ba28 <ISP_SVC_ISP_GetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
3400ba28:	b530      	push	{r4, r5, lr}
3400ba2a:	460c      	mov	r4, r1
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400ba2c:	4605      	mov	r5, r0
{
3400ba2e:	b089      	sub	sp, #36	@ 0x24
  if ((hIsp == NULL) || (pConfig == NULL))
3400ba30:	2800      	cmp	r0, #0
3400ba32:	d03c      	beq.n	3400baae <ISP_SVC_ISP_GetColorConv+0x86>
3400ba34:	2900      	cmp	r1, #0
3400ba36:	d03a      	beq.n	3400baae <ISP_SVC_ISP_GetColorConv+0x86>
  {
    return ISP_ERR_COLORCONV_EINVAL;
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3400ba38:	2101      	movs	r1, #1
3400ba3a:	6800      	ldr	r0, [r0, #0]
3400ba3c:	f7f9 f8d7 	bl	34004bee <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>
3400ba40:	7020      	strb	r0, [r4, #0]

  HAL_DCMIPP_PIPE_GetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
3400ba42:	2101      	movs	r1, #1
3400ba44:	6828      	ldr	r0, [r5, #0]
3400ba46:	aa01      	add	r2, sp, #4
3400ba48:	f7f9 f832 	bl	34004ab0 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400ba4c:	4b19      	ldr	r3, [pc, #100]	@ (3400bab4 <ISP_SVC_ISP_GetColorConv+0x8c>)
  int64_t Val = Reg;
3400ba4e:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
  pConfig->coeff[1][2] = From_CConv_Reg(colorConvConfig.GB);
  pConfig->coeff[2][0] = From_CConv_Reg(colorConvConfig.BR);
  pConfig->coeff[2][1] = From_CConv_Reg(colorConvConfig.BG);
  pConfig->coeff[2][2] = From_CConv_Reg(colorConvConfig.BB);

  return ISP_OK;
3400ba52:	2000      	movs	r0, #0
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400ba54:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
3400ba58:	6062      	str	r2, [r4, #4]
  int64_t Val = Reg;
3400ba5a:	f9bd 2008 	ldrsh.w	r2, [sp, #8]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400ba5e:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
3400ba62:	60a2      	str	r2, [r4, #8]
  int64_t Val = Reg;
3400ba64:	f9bd 200a 	ldrsh.w	r2, [sp, #10]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400ba68:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
3400ba6c:	60e2      	str	r2, [r4, #12]
  int64_t Val = Reg;
3400ba6e:	f9bd 200e 	ldrsh.w	r2, [sp, #14]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400ba72:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
3400ba76:	6122      	str	r2, [r4, #16]
  int64_t Val = Reg;
3400ba78:	f9bd 2010 	ldrsh.w	r2, [sp, #16]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400ba7c:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
3400ba80:	6162      	str	r2, [r4, #20]
  int64_t Val = Reg;
3400ba82:	f9bd 2012 	ldrsh.w	r2, [sp, #18]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400ba86:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
3400ba8a:	61a2      	str	r2, [r4, #24]
  int64_t Val = Reg;
3400ba8c:	f9bd 2016 	ldrsh.w	r2, [sp, #22]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400ba90:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
3400ba94:	61e2      	str	r2, [r4, #28]
  int64_t Val = Reg;
3400ba96:	f9bd 2018 	ldrsh.w	r2, [sp, #24]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400ba9a:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
3400ba9e:	6222      	str	r2, [r4, #32]
  int64_t Val = Reg;
3400baa0:	f9bd 201a 	ldrsh.w	r2, [sp, #26]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3400baa4:	fba2 2303 	umull	r2, r3, r2, r3
  return (int32_t) Val;
3400baa8:	6262      	str	r2, [r4, #36]	@ 0x24
}
3400baaa:	b009      	add	sp, #36	@ 0x24
3400baac:	bd30      	pop	{r4, r5, pc}
    return ISP_ERR_COLORCONV_EINVAL;
3400baae:	205a      	movs	r0, #90	@ 0x5a
3400bab0:	e7fb      	b.n	3400baaa <ISP_SVC_ISP_GetColorConv+0x82>
3400bab2:	bf00      	nop
3400bab4:	0005f5e1 	.word	0x0005f5e1

3400bab8 <ISP_SVC_Sensor_GetInfo>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor info
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetInfo(ISP_HandleTypeDef *hIsp, ISP_SensorInfoTypeDef *pConfig)
{
3400bab8:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400baba:	b138      	cbz	r0, 3400bacc <ISP_SVC_Sensor_GetInfo+0x14>
3400babc:	b131      	cbz	r1, 3400bacc <ISP_SVC_Sensor_GetInfo+0x14>
  {
    return ISP_ERR_SENSORINFO_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorInfo != NULL)
3400babe:	6a83      	ldr	r3, [r0, #40]	@ 0x28
3400bac0:	b113      	cbz	r3, 3400bac8 <ISP_SVC_Sensor_GetInfo+0x10>
  {
    if (hIsp->appliHelpers.GetSensorInfo(hIsp->cameraInstance, pConfig) != 0)
3400bac2:	6840      	ldr	r0, [r0, #4]
3400bac4:	4798      	blx	r3
3400bac6:	b918      	cbnz	r0, 3400bad0 <ISP_SVC_Sensor_GetInfo+0x18>
    {
      return ISP_ERR_SENSORINFO;
    }
  }

  return ISP_OK;
3400bac8:	2000      	movs	r0, #0
}
3400baca:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORINFO_EINVAL;
3400bacc:	206e      	movs	r0, #110	@ 0x6e
3400bace:	e7fc      	b.n	3400baca <ISP_SVC_Sensor_GetInfo+0x12>
      return ISP_ERR_SENSORINFO;
3400bad0:	206f      	movs	r0, #111	@ 0x6f
3400bad2:	e7fa      	b.n	3400baca <ISP_SVC_Sensor_GetInfo+0x12>

3400bad4 <ISP_SVC_Sensor_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
3400bad4:	b510      	push	{r4, lr}
3400bad6:	460c      	mov	r4, r1
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400bad8:	b170      	cbz	r0, 3400baf8 <ISP_SVC_Sensor_SetGain+0x24>
3400bada:	b169      	cbz	r1, 3400baf8 <ISP_SVC_Sensor_SetGain+0x24>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
  }

  if (hIsp->appliHelpers.SetSensorGain != NULL)
3400badc:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
  {
    if (hIsp->appliHelpers.SetSensorGain(hIsp->cameraInstance, pConfig->gain) != 0)
3400bade:	6809      	ldr	r1, [r1, #0]
  if (hIsp->appliHelpers.SetSensorGain != NULL)
3400bae0:	b923      	cbnz	r3, 3400baec <ISP_SVC_Sensor_SetGain+0x18>
    }
  }

  Meta.gain = pConfig->gain;

  return ISP_OK;
3400bae2:	2000      	movs	r0, #0
  Meta.gain = pConfig->gain;
3400bae4:	6822      	ldr	r2, [r4, #0]
3400bae6:	4b05      	ldr	r3, [pc, #20]	@ (3400bafc <ISP_SVC_Sensor_SetGain+0x28>)
3400bae8:	609a      	str	r2, [r3, #8]
}
3400baea:	bd10      	pop	{r4, pc}
    if (hIsp->appliHelpers.SetSensorGain(hIsp->cameraInstance, pConfig->gain) != 0)
3400baec:	6840      	ldr	r0, [r0, #4]
3400baee:	4798      	blx	r3
3400baf0:	2800      	cmp	r0, #0
3400baf2:	d0f6      	beq.n	3400bae2 <ISP_SVC_Sensor_SetGain+0xe>
      return ISP_ERR_SENSORGAIN;
3400baf4:	2079      	movs	r0, #121	@ 0x79
3400baf6:	e7f8      	b.n	3400baea <ISP_SVC_Sensor_SetGain+0x16>
    return ISP_ERR_SENSORGAIN_EINVAL;
3400baf8:	2078      	movs	r0, #120	@ 0x78
3400bafa:	e7f6      	b.n	3400baea <ISP_SVC_Sensor_SetGain+0x16>
3400bafc:	340cfe48 	.word	0x340cfe48

3400bb00 <ISP_SVC_Sensor_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
3400bb00:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400bb02:	b138      	cbz	r0, 3400bb14 <ISP_SVC_Sensor_GetGain+0x14>
3400bb04:	b131      	cbz	r1, 3400bb14 <ISP_SVC_Sensor_GetGain+0x14>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorGain != NULL)
3400bb06:	6b03      	ldr	r3, [r0, #48]	@ 0x30
3400bb08:	b113      	cbz	r3, 3400bb10 <ISP_SVC_Sensor_GetGain+0x10>
  {
    if (hIsp->appliHelpers.GetSensorGain(hIsp->cameraInstance, (int32_t *)&pConfig->gain) != 0)
3400bb0a:	6840      	ldr	r0, [r0, #4]
3400bb0c:	4798      	blx	r3
3400bb0e:	b918      	cbnz	r0, 3400bb18 <ISP_SVC_Sensor_GetGain+0x18>
    {
      return ISP_ERR_SENSORGAIN;
    }
  }

  return ISP_OK;
3400bb10:	2000      	movs	r0, #0
}
3400bb12:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORGAIN_EINVAL;
3400bb14:	2078      	movs	r0, #120	@ 0x78
3400bb16:	e7fc      	b.n	3400bb12 <ISP_SVC_Sensor_GetGain+0x12>
      return ISP_ERR_SENSORGAIN;
3400bb18:	2079      	movs	r0, #121	@ 0x79
3400bb1a:	e7fa      	b.n	3400bb12 <ISP_SVC_Sensor_GetGain+0x12>

3400bb1c <ISP_SVC_Sensor_SetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
3400bb1c:	b510      	push	{r4, lr}
3400bb1e:	460c      	mov	r4, r1
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400bb20:	b170      	cbz	r0, 3400bb40 <ISP_SVC_Sensor_SetExposure+0x24>
3400bb22:	b169      	cbz	r1, 3400bb40 <ISP_SVC_Sensor_SetExposure+0x24>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
  }

  if (hIsp->appliHelpers.SetSensorExposure != NULL)
3400bb24:	6b43      	ldr	r3, [r0, #52]	@ 0x34
  {
    if (hIsp->appliHelpers.SetSensorExposure(hIsp->cameraInstance, pConfig->exposure) != 0)
3400bb26:	6809      	ldr	r1, [r1, #0]
  if (hIsp->appliHelpers.SetSensorExposure != NULL)
3400bb28:	b923      	cbnz	r3, 3400bb34 <ISP_SVC_Sensor_SetExposure+0x18>
    }
  }

  Meta.exposure = pConfig->exposure;

  return ISP_OK;
3400bb2a:	2000      	movs	r0, #0
  Meta.exposure = pConfig->exposure;
3400bb2c:	6822      	ldr	r2, [r4, #0]
3400bb2e:	4b05      	ldr	r3, [pc, #20]	@ (3400bb44 <ISP_SVC_Sensor_SetExposure+0x28>)
3400bb30:	60da      	str	r2, [r3, #12]
}
3400bb32:	bd10      	pop	{r4, pc}
    if (hIsp->appliHelpers.SetSensorExposure(hIsp->cameraInstance, pConfig->exposure) != 0)
3400bb34:	6840      	ldr	r0, [r0, #4]
3400bb36:	4798      	blx	r3
3400bb38:	2800      	cmp	r0, #0
3400bb3a:	d0f6      	beq.n	3400bb2a <ISP_SVC_Sensor_SetExposure+0xe>
      return ISP_ERR_SENSOREXPOSURE;
3400bb3c:	2083      	movs	r0, #131	@ 0x83
3400bb3e:	e7f8      	b.n	3400bb32 <ISP_SVC_Sensor_SetExposure+0x16>
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
3400bb40:	2082      	movs	r0, #130	@ 0x82
3400bb42:	e7f6      	b.n	3400bb32 <ISP_SVC_Sensor_SetExposure+0x16>
3400bb44:	340cfe48 	.word	0x340cfe48

3400bb48 <ISP_SVC_Sensor_GetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
3400bb48:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3400bb4a:	b138      	cbz	r0, 3400bb5c <ISP_SVC_Sensor_GetExposure+0x14>
3400bb4c:	b131      	cbz	r1, 3400bb5c <ISP_SVC_Sensor_GetExposure+0x14>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorExposure != NULL)
3400bb4e:	6b83      	ldr	r3, [r0, #56]	@ 0x38
3400bb50:	b113      	cbz	r3, 3400bb58 <ISP_SVC_Sensor_GetExposure+0x10>
  {
    if (hIsp->appliHelpers.GetSensorExposure(hIsp->cameraInstance, (int32_t *)&pConfig->exposure) != 0)
3400bb52:	6840      	ldr	r0, [r0, #4]
3400bb54:	4798      	blx	r3
3400bb56:	b918      	cbnz	r0, 3400bb60 <ISP_SVC_Sensor_GetExposure+0x18>
    {
      return ISP_ERR_SENSOREXPOSURE;
    }
  }

  return ISP_OK;
3400bb58:	2000      	movs	r0, #0
}
3400bb5a:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
3400bb5c:	2082      	movs	r0, #130	@ 0x82
3400bb5e:	e7fc      	b.n	3400bb5a <ISP_SVC_Sensor_GetExposure+0x12>
      return ISP_ERR_SENSOREXPOSURE;
3400bb60:	2083      	movs	r0, #131	@ 0x83
3400bb62:	e7fa      	b.n	3400bb5a <ISP_SVC_Sensor_GetExposure+0x12>

3400bb64 <ISP_SVC_Misc_IsDCMIPPReady>:
  *         Check that the DCMIPP device is ready
  * @param  hIsp: ISP device handle
  * @retval ISP_OK if DCMIPP is running, ISP_FAIL otherwise
  */
ISP_StatusTypeDef ISP_SVC_Misc_IsDCMIPPReady(ISP_HandleTypeDef *hIsp)
{
3400bb64:	b508      	push	{r3, lr}
  /* Check handle validity */
  if (hIsp == NULL)
3400bb66:	b138      	cbz	r0, 3400bb78 <ISP_SVC_Misc_IsDCMIPPReady+0x14>
  {
    return ISP_ERR_EINVAL;
  }

  if (HAL_DCMIPP_GetState(hIsp->hDcmipp) != HAL_DCMIPP_STATE_READY)
3400bb68:	6800      	ldr	r0, [r0, #0]
3400bb6a:	f7f9 f849 	bl	34004c00 <HAL_DCMIPP_GetState>
  {
    return ISP_ERR_DCMIPP_STATE;
  }

  return ISP_OK;
3400bb6e:	2802      	cmp	r0, #2
3400bb70:	bf14      	ite	ne
3400bb72:	208c      	movne	r0, #140	@ 0x8c
3400bb74:	2000      	moveq	r0, #0
}
3400bb76:	bd08      	pop	{r3, pc}
    return ISP_ERR_EINVAL;
3400bb78:	2001      	movs	r0, #1
3400bb7a:	e7fc      	b.n	3400bb76 <ISP_SVC_Misc_IsDCMIPPReady+0x12>

3400bb7c <ISP_SVC_Misc_IncMainFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->MainPipe_FrameCount++;
3400bb7c:	6c03      	ldr	r3, [r0, #64]	@ 0x40
3400bb7e:	3301      	adds	r3, #1
3400bb80:	6403      	str	r3, [r0, #64]	@ 0x40
}
3400bb82:	4770      	bx	lr

3400bb84 <ISP_SVC_Misc_GetMainFrameId>:
  * @retval Id of the last frame output on the main pipe
  */
uint32_t ISP_SVC_Misc_GetMainFrameId(ISP_HandleTypeDef *hIsp)
{
  return hIsp->MainPipe_FrameCount;
}
3400bb84:	6c00      	ldr	r0, [r0, #64]	@ 0x40
3400bb86:	4770      	bx	lr

3400bb88 <ISP_SVC_Misc_IncAncillaryFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->AncillaryPipe_FrameCount++;
3400bb88:	6c43      	ldr	r3, [r0, #68]	@ 0x44
3400bb8a:	3301      	adds	r3, #1
3400bb8c:	6443      	str	r3, [r0, #68]	@ 0x44
}
3400bb8e:	4770      	bx	lr

3400bb90 <ISP_SVC_Misc_IncDumpFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->DumpPipe_FrameCount++;
3400bb90:	6c83      	ldr	r3, [r0, #72]	@ 0x48
3400bb92:	3301      	adds	r3, #1
3400bb94:	6483      	str	r3, [r0, #72]	@ 0x48
}
3400bb96:	4770      	bx	lr

3400bb98 <ISP_SVC_Misc_IsGammaEnabled>:
  * @param  hIsp: ISP device handle
  * @param  Pipe: DCMIPP pipe line
  * @retval 1 if enabled 0 otherwise
  */
bool ISP_SVC_Misc_IsGammaEnabled(ISP_HandleTypeDef *hIsp, uint32_t Pipe)
{
3400bb98:	b508      	push	{r3, lr}
  uint8_t ret;

  /* Check handle validity */
  if (hIsp == NULL)
3400bb9a:	b168      	cbz	r0, 3400bbb8 <ISP_SVC_Misc_IsGammaEnabled+0x20>
  {
    return ISP_ERR_EINVAL;
  }

  switch(Pipe)
3400bb9c:	2901      	cmp	r1, #1
3400bb9e:	d006      	beq.n	3400bbae <ISP_SVC_Misc_IsGammaEnabled+0x16>
3400bba0:	2902      	cmp	r1, #2
3400bba2:	d004      	beq.n	3400bbae <ISP_SVC_Misc_IsGammaEnabled+0x16>
3400bba4:	2000      	movs	r0, #0
    break;
  default:
    ret = 0; /*  No gamma on pipe 0 */
  }

  return ret;
3400bba6:	3800      	subs	r0, #0
3400bba8:	bf18      	it	ne
3400bbaa:	2001      	movne	r0, #1
}
3400bbac:	bd08      	pop	{r3, pc}
    ret = HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2);
3400bbae:	6800      	ldr	r0, [r0, #0]
3400bbb0:	f7f8 fbcb 	bl	3400434a <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
3400bbb4:	b2c0      	uxtb	r0, r0
    break;
3400bbb6:	e7f6      	b.n	3400bba6 <ISP_SVC_Misc_IsGammaEnabled+0xe>
    return ISP_ERR_EINVAL;
3400bbb8:	2001      	movs	r0, #1
3400bbba:	e7f7      	b.n	3400bbac <ISP_SVC_Misc_IsGammaEnabled+0x14>

3400bbbc <ISP_SVC_ISP_SetGamma>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gamma configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGamma(ISP_HandleTypeDef *hIsp, ISP_GammaTypeDef *pConfig)
{
3400bbbc:	b538      	push	{r3, r4, r5, lr}
3400bbbe:	460d      	mov	r5, r1
  if ((hIsp == NULL) || (pConfig == NULL))
3400bbc0:	4604      	mov	r4, r0
3400bbc2:	b908      	cbnz	r0, 3400bbc8 <ISP_SVC_ISP_SetGamma+0xc>
  {
    return ISP_ERR_DCMIPP_GAMMA;
3400bbc4:	2095      	movs	r0, #149	@ 0x95
      return ISP_ERR_DCMIPP_GAMMA;
    }
  }

  return ISP_OK;
}
3400bbc6:	bd38      	pop	{r3, r4, r5, pc}
  if ((hIsp == NULL) || (pConfig == NULL))
3400bbc8:	2900      	cmp	r1, #0
3400bbca:	d0fb      	beq.n	3400bbc4 <ISP_SVC_ISP_SetGamma+0x8>
  if (pConfig->enablePipe1 == 0)
3400bbcc:	780b      	ldrb	r3, [r1, #0]
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3400bbce:	6800      	ldr	r0, [r0, #0]
3400bbd0:	2101      	movs	r1, #1
  if (pConfig->enablePipe1 == 0)
3400bbd2:	b953      	cbnz	r3, 3400bbea <ISP_SVC_ISP_SetGamma+0x2e>
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3400bbd4:	f7f8 fba1 	bl	3400431a <HAL_DCMIPP_PIPE_DisableGammaConversion>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3400bbd8:	2800      	cmp	r0, #0
3400bbda:	d1f3      	bne.n	3400bbc4 <ISP_SVC_ISP_SetGamma+0x8>
  if (pConfig->enablePipe2 == 0)
3400bbdc:	786b      	ldrb	r3, [r5, #1]
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
3400bbde:	6820      	ldr	r0, [r4, #0]
  if (pConfig->enablePipe2 == 0)
3400bbe0:	b133      	cbz	r3, 3400bbf0 <ISP_SVC_ISP_SetGamma+0x34>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
3400bbe2:	2102      	movs	r1, #2
3400bbe4:	f7f8 fb81 	bl	340042ea <HAL_DCMIPP_PIPE_EnableGammaConversion>
3400bbe8:	e005      	b.n	3400bbf6 <ISP_SVC_ISP_SetGamma+0x3a>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3400bbea:	f7f8 fb7e 	bl	340042ea <HAL_DCMIPP_PIPE_EnableGammaConversion>
3400bbee:	e7f3      	b.n	3400bbd8 <ISP_SVC_ISP_SetGamma+0x1c>
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
3400bbf0:	2102      	movs	r1, #2
3400bbf2:	f7f8 fb92 	bl	3400431a <HAL_DCMIPP_PIPE_DisableGammaConversion>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
3400bbf6:	2800      	cmp	r0, #0
3400bbf8:	d1e4      	bne.n	3400bbc4 <ISP_SVC_ISP_SetGamma+0x8>
  return ISP_OK;
3400bbfa:	2000      	movs	r0, #0
3400bbfc:	e7e3      	b.n	3400bbc6 <ISP_SVC_ISP_SetGamma+0xa>
	...

3400bc00 <ISP_SVC_IQParam_Init>:
  *         Initialize the IQ parameters cache with values from non volatile memory
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_IQParam_Init(ISP_HandleTypeDef *hIsp, const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
3400bc00:	b508      	push	{r3, lr}
  (void)hIsp; /* unused */

  ISP_IQParamCache = *ISP_IQParamCacheInit;
3400bc02:	f44f 7215 	mov.w	r2, #596	@ 0x254
3400bc06:	4802      	ldr	r0, [pc, #8]	@ (3400bc10 <ISP_SVC_IQParam_Init+0x10>)
3400bc08:	f001 ff17 	bl	3400da3a <memcpy>
  return ISP_OK;
}
3400bc0c:	2000      	movs	r0, #0
3400bc0e:	bd08      	pop	{r3, pc}
3400bc10:	340d0050 	.word	0x340d0050

3400bc14 <ISP_SVC_IQParam_Get>:
ISP_IQParamTypeDef *ISP_SVC_IQParam_Get(ISP_HandleTypeDef *hIsp)
{
  (void)hIsp; /* unused */

  return &ISP_IQParamCache;
}
3400bc14:	4800      	ldr	r0, [pc, #0]	@ (3400bc18 <ISP_SVC_IQParam_Get+0x4>)
3400bc16:	4770      	bx	lr
3400bc18:	340d0050 	.word	0x340d0050

3400bc1c <ISP_SVC_Stats_Init>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Init(ISP_HandleTypeDef *hIsp)
{
  memset(&ISP_SVC_StatEngine, 0, sizeof(ISP_SVC_StatEngineTypeDef));
3400bc1c:	f44f 72b0 	mov.w	r2, #352	@ 0x160
3400bc20:	2100      	movs	r1, #0
3400bc22:	4801      	ldr	r0, [pc, #4]	@ (3400bc28 <ISP_SVC_Stats_Init+0xc>)
3400bc24:	f001 be76 	b.w	3400d914 <memset>
3400bc28:	340cfef0 	.word	0x340cfef0

3400bc2c <ISP_SVC_Stats_Gather>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Gather(ISP_HandleTypeDef *hIsp)
{
3400bc2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_SVC_StatStateTypeDef *ongoing;
  uint32_t i, avgR, avgG, avgB, frameId;

  /* Check handle validity */
  if (hIsp == NULL)
3400bc30:	4605      	mov	r5, r0
{
3400bc32:	b08d      	sub	sp, #52	@ 0x34
  if (hIsp == NULL)
3400bc34:	b928      	cbnz	r0, 3400bc42 <ISP_SVC_Stats_Gather+0x16>
  {
    printf("ERROR: ISP handle is NULL\r\n");
3400bc36:	48aa      	ldr	r0, [pc, #680]	@ (3400bee0 <ISP_SVC_Stats_Gather+0x2b4>)

  /* Save the two last processed stages and go to next stage */
  stagePrevious2 = stagePrevious1;
  stagePrevious1 = ISP_SVC_StatEngine.stage;
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
}
3400bc38:	b00d      	add	sp, #52	@ 0x34
3400bc3a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    printf("ERROR: ISP handle is NULL\r\n");
3400bc3e:	f001 bd39 	b.w	3400d6b4 <puts>
  if (hIsp->hDcmipp == NULL)
3400bc42:	6800      	ldr	r0, [r0, #0]
3400bc44:	2800      	cmp	r0, #0
3400bc46:	f000 80b4 	beq.w	3400bdb2 <ISP_SVC_Stats_Gather+0x186>
  switch(stagePrevious2)
3400bc4a:	f8df 92f0 	ldr.w	r9, [pc, #752]	@ 3400bf3c <ISP_SVC_Stats_Gather+0x310>
3400bc4e:	4ca5      	ldr	r4, [pc, #660]	@ (3400bee4 <ISP_SVC_Stats_Gather+0x2b8>)
3400bc50:	f899 3000 	ldrb.w	r3, [r9]
3400bc54:	2b09      	cmp	r3, #9
3400bc56:	d836      	bhi.n	3400bcc6 <ISP_SVC_Stats_Gather+0x9a>
3400bc58:	e8df f003 	tbb	[pc, r3]
3400bc5c:	46443f05 	.word	0x46443f05
3400bc60:	89874a48 	.word	0x89874a48
3400bc64:	8d8b      	.short	0x8d8b
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
3400bc66:	2201      	movs	r2, #1
3400bc68:	466b      	mov	r3, sp
3400bc6a:	4611      	mov	r1, r2
3400bc6c:	f7f8 feeb 	bl	34004a46 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
3400bc70:	2202      	movs	r2, #2
3400bc72:	2101      	movs	r1, #1
3400bc74:	ab01      	add	r3, sp, #4
3400bc76:	6828      	ldr	r0, [r5, #0]
3400bc78:	f7f8 fee5 	bl	34004a46 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
3400bc7c:	2203      	movs	r2, #3
3400bc7e:	2101      	movs	r1, #1
3400bc80:	ab02      	add	r3, sp, #8
3400bc82:	6828      	ldr	r0, [r5, #0]
3400bc84:	f7f8 fedf 	bl	34004a46 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
3400bc88:	2101      	movs	r1, #1
3400bc8a:	2200      	movs	r2, #0
3400bc8c:	9b00      	ldr	r3, [sp, #0]
3400bc8e:	4628      	mov	r0, r5
3400bc90:	f7ff fb1a 	bl	3400b2c8 <GetAvgStats>
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
3400bc94:	460a      	mov	r2, r1
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
3400bc96:	4606      	mov	r6, r0
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
3400bc98:	9b01      	ldr	r3, [sp, #4]
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
3400bc9a:	f884 007c 	strb.w	r0, [r4, #124]	@ 0x7c
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
3400bc9e:	4628      	mov	r0, r5
3400bca0:	f7ff fb12 	bl	3400b2c8 <GetAvgStats>
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
3400bca4:	2202      	movs	r2, #2
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
3400bca6:	4607      	mov	r7, r0
3400bca8:	f884 007d 	strb.w	r0, [r4, #125]	@ 0x7d
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
3400bcac:	9b02      	ldr	r3, [sp, #8]
3400bcae:	4628      	mov	r0, r5
3400bcb0:	f7ff fb0a 	bl	3400b2c8 <GetAvgStats>
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
3400bcb4:	4639      	mov	r1, r7
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
3400bcb6:	4602      	mov	r2, r0
3400bcb8:	f884 007e 	strb.w	r0, [r4, #126]	@ 0x7e
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
3400bcbc:	4630      	mov	r0, r6
3400bcbe:	f7ff fb47 	bl	3400b350 <LuminanceFromRGB>
3400bcc2:	f884 007f 	strb.w	r0, [r4, #127]	@ 0x7f
  switch(ISP_SVC_StatEngine.stage)
3400bcc6:	7823      	ldrb	r3, [r4, #0]
3400bcc8:	2b09      	cmp	r3, #9
3400bcca:	d863      	bhi.n	3400bd94 <ISP_SVC_Stats_Gather+0x168>
3400bccc:	e8df f003 	tbb	[pc, r3]
3400bcd0:	86847f74 	.word	0x86847f74
3400bcd4:	8c8a5588 	.word	0x8c8a5588
3400bcd8:	908e      	.short	0x908e
    ReadStatHistogram(hIsp, &ongoing->up.histogram[0]);
3400bcda:	4983      	ldr	r1, [pc, #524]	@ (3400bee8 <ISP_SVC_Stats_Gather+0x2bc>)
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
3400bcdc:	4628      	mov	r0, r5
3400bcde:	f7ff fb24 	bl	3400b32a <ReadStatHistogram>
    break;
3400bce2:	e7f0      	b.n	3400bcc6 <ISP_SVC_Stats_Gather+0x9a>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[3]);
3400bce4:	4981      	ldr	r1, [pc, #516]	@ (3400beec <ISP_SVC_Stats_Gather+0x2c0>)
3400bce6:	e7f9      	b.n	3400bcdc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[6]);
3400bce8:	4981      	ldr	r1, [pc, #516]	@ (3400bef0 <ISP_SVC_Stats_Gather+0x2c4>)
3400bcea:	e7f7      	b.n	3400bcdc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[9]);
3400bcec:	4981      	ldr	r1, [pc, #516]	@ (3400bef4 <ISP_SVC_Stats_Gather+0x2c8>)
3400bcee:	e7f5      	b.n	3400bcdc <ISP_SVC_Stats_Gather+0xb0>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
3400bcf0:	2201      	movs	r2, #1
3400bcf2:	466b      	mov	r3, sp
3400bcf4:	4611      	mov	r1, r2
3400bcf6:	f7f8 fea6 	bl	34004a46 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
3400bcfa:	2202      	movs	r2, #2
3400bcfc:	2101      	movs	r1, #1
3400bcfe:	ab01      	add	r3, sp, #4
3400bd00:	6828      	ldr	r0, [r5, #0]
3400bd02:	f7f8 fea0 	bl	34004a46 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
3400bd06:	2203      	movs	r2, #3
3400bd08:	2101      	movs	r1, #1
3400bd0a:	ab02      	add	r3, sp, #8
3400bd0c:	6828      	ldr	r0, [r5, #0]
3400bd0e:	f7f8 fe9a 	bl	34004a46 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
3400bd12:	2102      	movs	r1, #2
3400bd14:	2200      	movs	r2, #0
3400bd16:	9b00      	ldr	r3, [sp, #0]
3400bd18:	4628      	mov	r0, r5
3400bd1a:	f7ff fad5 	bl	3400b2c8 <GetAvgStats>
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
3400bd1e:	2201      	movs	r2, #1
3400bd20:	9b01      	ldr	r3, [sp, #4]
    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
3400bd22:	f884 00b0 	strb.w	r0, [r4, #176]	@ 0xb0
3400bd26:	4607      	mov	r7, r0
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
3400bd28:	4628      	mov	r0, r5
3400bd2a:	f7ff facd 	bl	3400b2c8 <GetAvgStats>
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
3400bd2e:	460a      	mov	r2, r1
3400bd30:	9b02      	ldr	r3, [sp, #8]
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
3400bd32:	f884 00b1 	strb.w	r0, [r4, #177]	@ 0xb1
3400bd36:	4606      	mov	r6, r0
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
3400bd38:	4628      	mov	r0, r5
3400bd3a:	f7ff fac5 	bl	3400b2c8 <GetAvgStats>
3400bd3e:	f884 00b2 	strb.w	r0, [r4, #178]	@ 0xb2
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
3400bd42:	f895 306c 	ldrb.w	r3, [r5, #108]	@ 0x6c
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
3400bd46:	4602      	mov	r2, r0
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
3400bd48:	2b04      	cmp	r3, #4
3400bd4a:	d002      	beq.n	3400bd52 <ISP_SVC_Stats_Gather+0x126>
3400bd4c:	4b6a      	ldr	r3, [pc, #424]	@ (3400bef8 <ISP_SVC_Stats_Gather+0x2cc>)
3400bd4e:	7b1b      	ldrb	r3, [r3, #12]
3400bd50:	b923      	cbnz	r3, 3400bd5c <ISP_SVC_Stats_Gather+0x130>
  return r + g + b;
3400bd52:	443e      	add	r6, r7
3400bd54:	4432      	add	r2, r6
      ongoing->down.averageL = LuminanceFromRGBMono(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
3400bd56:	f884 20b3 	strb.w	r2, [r4, #179]	@ 0xb3
3400bd5a:	e7b4      	b.n	3400bcc6 <ISP_SVC_Stats_Gather+0x9a>
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
3400bd5c:	4631      	mov	r1, r6
3400bd5e:	4638      	mov	r0, r7
3400bd60:	f7ff faf6 	bl	3400b350 <LuminanceFromRGB>
3400bd64:	f884 00b3 	strb.w	r0, [r4, #179]	@ 0xb3
3400bd68:	e7ad      	b.n	3400bcc6 <ISP_SVC_Stats_Gather+0x9a>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[0]);
3400bd6a:	4964      	ldr	r1, [pc, #400]	@ (3400befc <ISP_SVC_Stats_Gather+0x2d0>)
3400bd6c:	e7b6      	b.n	3400bcdc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[3]);
3400bd6e:	4964      	ldr	r1, [pc, #400]	@ (3400bf00 <ISP_SVC_Stats_Gather+0x2d4>)
3400bd70:	e7b4      	b.n	3400bcdc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[6]);
3400bd72:	4964      	ldr	r1, [pc, #400]	@ (3400bf04 <ISP_SVC_Stats_Gather+0x2d8>)
3400bd74:	e7b2      	b.n	3400bcdc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
3400bd76:	4964      	ldr	r1, [pc, #400]	@ (3400bf08 <ISP_SVC_Stats_Gather+0x2dc>)
3400bd78:	e7b0      	b.n	3400bcdc <ISP_SVC_Stats_Gather+0xb0>
      statConf[i].Source = avgRGBDown[i];
3400bd7a:	2300      	movs	r3, #0
3400bd7c:	2240      	movs	r2, #64	@ 0x40
3400bd7e:	e9cd 3203 	strd	r3, r2, [sp, #12]
3400bd82:	2250      	movs	r2, #80	@ 0x50
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
3400bd84:	e9cd 2307 	strd	r2, r3, [sp, #28]
      statConf[i].Source = avgRGBDown[i];
3400bd88:	2260      	movs	r2, #96	@ 0x60
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
3400bd8a:	e9cd 3305 	strd	r3, r3, [sp, #20]
3400bd8e:	9309      	str	r3, [sp, #36]	@ 0x24
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
3400bd90:	e9cd 230a 	strd	r2, r3, [sp, #40]	@ 0x28
{
3400bd94:	f04f 0801 	mov.w	r8, #1
3400bd98:	af03      	add	r7, sp, #12
    if (HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, i, &statConf[i - DCMIPP_STATEXT_MODULE1]) != HAL_OK)
3400bd9a:	fa5f f688 	uxtb.w	r6, r8
3400bd9e:	463b      	mov	r3, r7
3400bda0:	4632      	mov	r2, r6
3400bda2:	2101      	movs	r1, #1
3400bda4:	6828      	ldr	r0, [r5, #0]
3400bda6:	f7f8 fcac 	bl	34004702 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>
3400bdaa:	b318      	cbz	r0, 3400bdf4 <ISP_SVC_Stats_Gather+0x1c8>
      printf("ERROR: can't set Statistic Extraction config\r\n");
3400bdac:	4857      	ldr	r0, [pc, #348]	@ (3400bf0c <ISP_SVC_Stats_Gather+0x2e0>)
      printf("ERROR: can't enable Statistic Extraction config\r\n");
3400bdae:	f001 fc81 	bl	3400d6b4 <puts>
}
3400bdb2:	b00d      	add	sp, #52	@ 0x34
3400bdb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
3400bdb8:	2300      	movs	r3, #0
      statConf[i].Source = avgRGBUp[i];
3400bdba:	2210      	movs	r2, #16
3400bdbc:	e9cd 3303 	strd	r3, r3, [sp, #12]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
3400bdc0:	e9cd 2307 	strd	r2, r3, [sp, #28]
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
3400bdc4:	e9cd 3305 	strd	r3, r3, [sp, #20]
      statConf[i].Source = avgRGBUp[i];
3400bdc8:	2220      	movs	r2, #32
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
3400bdca:	9309      	str	r3, [sp, #36]	@ 0x24
      statConf[i].Source = avgRGBUp[i];
3400bdcc:	e7e0      	b.n	3400bd90 <ISP_SVC_Stats_Gather+0x164>
    SetStatConfig(statConf, &statConfUpBins_0_2);
3400bdce:	4950      	ldr	r1, [pc, #320]	@ (3400bf10 <ISP_SVC_Stats_Gather+0x2e4>)
    SetStatConfig(statConf, &statConfDownBins_9_11);
3400bdd0:	a803      	add	r0, sp, #12
3400bdd2:	f7ff fa9b 	bl	3400b30c <SetStatConfig>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3400bdd6:	e7dd      	b.n	3400bd94 <ISP_SVC_Stats_Gather+0x168>
    SetStatConfig(statConf, &statConfUpBins_3_5);
3400bdd8:	494e      	ldr	r1, [pc, #312]	@ (3400bf14 <ISP_SVC_Stats_Gather+0x2e8>)
3400bdda:	e7f9      	b.n	3400bdd0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfUpBins_6_8);
3400bddc:	494e      	ldr	r1, [pc, #312]	@ (3400bf18 <ISP_SVC_Stats_Gather+0x2ec>)
3400bdde:	e7f7      	b.n	3400bdd0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfUpBins_9_11);
3400bde0:	494e      	ldr	r1, [pc, #312]	@ (3400bf1c <ISP_SVC_Stats_Gather+0x2f0>)
3400bde2:	e7f5      	b.n	3400bdd0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_0_2);
3400bde4:	494e      	ldr	r1, [pc, #312]	@ (3400bf20 <ISP_SVC_Stats_Gather+0x2f4>)
3400bde6:	e7f3      	b.n	3400bdd0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_3_5);
3400bde8:	494e      	ldr	r1, [pc, #312]	@ (3400bf24 <ISP_SVC_Stats_Gather+0x2f8>)
3400bdea:	e7f1      	b.n	3400bdd0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_6_8);
3400bdec:	494e      	ldr	r1, [pc, #312]	@ (3400bf28 <ISP_SVC_Stats_Gather+0x2fc>)
3400bdee:	e7ef      	b.n	3400bdd0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_9_11);
3400bdf0:	494e      	ldr	r1, [pc, #312]	@ (3400bf2c <ISP_SVC_Stats_Gather+0x300>)
3400bdf2:	e7ed      	b.n	3400bdd0 <ISP_SVC_Stats_Gather+0x1a4>
    if (HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1, i) != HAL_OK)
3400bdf4:	4632      	mov	r2, r6
3400bdf6:	2101      	movs	r1, #1
3400bdf8:	6828      	ldr	r0, [r5, #0]
3400bdfa:	f7f8 fccd 	bl	34004798 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>
3400bdfe:	4606      	mov	r6, r0
3400be00:	b108      	cbz	r0, 3400be06 <ISP_SVC_Stats_Gather+0x1da>
      printf("ERROR: can't enable Statistic Extraction config\r\n");
3400be02:	484b      	ldr	r0, [pc, #300]	@ (3400bf30 <ISP_SVC_Stats_Gather+0x304>)
3400be04:	e7d3      	b.n	3400bdae <ISP_SVC_Stats_Gather+0x182>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3400be06:	f108 0801 	add.w	r8, r8, #1
3400be0a:	f1b8 0f04 	cmp.w	r8, #4
3400be0e:	f107 070c 	add.w	r7, r7, #12
3400be12:	d1c2      	bne.n	3400bd9a <ISP_SVC_Stats_Gather+0x16e>
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
3400be14:	f894 8158 	ldrb.w	r8, [r4, #344]	@ 0x158
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
3400be18:	f899 b000 	ldrb.w	fp, [r9]
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
3400be1c:	f018 0f05 	tst.w	r8, #5
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
3400be20:	bf0c      	ite	eq
3400be22:	2301      	moveq	r3, #1
3400be24:	2300      	movne	r3, #0
  return hIsp->MainPipe_FrameCount;
3400be26:	f8d5 a040 	ldr.w	sl, [r5, #64]	@ 0x40
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
3400be2a:	f894 7159 	ldrb.w	r7, [r4, #345]	@ 0x159
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
3400be2e:	455b      	cmp	r3, fp
    ongoing->upFrameIdStart = frameId;
3400be30:	bf08      	it	eq
3400be32:	f8c4 a0e4 	streq.w	sl, [r4, #228]	@ 0xe4
      stage = ISP_STAT_CFG_DOWN_AVG;
3400be36:	f017 0f05 	tst.w	r7, #5
3400be3a:	bf0c      	ite	eq
3400be3c:	2306      	moveq	r3, #6
3400be3e:	2305      	movne	r3, #5
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_DOWN))
3400be40:	459b      	cmp	fp, r3
3400be42:	d17d      	bne.n	3400bf40 <ISP_SVC_Stats_Gather+0x314>
    ongoing->downFrameIdStart = frameId;
3400be44:	f8c4 a0ec 	str.w	sl, [r4, #236]	@ 0xec
      stage = ISP_STAT_CFG_DOWN_BINS_9_11;
3400be48:	f017 0f06 	tst.w	r7, #6
3400be4c:	bf0c      	ite	eq
3400be4e:	2305      	moveq	r3, #5
3400be50:	2309      	movne	r3, #9
  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_DOWN)) && (ongoing->downFrameIdStart != 0))
3400be52:	459b      	cmp	fp, r3
3400be54:	d11e      	bne.n	3400be94 <ISP_SVC_Stats_Gather+0x268>
3400be56:	f8d4 e0ec 	ldr.w	lr, [r4, #236]	@ 0xec
3400be5a:	f1be 0f00 	cmp.w	lr, #0
3400be5e:	d019      	beq.n	3400be94 <ISP_SVC_Stats_Gather+0x268>
    ISP_SVC_StatEngine.last.down = ongoing->down;
3400be60:	4d34      	ldr	r5, [pc, #208]	@ (3400bf34 <ISP_SVC_Stats_Gather+0x308>)
    ISP_SVC_StatEngine.last.downFrameIdStart = ongoing->downFrameIdStart;
3400be62:	e9c4 ea1d 	strd	lr, sl, [r4, #116]	@ 0x74
    ISP_SVC_StatEngine.last.down = ongoing->down;
3400be66:	f105 0c78 	add.w	ip, r5, #120	@ 0x78
3400be6a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
3400be6e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3400be70:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
3400be74:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3400be76:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
3400be7a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3400be7c:	4628      	mov	r0, r5
3400be7e:	f8dc 3000 	ldr.w	r3, [ip]
    memset(&ongoing->down, 0, sizeof(ongoing->down));
3400be82:	2234      	movs	r2, #52	@ 0x34
    ISP_SVC_StatEngine.last.down = ongoing->down;
3400be84:	f840 3b48 	str.w	r3, [r0], #72
    memset(&ongoing->down, 0, sizeof(ongoing->down));
3400be88:	2100      	movs	r1, #0
3400be8a:	f001 fd43 	bl	3400d914 <memset>
    ongoing->downFrameIdStart = 0;
3400be8e:	2300      	movs	r3, #0
    ongoing->downFrameIdEnd = 0;
3400be90:	e9c4 333b 	strd	r3, r3, [r4, #236]	@ 0xec
  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
3400be94:	ea48 0307 	orr.w	r3, r8, r7
3400be98:	075a      	lsls	r2, r3, #29
3400be9a:	d50b      	bpl.n	3400beb4 <ISP_SVC_Stats_Gather+0x288>
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
3400be9c:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
3400bea0:	4553      	cmp	r3, sl
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
3400bea2:	bf3f      	itttt	cc
3400bea4:	f028 0804 	biccc.w	r8, r8, #4
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
3400bea8:	f027 0704 	biccc.w	r7, r7, #4
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
3400beac:	f884 8158 	strbcc.w	r8, [r4, #344]	@ 0x158
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
3400beb0:	f884 7159 	strbcc.w	r7, [r4, #345]	@ 0x159
  stagePrevious2 = stagePrevious1;
3400beb4:	4b20      	ldr	r3, [pc, #128]	@ (3400bf38 <ISP_SVC_Stats_Gather+0x30c>)
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
3400beb6:	f894 1158 	ldrb.w	r1, [r4, #344]	@ 0x158
  stagePrevious2 = stagePrevious1;
3400beba:	781a      	ldrb	r2, [r3, #0]
3400bebc:	f889 2000 	strb.w	r2, [r9]
  stagePrevious1 = ISP_SVC_StatEngine.stage;
3400bec0:	7822      	ldrb	r2, [r4, #0]
3400bec2:	701a      	strb	r2, [r3, #0]
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
3400bec4:	074b      	lsls	r3, r1, #29
3400bec6:	d403      	bmi.n	3400bed0 <ISP_SVC_Stats_Gather+0x2a4>
      (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
3400bec8:	f894 3159 	ldrb.w	r3, [r4, #345]	@ 0x159
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
3400becc:	075f      	lsls	r7, r3, #29
3400bece:	d561      	bpl.n	3400bf94 <ISP_SVC_Stats_Gather+0x368>
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
3400bed0:	1c53      	adds	r3, r2, #1
3400bed2:	b2db      	uxtb	r3, r3
3400bed4:	2a09      	cmp	r2, #9
3400bed6:	bf38      	it	cc
3400bed8:	461e      	movcc	r6, r3
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
3400beda:	7026      	strb	r6, [r4, #0]
3400bedc:	e769      	b.n	3400bdb2 <ISP_SVC_Stats_Gather+0x186>
3400bede:	bf00      	nop
3400bee0:	340108fd 	.word	0x340108fd
3400bee4:	340cfef0 	.word	0x340cfef0
3400bee8:	340cff70 	.word	0x340cff70
3400beec:	340cff7c 	.word	0x340cff7c
3400bef0:	340cff88 	.word	0x340cff88
3400bef4:	340cff94 	.word	0x340cff94
3400bef8:	340d0050 	.word	0x340d0050
3400befc:	340cffa4 	.word	0x340cffa4
3400bf00:	340cffb0 	.word	0x340cffb0
3400bf04:	340cffbc 	.word	0x340cffbc
3400bf08:	340cffc8 	.word	0x340cffc8
3400bf0c:	34010918 	.word	0x34010918
3400bf10:	34011184 	.word	0x34011184
3400bf14:	34011178 	.word	0x34011178
3400bf18:	3401116c 	.word	0x3401116c
3400bf1c:	34011160 	.word	0x34011160
3400bf20:	34011154 	.word	0x34011154
3400bf24:	34011148 	.word	0x34011148
3400bf28:	3401113c 	.word	0x3401113c
3400bf2c:	34011130 	.word	0x34011130
3400bf30:	34010946 	.word	0x34010946
3400bf34:	340cff28 	.word	0x340cff28
3400bf38:	34013be8 	.word	0x34013be8
3400bf3c:	34013be9 	.word	0x34013be9
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
3400bf40:	f018 0f06 	tst.w	r8, #6
3400bf44:	bf14      	ite	ne
3400bf46:	2301      	movne	r3, #1
3400bf48:	2300      	moveq	r3, #0
  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_UP)) && (ongoing->upFrameIdStart != 0))
3400bf4a:	ebbb 0f83 	cmp.w	fp, r3, lsl #2
3400bf4e:	f47f af7b 	bne.w	3400be48 <ISP_SVC_Stats_Gather+0x21c>
3400bf52:	f8d4 e0e4 	ldr.w	lr, [r4, #228]	@ 0xe4
3400bf56:	f1be 0f00 	cmp.w	lr, #0
3400bf5a:	f43f af75 	beq.w	3400be48 <ISP_SVC_Stats_Gather+0x21c>
    ISP_SVC_StatEngine.last.up = ongoing->up;
3400bf5e:	4d2f      	ldr	r5, [pc, #188]	@ (3400c01c <ISP_SVC_Stats_Gather+0x3f0>)
    ISP_SVC_StatEngine.last.upFrameIdStart = ongoing->upFrameIdStart;
3400bf60:	e9c4 ea1b 	strd	lr, sl, [r4, #108]	@ 0x6c
    ISP_SVC_StatEngine.last.up = ongoing->up;
3400bf64:	f105 0c78 	add.w	ip, r5, #120	@ 0x78
3400bf68:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
3400bf6c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3400bf6e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
3400bf72:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3400bf74:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
3400bf78:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3400bf7a:	4628      	mov	r0, r5
3400bf7c:	f8dc 3000 	ldr.w	r3, [ip]
    memset(&ongoing->up, 0, sizeof(ongoing->up));
3400bf80:	2234      	movs	r2, #52	@ 0x34
    ISP_SVC_StatEngine.last.up = ongoing->up;
3400bf82:	f840 3b48 	str.w	r3, [r0], #72
    memset(&ongoing->up, 0, sizeof(ongoing->up));
3400bf86:	2100      	movs	r1, #0
3400bf88:	f001 fcc4 	bl	3400d914 <memset>
    ongoing->upFrameIdStart = 0;
3400bf8c:	2300      	movs	r3, #0
    ongoing->upFrameIdEnd = 0;
3400bf8e:	e9c4 3339 	strd	r3, r3, [r4, #228]	@ 0xe4
3400bf92:	e759      	b.n	3400be48 <ISP_SVC_Stats_Gather+0x21c>
  switch (current)
3400bf94:	2a09      	cmp	r2, #9
3400bf96:	d836      	bhi.n	3400c006 <ISP_SVC_Stats_Gather+0x3da>
3400bf98:	e8df f002 	tbb	[pc, r2]
3400bf9c:	35353505 	.word	0x35353505
3400bfa0:	35351d11 	.word	0x35351d11
3400bfa4:	2a35      	.short	0x2a35
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3400bfa6:	078d      	lsls	r5, r1, #30
3400bfa8:	d434      	bmi.n	3400c014 <ISP_SVC_Stats_Gather+0x3e8>
    else if (ISP_SVC_StatEngine.downRequest &  ISP_STAT_TYPE_AVG)
3400bfaa:	07d8      	lsls	r0, r3, #31
3400bfac:	d434      	bmi.n	3400c018 <ISP_SVC_Stats_Gather+0x3ec>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
3400bfae:	f013 0602 	ands.w	r6, r3, #2
3400bfb2:	d12b      	bne.n	3400c00c <ISP_SVC_Stats_Gather+0x3e0>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
3400bfb4:	f011 0f01 	tst.w	r1, #1
3400bfb8:	bf08      	it	eq
3400bfba:	2609      	moveq	r6, #9
3400bfbc:	e78d      	b.n	3400beda <ISP_SVC_Stats_Gather+0x2ae>
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
3400bfbe:	07da      	lsls	r2, r3, #31
3400bfc0:	d42a      	bmi.n	3400c018 <ISP_SVC_Stats_Gather+0x3ec>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
3400bfc2:	f013 0602 	ands.w	r6, r3, #2
3400bfc6:	d121      	bne.n	3400c00c <ISP_SVC_Stats_Gather+0x3e0>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
3400bfc8:	07cb      	lsls	r3, r1, #31
3400bfca:	d486      	bmi.n	3400beda <ISP_SVC_Stats_Gather+0x2ae>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
3400bfcc:	f011 0f02 	tst.w	r1, #2
3400bfd0:	bf18      	it	ne
3400bfd2:	2601      	movne	r6, #1
3400bfd4:	e7f0      	b.n	3400bfb8 <ISP_SVC_Stats_Gather+0x38c>
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
3400bfd6:	f013 0602 	ands.w	r6, r3, #2
3400bfda:	d117      	bne.n	3400c00c <ISP_SVC_Stats_Gather+0x3e0>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
3400bfdc:	07cf      	lsls	r7, r1, #31
3400bfde:	f53f af7c 	bmi.w	3400beda <ISP_SVC_Stats_Gather+0x2ae>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3400bfe2:	078d      	lsls	r5, r1, #30
3400bfe4:	d416      	bmi.n	3400c014 <ISP_SVC_Stats_Gather+0x3e8>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
3400bfe6:	f013 0f01 	tst.w	r3, #1
3400bfea:	bf18      	it	ne
3400bfec:	4616      	movne	r6, r2
3400bfee:	e7e3      	b.n	3400bfb8 <ISP_SVC_Stats_Gather+0x38c>
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
3400bff0:	07c8      	lsls	r0, r1, #31
3400bff2:	d40d      	bmi.n	3400c010 <ISP_SVC_Stats_Gather+0x3e4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3400bff4:	0789      	lsls	r1, r1, #30
3400bff6:	d40d      	bmi.n	3400c014 <ISP_SVC_Stats_Gather+0x3e8>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
3400bff8:	07da      	lsls	r2, r3, #31
3400bffa:	d40d      	bmi.n	3400c018 <ISP_SVC_Stats_Gather+0x3ec>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
3400bffc:	f013 0f02 	tst.w	r3, #2
3400c000:	bf18      	it	ne
3400c002:	2606      	movne	r6, #6
3400c004:	e7d8      	b.n	3400bfb8 <ISP_SVC_Stats_Gather+0x38c>
    next = (ISP_SVC_StatEngineStage) (current + 1);
3400c006:	3201      	adds	r2, #1
3400c008:	b2d6      	uxtb	r6, r2
    break;
3400c00a:	e766      	b.n	3400beda <ISP_SVC_Stats_Gather+0x2ae>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
3400c00c:	2606      	movs	r6, #6
3400c00e:	e764      	b.n	3400beda <ISP_SVC_Stats_Gather+0x2ae>
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
3400c010:	2600      	movs	r6, #0
3400c012:	e762      	b.n	3400beda <ISP_SVC_Stats_Gather+0x2ae>
      next = ISP_STAT_CFG_UP_BINS_0_2;
3400c014:	2601      	movs	r6, #1
3400c016:	e760      	b.n	3400beda <ISP_SVC_Stats_Gather+0x2ae>
      next = ISP_STAT_CFG_DOWN_AVG;
3400c018:	2605      	movs	r6, #5
3400c01a:	e75e      	b.n	3400beda <ISP_SVC_Stats_Gather+0x2ae>
3400c01c:	340cfef4 	.word	0x340cfef4

3400c020 <ISP_SVC_Stats_ProcessCallbacks>:
  *         If the conditions are met, call the client registered callbacks
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_ProcessCallbacks(ISP_HandleTypeDef *hIsp)
{
3400c020:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  (void)hIsp; /* unused */
  ISP_SVC_StatStateTypeDef *pLastStat;
  ISP_SVC_StatRegisteredClient *client;
  ISP_StatusTypeDef retcb, ret = ISP_OK;
3400c024:	2500      	movs	r5, #0
3400c026:	4c1c      	ldr	r4, [pc, #112]	@ (3400c098 <ISP_SVC_Stats_ProcessCallbacks+0x78>)
{
3400c028:	2705      	movs	r7, #5
3400c02a:	4626      	mov	r6, r4
      {
        ret = retcb;
      }

      /* Remove the client from the registered list */
      client->callback = NULL;
3400c02c:	46a9      	mov	r9, r5
      *(client->pStats) = *pLastStat;
3400c02e:	f104 0804 	add.w	r8, r4, #4
    if (client->callback == NULL)
3400c032:	f8d4 a0f4 	ldr.w	sl, [r4, #244]	@ 0xf4
3400c036:	f1ba 0f00 	cmp.w	sl, #0
3400c03a:	d016      	beq.n	3400c06a <ISP_SVC_Stats_ProcessCallbacks+0x4a>
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
3400c03c:	f894 3104 	ldrb.w	r3, [r4, #260]	@ 0x104
3400c040:	2b02      	cmp	r3, #2
3400c042:	d119      	bne.n	3400c078 <ISP_SVC_Stats_ProcessCallbacks+0x58>
3400c044:	f8d4 2100 	ldr.w	r2, [r4, #256]	@ 0x100
3400c048:	6f73      	ldr	r3, [r6, #116]	@ 0x74
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
3400c04a:	429a      	cmp	r2, r3
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
3400c04c:	d80d      	bhi.n	3400c06a <ISP_SVC_Stats_ProcessCallbacks+0x4a>
      *(client->pStats) = *pLastStat;
3400c04e:	2278      	movs	r2, #120	@ 0x78
3400c050:	4641      	mov	r1, r8
3400c052:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
3400c056:	f001 fcf0 	bl	3400da3a <memcpy>
      retcb = client->callback(client->pAlgo);
3400c05a:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
3400c05e:	47d0      	blx	sl
      if (retcb != ISP_OK)
3400c060:	2800      	cmp	r0, #0
      client->callback = NULL;
3400c062:	bf18      	it	ne
3400c064:	4605      	movne	r5, r0
3400c066:	f8c4 90f4 	str.w	r9, [r4, #244]	@ 0xf4
  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3400c06a:	3f01      	subs	r7, #1
3400c06c:	f104 0414 	add.w	r4, r4, #20
3400c070:	d1df      	bne.n	3400c032 <ISP_SVC_Stats_ProcessCallbacks+0x12>
    }
  }

  return ret;
}
3400c072:	4628      	mov	r0, r5
3400c074:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
3400c078:	2b01      	cmp	r3, #1
3400c07a:	d103      	bne.n	3400c084 <ISP_SVC_Stats_ProcessCallbacks+0x64>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
3400c07c:	f8d4 2100 	ldr.w	r2, [r4, #256]	@ 0x100
3400c080:	6ef3      	ldr	r3, [r6, #108]	@ 0x6c
3400c082:	e7e2      	b.n	3400c04a <ISP_SVC_Stats_ProcessCallbacks+0x2a>
3400c084:	2b03      	cmp	r3, #3
3400c086:	d1f0      	bne.n	3400c06a <ISP_SVC_Stats_ProcessCallbacks+0x4a>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
3400c088:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
3400c08c:	6ef2      	ldr	r2, [r6, #108]	@ 0x6c
3400c08e:	4293      	cmp	r3, r2
3400c090:	d8eb      	bhi.n	3400c06a <ISP_SVC_Stats_ProcessCallbacks+0x4a>
3400c092:	6f72      	ldr	r2, [r6, #116]	@ 0x74
3400c094:	4293      	cmp	r3, r2
3400c096:	e7d9      	b.n	3400c04c <ISP_SVC_Stats_ProcessCallbacks+0x2c>
3400c098:	340cfef0 	.word	0x340cfef0

3400c09c <ISP_SVC_Stats_GetNext>:
  * @param  frameDelay: number of frames to wait before considering the stats as valid
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_GetNext(ISP_HandleTypeDef *hIsp, ISP_stat_ready_cb callback, ISP_AlgoTypeDef *pAlgo, ISP_SVC_StatStateTypeDef *pStats,
                                        ISP_SVC_StatLocation location, ISP_SVC_StatType type, uint32_t frameDelay)
{
3400c09c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
3400c0a0:	4691      	mov	r9, r2
3400c0a2:	f89d c01c 	ldrb.w	ip, [sp, #28]
3400c0a6:	f89d 5020 	ldrb.w	r5, [sp, #32]
  uint32_t i, refFrameId;

  /* Check handle validity */
  if ((hIsp == NULL) || (pStats == NULL))
3400c0aa:	b1b0      	cbz	r0, 3400c0da <ISP_SVC_Stats_GetNext+0x3e>
3400c0ac:	b1ab      	cbz	r3, 3400c0da <ISP_SVC_Stats_GetNext+0x3e>
  return hIsp->MainPipe_FrameCount;
3400c0ae:	4e1e      	ldr	r6, [pc, #120]	@ (3400c128 <ISP_SVC_Stats_GetNext+0x8c>)
  }

  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;

  /* Register the callback */
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3400c0b0:	f04f 0e00 	mov.w	lr, #0
3400c0b4:	4634      	mov	r4, r6
3400c0b6:	f04f 0805 	mov.w	r8, #5
  return hIsp->MainPipe_FrameCount;
3400c0ba:	6c00      	ldr	r0, [r0, #64]	@ 0x40
  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;
3400c0bc:	9f09      	ldr	r7, [sp, #36]	@ 0x24
3400c0be:	4407      	add	r7, r0
  {
    if (ISP_SVC_StatEngine.client[i].callback == NULL)
3400c0c0:	f8d6 20f4 	ldr.w	r2, [r6, #244]	@ 0xf4
3400c0c4:	b15a      	cbz	r2, 3400c0de <ISP_SVC_Stats_GetNext+0x42>
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3400c0c6:	f1b8 0801 	subs.w	r8, r8, #1
3400c0ca:	f10e 0e01 	add.w	lr, lr, #1
3400c0ce:	f106 0614 	add.w	r6, r6, #20
3400c0d2:	d1f5      	bne.n	3400c0c0 <ISP_SVC_Stats_GetNext+0x24>
  }

  if (i == ISP_SVC_STAT_MAX_CB)
  {
    /* Too much callback registered */
    return ISP_ERR_STAT_MAXCLIENTS;
3400c0d4:	20ac      	movs	r0, #172	@ 0xac
  ISP_SVC_StatEngine.client[i].location = location;
  ISP_SVC_StatEngine.client[i].type = type;
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;

  return ISP_OK;
}
3400c0d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return ISP_ERR_EINVAL;
3400c0da:	2001      	movs	r0, #1
3400c0dc:	e7fb      	b.n	3400c0d6 <ISP_SVC_Stats_GetNext+0x3a>
  if (location & ISP_STAT_LOC_UP)
3400c0de:	f01c 0f01 	tst.w	ip, #1
3400c0e2:	d004      	beq.n	3400c0ee <ISP_SVC_Stats_GetNext+0x52>
    ISP_SVC_StatEngine.upRequest |= type;
3400c0e4:	f894 6158 	ldrb.w	r6, [r4, #344]	@ 0x158
3400c0e8:	432e      	orrs	r6, r5
3400c0ea:	f884 6158 	strb.w	r6, [r4, #344]	@ 0x158
  if (location & ISP_STAT_LOC_DOWN)
3400c0ee:	f01c 0f02 	tst.w	ip, #2
    ISP_SVC_StatEngine.downRequest |= type;
3400c0f2:	bf1e      	ittt	ne
3400c0f4:	f894 6159 	ldrbne.w	r6, [r4, #345]	@ 0x159
3400c0f8:	432e      	orrne	r6, r5
3400c0fa:	f884 6159 	strbne.w	r6, [r4, #345]	@ 0x159
  if (type == ISP_STAT_TYPE_ALL_TMP)
3400c0fe:	2d04      	cmp	r5, #4
    ISP_SVC_StatEngine.requestAllCounter = ISP_SVC_Misc_GetMainFrameId(hIsp) + 3 * ISP_STAT_CFG_CYCLE_SIZE;
3400c100:	bf04      	itt	eq
3400c102:	301e      	addeq	r0, #30
3400c104:	f8c4 015c 	streq.w	r0, [r4, #348]	@ 0x15c
  ISP_SVC_StatEngine.client[i].callback = callback;
3400c108:	2014      	movs	r0, #20
3400c10a:	fb00 400e 	mla	r0, r0, lr, r4
  ISP_SVC_StatEngine.client[i].pAlgo = pAlgo;
3400c10e:	e9c0 193d 	strd	r1, r9, [r0, #244]	@ 0xf4
  ISP_SVC_StatEngine.client[i].pStats = pStats;
3400c112:	f8c0 30fc 	str.w	r3, [r0, #252]	@ 0xfc
  ISP_SVC_StatEngine.client[i].location = location;
3400c116:	f880 c104 	strb.w	ip, [r0, #260]	@ 0x104
  ISP_SVC_StatEngine.client[i].type = type;
3400c11a:	f880 5105 	strb.w	r5, [r0, #261]	@ 0x105
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;
3400c11e:	f8c0 7100 	str.w	r7, [r0, #256]	@ 0x100
  return ISP_OK;
3400c122:	2000      	movs	r0, #0
3400c124:	e7d7      	b.n	3400c0d6 <ISP_SVC_Stats_GetNext+0x3a>
3400c126:	bf00      	nop
3400c128:	340cfef0 	.word	0x340cfef0

3400c12c <CB_ISP_GetSensorGain>:
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_GetGain(int32_t *Gain)
{
  *Gain = Camera_Ctx.Gain;
3400c12c:	4b02      	ldr	r3, [pc, #8]	@ (3400c138 <CB_ISP_GetSensorGain+0xc>)
{
  if (CMW_CAMERA_GetGain(gain) != CMW_ERROR_NONE)
    return ISP_ERR_SENSORGAIN;

  return ISP_OK;
}
3400c12e:	2000      	movs	r0, #0
  *Gain = Camera_Ctx.Gain;
3400c130:	6a1b      	ldr	r3, [r3, #32]
3400c132:	600b      	str	r3, [r1, #0]
}
3400c134:	4770      	bx	lr
3400c136:	bf00      	nop
3400c138:	340d0420 	.word	0x340d0420

3400c13c <CB_ISP_GetSensorExposure>:
  *exposure = Camera_Ctx.Exposure;
3400c13c:	4b02      	ldr	r3, [pc, #8]	@ (3400c148 <CB_ISP_GetSensorExposure+0xc>)
{
  if (CMW_CAMERA_GetExposure(exposure) != CMW_ERROR_NONE)
    return ISP_ERR_SENSOREXPOSURE;

  return ISP_OK;
}
3400c13e:	2000      	movs	r0, #0
  *exposure = Camera_Ctx.Exposure;
3400c140:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c142:	600b      	str	r3, [r1, #0]
}
3400c144:	4770      	bx	lr
3400c146:	bf00      	nop
3400c148:	340d0420 	.word	0x340d0420

3400c14c <CB_ISP_GetSensorInfo>:

static ISP_StatusTypeDef CB_ISP_GetSensorInfo(uint32_t camera_instance, ISP_SensorInfoTypeDef *Info)
{
3400c14c:	b508      	push	{r3, lr}
  if(Camera_Drv.GetSensorInfo != NULL)
3400c14e:	4b05      	ldr	r3, [pc, #20]	@ (3400c164 <CB_ISP_GetSensorInfo+0x18>)
3400c150:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400c152:	b113      	cbz	r3, 3400c15a <CB_ISP_GetSensorInfo+0xe>
  {
    if (Camera_Drv.GetSensorInfo(&camera_bsp, Info) != CMW_ERROR_NONE)
3400c154:	4804      	ldr	r0, [pc, #16]	@ (3400c168 <CB_ISP_GetSensorInfo+0x1c>)
3400c156:	4798      	blx	r3
3400c158:	b908      	cbnz	r0, 3400c15e <CB_ISP_GetSensorInfo+0x12>
      return ISP_ERR_SENSOREXPOSURE;
  }
  return ISP_OK;
3400c15a:	2000      	movs	r0, #0
}
3400c15c:	bd08      	pop	{r3, pc}
      return ISP_ERR_SENSOREXPOSURE;
3400c15e:	2083      	movs	r0, #131	@ 0x83
3400c160:	e7fc      	b.n	3400c15c <CB_ISP_GetSensorInfo+0x10>
3400c162:	bf00      	nop
3400c164:	340d03b4 	.word	0x340d03b4
3400c168:	340d02b0 	.word	0x340d02b0

3400c16c <CMW_CAMERA_IMX335_Init>:

#if defined(USE_IMX335_SENSOR)
static int32_t CMW_CAMERA_IMX335_Init( CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3400c16c:	2100      	movs	r1, #0
{
3400c16e:	b570      	push	{r4, r5, r6, lr}
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
3400c170:	4b41      	ldr	r3, [pc, #260]	@ (3400c278 <CMW_CAMERA_IMX335_Init+0x10c>)
{
3400c172:	b096      	sub	sp, #88	@ 0x58
  memset(&camera_bsp, 0, sizeof(camera_bsp));
3400c174:	f44f 7282 	mov.w	r2, #260	@ 0x104
{
3400c178:	4604      	mov	r4, r0
  memset(&camera_bsp, 0, sizeof(camera_bsp));
3400c17a:	4618      	mov	r0, r3
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3400c17c:	e9cd 1101 	strd	r1, r1, [sp, #4]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3400c180:	e9cd 1103 	strd	r1, r1, [sp, #12]
3400c184:	e9cd 1105 	strd	r1, r1, [sp, #20]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
3400c188:	f001 fbc4 	bl	3400d914 <memset>
  camera_bsp.imx335_bsp.Address     = CAMERA_IMX335_ADDRESS;
3400c18c:	2234      	movs	r2, #52	@ 0x34
3400c18e:	8002      	strh	r2, [r0, #0]
  camera_bsp.imx335_bsp.Init        = CMW_I2C_INIT;
3400c190:	4a3a      	ldr	r2, [pc, #232]	@ (3400c27c <CMW_CAMERA_IMX335_Init+0x110>)
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;

  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
3400c192:	493b      	ldr	r1, [pc, #236]	@ (3400c280 <CMW_CAMERA_IMX335_Init+0x114>)
  camera_bsp.imx335_bsp.Init        = CMW_I2C_INIT;
3400c194:	f8c0 20e4 	str.w	r2, [r0, #228]	@ 0xe4
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
3400c198:	4a3a      	ldr	r2, [pc, #232]	@ (3400c284 <CMW_CAMERA_IMX335_Init+0x118>)
3400c19a:	f8c0 20e8 	str.w	r2, [r0, #232]	@ 0xe8
  camera_bsp.imx335_bsp.ReadReg     = CMW_I2C_READREG16;
3400c19e:	4a3a      	ldr	r2, [pc, #232]	@ (3400c288 <CMW_CAMERA_IMX335_Init+0x11c>)
3400c1a0:	f8c0 20f0 	str.w	r2, [r0, #240]	@ 0xf0
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3400c1a4:	4a39      	ldr	r2, [pc, #228]	@ (3400c28c <CMW_CAMERA_IMX335_Init+0x120>)
3400c1a6:	f8c0 20ec 	str.w	r2, [r0, #236]	@ 0xec
  camera_bsp.imx335_bsp.GetTick     = BSP_GetTick;
3400c1aa:	4a39      	ldr	r2, [pc, #228]	@ (3400c290 <CMW_CAMERA_IMX335_Init+0x124>)
3400c1ac:	f8c0 20f4 	str.w	r2, [r0, #244]	@ 0xf4
  camera_bsp.imx335_bsp.Delay       = HAL_Delay;
3400c1b0:	4a38      	ldr	r2, [pc, #224]	@ (3400c294 <CMW_CAMERA_IMX335_Init+0x128>)
3400c1b2:	f8c0 20f8 	str.w	r2, [r0, #248]	@ 0xf8
  camera_bsp.imx335_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
3400c1b6:	4a38      	ldr	r2, [pc, #224]	@ (3400c298 <CMW_CAMERA_IMX335_Init+0x12c>)
3400c1b8:	f8c0 20fc 	str.w	r2, [r0, #252]	@ 0xfc
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3400c1bc:	4a37      	ldr	r2, [pc, #220]	@ (3400c29c <CMW_CAMERA_IMX335_Init+0x130>)
3400c1be:	f8c0 2100 	str.w	r2, [r0, #256]	@ 0x100
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
3400c1c2:	4a37      	ldr	r2, [pc, #220]	@ (3400c2a0 <CMW_CAMERA_IMX335_Init+0x134>)
3400c1c4:	f8c0 20dc 	str.w	r2, [r0, #220]	@ 0xdc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
3400c1c8:	4a36      	ldr	r2, [pc, #216]	@ (3400c2a4 <CMW_CAMERA_IMX335_Init+0x138>)
3400c1ca:	f8c0 20c8 	str.w	r2, [r0, #200]	@ 0xc8
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
3400c1ce:	4a36      	ldr	r2, [pc, #216]	@ (3400c2a8 <CMW_CAMERA_IMX335_Init+0x13c>)
3400c1d0:	f8c0 20cc 	str.w	r2, [r0, #204]	@ 0xcc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
3400c1d4:	4a35      	ldr	r2, [pc, #212]	@ (3400c2ac <CMW_CAMERA_IMX335_Init+0x140>)
3400c1d6:	f8c0 20d0 	str.w	r2, [r0, #208]	@ 0xd0
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
3400c1da:	4a35      	ldr	r2, [pc, #212]	@ (3400c2b0 <CMW_CAMERA_IMX335_Init+0x144>)
3400c1dc:	f8c0 20d4 	str.w	r2, [r0, #212]	@ 0xd4
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
3400c1e0:	4a34      	ldr	r2, [pc, #208]	@ (3400c2b4 <CMW_CAMERA_IMX335_Init+0x148>)
3400c1e2:	f8c0 20c4 	str.w	r2, [r0, #196]	@ 0xc4
  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
3400c1e6:	f000 fb49 	bl	3400c87c <CMW_IMX335_Probe>
  if (ret != CMW_ERROR_NONE)
3400c1ea:	2800      	cmp	r0, #0
3400c1ec:	d140      	bne.n	3400c270 <CMW_CAMERA_IMX335_Init+0x104>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3400c1ee:	6823      	ldr	r3, [r4, #0]
3400c1f0:	4d23      	ldr	r5, [pc, #140]	@ (3400c280 <CMW_CAMERA_IMX335_Init+0x114>)
3400c1f2:	b10b      	cbz	r3, 3400c1f8 <CMW_CAMERA_IMX335_Init+0x8c>
3400c1f4:	6863      	ldr	r3, [r4, #4]
3400c1f6:	b93b      	cbnz	r3, 3400c208 <CMW_CAMERA_IMX335_Init+0x9c>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3400c1f8:	6dab      	ldr	r3, [r5, #88]	@ 0x58
3400c1fa:	481f      	ldr	r0, [pc, #124]	@ (3400c278 <CMW_CAMERA_IMX335_Init+0x10c>)
3400c1fc:	a907      	add	r1, sp, #28
3400c1fe:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
3400c200:	9b10      	ldr	r3, [sp, #64]	@ 0x40
3400c202:	6023      	str	r3, [r4, #0]
    initSensors_params->height = sensor_info.height;
3400c204:	9b11      	ldr	r3, [sp, #68]	@ 0x44
3400c206:	6063      	str	r3, [r4, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
3400c208:	4621      	mov	r1, r4
3400c20a:	682b      	ldr	r3, [r5, #0]
3400c20c:	481a      	ldr	r0, [pc, #104]	@ (3400c278 <CMW_CAMERA_IMX335_Init+0x10c>)
3400c20e:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
3400c210:	bb70      	cbnz	r0, 3400c270 <CMW_CAMERA_IMX335_Init+0x104>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  ret = Camera_Drv.SetFrequency(&camera_bsp, IMX335_INCK_37MHZ);
3400c212:	2105      	movs	r1, #5
3400c214:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
3400c216:	4818      	ldr	r0, [pc, #96]	@ (3400c278 <CMW_CAMERA_IMX335_Init+0x10c>)
3400c218:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
3400c21a:	4604      	mov	r4, r0
3400c21c:	bb40      	cbnz	r0, 3400c270 <CMW_CAMERA_IMX335_Init+0x104>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3400c21e:	2301      	movs	r3, #1
3400c220:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400c224:	e9cd 2301 	strd	r2, r3, [sp, #4]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
3400c228:	232c      	movs	r3, #44	@ 0x2c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3400c22a:	481d      	ldr	r0, [pc, #116]	@ (3400c2a0 <CMW_CAMERA_IMX335_Init+0x134>)
3400c22c:	a901      	add	r1, sp, #4
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
3400c22e:	9303      	str	r3, [sp, #12]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3400c230:	f7f7 fc00 	bl	34003a34 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
3400c234:	b120      	cbz	r0, 3400c240 <CMW_CAMERA_IMX335_Init+0xd4>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3400c236:	f06f 0403 	mvn.w	r4, #3
    }
  }


  return ret;
}
3400c23a:	4620      	mov	r0, r4
3400c23c:	b016      	add	sp, #88	@ 0x58
3400c23e:	bd70      	pop	{r4, r5, r6, pc}
  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP10);
3400c240:	2203      	movs	r2, #3
3400c242:	4621      	mov	r1, r4
3400c244:	4816      	ldr	r0, [pc, #88]	@ (3400c2a0 <CMW_CAMERA_IMX335_Init+0x134>)
3400c246:	f7f7 fcd9 	bl	34003bfc <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
3400c24a:	2800      	cmp	r0, #0
3400c24c:	d1f3      	bne.n	3400c236 <CMW_CAMERA_IMX335_Init+0xca>
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW10;
3400c24e:	232b      	movs	r3, #43	@ 0x2b
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3400c250:	4625      	mov	r5, r4
  csi_pipe_conf.DataTypeIDB = 0;
3400c252:	e9cd 3405 	strd	r3, r4, [sp, #20]
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3400c256:	4e12      	ldr	r6, [pc, #72]	@ (3400c2a0 <CMW_CAMERA_IMX335_Init+0x134>)
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3400c258:	9404      	str	r4, [sp, #16]
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3400c25a:	4629      	mov	r1, r5
3400c25c:	4630      	mov	r0, r6
3400c25e:	aa04      	add	r2, sp, #16
3400c260:	f7f7 fc76 	bl	34003b50 <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
3400c264:	2800      	cmp	r0, #0
3400c266:	d1e6      	bne.n	3400c236 <CMW_CAMERA_IMX335_Init+0xca>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3400c268:	3501      	adds	r5, #1
3400c26a:	2d03      	cmp	r5, #3
3400c26c:	d1f5      	bne.n	3400c25a <CMW_CAMERA_IMX335_Init+0xee>
3400c26e:	e7e4      	b.n	3400c23a <CMW_CAMERA_IMX335_Init+0xce>
    return CMW_ERROR_COMPONENT_FAILURE;
3400c270:	f06f 0404 	mvn.w	r4, #4
3400c274:	e7e1      	b.n	3400c23a <CMW_CAMERA_IMX335_Init+0xce>
3400c276:	bf00      	nop
3400c278:	340d02b0 	.word	0x340d02b0
3400c27c:	34002ffd 	.word	0x34002ffd
3400c280:	340d03b4 	.word	0x340d03b4
3400c284:	34003015 	.word	0x34003015
3400c288:	34003061 	.word	0x34003061
3400c28c:	34003039 	.word	0x34003039
3400c290:	34003089 	.word	0x34003089
3400c294:	340036b5 	.word	0x340036b5
3400c298:	3400c2cd 	.word	0x3400c2cd
3400c29c:	3400c2b9 	.word	0x3400c2b9
3400c2a0:	340d0414 	.word	0x340d0414
3400c2a4:	3400c54d 	.word	0x3400c54d
3400c2a8:	3400c12d 	.word	0x3400c12d
3400c2ac:	3400c591 	.word	0x3400c591
3400c2b0:	3400c13d 	.word	0x3400c13d
3400c2b4:	3400c14d 	.word	0x3400c14d

3400c2b8 <CMW_CAMERA_EnablePin>:
  HAL_GPIO_WritePin(EN_CAM_PORT, EN_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
3400c2b8:	1e02      	subs	r2, r0, #0
3400c2ba:	bf18      	it	ne
3400c2bc:	2201      	movne	r2, #1
3400c2be:	2140      	movs	r1, #64	@ 0x40
3400c2c0:	4801      	ldr	r0, [pc, #4]	@ (3400c2c8 <CMW_CAMERA_EnablePin+0x10>)
3400c2c2:	f7f8 bfb7 	b.w	34005234 <HAL_GPIO_WritePin>
3400c2c6:	bf00      	nop
3400c2c8:	56021800 	.word	0x56021800

3400c2cc <CMW_CAMERA_ShutdownPin>:
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
3400c2cc:	1e02      	subs	r2, r0, #0
3400c2ce:	bf18      	it	ne
3400c2d0:	2201      	movne	r2, #1
3400c2d2:	2110      	movs	r1, #16
3400c2d4:	4801      	ldr	r0, [pc, #4]	@ (3400c2dc <CMW_CAMERA_ShutdownPin+0x10>)
3400c2d6:	f7f8 bfad 	b.w	34005234 <HAL_GPIO_WritePin>
3400c2da:	bf00      	nop
3400c2dc:	56021800 	.word	0x56021800

3400c2e0 <CMW_CAMERA_EnableGPIOs>:
{
3400c2e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3400c2e2:	2240      	movs	r2, #64	@ 0x40
  GPIO_InitTypeDef gpio_init_structure = {0};
3400c2e4:	2400      	movs	r4, #0
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3400c2e6:	2701      	movs	r7, #1
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3400c2e8:	2603      	movs	r6, #3
3400c2ea:	4b11      	ldr	r3, [pc, #68]	@ (3400c330 <CMW_CAMERA_EnableGPIOs+0x50>)
{
3400c2ec:	b089      	sub	sp, #36	@ 0x24
  GPIO_InitTypeDef gpio_init_structure = {0};
3400c2ee:	9407      	str	r4, [sp, #28]
3400c2f0:	f8c3 2a5c 	str.w	r2, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3400c2f4:	f8d3 125c 	ldr.w	r1, [r3, #604]	@ 0x25c
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
3400c2f8:	4d0e      	ldr	r5, [pc, #56]	@ (3400c334 <CMW_CAMERA_EnableGPIOs+0x54>)
3400c2fa:	9102      	str	r1, [sp, #8]
  (void)tmpreg;
3400c2fc:	9902      	ldr	r1, [sp, #8]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3400c2fe:	f8c3 2a5c 	str.w	r2, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3400c302:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3400c306:	4628      	mov	r0, r5
3400c308:	9301      	str	r3, [sp, #4]
3400c30a:	a903      	add	r1, sp, #12
  (void)tmpreg;
3400c30c:	9b01      	ldr	r3, [sp, #4]
  gpio_init_structure.Pin       = EN_CAM_PIN;
3400c30e:	9203      	str	r2, [sp, #12]
  gpio_init_structure.Pull      = GPIO_NOPULL;
3400c310:	9405      	str	r4, [sp, #20]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3400c312:	9704      	str	r7, [sp, #16]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3400c314:	9606      	str	r6, [sp, #24]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
3400c316:	f7f8 fded 	bl	34004ef4 <HAL_GPIO_Init>
  gpio_init_structure.Pin       = NRST_CAM_PIN;
3400c31a:	2310      	movs	r3, #16
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
3400c31c:	4628      	mov	r0, r5
3400c31e:	a903      	add	r1, sp, #12
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3400c320:	e9cd 7404 	strd	r7, r4, [sp, #16]
  gpio_init_structure.Pin       = NRST_CAM_PIN;
3400c324:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3400c326:	9606      	str	r6, [sp, #24]
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
3400c328:	f7f8 fde4 	bl	34004ef4 <HAL_GPIO_Init>
}
3400c32c:	b009      	add	sp, #36	@ 0x24
3400c32e:	bdf0      	pop	{r4, r5, r6, r7, pc}
3400c330:	56028000 	.word	0x56028000
3400c334:	56021800 	.word	0x56021800

3400c338 <CMW_CAMERA_GetDCMIPPHandle>:
}
3400c338:	4800      	ldr	r0, [pc, #0]	@ (3400c33c <CMW_CAMERA_GetDCMIPPHandle+0x4>)
3400c33a:	4770      	bx	lr
3400c33c:	340d0414 	.word	0x340d0414

3400c340 <CMW_CAMERA_SetPipeConfig>:
{
3400c340:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#endif

static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3400c344:	2600      	movs	r6, #0
{
3400c346:	4604      	mov	r4, r0
3400c348:	b093      	sub	sp, #76	@ 0x4c
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3400c34a:	f10d 0830 	add.w	r8, sp, #48	@ 0x30
{
3400c34e:	460d      	mov	r5, r1
3400c350:	4617      	mov	r7, r2
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3400c352:	4631      	mov	r1, r6
3400c354:	2218      	movs	r2, #24
3400c356:	4640      	mov	r0, r8
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
3400c358:	e9cd 6604 	strd	r6, r6, [sp, #16]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3400c35c:	9602      	str	r6, [sp, #8]
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
3400c35e:	9606      	str	r6, [sp, #24]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3400c360:	9603      	str	r6, [sp, #12]
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3400c362:	f001 fad7 	bl	3400d914 <memset>
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
3400c366:	2214      	movs	r2, #20
3400c368:	4631      	mov	r1, r6
3400c36a:	a807      	add	r0, sp, #28
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3400c36c:	f10d 0908 	add.w	r9, sp, #8
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
3400c370:	f001 fad0 	bl	3400d914 <memset>
  int ret;

  /* specific case for pipe0 which is only a dump pipe */
  if (pipe == DCMIPP_PIPE0)
3400c374:	b95c      	cbnz	r4, 3400c38e <CMW_CAMERA_SetPipeConfig+0x4e>
  {
    /*  TODO: properly configure the dump pipe with decimation and crop */
    pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
3400c376:	4621      	mov	r1, r4
3400c378:	484f      	ldr	r0, [pc, #316]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c37a:	aa04      	add	r2, sp, #16
3400c37c:	f7f7 fc62 	bl	34003c44 <HAL_DCMIPP_PIPE_SetConfig>
    if (ret != HAL_OK)
3400c380:	2800      	cmp	r0, #0
3400c382:	d07c      	beq.n	3400c47e <CMW_CAMERA_SetPipeConfig+0x13e>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3400c384:	f06f 0004 	mvn.w	r0, #4
}
3400c388:	b013      	add	sp, #76	@ 0x4c
3400c38a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }

    return HAL_OK;
  }

  CMW_UTILS_GetPipeConfig(camera_conf.width, camera_conf.height, p_conf, &crop_conf, &dec_conf, &down_conf);
3400c38e:	e9cd 9800 	strd	r9, r8, [sp]
3400c392:	484a      	ldr	r0, [pc, #296]	@ (3400c4bc <CMW_CAMERA_SetPipeConfig+0x17c>)
3400c394:	462a      	mov	r2, r5
3400c396:	e9d0 0100 	ldrd	r0, r1, [r0]
3400c39a:	ab07      	add	r3, sp, #28
3400c39c:	f000 fb36 	bl	3400ca0c <CMW_UTILS_GetPipeConfig>

  if (crop_conf.VSize != 0 || crop_conf.HSize != 0)
3400c3a0:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	@ 0x24
3400c3a4:	4313      	orrs	r3, r2
3400c3a6:	d015      	beq.n	3400c3d4 <CMW_CAMERA_SetPipeConfig+0x94>
  {
    ret = HAL_DCMIPP_PIPE_SetCropConfig(hdcmipp, pipe, &crop_conf);
3400c3a8:	4621      	mov	r1, r4
3400c3aa:	4843      	ldr	r0, [pc, #268]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c3ac:	aa07      	add	r2, sp, #28
3400c3ae:	f7f7 fe07 	bl	34003fc0 <HAL_DCMIPP_PIPE_SetCropConfig>
    if (ret != HAL_OK)
3400c3b2:	2800      	cmp	r0, #0
3400c3b4:	d1e6      	bne.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }

    ret = HAL_DCMIPP_PIPE_EnableCrop(hdcmipp, pipe);
3400c3b6:	4621      	mov	r1, r4
3400c3b8:	483f      	ldr	r0, [pc, #252]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c3ba:	f7f7 fe67 	bl	3400408c <HAL_DCMIPP_PIPE_EnableCrop>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
    if (ret != HAL_OK)
3400c3be:	2800      	cmp	r0, #0
3400c3c0:	d1e0      	bne.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }

  if (dec_conf.VRatio != 0 || dec_conf.HRatio != 0)
3400c3c2:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
3400c3c6:	4313      	orrs	r3, r2
3400c3c8:	d109      	bne.n	3400c3de <CMW_CAMERA_SetPipeConfig+0x9e>
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableDecimation(hdcmipp, pipe);
3400c3ca:	4621      	mov	r1, r4
3400c3cc:	483a      	ldr	r0, [pc, #232]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c3ce:	f7f7 ff11 	bl	340041f4 <HAL_DCMIPP_PIPE_DisableDecimation>
3400c3d2:	e00f      	b.n	3400c3f4 <CMW_CAMERA_SetPipeConfig+0xb4>
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
3400c3d4:	4621      	mov	r1, r4
3400c3d6:	4838      	ldr	r0, [pc, #224]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c3d8:	f7f7 fe8c 	bl	340040f4 <HAL_DCMIPP_PIPE_DisableCrop>
3400c3dc:	e7ef      	b.n	3400c3be <CMW_CAMERA_SetPipeConfig+0x7e>
    ret = HAL_DCMIPP_PIPE_SetDecimationConfig(hdcmipp, pipe, &dec_conf);
3400c3de:	464a      	mov	r2, r9
3400c3e0:	4621      	mov	r1, r4
3400c3e2:	4835      	ldr	r0, [pc, #212]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c3e4:	f7f7 fecb 	bl	3400417e <HAL_DCMIPP_PIPE_SetDecimationConfig>
    if (ret != HAL_OK)
3400c3e8:	2800      	cmp	r0, #0
3400c3ea:	d1cb      	bne.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
    ret = HAL_DCMIPP_PIPE_EnableDecimation(hdcmipp, pipe);
3400c3ec:	4621      	mov	r1, r4
3400c3ee:	4832      	ldr	r0, [pc, #200]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c3f0:	f7f7 fee8 	bl	340041c4 <HAL_DCMIPP_PIPE_EnableDecimation>
    if (ret != HAL_OK)
3400c3f4:	2800      	cmp	r0, #0
3400c3f6:	d1c5      	bne.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }

  ret = HAL_DCMIPP_PIPE_SetDownsizeConfig(hdcmipp, pipe, &down_conf);
3400c3f8:	4642      	mov	r2, r8
3400c3fa:	4621      	mov	r1, r4
3400c3fc:	482e      	ldr	r0, [pc, #184]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c3fe:	f7f7 ff11 	bl	34004224 <HAL_DCMIPP_PIPE_SetDownsizeConfig>
  if (ret != HAL_OK)
3400c402:	4e2d      	ldr	r6, [pc, #180]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c404:	2800      	cmp	r0, #0
3400c406:	d1bd      	bne.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  ret = HAL_DCMIPP_PIPE_EnableDownsize(hdcmipp, pipe);
3400c408:	4621      	mov	r1, r4
3400c40a:	4630      	mov	r0, r6
3400c40c:	f7f7 ff55 	bl	340042ba <HAL_DCMIPP_PIPE_EnableDownsize>
  if (ret != HAL_OK)
3400c410:	2800      	cmp	r0, #0
3400c412:	d1b7      	bne.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  if (p_conf->enable_swap)
3400c414:	692b      	ldr	r3, [r5, #16]
  {
    /* Config pipe */
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
3400c416:	4621      	mov	r1, r4
3400c418:	4630      	mov	r0, r6
  if (p_conf->enable_swap)
3400c41a:	2b00      	cmp	r3, #0
3400c41c:	d031      	beq.n	3400c482 <CMW_CAMERA_SetPipeConfig+0x142>
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
3400c41e:	f7f8 fac9 	bl	340049b4 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
    if (ret != HAL_OK)
3400c422:	2800      	cmp	r0, #0
3400c424:	d1ae      	bne.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
  }

  /* Ignore the configuration of gamma if -1
   * Activation is then done by the ISP Library
   */
  if (p_conf->enable_gamma_conversion > -1)
3400c426:	696b      	ldr	r3, [r5, #20]
3400c428:	2b00      	cmp	r3, #0
3400c42a:	da2d      	bge.n	3400c488 <CMW_CAMERA_SetPipeConfig+0x148>
        return CMW_ERROR_COMPONENT_FAILURE;
      }
    }
  }

  if (pipe == DCMIPP_PIPE2)
3400c42c:	2c02      	cmp	r4, #2
3400c42e:	d10f      	bne.n	3400c450 <CMW_CAMERA_SetPipeConfig+0x110>
  {
    if (!is_pipe1_2_shared)
3400c430:	f8df 808c 	ldr.w	r8, [pc, #140]	@ 3400c4c0 <CMW_CAMERA_SetPipeConfig+0x180>
3400c434:	f8d8 3000 	ldr.w	r3, [r8]
3400c438:	b953      	cbnz	r3, 3400c450 <CMW_CAMERA_SetPipeConfig+0x110>
    {
      ret = HAL_DCMIPP_PIPE_CSI_EnableShare(hdcmipp, pipe);
3400c43a:	4621      	mov	r1, r4
3400c43c:	481e      	ldr	r0, [pc, #120]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c43e:	f7f8 faef 	bl	34004a20 <HAL_DCMIPP_PIPE_CSI_EnableShare>
      if (ret != HAL_OK)
3400c442:	2800      	cmp	r0, #0
3400c444:	d19e      	bne.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
      }
      is_pipe1_2_shared++;
3400c446:	f8d8 3000 	ldr.w	r3, [r8]
3400c44a:	3301      	adds	r3, #1
3400c44c:	f8c8 3000 	str.w	r3, [r8]
    }
  }

  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3400c450:	2300      	movs	r3, #0
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
3400c452:	68ea      	ldr	r2, [r5, #12]
  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3400c454:	9304      	str	r3, [sp, #16]
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
3400c456:	682b      	ldr	r3, [r5, #0]
  /* Hardware constraint, pitch must be multiple of 16 */
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
  pipe_conf.PixelPackerFormat = p_conf->output_format;
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
3400c458:	4426      	add	r6, r4
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
3400c45a:	4353      	muls	r3, r2
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
3400c45c:	330f      	adds	r3, #15
3400c45e:	f023 030f 	bic.w	r3, r3, #15
  pipe_conf.PixelPackerFormat = p_conf->output_format;
3400c462:	68aa      	ldr	r2, [r5, #8]
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
3400c464:	9305      	str	r3, [sp, #20]
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
3400c466:	7973      	ldrb	r3, [r6, #5]
  pipe_conf.PixelPackerFormat = p_conf->output_format;
3400c468:	9206      	str	r2, [sp, #24]
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
3400c46a:	b9c3      	cbnz	r3, 3400c49e <CMW_CAMERA_SetPipeConfig+0x15e>
  {
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
3400c46c:	4621      	mov	r1, r4
3400c46e:	4812      	ldr	r0, [pc, #72]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c470:	aa04      	add	r2, sp, #16
3400c472:	f7f7 fbe7 	bl	34003c44 <HAL_DCMIPP_PIPE_SetConfig>
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }

    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
3400c476:	2800      	cmp	r0, #0
3400c478:	d184      	bne.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
    }
  }

  /* Update the pitch field so that application can use this information for
   * buffer alignement */
  *pitch = pipe_conf.PixelPipePitch;
3400c47a:	9b05      	ldr	r3, [sp, #20]
3400c47c:	603b      	str	r3, [r7, #0]
    return HAL_OK;
3400c47e:	2000      	movs	r0, #0
  return CMW_CAMERA_SetPipe(&hcamera_dcmipp, pipe, p_conf, pitch);
3400c480:	e782      	b.n	3400c388 <CMW_CAMERA_SetPipeConfig+0x48>
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
3400c482:	f7f8 fab2 	bl	340049ea <HAL_DCMIPP_PIPE_DisableRedBlueSwap>
3400c486:	e7cc      	b.n	3400c422 <CMW_CAMERA_SetPipeConfig+0xe2>
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
3400c488:	4621      	mov	r1, r4
3400c48a:	480b      	ldr	r0, [pc, #44]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
    if (p_conf->enable_gamma_conversion)
3400c48c:	d004      	beq.n	3400c498 <CMW_CAMERA_SetPipeConfig+0x158>
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
3400c48e:	f7f7 ff2c 	bl	340042ea <HAL_DCMIPP_PIPE_EnableGammaConversion>
      if (ret != HAL_OK)
3400c492:	2800      	cmp	r0, #0
3400c494:	d0ca      	beq.n	3400c42c <CMW_CAMERA_SetPipeConfig+0xec>
3400c496:	e775      	b.n	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
      ret = HAL_DCMIPP_PIPE_DisableGammaConversion(hdcmipp, pipe);
3400c498:	f7f7 ff3f 	bl	3400431a <HAL_DCMIPP_PIPE_DisableGammaConversion>
3400c49c:	e7f9      	b.n	3400c492 <CMW_CAMERA_SetPipeConfig+0x152>
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
3400c49e:	4621      	mov	r1, r4
3400c4a0:	4805      	ldr	r0, [pc, #20]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c4a2:	f7f8 fa48 	bl	34004936 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>
3400c4a6:	2800      	cmp	r0, #0
3400c4a8:	f47f af6c 	bne.w	3400c384 <CMW_CAMERA_SetPipeConfig+0x44>
    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
3400c4ac:	4621      	mov	r1, r4
3400c4ae:	9a05      	ldr	r2, [sp, #20]
3400c4b0:	4801      	ldr	r0, [pc, #4]	@ (3400c4b8 <CMW_CAMERA_SetPipeConfig+0x178>)
3400c4b2:	f7f8 fa26 	bl	34004902 <HAL_DCMIPP_PIPE_SetPitch>
3400c4b6:	e7de      	b.n	3400c476 <CMW_CAMERA_SetPipeConfig+0x136>
3400c4b8:	340d0414 	.word	0x340d0414
3400c4bc:	340d0464 	.word	0x340d0464
3400c4c0:	340d02a4 	.word	0x340d02a4

3400c4c4 <CMW_CAMERA_Start>:
  if (pipe >= DCMIPP_NUM_OF_PIPES)
3400c4c4:	2802      	cmp	r0, #2
{
3400c4c6:	460b      	mov	r3, r1
3400c4c8:	b513      	push	{r0, r1, r4, lr}
  if (pipe >= DCMIPP_NUM_OF_PIPES)
3400c4ca:	d815      	bhi.n	3400c4f8 <CMW_CAMERA_Start+0x34>
  ret = HAL_DCMIPP_CSI_PIPE_Start(&hcamera_dcmipp, pipe, DCMIPP_VIRTUAL_CHANNEL0, (uint32_t)pbuff, mode);
3400c4cc:	4601      	mov	r1, r0
3400c4ce:	9200      	str	r2, [sp, #0]
3400c4d0:	480e      	ldr	r0, [pc, #56]	@ (3400c50c <CMW_CAMERA_Start+0x48>)
3400c4d2:	2200      	movs	r2, #0
3400c4d4:	f7f7 fc1e 	bl	34003d14 <HAL_DCMIPP_CSI_PIPE_Start>
  if (ret != HAL_OK)
3400c4d8:	b988      	cbnz	r0, 3400c4fe <CMW_CAMERA_Start+0x3a>
  if (!is_camera_started)
3400c4da:	4c0d      	ldr	r4, [pc, #52]	@ (3400c510 <CMW_CAMERA_Start+0x4c>)
3400c4dc:	6823      	ldr	r3, [r4, #0]
3400c4de:	b113      	cbz	r3, 3400c4e6 <CMW_CAMERA_Start+0x22>
  return ret;
3400c4e0:	2000      	movs	r0, #0
}
3400c4e2:	b002      	add	sp, #8
3400c4e4:	bd10      	pop	{r4, pc}
    ret = Camera_Drv.Start(&camera_bsp);
3400c4e6:	4b0b      	ldr	r3, [pc, #44]	@ (3400c514 <CMW_CAMERA_Start+0x50>)
3400c4e8:	480b      	ldr	r0, [pc, #44]	@ (3400c518 <CMW_CAMERA_Start+0x54>)
3400c4ea:	689b      	ldr	r3, [r3, #8]
3400c4ec:	4798      	blx	r3
    if (ret != CMW_ERROR_NONE)
3400c4ee:	b948      	cbnz	r0, 3400c504 <CMW_CAMERA_Start+0x40>
    is_camera_started++;
3400c4f0:	6823      	ldr	r3, [r4, #0]
3400c4f2:	3301      	adds	r3, #1
3400c4f4:	6023      	str	r3, [r4, #0]
3400c4f6:	e7f3      	b.n	3400c4e0 <CMW_CAMERA_Start+0x1c>
    return CMW_ERROR_WRONG_PARAM;
3400c4f8:	f06f 0001 	mvn.w	r0, #1
3400c4fc:	e7f1      	b.n	3400c4e2 <CMW_CAMERA_Start+0x1e>
    return CMW_ERROR_PERIPH_FAILURE;
3400c4fe:	f06f 0003 	mvn.w	r0, #3
3400c502:	e7ee      	b.n	3400c4e2 <CMW_CAMERA_Start+0x1e>
      return CMW_ERROR_COMPONENT_FAILURE;
3400c504:	f06f 0004 	mvn.w	r0, #4
3400c508:	e7eb      	b.n	3400c4e2 <CMW_CAMERA_Start+0x1e>
3400c50a:	bf00      	nop
3400c50c:	340d0414 	.word	0x340d0414
3400c510:	340d02a8 	.word	0x340d02a8
3400c514:	340d03b4 	.word	0x340d03b4
3400c518:	340d02b0 	.word	0x340d02b0

3400c51c <CMW_CAMERA_SetGain>:
  if(Camera_Drv.SetGain == NULL)
3400c51c:	4b08      	ldr	r3, [pc, #32]	@ (3400c540 <CMW_CAMERA_SetGain+0x24>)
{
3400c51e:	b510      	push	{r4, lr}
  if(Camera_Drv.SetGain == NULL)
3400c520:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
{
3400c522:	4604      	mov	r4, r0
  if(Camera_Drv.SetGain == NULL)
3400c524:	b133      	cbz	r3, 3400c534 <CMW_CAMERA_SetGain+0x18>
  ret = Camera_Drv.SetGain(&camera_bsp, Gain);
3400c526:	4601      	mov	r1, r0
3400c528:	4806      	ldr	r0, [pc, #24]	@ (3400c544 <CMW_CAMERA_SetGain+0x28>)
3400c52a:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
3400c52c:	b928      	cbnz	r0, 3400c53a <CMW_CAMERA_SetGain+0x1e>
  Camera_Ctx.Gain = Gain;
3400c52e:	4b06      	ldr	r3, [pc, #24]	@ (3400c548 <CMW_CAMERA_SetGain+0x2c>)
3400c530:	621c      	str	r4, [r3, #32]
}
3400c532:	bd10      	pop	{r4, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3400c534:	f06f 000a 	mvn.w	r0, #10
3400c538:	e7fb      	b.n	3400c532 <CMW_CAMERA_SetGain+0x16>
    return CMW_ERROR_COMPONENT_FAILURE;
3400c53a:	f06f 0004 	mvn.w	r0, #4
3400c53e:	e7f8      	b.n	3400c532 <CMW_CAMERA_SetGain+0x16>
3400c540:	340d03b4 	.word	0x340d03b4
3400c544:	340d02b0 	.word	0x340d02b0
3400c548:	340d0420 	.word	0x340d0420

3400c54c <CB_ISP_SetSensorGain>:
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
3400c54c:	4608      	mov	r0, r1
{
3400c54e:	b508      	push	{r3, lr}
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
3400c550:	f7ff ffe4 	bl	3400c51c <CMW_CAMERA_SetGain>
  return ISP_OK;
3400c554:	2800      	cmp	r0, #0
}
3400c556:	bf14      	ite	ne
3400c558:	2079      	movne	r0, #121	@ 0x79
3400c55a:	2000      	moveq	r0, #0
3400c55c:	bd08      	pop	{r3, pc}
	...

3400c560 <CMW_CAMERA_SetExposure>:
  if(Camera_Drv.SetExposure == NULL)
3400c560:	4b08      	ldr	r3, [pc, #32]	@ (3400c584 <CMW_CAMERA_SetExposure+0x24>)
{
3400c562:	b510      	push	{r4, lr}
  if(Camera_Drv.SetExposure == NULL)
3400c564:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
{
3400c566:	4604      	mov	r4, r0
  if(Camera_Drv.SetExposure == NULL)
3400c568:	b133      	cbz	r3, 3400c578 <CMW_CAMERA_SetExposure+0x18>
  ret = Camera_Drv.SetExposure(&camera_bsp, exposure);
3400c56a:	4601      	mov	r1, r0
3400c56c:	4806      	ldr	r0, [pc, #24]	@ (3400c588 <CMW_CAMERA_SetExposure+0x28>)
3400c56e:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
3400c570:	b928      	cbnz	r0, 3400c57e <CMW_CAMERA_SetExposure+0x1e>
  Camera_Ctx.Exposure = exposure;
3400c572:	4b06      	ldr	r3, [pc, #24]	@ (3400c58c <CMW_CAMERA_SetExposure+0x2c>)
3400c574:	625c      	str	r4, [r3, #36]	@ 0x24
}
3400c576:	bd10      	pop	{r4, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3400c578:	f06f 000a 	mvn.w	r0, #10
3400c57c:	e7fb      	b.n	3400c576 <CMW_CAMERA_SetExposure+0x16>
    return CMW_ERROR_COMPONENT_FAILURE;
3400c57e:	f06f 0004 	mvn.w	r0, #4
3400c582:	e7f8      	b.n	3400c576 <CMW_CAMERA_SetExposure+0x16>
3400c584:	340d03b4 	.word	0x340d03b4
3400c588:	340d02b0 	.word	0x340d02b0
3400c58c:	340d0420 	.word	0x340d0420

3400c590 <CB_ISP_SetSensorExposure>:
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
3400c590:	4608      	mov	r0, r1
{
3400c592:	b508      	push	{r3, lr}
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
3400c594:	f7ff ffe4 	bl	3400c560 <CMW_CAMERA_SetExposure>
  return ISP_OK;
3400c598:	2800      	cmp	r0, #0
}
3400c59a:	bf14      	ite	ne
3400c59c:	2083      	movne	r0, #131	@ 0x83
3400c59e:	2000      	moveq	r0, #0
3400c5a0:	bd08      	pop	{r3, pc}
	...

3400c5a4 <CMW_CAMERA_GetSensorInfo>:
{
3400c5a4:	b508      	push	{r3, lr}
  if(Camera_Drv.GetSensorInfo == NULL)
3400c5a6:	4b07      	ldr	r3, [pc, #28]	@ (3400c5c4 <CMW_CAMERA_GetSensorInfo+0x20>)
{
3400c5a8:	4601      	mov	r1, r0
  if(Camera_Drv.GetSensorInfo == NULL)
3400c5aa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400c5ac:	b133      	cbz	r3, 3400c5bc <CMW_CAMERA_GetSensorInfo+0x18>
  ret = Camera_Drv.GetSensorInfo(&camera_bsp, info);
3400c5ae:	4806      	ldr	r0, [pc, #24]	@ (3400c5c8 <CMW_CAMERA_GetSensorInfo+0x24>)
3400c5b0:	4798      	blx	r3
    return CMW_ERROR_COMPONENT_FAILURE;
3400c5b2:	2800      	cmp	r0, #0
3400c5b4:	bf18      	it	ne
3400c5b6:	f06f 0004 	mvnne.w	r0, #4
}
3400c5ba:	bd08      	pop	{r3, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3400c5bc:	f06f 000a 	mvn.w	r0, #10
3400c5c0:	e7fb      	b.n	3400c5ba <CMW_CAMERA_GetSensorInfo+0x16>
3400c5c2:	bf00      	nop
3400c5c4:	340d03b4 	.word	0x340d03b4
3400c5c8:	340d02b0 	.word	0x340d02b0

3400c5cc <CMW_CAMERA_Init>:
{
3400c5cc:	b570      	push	{r4, r5, r6, lr}
3400c5ce:	4604      	mov	r4, r0
3400c5d0:	b094      	sub	sp, #80	@ 0x50
  ISP_SensorInfoTypeDef info = {0};
3400c5d2:	223c      	movs	r2, #60	@ 0x3c
3400c5d4:	2100      	movs	r1, #0
3400c5d6:	a805      	add	r0, sp, #20
3400c5d8:	f001 f99c 	bl	3400d914 <memset>
  initValues.width = initConf->width;
3400c5dc:	6823      	ldr	r3, [r4, #0]
  if (is_camera_init != 0)
3400c5de:	4e24      	ldr	r6, [pc, #144]	@ (3400c670 <CMW_CAMERA_Init+0xa4>)
  initValues.width = initConf->width;
3400c5e0:	9300      	str	r3, [sp, #0]
  initValues.height = initConf->height;
3400c5e2:	6863      	ldr	r3, [r4, #4]
3400c5e4:	9301      	str	r3, [sp, #4]
  initValues.fps = initConf->fps;
3400c5e6:	68a3      	ldr	r3, [r4, #8]
3400c5e8:	9302      	str	r3, [sp, #8]
  initValues.pixel_format = initConf->pixel_format;
3400c5ea:	68e3      	ldr	r3, [r4, #12]
3400c5ec:	9303      	str	r3, [sp, #12]
  initValues.mirrorFlip = initConf->mirror_flip;
3400c5ee:	6963      	ldr	r3, [r4, #20]
3400c5f0:	9304      	str	r3, [sp, #16]
  if (is_camera_init != 0)
3400c5f2:	6833      	ldr	r3, [r6, #0]
3400c5f4:	2b00      	cmp	r3, #0
3400c5f6:	d138      	bne.n	3400c66a <CMW_CAMERA_Init+0x9e>
  hcamera_dcmipp.Instance = DCMIPP;
3400c5f8:	4d1e      	ldr	r5, [pc, #120]	@ (3400c674 <CMW_CAMERA_Init+0xa8>)
3400c5fa:	4b1f      	ldr	r3, [pc, #124]	@ (3400c678 <CMW_CAMERA_Init+0xac>)
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
3400c5fc:	4628      	mov	r0, r5
  hcamera_dcmipp.Instance = DCMIPP;
3400c5fe:	602b      	str	r3, [r5, #0]
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
3400c600:	f7f5 fa5e 	bl	34001ac0 <MX_DCMIPP_ClockConfig>
  if (ret != HAL_OK)
3400c604:	b118      	cbz	r0, 3400c60e <CMW_CAMERA_Init+0x42>
    return CMW_ERROR_PERIPH_FAILURE;
3400c606:	f06f 0003 	mvn.w	r0, #3
}
3400c60a:	b014      	add	sp, #80	@ 0x50
3400c60c:	bd70      	pop	{r4, r5, r6, pc}
  ret = HAL_DCMIPP_Init(&hcamera_dcmipp);
3400c60e:	4628      	mov	r0, r5
3400c610:	f7f7 f9fc 	bl	34003a0c <HAL_DCMIPP_Init>
  if (ret != HAL_OK)
3400c614:	2800      	cmp	r0, #0
3400c616:	d1f6      	bne.n	3400c606 <CMW_CAMERA_Init+0x3a>
  CMW_CAMERA_EnableGPIOs();
3400c618:	f7ff fe62 	bl	3400c2e0 <CMW_CAMERA_EnableGPIOs>
  ret = CMW_CAMERA_IMX335_Init(initValues);
3400c61c:	4668      	mov	r0, sp
3400c61e:	f7ff fda5 	bl	3400c16c <CMW_CAMERA_IMX335_Init>
  if (ret == CMW_ERROR_NONE)
3400c622:	b110      	cbz	r0, 3400c62a <CMW_CAMERA_Init+0x5e>
    return CMW_ERROR_UNKNOWN_COMPONENT;
3400c624:	f06f 0006 	mvn.w	r0, #6
3400c628:	e7ef      	b.n	3400c60a <CMW_CAMERA_Init+0x3e>
    *sensorName = CMW_IMX335_Sensor;
3400c62a:	2201      	movs	r2, #1
3400c62c:	4b13      	ldr	r3, [pc, #76]	@ (3400c67c <CMW_CAMERA_Init+0xb0>)
  ret = CMW_CAMERA_GetSensorInfo(&info);
3400c62e:	a805      	add	r0, sp, #20
    *sensorName = CMW_IMX335_Sensor;
3400c630:	701a      	strb	r2, [r3, #0]
  ret = CMW_CAMERA_GetSensorInfo(&info);
3400c632:	f7ff ffb7 	bl	3400c5a4 <CMW_CAMERA_GetSensorInfo>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3400c636:	3005      	adds	r0, #5
3400c638:	d0f4      	beq.n	3400c624 <CMW_CAMERA_Init+0x58>
  ret = CMW_CAMERA_SetExposure(info.exposure_min);
3400c63a:	9812      	ldr	r0, [sp, #72]	@ 0x48
3400c63c:	f7ff ff90 	bl	3400c560 <CMW_CAMERA_SetExposure>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3400c640:	3005      	adds	r0, #5
3400c642:	d0ef      	beq.n	3400c624 <CMW_CAMERA_Init+0x58>
  ret = CMW_CAMERA_SetGain(info.gain_min);
3400c644:	9810      	ldr	r0, [sp, #64]	@ 0x40
3400c646:	f7ff ff69 	bl	3400c51c <CMW_CAMERA_SetGain>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3400c64a:	3005      	adds	r0, #5
3400c64c:	d0ea      	beq.n	3400c624 <CMW_CAMERA_Init+0x58>
  initConf->width = initValues.width;
3400c64e:	9b00      	ldr	r3, [sp, #0]
  camera_conf = *initConf;
3400c650:	4d0b      	ldr	r5, [pc, #44]	@ (3400c680 <CMW_CAMERA_Init+0xb4>)
  initConf->width = initValues.width;
3400c652:	6023      	str	r3, [r4, #0]
  initConf->height = initValues.height ;
3400c654:	9b01      	ldr	r3, [sp, #4]
3400c656:	6063      	str	r3, [r4, #4]
  camera_conf = *initConf;
3400c658:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
3400c65a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  is_camera_init++;
3400c65c:	6833      	ldr	r3, [r6, #0]
  camera_conf = *initConf;
3400c65e:	e894 0003 	ldmia.w	r4, {r0, r1}
3400c662:	e885 0003 	stmia.w	r5, {r0, r1}
  is_camera_init++;
3400c666:	3301      	adds	r3, #1
3400c668:	6033      	str	r3, [r6, #0]
    return CMW_ERROR_NONE;
3400c66a:	2000      	movs	r0, #0
3400c66c:	e7cd      	b.n	3400c60a <CMW_CAMERA_Init+0x3e>
3400c66e:	bf00      	nop
3400c670:	340d02ac 	.word	0x340d02ac
3400c674:	340d0414 	.word	0x340d0414
3400c678:	58002000 	.word	0x58002000
3400c67c:	340d0460 	.word	0x340d0460
3400c680:	340d0464 	.word	0x340d0464

3400c684 <CMW_CAMERA_Run>:
  if(Camera_Drv.Run != NULL)
3400c684:	4b03      	ldr	r3, [pc, #12]	@ (3400c694 <CMW_CAMERA_Run+0x10>)
3400c686:	68db      	ldr	r3, [r3, #12]
3400c688:	b10b      	cbz	r3, 3400c68e <CMW_CAMERA_Run+0xa>
      return Camera_Drv.Run(&camera_bsp);
3400c68a:	4803      	ldr	r0, [pc, #12]	@ (3400c698 <CMW_CAMERA_Run+0x14>)
3400c68c:	4718      	bx	r3
}
3400c68e:	4618      	mov	r0, r3
3400c690:	4770      	bx	lr
3400c692:	bf00      	nop
3400c694:	340d03b4 	.word	0x340d03b4
3400c698:	340d02b0 	.word	0x340d02b0

3400c69c <HAL_DCMIPP_MspInit>:
  WRITE_REG(RCC->APB5ENSR, Periphs);
3400c69c:	2304      	movs	r3, #4
{
3400c69e:	b530      	push	{r4, r5, lr}
3400c6a0:	4c1b      	ldr	r4, [pc, #108]	@ (3400c710 <HAL_DCMIPP_MspInit+0x74>)
3400c6a2:	b085      	sub	sp, #20
3400c6a4:	f8c4 3a7c 	str.w	r3, [r4, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
3400c6a8:	f8d4 227c 	ldr.w	r2, [r4, #636]	@ 0x27c
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ReleaseReset(uint32_t Periphs)
{
  WRITE_REG(RCC->APB5RSTCR, Periphs);
3400c6ac:	f504 5580 	add.w	r5, r4, #4096	@ 0x1000
  tmpreg = READ_REG(RCC->APB5ENR);
3400c6b0:	9203      	str	r2, [sp, #12]
  (void)tmpreg;
3400c6b2:	9a03      	ldr	r2, [sp, #12]
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5LPENSR, Periphs);
3400c6b4:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5LPENR);
3400c6b8:	f8d4 22bc 	ldr.w	r2, [r4, #700]	@ 0x2bc
  HAL_NVIC_SetPriority(DCMIPP_IRQn, 0x07, 0);
3400c6bc:	2107      	movs	r1, #7
3400c6be:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
3400c6c0:	9a02      	ldr	r2, [sp, #8]
3400c6c2:	2030      	movs	r0, #48	@ 0x30
  WRITE_REG(RCC->APB5RSTSR, Periphs);
3400c6c4:	f8c4 3a3c 	str.w	r3, [r4, #2620]	@ 0xa3c
3400c6c8:	2200      	movs	r2, #0
  WRITE_REG(RCC->APB5RSTCR, Periphs);
3400c6ca:	f8c5 323c 	str.w	r3, [r5, #572]	@ 0x23c
3400c6ce:	f7f7 f84b 	bl	34003768 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DCMIPP_IRQn);
3400c6d2:	2030      	movs	r0, #48	@ 0x30
3400c6d4:	f7f7 f87c 	bl	340037d0 <HAL_NVIC_EnableIRQ>
  WRITE_REG(RCC->APB5ENSR, Periphs);
3400c6d8:	2340      	movs	r3, #64	@ 0x40
3400c6da:	f8c4 3a7c 	str.w	r3, [r4, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
3400c6de:	f8d4 227c 	ldr.w	r2, [r4, #636]	@ 0x27c
  HAL_NVIC_SetPriority(CSI_IRQn, 0x07, 0);
3400c6e2:	2107      	movs	r1, #7
3400c6e4:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
3400c6e6:	9a01      	ldr	r2, [sp, #4]
  WRITE_REG(RCC->APB5LPENSR, Periphs);
3400c6e8:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
3400c6ec:	f8d4 22bc 	ldr.w	r2, [r4, #700]	@ 0x2bc
3400c6f0:	202f      	movs	r0, #47	@ 0x2f
3400c6f2:	9200      	str	r2, [sp, #0]
  (void)tmpreg;
3400c6f4:	9a00      	ldr	r2, [sp, #0]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
3400c6f6:	f8c4 3a3c 	str.w	r3, [r4, #2620]	@ 0xa3c
3400c6fa:	2200      	movs	r2, #0
  WRITE_REG(RCC->APB5RSTCR, Periphs);
3400c6fc:	f8c5 323c 	str.w	r3, [r5, #572]	@ 0x23c
3400c700:	f7f7 f832 	bl	34003768 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(CSI_IRQn);
3400c704:	202f      	movs	r0, #47	@ 0x2f
}
3400c706:	b005      	add	sp, #20
3400c708:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  HAL_NVIC_EnableIRQ(CSI_IRQn);
3400c70c:	f7f7 b860 	b.w	340037d0 <HAL_NVIC_EnableIRQ>
3400c710:	56028000 	.word	0x56028000

3400c714 <CMW_IMX335_FrameEventCallback>:
#endif
}

static void CMW_IMX335_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
}
3400c714:	4770      	bx	lr

3400c716 <CMW_IMX335_ReadID>:
  return IMX335_ReadID(&((CMW_IMX335_t *)io_ctx)->ctx_driver, Id);
3400c716:	3008      	adds	r0, #8
3400c718:	f000 badc 	b.w	3400ccd4 <IMX335_ReadID>

3400c71c <CMW_IMX335_SetTestPattern>:
  return IMX335_SetTestPattern(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mode);
3400c71c:	3008      	adds	r0, #8
3400c71e:	f000 bbe9 	b.w	3400cef4 <IMX335_SetTestPattern>
	...

3400c724 <CMW_IMX335_GetSensorInfo>:
{
3400c724:	b508      	push	{r3, lr}
3400c726:	460b      	mov	r3, r1
  if ((io_ctx ==  NULL) || (info == NULL))
3400c728:	b1b8      	cbz	r0, 3400c75a <CMW_IMX335_GetSensorInfo+0x36>
3400c72a:	b1b1      	cbz	r1, 3400c75a <CMW_IMX335_GetSensorInfo+0x36>
    strcpy(info->name, IMX335_NAME);
3400c72c:	4618      	mov	r0, r3
3400c72e:	490c      	ldr	r1, [pc, #48]	@ (3400c760 <CMW_IMX335_GetSensorInfo+0x3c>)
3400c730:	f001 f97b 	bl	3400da2a <strcpy>
  info->bayer_pattern = IMX335_BAYER_PATTERN;
3400c734:	f44f 6220 	mov.w	r2, #2560	@ 0xa00
  info->height = IMX335_HEIGHT;
3400c738:	f44f 6122 	mov.w	r1, #2592	@ 0xa20
  info->bayer_pattern = IMX335_BAYER_PATTERN;
3400c73c:	8402      	strh	r2, [r0, #32]
  info->height = IMX335_HEIGHT;
3400c73e:	f44f 62f3 	mov.w	r2, #1944	@ 0x798
    strcpy(info->name, IMX335_NAME);
3400c742:	4603      	mov	r3, r0
  info->height = IMX335_HEIGHT;
3400c744:	e9c0 1209 	strd	r1, r2, [r0, #36]	@ 0x24
  info->gain_max = IMX335_GAIN_MAX;
3400c748:	2000      	movs	r0, #0
3400c74a:	4a06      	ldr	r2, [pc, #24]	@ (3400c764 <CMW_IMX335_GetSensorInfo+0x40>)
  info->exposure_min = IMX335_EXPOSURE_MIN;
3400c74c:	6358      	str	r0, [r3, #52]	@ 0x34
  info->gain_max = IMX335_GAIN_MAX;
3400c74e:	e9c3 020b 	strd	r0, r2, [r3, #44]	@ 0x2c
  info->exposure_max = IMX335_EXPOSURE_MAX;
3400c752:	f248 12f2 	movw	r2, #33266	@ 0x81f2
3400c756:	639a      	str	r2, [r3, #56]	@ 0x38
}
3400c758:	bd08      	pop	{r3, pc}
    return CMW_ERROR_WRONG_PARAM;
3400c75a:	f06f 0001 	mvn.w	r0, #1
3400c75e:	e7fb      	b.n	3400c758 <CMW_IMX335_GetSensorInfo+0x34>
3400c760:	34010977 	.word	0x34010977
3400c764:	00011940 	.word	0x00011940

3400c768 <CMW_IMX335_SetMirrorFlip>:
  return IMX335_MirrorFlipConfig(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mirrorFlip);
3400c768:	2903      	cmp	r1, #3
3400c76a:	bf28      	it	cs
3400c76c:	2103      	movcs	r1, #3
3400c76e:	3008      	adds	r0, #8
3400c770:	f000 bba6 	b.w	3400cec0 <IMX335_MirrorFlipConfig>

3400c774 <CMW_IMX335_SetFramerate>:
  return IMX335_SetFramerate(&((CMW_IMX335_t *)io_ctx)->ctx_driver, framerate);
3400c774:	3008      	adds	r0, #8
3400c776:	f000 bb77 	b.w	3400ce68 <IMX335_SetFramerate>

3400c77a <CMW_IMX335_SetFrequency>:
  return IMX335_SetFrequency(&((CMW_IMX335_t *)io_ctx)->ctx_driver, frequency);
3400c77a:	3008      	adds	r0, #8
3400c77c:	f000 bb4c 	b.w	3400ce18 <IMX335_SetFrequency>

3400c780 <CMW_IMX335_SetExposure>:
  return IMX335_SetExposure(&((CMW_IMX335_t *)io_ctx)->ctx_driver, exposure);
3400c780:	3008      	adds	r0, #8
3400c782:	f000 baf7 	b.w	3400cd74 <IMX335_SetExposure>

3400c786 <CMW_IMX335_SetGain>:
  return IMX335_SetGain(&((CMW_IMX335_t *)io_ctx)->ctx_driver, gain);
3400c786:	3008      	adds	r0, #8
3400c788:	f000 babc 	b.w	3400cd04 <IMX335_SetGain>

3400c78c <CMW_IMX335_Run>:
{
3400c78c:	b508      	push	{r3, lr}
  ret = ISP_BackgroundProcess(&((CMW_IMX335_t *)io_ctx)->hIsp);
3400c78e:	3030      	adds	r0, #48	@ 0x30
3400c790:	f7fe fd6a 	bl	3400b268 <ISP_BackgroundProcess>
  return CMW_ERROR_NONE;
3400c794:	2800      	cmp	r0, #0
}
3400c796:	bf14      	ite	ne
3400c798:	f06f 0003 	mvnne.w	r0, #3
3400c79c:	2000      	moveq	r0, #0
3400c79e:	bd08      	pop	{r3, pc}

3400c7a0 <CMW_IMX335_DeInit>:
{
3400c7a0:	b510      	push	{r4, lr}
3400c7a2:	4604      	mov	r4, r0
  ret = ISP_DeInit(&((CMW_IMX335_t *)io_ctx)->hIsp);
3400c7a4:	3030      	adds	r0, #48	@ 0x30
3400c7a6:	f7fe fcaf 	bl	3400b108 <ISP_DeInit>
  if (ret)
3400c7aa:	b110      	cbz	r0, 3400c7b2 <CMW_IMX335_DeInit+0x12>
    return CMW_ERROR_COMPONENT_FAILURE;
3400c7ac:	f06f 0004 	mvn.w	r0, #4
}
3400c7b0:	bd10      	pop	{r4, pc}
  ret = IMX335_DeInit(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
3400c7b2:	f104 0008 	add.w	r0, r4, #8
3400c7b6:	f000 fa84 	bl	3400ccc2 <IMX335_DeInit>
  if (ret)
3400c7ba:	2800      	cmp	r0, #0
3400c7bc:	d0f8      	beq.n	3400c7b0 <CMW_IMX335_DeInit+0x10>
3400c7be:	e7f5      	b.n	3400c7ac <CMW_IMX335_DeInit+0xc>

3400c7c0 <CMW_IMX335_Start>:
{
3400c7c0:	b513      	push	{r0, r1, r4, lr}
  ret = ISP_Init(&hIsp, ((CMW_IMX335_t *)io_ctx)->hdcmipp, 0, &((CMW_IMX335_t *)io_ctx)->appliHelpers,  &ISP_IQParamCacheInit_IMX335);
3400c7c2:	4b0f      	ldr	r3, [pc, #60]	@ (3400c800 <CMW_IMX335_Start+0x40>)
{
3400c7c4:	4604      	mov	r4, r0
  ret = ISP_Init(&hIsp, ((CMW_IMX335_t *)io_ctx)->hdcmipp, 0, &((CMW_IMX335_t *)io_ctx)->appliHelpers,  &ISP_IQParamCacheInit_IMX335);
3400c7c6:	9300      	str	r3, [sp, #0]
3400c7c8:	f8d0 10dc 	ldr.w	r1, [r0, #220]	@ 0xdc
3400c7cc:	f100 03b8 	add.w	r3, r0, #184	@ 0xb8
3400c7d0:	2200      	movs	r2, #0
3400c7d2:	480c      	ldr	r0, [pc, #48]	@ (3400c804 <CMW_IMX335_Start+0x44>)
3400c7d4:	f7fe fc1c 	bl	3400b010 <ISP_Init>
  if (ret != ISP_OK)
3400c7d8:	b950      	cbnz	r0, 3400c7f0 <CMW_IMX335_Start+0x30>
  ret = ISP_Start(&hIsp);
3400c7da:	480a      	ldr	r0, [pc, #40]	@ (3400c804 <CMW_IMX335_Start+0x44>)
3400c7dc:	f7fe fca4 	bl	3400b128 <ISP_Start>
  if (ret != ISP_OK)
3400c7e0:	b950      	cbnz	r0, 3400c7f8 <CMW_IMX335_Start+0x38>
  return IMX335_Start(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
3400c7e2:	f104 0008 	add.w	r0, r4, #8
}
3400c7e6:	b002      	add	sp, #8
3400c7e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return IMX335_Start(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
3400c7ec:	f000 ba4c 	b.w	3400cc88 <IMX335_Start>
    return CMW_ERROR_COMPONENT_FAILURE;
3400c7f0:	f06f 0004 	mvn.w	r0, #4
}
3400c7f4:	b002      	add	sp, #8
3400c7f6:	bd10      	pop	{r4, pc}
      return CMW_ERROR_PERIPH_FAILURE;
3400c7f8:	f06f 0003 	mvn.w	r0, #3
3400c7fc:	e7fa      	b.n	3400c7f4 <CMW_IMX335_Start+0x34>
3400c7fe:	bf00      	nop
3400c800:	34011190 	.word	0x34011190
3400c804:	340cfe68 	.word	0x340cfe68

3400c808 <CMW_IMX335_Init>:
{
3400c808:	b538      	push	{r3, r4, r5, lr}
  if (width == 2592 && height == 1944)
3400c80a:	e9d1 2300 	ldrd	r2, r3, [r1]
3400c80e:	f5b2 6f22 	cmp.w	r2, #2592	@ 0xa20
{
3400c812:	4605      	mov	r5, r0
3400c814:	460c      	mov	r4, r1
  if (width == 2592 && height == 1944)
3400c816:	d002      	beq.n	3400c81e <CMW_IMX335_Init+0x16>
    return CMW_ERROR_WRONG_PARAM;
3400c818:	f06f 0001 	mvn.w	r0, #1
}
3400c81c:	bd38      	pop	{r3, r4, r5, pc}
  if (width == 2592 && height == 1944)
3400c81e:	f5b3 6ff3 	cmp.w	r3, #1944	@ 0x798
3400c822:	d1f9      	bne.n	3400c818 <CMW_IMX335_Init+0x10>
  ret = CMW_IMX335_SetMirrorFlip(io_ctx, initSensor->mirrorFlip);
3400c824:	6909      	ldr	r1, [r1, #16]
3400c826:	f7ff ff9f 	bl	3400c768 <CMW_IMX335_SetMirrorFlip>
  if (ret)
3400c82a:	2800      	cmp	r0, #0
3400c82c:	d1f4      	bne.n	3400c818 <CMW_IMX335_Init+0x10>
  ret = IMX335_Init(&((CMW_IMX335_t *)io_ctx)->ctx_driver, resolution, initSensor->pixel_format);
3400c82e:	2106      	movs	r1, #6
3400c830:	68e2      	ldr	r2, [r4, #12]
3400c832:	f105 0008 	add.w	r0, r5, #8
3400c836:	f000 fa07 	bl	3400cc48 <IMX335_Init>
    return CMW_ERROR_COMPONENT_FAILURE;
3400c83a:	2800      	cmp	r0, #0
3400c83c:	bf18      	it	ne
3400c83e:	f06f 0004 	mvnne.w	r0, #4
3400c842:	e7eb      	b.n	3400c81c <CMW_IMX335_Init+0x14>

3400c844 <CMW_IMX335_VsyncEventCallback>:
  switch (pipe)
3400c844:	2901      	cmp	r1, #1
{
3400c846:	b510      	push	{r4, lr}
  switch (pipe)
3400c848:	d007      	beq.n	3400c85a <CMW_IMX335_VsyncEventCallback+0x16>
3400c84a:	2902      	cmp	r1, #2
3400c84c:	d00f      	beq.n	3400c86e <CMW_IMX335_VsyncEventCallback+0x2a>
3400c84e:	b999      	cbnz	r1, 3400c878 <CMW_IMX335_VsyncEventCallback+0x34>
}
3400c850:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncDumpFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3400c854:	3030      	adds	r0, #48	@ 0x30
3400c856:	f7fe bd1d 	b.w	3400b294 <ISP_IncDumpFrameId>
      ISP_IncMainFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3400c85a:	f100 0430 	add.w	r4, r0, #48	@ 0x30
3400c85e:	4620      	mov	r0, r4
3400c860:	f7fe fd14 	bl	3400b28c <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
3400c864:	4620      	mov	r0, r4
}
3400c866:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
3400c86a:	f7fe bd0d 	b.w	3400b288 <ISP_GatherStatistics>
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3400c86e:	3030      	adds	r0, #48	@ 0x30
}
3400c870:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3400c874:	f7fe bd0c 	b.w	3400b290 <ISP_IncAncillaryFrameId>
}
3400c878:	bd10      	pop	{r4, pc}
	...

3400c87c <CMW_IMX335_Probe>:

int CMW_IMX335_Probe(CMW_IMX335_t *io_ctx, CMW_Sensor_if_t *imx335_if)
{
3400c87c:	b573      	push	{r0, r1, r4, r5, r6, lr}
3400c87e:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
3400c880:	8803      	ldrh	r3, [r0, #0]
{
3400c882:	460d      	mov	r5, r1
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
3400c884:	8203      	strh	r3, [r0, #16]
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
3400c886:	f8d0 30e4 	ldr.w	r3, [r0, #228]	@ 0xe4
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;

  CMW_IMX335_PowerOn(io_ctx);

  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
3400c88a:	3408      	adds	r4, #8
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
3400c88c:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.IO.DeInit = io_ctx->DeInit;
3400c88e:	f8d0 30e8 	ldr.w	r3, [r0, #232]	@ 0xe8
3400c892:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.IO.GetTick = io_ctx->GetTick;
3400c894:	f8d0 30f4 	ldr.w	r3, [r0, #244]	@ 0xf4
3400c898:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
3400c89a:	f8d0 30f0 	ldr.w	r3, [r0, #240]	@ 0xf0
3400c89e:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;
3400c8a0:	f8d0 30ec 	ldr.w	r3, [r0, #236]	@ 0xec
3400c8a4:	6143      	str	r3, [r0, #20]
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
3400c8a6:	f8d0 30fc 	ldr.w	r3, [r0, #252]	@ 0xfc
3400c8aa:	2000      	movs	r0, #0
3400c8ac:	4798      	blx	r3
  io_ctx->Delay(100);
3400c8ae:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400c8b2:	2064      	movs	r0, #100	@ 0x64
3400c8b4:	4798      	blx	r3
  io_ctx->EnablePin(0);  /* RESET low (reset active low) */
3400c8b6:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
3400c8ba:	2000      	movs	r0, #0
3400c8bc:	4798      	blx	r3
  io_ctx->Delay(100);
3400c8be:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400c8c2:	2064      	movs	r0, #100	@ 0x64
3400c8c4:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
3400c8c6:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
3400c8ca:	2001      	movs	r0, #1
3400c8cc:	4798      	blx	r3
  io_ctx->Delay(100);
3400c8ce:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400c8d2:	2064      	movs	r0, #100	@ 0x64
3400c8d4:	4798      	blx	r3
  io_ctx->EnablePin(1);  /* RESET low (reset active low) */
3400c8d6:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
3400c8da:	2001      	movs	r0, #1
3400c8dc:	4798      	blx	r3
  io_ctx->Delay(100);
3400c8de:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400c8e2:	2064      	movs	r0, #100	@ 0x64
3400c8e4:	4798      	blx	r3
  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
3400c8e6:	4621      	mov	r1, r4
3400c8e8:	4620      	mov	r0, r4
3400c8ea:	f000 f991 	bl	3400cc10 <IMX335_RegisterBusIO>
  if (ret != IMX335_OK)
3400c8ee:	4606      	mov	r6, r0
3400c8f0:	b120      	cbz	r0, 3400c8fc <CMW_IMX335_Probe+0x80>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3400c8f2:	f06f 0404 	mvn.w	r4, #4
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
  return ret;
}
3400c8f6:	4620      	mov	r0, r4
3400c8f8:	b002      	add	sp, #8
3400c8fa:	bd70      	pop	{r4, r5, r6, pc}
  ret = IMX335_ReadID(&io_ctx->ctx_driver, &id);
3400c8fc:	4620      	mov	r0, r4
3400c8fe:	a901      	add	r1, sp, #4
3400c900:	f000 f9e8 	bl	3400ccd4 <IMX335_ReadID>
  if (ret != IMX335_OK)
3400c904:	4604      	mov	r4, r0
3400c906:	2800      	cmp	r0, #0
3400c908:	d1f3      	bne.n	3400c8f2 <CMW_IMX335_Probe+0x76>
  if (id != IMX335_CHIP_ID)
3400c90a:	9b01      	ldr	r3, [sp, #4]
  memset(imx335_if, 0, sizeof(*imx335_if));
3400c90c:	2248      	movs	r2, #72	@ 0x48
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
3400c90e:	2b00      	cmp	r3, #0
3400c910:	bf08      	it	eq
3400c912:	4604      	moveq	r4, r0
  memset(imx335_if, 0, sizeof(*imx335_if));
3400c914:	4631      	mov	r1, r6
3400c916:	f105 0018 	add.w	r0, r5, #24
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
3400c91a:	bf18      	it	ne
3400c91c:	f06f 0406 	mvnne.w	r4, #6
  memset(imx335_if, 0, sizeof(*imx335_if));
3400c920:	f000 fff8 	bl	3400d914 <memset>
  imx335_if->Init = CMW_IMX335_Init;
3400c924:	4b0e      	ldr	r3, [pc, #56]	@ (3400c960 <CMW_IMX335_Probe+0xe4>)
3400c926:	602b      	str	r3, [r5, #0]
  imx335_if->Start = CMW_IMX335_Start;
3400c928:	4b0e      	ldr	r3, [pc, #56]	@ (3400c964 <CMW_IMX335_Probe+0xe8>)
3400c92a:	60ab      	str	r3, [r5, #8]
  imx335_if->DeInit = CMW_IMX335_DeInit;
3400c92c:	4b0e      	ldr	r3, [pc, #56]	@ (3400c968 <CMW_IMX335_Probe+0xec>)
3400c92e:	606b      	str	r3, [r5, #4]
  imx335_if->Run = CMW_IMX335_Run;
3400c930:	4b0e      	ldr	r3, [pc, #56]	@ (3400c96c <CMW_IMX335_Probe+0xf0>)
3400c932:	60eb      	str	r3, [r5, #12]
  imx335_if->VsyncEventCallback = CMW_IMX335_VsyncEventCallback;
3400c934:	4b0e      	ldr	r3, [pc, #56]	@ (3400c970 <CMW_IMX335_Probe+0xf4>)
3400c936:	612b      	str	r3, [r5, #16]
  imx335_if->FrameEventCallback = CMW_IMX335_FrameEventCallback;
3400c938:	4b0e      	ldr	r3, [pc, #56]	@ (3400c974 <CMW_IMX335_Probe+0xf8>)
3400c93a:	616b      	str	r3, [r5, #20]
  imx335_if->ReadID = CMW_IMX335_ReadID;
3400c93c:	4b0e      	ldr	r3, [pc, #56]	@ (3400c978 <CMW_IMX335_Probe+0xfc>)
3400c93e:	61eb      	str	r3, [r5, #28]
  imx335_if->SetGain = CMW_IMX335_SetGain;
3400c940:	4b0e      	ldr	r3, [pc, #56]	@ (3400c97c <CMW_IMX335_Probe+0x100>)
3400c942:	64ab      	str	r3, [r5, #72]	@ 0x48
  imx335_if->SetExposure = CMW_IMX335_SetExposure;
3400c944:	4b0e      	ldr	r3, [pc, #56]	@ (3400c980 <CMW_IMX335_Probe+0x104>)
3400c946:	64eb      	str	r3, [r5, #76]	@ 0x4c
  imx335_if->SetFrequency = CMW_IMX335_SetFrequency;
3400c948:	4b0e      	ldr	r3, [pc, #56]	@ (3400c984 <CMW_IMX335_Probe+0x108>)
3400c94a:	642b      	str	r3, [r5, #64]	@ 0x40
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
3400c94c:	4b0e      	ldr	r3, [pc, #56]	@ (3400c988 <CMW_IMX335_Probe+0x10c>)
3400c94e:	646b      	str	r3, [r5, #68]	@ 0x44
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
3400c950:	4b0e      	ldr	r3, [pc, #56]	@ (3400c98c <CMW_IMX335_Probe+0x110>)
3400c952:	62eb      	str	r3, [r5, #44]	@ 0x2c
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
3400c954:	4b0e      	ldr	r3, [pc, #56]	@ (3400c990 <CMW_IMX335_Probe+0x114>)
3400c956:	65ab      	str	r3, [r5, #88]	@ 0x58
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
3400c958:	4b0e      	ldr	r3, [pc, #56]	@ (3400c994 <CMW_IMX335_Probe+0x118>)
3400c95a:	65eb      	str	r3, [r5, #92]	@ 0x5c
  return ret;
3400c95c:	e7cb      	b.n	3400c8f6 <CMW_IMX335_Probe+0x7a>
3400c95e:	bf00      	nop
3400c960:	3400c809 	.word	0x3400c809
3400c964:	3400c7c1 	.word	0x3400c7c1
3400c968:	3400c7a1 	.word	0x3400c7a1
3400c96c:	3400c78d 	.word	0x3400c78d
3400c970:	3400c845 	.word	0x3400c845
3400c974:	3400c715 	.word	0x3400c715
3400c978:	3400c717 	.word	0x3400c717
3400c97c:	3400c787 	.word	0x3400c787
3400c980:	3400c781 	.word	0x3400c781
3400c984:	3400c77b 	.word	0x3400c77b
3400c988:	3400c775 	.word	0x3400c775
3400c98c:	3400c769 	.word	0x3400c769
3400c990:	3400c725 	.word	0x3400c725
3400c994:	3400c71d 	.word	0x3400c71d

3400c998 <CMW_UTILS_get_dec_ratio_and_update>:

  return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
}

static uint32_t CMW_UTILS_get_dec_ratio_and_update(float *ratio, int is_vertical)
{
3400c998:	b508      	push	{r3, lr}
  int dec_ratio = 1;

  while (*ratio >= 8) {
3400c99a:	eeb2 7a00 	vmov.f32	s14, #32	@ 0x41000000  8.0
  int dec_ratio = 1;
3400c99e:	2301      	movs	r3, #1
    dec_ratio *= 2;
    *ratio /= 2;
3400c9a0:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
  while (*ratio >= 8) {
3400c9a4:	edd0 7a00 	vldr	s15, [r0]
3400c9a8:	eef4 7ac7 	vcmpe.f32	s15, s14
3400c9ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400c9b0:	da08      	bge.n	3400c9c4 <CMW_UTILS_get_dec_ratio_and_update+0x2c>
  switch (dec_ratio) {
3400c9b2:	3b01      	subs	r3, #1
3400c9b4:	2b07      	cmp	r3, #7
3400c9b6:	d81a      	bhi.n	3400c9ee <CMW_UTILS_get_dec_ratio_and_update+0x56>
3400c9b8:	e8df f003 	tbb	[pc, r3]
3400c9bc:	0f190a1f 	.word	0x0f190a1f
3400c9c0:	14191919 	.word	0x14191919
    *ratio /= 2;
3400c9c4:	ee67 7aa6 	vmul.f32	s15, s15, s13
    dec_ratio *= 2;
3400c9c8:	005b      	lsls	r3, r3, #1
    *ratio /= 2;
3400c9ca:	edc0 7a00 	vstr	s15, [r0]
3400c9ce:	e7e9      	b.n	3400c9a4 <CMW_UTILS_get_dec_ratio_and_update+0xc>
    return is_vertical ? DCMIPP_VDEC_1_OUT_2 : DCMIPP_HDEC_1_OUT_2;
3400c9d0:	2900      	cmp	r1, #0
3400c9d2:	bf0c      	ite	eq
3400c9d4:	2002      	moveq	r0, #2
3400c9d6:	2008      	movne	r0, #8
  }

  return CMW_UTILS_get_dec_ratio_from_decimal_ratio(dec_ratio, is_vertical);
}
3400c9d8:	bd08      	pop	{r3, pc}
    return is_vertical ? DCMIPP_VDEC_1_OUT_4 : DCMIPP_HDEC_1_OUT_4;
3400c9da:	2900      	cmp	r1, #0
3400c9dc:	bf0c      	ite	eq
3400c9de:	2004      	moveq	r0, #4
3400c9e0:	2010      	movne	r0, #16
3400c9e2:	e7f9      	b.n	3400c9d8 <CMW_UTILS_get_dec_ratio_and_update+0x40>
    return is_vertical ? DCMIPP_VDEC_1_OUT_8 : DCMIPP_HDEC_1_OUT_8;
3400c9e4:	2900      	cmp	r1, #0
3400c9e6:	bf0c      	ite	eq
3400c9e8:	2006      	moveq	r0, #6
3400c9ea:	2018      	movne	r0, #24
3400c9ec:	e7f4      	b.n	3400c9d8 <CMW_UTILS_get_dec_ratio_and_update+0x40>
    assert(0);
3400c9ee:	2177      	movs	r1, #119	@ 0x77
3400c9f0:	4b03      	ldr	r3, [pc, #12]	@ (3400ca00 <CMW_UTILS_get_dec_ratio_and_update+0x68>)
3400c9f2:	4a04      	ldr	r2, [pc, #16]	@ (3400ca04 <CMW_UTILS_get_dec_ratio_and_update+0x6c>)
3400c9f4:	4804      	ldr	r0, [pc, #16]	@ (3400ca08 <CMW_UTILS_get_dec_ratio_and_update+0x70>)
3400c9f6:	f000 fb7b 	bl	3400d0f0 <__assert_func>
  switch (dec_ratio) {
3400c9fa:	2000      	movs	r0, #0
3400c9fc:	e7ec      	b.n	3400c9d8 <CMW_UTILS_get_dec_ratio_and_update+0x40>
3400c9fe:	bf00      	nop
3400ca00:	3401070e 	.word	0x3401070e
3400ca04:	340113e4 	.word	0x340113e4
3400ca08:	3401097e 	.word	0x3401097e

3400ca0c <CMW_UTILS_GetPipeConfig>:
{
3400ca0c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400ca0e:	4614      	mov	r4, r2
3400ca10:	e9dd 5608 	ldrd	r5, r6, [sp, #32]
    CMW_UTILS_get_crop_config(cam_width, cam_height, p_conf->output_width, p_conf->output_height, crop);
3400ca14:	6867      	ldr	r7, [r4, #4]
  if (p_conf->mode == CMW_Aspect_ratio_crop)
3400ca16:	6992      	ldr	r2, [r2, #24]
  const float ratio_height = (float)cam_height / pipe_height;
3400ca18:	ee06 7a90 	vmov	s13, r7
{
3400ca1c:	ee07 0a10 	vmov	s14, r0
3400ca20:	ee07 1a90 	vmov	s15, r1
  const float ratio_height = (float)cam_height / pipe_height;
3400ca24:	eeb8 5a66 	vcvt.f32.u32	s10, s13
  if (p_conf->mode == CMW_Aspect_ratio_crop)
3400ca28:	2a00      	cmp	r2, #0
3400ca2a:	f040 808e 	bne.w	3400cb4a <CMW_UTILS_GetPipeConfig+0x13e>
  const float ratio_width = (float)cam_width / pipe_width ;
3400ca2e:	edd4 6a00 	vldr	s13, [r4]
3400ca32:	eeb8 6a47 	vcvt.f32.u32	s12, s14
3400ca36:	eef8 4a66 	vcvt.f32.u32	s9, s13
  const float ratio_height = (float)cam_height / pipe_height;
3400ca3a:	eef8 6a67 	vcvt.f32.u32	s13, s15
  const float ratio_width = (float)cam_width / pipe_width ;
3400ca3e:	ee86 4a24 	vdiv.f32	s8, s12, s9
  const float ratio_height = (float)cam_height / pipe_height;
3400ca42:	eec6 5a85 	vdiv.f32	s11, s13, s10
  const float ratio = MIN(ratio_width, ratio_height);
3400ca46:	eeb4 4a65 	vcmp.f32	s8, s11
3400ca4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400ca4e:	bf48      	it	mi
3400ca50:	eef0 5a44 	vmovmi.f32	s11, s8
  assert(ratio >= 1);
3400ca54:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
3400ca58:	eef4 5ac4 	vcmpe.f32	s11, s8
3400ca5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400ca60:	da05      	bge.n	3400ca6e <CMW_UTILS_GetPipeConfig+0x62>
3400ca62:	214f      	movs	r1, #79	@ 0x4f
3400ca64:	4b4f      	ldr	r3, [pc, #316]	@ (3400cba4 <CMW_UTILS_GetPipeConfig+0x198>)
3400ca66:	4a50      	ldr	r2, [pc, #320]	@ (3400cba8 <CMW_UTILS_GetPipeConfig+0x19c>)
  assert(ratio < 64);
3400ca68:	4850      	ldr	r0, [pc, #320]	@ (3400cbac <CMW_UTILS_GetPipeConfig+0x1a0>)
3400ca6a:	f000 fb41 	bl	3400d0f0 <__assert_func>
3400ca6e:	ed9f 4a50 	vldr	s8, [pc, #320]	@ 3400cbb0 <CMW_UTILS_GetPipeConfig+0x1a4>
3400ca72:	eef4 5ac4 	vcmpe.f32	s11, s8
3400ca76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400ca7a:	d403      	bmi.n	3400ca84 <CMW_UTILS_GetPipeConfig+0x78>
3400ca7c:	2150      	movs	r1, #80	@ 0x50
3400ca7e:	4b4d      	ldr	r3, [pc, #308]	@ (3400cbb4 <CMW_UTILS_GetPipeConfig+0x1a8>)
3400ca80:	4a49      	ldr	r2, [pc, #292]	@ (3400cba8 <CMW_UTILS_GetPipeConfig+0x19c>)
3400ca82:	e7f1      	b.n	3400ca68 <CMW_UTILS_GetPipeConfig+0x5c>
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
3400ca84:	ee24 4aa5 	vmul.f32	s8, s9, s11
3400ca88:	eeb4 6ac4 	vcmpe.f32	s12, s8
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
3400ca8c:	ee65 5a25 	vmul.f32	s11, s10, s11
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
3400ca90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
3400ca94:	eef4 6ae5 	vcmpe.f32	s13, s11
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
3400ca98:	bfcc      	ite	gt
3400ca9a:	eebc 6ac4 	vcvtgt.u32.f32	s12, s8
3400ca9e:	eebc 6ac6 	vcvtle.u32.f32	s12, s12
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
3400caa2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
3400caa6:	4601      	mov	r1, r0
3400caa8:	ee16 2a10 	vmov	r2, s12
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
3400caac:	bfcc      	ite	gt
3400caae:	eefc 6ae5 	vcvtgt.u32.f32	s13, s11
3400cab2:	eefc 6ae6 	vcvtle.u32.f32	s13, s13
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
3400cab6:	3101      	adds	r1, #1
3400cab8:	1a89      	subs	r1, r1, r2
3400caba:	0849      	lsrs	r1, r1, #1
3400cabc:	6059      	str	r1, [r3, #4]
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
3400cabe:	ee17 1a90 	vmov	r1, s15
3400cac2:	ee16 2a90 	vmov	r2, s13
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
3400cac6:	ed83 6a03 	vstr	s12, [r3, #12]
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
3400caca:	edc3 6a02 	vstr	s13, [r3, #8]
    ratio_width = (float)crop->HSize / p_conf->output_width;
3400cace:	eeb8 6a46 	vcvt.f32.u32	s12, s12
    ratio_height = (float)crop->VSize / p_conf->output_height;
3400cad2:	eef8 6a66 	vcvt.f32.u32	s13, s13
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
3400cad6:	3101      	adds	r1, #1
3400cad8:	1a89      	subs	r1, r1, r2
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
3400cada:	2200      	movs	r2, #0
    ratio_width = (float)crop->HSize / p_conf->output_width;
3400cadc:	eec6 5a24 	vdiv.f32	s11, s12, s9
    ratio_height = (float)crop->VSize / p_conf->output_height;
3400cae0:	ee86 7a85 	vdiv.f32	s14, s13, s10
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
3400cae4:	0849      	lsrs	r1, r1, #1
3400cae6:	6019      	str	r1, [r3, #0]
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
3400cae8:	611a      	str	r2, [r3, #16]

static void CMW_UTILS_get_scale_configs(CMW_DCMIPP_Conf_t *p_conf, float ratio_width, float ratio_height,
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down)
{
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
3400caea:	2100      	movs	r1, #0
3400caec:	4668      	mov	r0, sp
3400caee:	ed8d 7a01 	vstr	s14, [sp, #4]
3400caf2:	edcd 5a00 	vstr	s11, [sp]
3400caf6:	f7ff ff4f 	bl	3400c998 <CMW_UTILS_get_dec_ratio_and_update>
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
3400cafa:	2101      	movs	r1, #1
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
3400cafc:	6068      	str	r0, [r5, #4]
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
3400cafe:	a801      	add	r0, sp, #4
3400cb00:	f7ff ff4a 	bl	3400c998 <CMW_UTILS_get_dec_ratio_and_update>
  down->HRatio = (uint32_t) (8192 * ratio_width);
3400cb04:	ed9f 7a2c 	vldr	s14, [pc, #176]	@ 3400cbb8 <CMW_UTILS_GetPipeConfig+0x1ac>
3400cb08:	eddd 7a00 	vldr	s15, [sp]
3400cb0c:	ee67 7a87 	vmul.f32	s15, s15, s14
3400cb10:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
3400cb14:	6028      	str	r0, [r5, #0]
  down->HRatio = (uint32_t) (8192 * ratio_width);
3400cb16:	ee17 3a90 	vmov	r3, s15
  CMW_UTILS_get_down_config(ratio_width, ratio_height, p_conf->output_width, p_conf->output_height, down);
3400cb1a:	6820      	ldr	r0, [r4, #0]
  down->HRatio = (uint32_t) (8192 * ratio_width);
3400cb1c:	edc6 7a03 	vstr	s15, [r6, #12]
  down->VRatio = (uint32_t) (8192 * ratio_height);
3400cb20:	eddd 7a01 	vldr	s15, [sp, #4]
3400cb24:	ee67 7a87 	vmul.f32	s15, s15, s14
3400cb28:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3400cb2c:	ee17 2a90 	vmov	r2, s15
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
3400cb30:	4922      	ldr	r1, [pc, #136]	@ (3400cbbc <CMW_UTILS_GetPipeConfig+0x1b0>)
  down->VRatio = (uint32_t) (8192 * ratio_height);
3400cb32:	edc6 7a02 	vstr	s15, [r6, #8]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
3400cb36:	fbb1 f3f3 	udiv	r3, r1, r3
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
3400cb3a:	fbb1 f1f2 	udiv	r1, r1, r2
  down->VSize = height;
3400cb3e:	e9c6 7000 	strd	r7, r0, [r6]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
3400cb42:	6173      	str	r3, [r6, #20]
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
3400cb44:	6131      	str	r1, [r6, #16]
}
3400cb46:	b003      	add	sp, #12
3400cb48:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (p_conf->mode == CMW_Aspect_ratio_fit)
3400cb4a:	2a01      	cmp	r2, #1
3400cb4c:	d10c      	bne.n	3400cb68 <CMW_UTILS_GetPipeConfig+0x15c>
    ratio_width = (float)cam_width / p_conf->output_width;
3400cb4e:	edd4 6a00 	vldr	s13, [r4]
3400cb52:	eeb8 7a47 	vcvt.f32.u32	s14, s14
3400cb56:	eef8 6a66 	vcvt.f32.u32	s13, s13
3400cb5a:	eec7 5a26 	vdiv.f32	s11, s14, s13
    ratio_height = (float)crop->VSize / p_conf->output_height;
3400cb5e:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400cb62:	ee87 7a85 	vdiv.f32	s14, s15, s10
3400cb66:	e7c0      	b.n	3400caea <CMW_UTILS_GetPipeConfig+0xde>
  else if (p_conf->mode == CMW_Aspect_ratio_fullscreen)
3400cb68:	2a02      	cmp	r2, #2
3400cb6a:	d106      	bne.n	3400cb7a <CMW_UTILS_GetPipeConfig+0x16e>
    ratio_height = (float) cam_height / p_conf->output_height;
3400cb6c:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400cb70:	ee87 7a85 	vdiv.f32	s14, s15, s10
    ratio_width = (float) ratio_height;
3400cb74:	eef0 5a47 	vmov.f32	s11, s14
3400cb78:	e7b7      	b.n	3400caea <CMW_UTILS_GetPipeConfig+0xde>
  crop->HSize = roi->width;
3400cb7a:	69e1      	ldr	r1, [r4, #28]
    ratio_width = (float)crop->HSize / p_conf->output_width;
3400cb7c:	ed94 7a00 	vldr	s14, [r4]
3400cb80:	ee07 1a90 	vmov	s15, r1
3400cb84:	eeb8 7a47 	vcvt.f32.u32	s14, s14
3400cb88:	eef8 7a67 	vcvt.f32.u32	s15, s15
  crop->HStart = roi->offset_x;
3400cb8c:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  crop->VSize = roi->height;
3400cb8e:	6a22      	ldr	r2, [r4, #32]
  crop->HStart = roi->offset_x;
3400cb90:	6058      	str	r0, [r3, #4]
  crop->VStart = roi->offset_y;
3400cb92:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
    ratio_width = (float)crop->HSize / p_conf->output_width;
3400cb94:	eec7 5a87 	vdiv.f32	s11, s15, s14
  crop->HSize = roi->width;
3400cb98:	60d9      	str	r1, [r3, #12]
    ratio_height = (float)crop->VSize / p_conf->output_height;
3400cb9a:	ee07 2a90 	vmov	s15, r2
  crop->VSize = roi->height;
3400cb9e:	609a      	str	r2, [r3, #8]
  crop->VStart = roi->offset_y;
3400cba0:	6018      	str	r0, [r3, #0]
    ratio_height = (float)crop->VSize / p_conf->output_height;
3400cba2:	e7dc      	b.n	3400cb5e <CMW_UTILS_GetPipeConfig+0x152>
3400cba4:	340109a9 	.word	0x340109a9
3400cba8:	3401140f 	.word	0x3401140f
3400cbac:	3401097e 	.word	0x3401097e
3400cbb0:	42800000 	.word	0x42800000
3400cbb4:	340109b4 	.word	0x340109b4
3400cbb8:	46000000 	.word	0x46000000
3400cbbc:	007fffff 	.word	0x007fffff

3400cbc0 <IMX335_ReadRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_ReadRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
3400cbc0:	b410      	push	{r4}
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
3400cbc2:	6904      	ldr	r4, [r0, #16]
3400cbc4:	8900      	ldrh	r0, [r0, #8]
3400cbc6:	46a4      	mov	ip, r4
}
3400cbc8:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
3400cbcc:	4760      	bx	ip

3400cbce <IMX335_WriteRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_WriteRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
3400cbce:	b410      	push	{r4}
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
3400cbd0:	68c4      	ldr	r4, [r0, #12]
3400cbd2:	8900      	ldrh	r0, [r0, #8]
3400cbd4:	46a4      	mov	ip, r4
}
3400cbd6:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
3400cbda:	4760      	bx	ip

3400cbdc <IMX335_WriteTable>:
{
3400cbdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int32_t ret = IMX335_OK;
3400cbde:	2500      	movs	r5, #0
3400cbe0:	1c8c      	adds	r4, r1, #2
3400cbe2:	eb04 0682 	add.w	r6, r4, r2, lsl #2
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
3400cbe6:	f100 0718 	add.w	r7, r0, #24
    if(ret != IMX335_ERROR)
3400cbea:	b135      	cbz	r5, 3400cbfa <IMX335_WriteTable+0x1e>
  int32_t ret = IMX335_OK;
3400cbec:	f04f 35ff 	mov.w	r5, #4294967295
  for(index=0; index<size ; index++)
3400cbf0:	3404      	adds	r4, #4
3400cbf2:	42b4      	cmp	r4, r6
3400cbf4:	d1f9      	bne.n	3400cbea <IMX335_WriteTable+0xe>
}
3400cbf6:	4628      	mov	r0, r5
3400cbf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
3400cbfa:	2301      	movs	r3, #1
3400cbfc:	4622      	mov	r2, r4
3400cbfe:	4638      	mov	r0, r7
3400cc00:	f834 1c02 	ldrh.w	r1, [r4, #-2]
3400cc04:	f000 f9a1 	bl	3400cf4a <imx335_write_reg>
3400cc08:	2800      	cmp	r0, #0
3400cc0a:	d1ef      	bne.n	3400cbec <IMX335_WriteTable+0x10>
3400cc0c:	e7f0      	b.n	3400cbf0 <IMX335_WriteTable+0x14>
	...

3400cc10 <IMX335_RegisterBusIO>:
  */
int32_t IMX335_RegisterBusIO(IMX335_Object_t *pObj, IMX335_IO_t *pIO)
{
  int32_t ret;

  if (pObj == NULL)
3400cc10:	b190      	cbz	r0, 3400cc38 <IMX335_RegisterBusIO+0x28>
    ret = IMX335_ERROR;
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
    pObj->IO.DeInit    = pIO->DeInit;
3400cc12:	684a      	ldr	r2, [r1, #4]
    pObj->IO.Init      = pIO->Init;
3400cc14:	680b      	ldr	r3, [r1, #0]
    pObj->IO.DeInit    = pIO->DeInit;
3400cc16:	6042      	str	r2, [r0, #4]
    pObj->IO.Address   = pIO->Address;
3400cc18:	890a      	ldrh	r2, [r1, #8]
    pObj->IO.Init      = pIO->Init;
3400cc1a:	6003      	str	r3, [r0, #0]
    pObj->IO.Address   = pIO->Address;
3400cc1c:	8102      	strh	r2, [r0, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
3400cc1e:	68ca      	ldr	r2, [r1, #12]
3400cc20:	60c2      	str	r2, [r0, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
3400cc22:	690a      	ldr	r2, [r1, #16]
3400cc24:	6102      	str	r2, [r0, #16]
    pObj->IO.GetTick   = pIO->GetTick;
3400cc26:	694a      	ldr	r2, [r1, #20]

    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
    pObj->Ctx.handle   = pObj;
3400cc28:	6200      	str	r0, [r0, #32]
    pObj->IO.GetTick   = pIO->GetTick;
3400cc2a:	6142      	str	r2, [r0, #20]
    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
3400cc2c:	4a04      	ldr	r2, [pc, #16]	@ (3400cc40 <IMX335_RegisterBusIO+0x30>)
3400cc2e:	61c2      	str	r2, [r0, #28]
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
3400cc30:	4a04      	ldr	r2, [pc, #16]	@ (3400cc44 <IMX335_RegisterBusIO+0x34>)
3400cc32:	6182      	str	r2, [r0, #24]

    if(pObj->IO.Init != NULL)
3400cc34:	b103      	cbz	r3, 3400cc38 <IMX335_RegisterBusIO+0x28>
    {
      ret = pObj->IO.Init();
3400cc36:	4718      	bx	r3
      ret = IMX335_ERROR;
    }
  }

  return ret;
}
3400cc38:	f04f 30ff 	mov.w	r0, #4294967295
3400cc3c:	4770      	bx	lr
3400cc3e:	bf00      	nop
3400cc40:	3400cbc1 	.word	0x3400cbc1
3400cc44:	3400cbcf 	.word	0x3400cbcf

3400cc48 <IMX335_Init>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Init(IMX335_Object_t *pObj, uint32_t Resolution, uint32_t PixelFormat)
{
3400cc48:	b510      	push	{r4, lr}
  int32_t ret = IMX335_OK;

  if(pObj->IsInitialized == 0U)
3400cc4a:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
{
3400cc4e:	4604      	mov	r4, r0
  if(pObj->IsInitialized == 0U)
3400cc50:	b9a3      	cbnz	r3, 3400cc7c <IMX335_Init+0x34>
  {
    switch (Resolution)
3400cc52:	2906      	cmp	r1, #6
3400cc54:	d002      	beq.n	3400cc5c <IMX335_Init+0x14>
        }
        break;
      /* Add new resolution here */
      default:
        /* Resolution not supported */
        ret = IMX335_ERROR;
3400cc56:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

  return ret;
}
3400cc5a:	bd10      	pop	{r4, pc}
        if(IMX335_WriteTable(pObj, res_2592_1944_regs, ARRAY_SIZE(res_2592_1944_regs)) != IMX335_OK)
3400cc5c:	2254      	movs	r2, #84	@ 0x54
3400cc5e:	4908      	ldr	r1, [pc, #32]	@ (3400cc80 <IMX335_Init+0x38>)
3400cc60:	f7ff ffbc 	bl	3400cbdc <IMX335_WriteTable>
3400cc64:	2800      	cmp	r0, #0
3400cc66:	d1f6      	bne.n	3400cc56 <IMX335_Init+0xe>
      if(IMX335_WriteTable(pObj, mode_2l_10b_regs, ARRAY_SIZE(mode_2l_10b_regs)) != IMX335_OK)
3400cc68:	2205      	movs	r2, #5
3400cc6a:	4620      	mov	r0, r4
3400cc6c:	4905      	ldr	r1, [pc, #20]	@ (3400cc84 <IMX335_Init+0x3c>)
3400cc6e:	f7ff ffb5 	bl	3400cbdc <IMX335_WriteTable>
3400cc72:	2800      	cmp	r0, #0
3400cc74:	d1ef      	bne.n	3400cc56 <IMX335_Init+0xe>
        pObj->IsInitialized = 1U;
3400cc76:	2301      	movs	r3, #1
3400cc78:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
  int32_t ret = IMX335_OK;
3400cc7c:	2000      	movs	r0, #0
  return ret;
3400cc7e:	e7ec      	b.n	3400cc5a <IMX335_Init+0x12>
3400cc80:	340115e6 	.word	0x340115e6
3400cc84:	340115d2 	.word	0x340115d2

3400cc88 <IMX335_Start>:
int32_t IMX335_Start(IMX335_Object_t *pObj)
{
  uint8_t tmp;
  int32_t ret = IMX335_OK;
  /* Start streaming */
  tmp = IMX335_MODE_STREAMING;
3400cc88:	2300      	movs	r3, #0
{
3400cc8a:	b573      	push	{r0, r1, r4, r5, r6, lr}
3400cc8c:	4605      	mov	r5, r0
  tmp = IMX335_MODE_STREAMING;
3400cc8e:	f88d 3007 	strb.w	r3, [sp, #7]
  ret = imx335_write_reg(&pObj->Ctx, IMX335_REG_MODE_SELECT, &tmp, 1);
3400cc92:	f44f 5140 	mov.w	r1, #12288	@ 0x3000
3400cc96:	2301      	movs	r3, #1
3400cc98:	f10d 0207 	add.w	r2, sp, #7
3400cc9c:	3018      	adds	r0, #24
3400cc9e:	f000 f954 	bl	3400cf4a <imx335_write_reg>
  if (ret != IMX335_OK)
3400cca2:	4604      	mov	r4, r0
3400cca4:	b950      	cbnz	r0, 3400ccbc <IMX335_Start+0x34>
  tickstart = pObj->IO.GetTick();
3400cca6:	696b      	ldr	r3, [r5, #20]
3400cca8:	4798      	blx	r3
3400ccaa:	4606      	mov	r6, r0
  while((pObj->IO.GetTick() - tickstart) < Delay)
3400ccac:	696b      	ldr	r3, [r5, #20]
3400ccae:	4798      	blx	r3
3400ccb0:	1b83      	subs	r3, r0, r6
3400ccb2:	2b13      	cmp	r3, #19
3400ccb4:	d9fa      	bls.n	3400ccac <IMX335_Start+0x24>
  {
    return IMX335_ERROR;
  }
  IMX335_Delay(pObj, 20);
  return ret;
}
3400ccb6:	4620      	mov	r0, r4
3400ccb8:	b002      	add	sp, #8
3400ccba:	bd70      	pop	{r4, r5, r6, pc}
    return IMX335_ERROR;
3400ccbc:	f04f 34ff 	mov.w	r4, #4294967295
3400ccc0:	e7f9      	b.n	3400ccb6 <IMX335_Start+0x2e>

3400ccc2 <IMX335_DeInit>:
  * @param  pObj  pointer to component object
  * @retval Component status
  */
int32_t IMX335_DeInit(IMX335_Object_t *pObj)
{
  if(pObj->IsInitialized == 1U)
3400ccc2:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
3400ccc6:	2b01      	cmp	r3, #1
  {
    /* De-initialize camera sensor interface */
    pObj->IsInitialized = 0U;
3400ccc8:	bf04      	itt	eq
3400ccca:	2300      	moveq	r3, #0
3400cccc:	f880 3024 	strbeq.w	r3, [r0, #36]	@ 0x24
  }

  return IMX335_OK;
}
3400ccd0:	2000      	movs	r0, #0
3400ccd2:	4770      	bx	lr

3400ccd4 <IMX335_ReadID>:
  * @param  pObj  pointer to component object
  * @param  Id    pointer to component ID
  * @retval Component status
  */
int32_t IMX335_ReadID(IMX335_Object_t *pObj, uint32_t *Id)
{
3400ccd4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  int32_t ret;
  uint8_t tmp;

  /* Initialize I2C */
  pObj->IO.Init();
3400ccd6:	4604      	mov	r4, r0
3400ccd8:	f854 3b18 	ldr.w	r3, [r4], #24
{
3400ccdc:	460d      	mov	r5, r1
  pObj->IO.Init();
3400ccde:	4798      	blx	r3

  if(imx335_read_reg(&pObj->Ctx, IMX335_REG_ID, &tmp, 1)!= IMX335_OK)
3400cce0:	2301      	movs	r3, #1
3400cce2:	f643 1112 	movw	r1, #14610	@ 0x3912
3400cce6:	4620      	mov	r0, r4
3400cce8:	f10d 0207 	add.w	r2, sp, #7
3400ccec:	f000 f926 	bl	3400cf3c <imx335_read_reg>
3400ccf0:	b920      	cbnz	r0, 3400ccfc <IMX335_ReadID+0x28>
  {
    ret = IMX335_ERROR;
  }
  else
  {
    *Id = tmp;
3400ccf2:	f89d 3007 	ldrb.w	r3, [sp, #7]
3400ccf6:	602b      	str	r3, [r5, #0]
    ret = IMX335_OK;
  }

  /* Component status */
  return ret;
}
3400ccf8:	b003      	add	sp, #12
3400ccfa:	bd30      	pop	{r4, r5, pc}
    ret = IMX335_ERROR;
3400ccfc:	f04f 30ff 	mov.w	r0, #4294967295
  return ret;
3400cd00:	e7fa      	b.n	3400ccf8 <IMX335_ReadID+0x24>
	...

3400cd04 <IMX335_SetGain>:
  * @param  pObj  pointer to component object
  * @param  Gain Gain in mdB
  * @retval Component status
  */
int32_t IMX335_SetGain(IMX335_Object_t *pObj, int32_t gain)
{
3400cd04:	b530      	push	{r4, r5, lr}
  int32_t ret = IMX335_OK;
  uint8_t hold;

  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
3400cd06:	4b1a      	ldr	r3, [pc, #104]	@ (3400cd70 <IMX335_SetGain+0x6c>)
{
3400cd08:	b085      	sub	sp, #20
  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
3400cd0a:	4299      	cmp	r1, r3
3400cd0c:	d903      	bls.n	3400cd16 <IMX335_SetGain+0x12>
  {
    ret = IMX335_ERROR;
3400cd0e:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

return ret;
}
3400cd12:	b005      	add	sp, #20
3400cd14:	bd30      	pop	{r4, r5, pc}
    gain /= IMX335_GAIN_UNIT_MDB;
3400cd16:	f44f 7396 	mov.w	r3, #300	@ 0x12c
    hold = 1;
3400cd1a:	2501      	movs	r5, #1
    gain /= IMX335_GAIN_UNIT_MDB;
3400cd1c:	fb91 f1f3 	sdiv	r1, r1, r3
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3400cd20:	f100 0418 	add.w	r4, r0, #24
    gain /= IMX335_GAIN_UNIT_MDB;
3400cd24:	9101      	str	r1, [sp, #4]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3400cd26:	462b      	mov	r3, r5
3400cd28:	f243 0101 	movw	r1, #12289	@ 0x3001
3400cd2c:	4620      	mov	r0, r4
3400cd2e:	f10d 020f 	add.w	r2, sp, #15
    hold = 1;
3400cd32:	f88d 500f 	strb.w	r5, [sp, #15]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3400cd36:	f000 f908 	bl	3400cf4a <imx335_write_reg>
3400cd3a:	2800      	cmp	r0, #0
3400cd3c:	d1e7      	bne.n	3400cd0e <IMX335_SetGain+0xa>
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_GAIN, (uint8_t *)&gain, 2) != IMX335_OK)
3400cd3e:	2302      	movs	r3, #2
3400cd40:	f243 01e8 	movw	r1, #12520	@ 0x30e8
3400cd44:	4620      	mov	r0, r4
3400cd46:	aa01      	add	r2, sp, #4
3400cd48:	f000 f8ff 	bl	3400cf4a <imx335_write_reg>
3400cd4c:	2800      	cmp	r0, #0
3400cd4e:	d1de      	bne.n	3400cd0e <IMX335_SetGain+0xa>
        hold = 0;
3400cd50:	f88d 000f 	strb.w	r0, [sp, #15]
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3400cd54:	462b      	mov	r3, r5
3400cd56:	f243 0101 	movw	r1, #12289	@ 0x3001
3400cd5a:	4620      	mov	r0, r4
3400cd5c:	f10d 020f 	add.w	r2, sp, #15
3400cd60:	f000 f8f3 	bl	3400cf4a <imx335_write_reg>
3400cd64:	3800      	subs	r0, #0
3400cd66:	bf18      	it	ne
3400cd68:	2001      	movne	r0, #1
3400cd6a:	4240      	negs	r0, r0
return ret;
3400cd6c:	e7d1      	b.n	3400cd12 <IMX335_SetGain+0xe>
3400cd6e:	bf00      	nop
3400cd70:	00011940 	.word	0x00011940

3400cd74 <IMX335_SetExposure>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure in micro seconds
  * @retval Component status
  */
int32_t IMX335_SetExposure(IMX335_Object_t *pObj, int32_t exposure)
{
3400cd74:	b530      	push	{r4, r5, lr}
3400cd76:	ed2d 8b02 	vpush	{d8}
  int32_t ret = IMX335_OK;
  uint32_t vmax, shutter;
  uint8_t hold;


  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
3400cd7a:	f100 0418 	add.w	r4, r0, #24
{
3400cd7e:	b085      	sub	sp, #20
3400cd80:	ee08 1a10 	vmov	s16, r1
  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
3400cd84:	2304      	movs	r3, #4
3400cd86:	f243 0130 	movw	r1, #12336	@ 0x3030
3400cd8a:	4620      	mov	r0, r4
3400cd8c:	aa02      	add	r2, sp, #8
3400cd8e:	f000 f8d5 	bl	3400cf3c <imx335_read_reg>
3400cd92:	b128      	cbz	r0, 3400cda0 <IMX335_SetExposure+0x2c>
  {
    ret = IMX335_ERROR;
3400cd94:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

  return ret;
}
3400cd98:	b005      	add	sp, #20
3400cd9a:	ecbd 8b02 	vpop	{d8}
3400cd9e:	bd30      	pop	{r4, r5, pc}
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
3400cda0:	eddd 7a02 	vldr	s15, [sp, #8]
3400cda4:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
3400cda8:	eddf 6a1a 	vldr	s13, [pc, #104]	@ 3400ce14 <IMX335_SetExposure+0xa0>
3400cdac:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400cdb0:	ee88 7a26 	vdiv.f32	s14, s16, s13
3400cdb4:	ee77 7ac7 	vsub.f32	s15, s15, s14
3400cdb8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3400cdbc:	ee17 3a90 	vmov	r3, s15
    if (shutter < IMX335_SHUTTER_MIN)
3400cdc0:	2b08      	cmp	r3, #8
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
3400cdc2:	edcd 7a03 	vstr	s15, [sp, #12]
    if (shutter < IMX335_SHUTTER_MIN)
3400cdc6:	d9e5      	bls.n	3400cd94 <IMX335_SetExposure+0x20>
      hold = 1;
3400cdc8:	2501      	movs	r5, #1
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3400cdca:	f243 0101 	movw	r1, #12289	@ 0x3001
3400cdce:	462b      	mov	r3, r5
3400cdd0:	4620      	mov	r0, r4
3400cdd2:	f10d 0207 	add.w	r2, sp, #7
      hold = 1;
3400cdd6:	f88d 5007 	strb.w	r5, [sp, #7]
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3400cdda:	f000 f8b6 	bl	3400cf4a <imx335_write_reg>
3400cdde:	2800      	cmp	r0, #0
3400cde0:	d1d8      	bne.n	3400cd94 <IMX335_SetExposure+0x20>
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_SHUTTER, (uint8_t *)&shutter, 3) != IMX335_OK)
3400cde2:	2303      	movs	r3, #3
3400cde4:	f243 0158 	movw	r1, #12376	@ 0x3058
3400cde8:	4620      	mov	r0, r4
3400cdea:	aa03      	add	r2, sp, #12
3400cdec:	f000 f8ad 	bl	3400cf4a <imx335_write_reg>
3400cdf0:	2800      	cmp	r0, #0
3400cdf2:	d1cf      	bne.n	3400cd94 <IMX335_SetExposure+0x20>
          hold = 0;
3400cdf4:	f88d 0007 	strb.w	r0, [sp, #7]
          if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3400cdf8:	462b      	mov	r3, r5
3400cdfa:	f243 0101 	movw	r1, #12289	@ 0x3001
3400cdfe:	4620      	mov	r0, r4
3400ce00:	f10d 0207 	add.w	r2, sp, #7
3400ce04:	f000 f8a1 	bl	3400cf4a <imx335_write_reg>
3400ce08:	3800      	subs	r0, #0
3400ce0a:	bf18      	it	ne
3400ce0c:	2001      	movne	r0, #1
3400ce0e:	4240      	negs	r0, r0
  return ret;
3400ce10:	e7c2      	b.n	3400cd98 <IMX335_SetExposure+0x24>
3400ce12:	bf00      	nop
3400ce14:	40ed097c 	.word	0x40ed097c

3400ce18 <IMX335_SetFrequency>:
  */
int32_t IMX335_SetFrequency(IMX335_Object_t *pObj, int32_t frequency)
{
  uint32_t ret = IMX335_OK;

  switch (frequency)
3400ce18:	3901      	subs	r1, #1
        ret = IMX335_ERROR;
      }
      break;
    default:
      /* IMX335_INCK_6MHZ */
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
3400ce1a:	2207      	movs	r2, #7
{
3400ce1c:	b508      	push	{r3, lr}
  switch (frequency)
3400ce1e:	2904      	cmp	r1, #4
3400ce20:	d814      	bhi.n	3400ce4c <IMX335_SetFrequency+0x34>
3400ce22:	e8df f001 	tbb	[pc, r1]
3400ce26:	0f11      	.short	0x0f11
3400ce28:	030d      	.short	0x030d
3400ce2a:	0b          	.byte	0x0b
3400ce2b:	00          	.byte	0x00
      if(IMX335_WriteTable(pObj, inck_74Mhz_regs, ARRAY_SIZE(inck_74Mhz_regs)) != IMX335_OK)
3400ce2c:	4908      	ldr	r1, [pc, #32]	@ (3400ce50 <IMX335_SetFrequency+0x38>)
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
3400ce2e:	f7ff fed5 	bl	3400cbdc <IMX335_WriteTable>
3400ce32:	3800      	subs	r0, #0
3400ce34:	bf18      	it	ne
3400ce36:	2001      	movne	r0, #1
3400ce38:	4240      	negs	r0, r0
      }
      break;
  };

  return ret;
}
3400ce3a:	bd08      	pop	{r3, pc}
      if(IMX335_WriteTable(pObj, inck_37Mhz_regs, ARRAY_SIZE(inck_37Mhz_regs)) != IMX335_OK)
3400ce3c:	4905      	ldr	r1, [pc, #20]	@ (3400ce54 <IMX335_SetFrequency+0x3c>)
3400ce3e:	e7f6      	b.n	3400ce2e <IMX335_SetFrequency+0x16>
      if(IMX335_WriteTable(pObj, inck_27Mhz_regs, ARRAY_SIZE(inck_27Mhz_regs)) != IMX335_OK)
3400ce40:	4905      	ldr	r1, [pc, #20]	@ (3400ce58 <IMX335_SetFrequency+0x40>)
3400ce42:	e7f4      	b.n	3400ce2e <IMX335_SetFrequency+0x16>
      if(IMX335_WriteTable(pObj, inck_24Mhz_regs, ARRAY_SIZE(inck_24Mhz_regs)) != IMX335_OK)
3400ce44:	4905      	ldr	r1, [pc, #20]	@ (3400ce5c <IMX335_SetFrequency+0x44>)
3400ce46:	e7f2      	b.n	3400ce2e <IMX335_SetFrequency+0x16>
      if(IMX335_WriteTable(pObj, inck_18Mhz_regs, ARRAY_SIZE(inck_18Mhz_regs)) != IMX335_OK)
3400ce48:	4905      	ldr	r1, [pc, #20]	@ (3400ce60 <IMX335_SetFrequency+0x48>)
3400ce4a:	e7f0      	b.n	3400ce2e <IMX335_SetFrequency+0x16>
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
3400ce4c:	4905      	ldr	r1, [pc, #20]	@ (3400ce64 <IMX335_SetFrequency+0x4c>)
3400ce4e:	e7ee      	b.n	3400ce2e <IMX335_SetFrequency+0x16>
3400ce50:	340115b6 	.word	0x340115b6
3400ce54:	3401159a 	.word	0x3401159a
3400ce58:	3401157e 	.word	0x3401157e
3400ce5c:	34011562 	.word	0x34011562
3400ce60:	34011546 	.word	0x34011546
3400ce64:	3401152a 	.word	0x3401152a

3400ce68 <IMX335_SetFramerate>:
  * @retval Component status
  */
int32_t IMX335_SetFramerate(IMX335_Object_t *pObj, int32_t framerate)
{
  uint32_t ret = IMX335_OK;
  switch (framerate)
3400ce68:	2914      	cmp	r1, #20
{
3400ce6a:	b508      	push	{r3, lr}
3400ce6c:	4603      	mov	r3, r0
  switch (framerate)
3400ce6e:	d019      	beq.n	3400cea4 <IMX335_SetFramerate+0x3c>
3400ce70:	dc07      	bgt.n	3400ce82 <IMX335_SetFramerate+0x1a>
3400ce72:	290a      	cmp	r1, #10
3400ce74:	d00a      	beq.n	3400ce8c <IMX335_SetFramerate+0x24>
3400ce76:	290f      	cmp	r1, #15
3400ce78:	d011      	beq.n	3400ce9e <IMX335_SetFramerate+0x36>
        ret = IMX335_ERROR;
      }
      break;
    default:
      /* 30fps */
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
3400ce7a:	2202      	movs	r2, #2
3400ce7c:	4618      	mov	r0, r3
3400ce7e:	490b      	ldr	r1, [pc, #44]	@ (3400ceac <IMX335_SetFramerate+0x44>)
3400ce80:	e006      	b.n	3400ce90 <IMX335_SetFramerate+0x28>
  switch (framerate)
3400ce82:	2919      	cmp	r1, #25
3400ce84:	d1f9      	bne.n	3400ce7a <IMX335_SetFramerate+0x12>
      if(IMX335_WriteTable(pObj, framerate_25fps_regs, ARRAY_SIZE(framerate_25fps_regs)) != IMX335_OK)
3400ce86:	2202      	movs	r2, #2
3400ce88:	4909      	ldr	r1, [pc, #36]	@ (3400ceb0 <IMX335_SetFramerate+0x48>)
3400ce8a:	e001      	b.n	3400ce90 <IMX335_SetFramerate+0x28>
      if(IMX335_WriteTable(pObj, framerate_10fps_regs, ARRAY_SIZE(framerate_10fps_regs)) != IMX335_OK)
3400ce8c:	2202      	movs	r2, #2
3400ce8e:	4909      	ldr	r1, [pc, #36]	@ (3400ceb4 <IMX335_SetFramerate+0x4c>)
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
3400ce90:	f7ff fea4 	bl	3400cbdc <IMX335_WriteTable>
3400ce94:	3800      	subs	r0, #0
3400ce96:	bf18      	it	ne
3400ce98:	2001      	movne	r0, #1
3400ce9a:	4240      	negs	r0, r0
      }
      break;
  };

  return ret;
}
3400ce9c:	bd08      	pop	{r3, pc}
      if(IMX335_WriteTable(pObj, framerate_15fps_regs, ARRAY_SIZE(framerate_15fps_regs)) != IMX335_OK)
3400ce9e:	2202      	movs	r2, #2
3400cea0:	4905      	ldr	r1, [pc, #20]	@ (3400ceb8 <IMX335_SetFramerate+0x50>)
3400cea2:	e7f5      	b.n	3400ce90 <IMX335_SetFramerate+0x28>
      if(IMX335_WriteTable(pObj, framerate_20fps_regs, ARRAY_SIZE(framerate_20fps_regs)) != IMX335_OK)
3400cea4:	2202      	movs	r2, #2
3400cea6:	4905      	ldr	r1, [pc, #20]	@ (3400cebc <IMX335_SetFramerate+0x54>)
3400cea8:	e7f2      	b.n	3400ce90 <IMX335_SetFramerate+0x28>
3400ceaa:	bf00      	nop
3400ceac:	34011502 	.word	0x34011502
3400ceb0:	3401150a 	.word	0x3401150a
3400ceb4:	34011522 	.word	0x34011522
3400ceb8:	3401151a 	.word	0x3401151a
3400cebc:	34011512 	.word	0x34011512

3400cec0 <IMX335_MirrorFlipConfig>:
  */
int32_t IMX335_MirrorFlipConfig(IMX335_Object_t *pObj, uint32_t Config)
{
  int32_t ret = IMX335_OK;

  switch (Config)
3400cec0:	2902      	cmp	r1, #2
    case IMX335_MIRROR_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
      break;
    case IMX335_MIRROR_FLIP_NONE:
    default:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
3400cec2:	f04f 020a 	mov.w	r2, #10
  switch (Config)
3400cec6:	d006      	beq.n	3400ced6 <IMX335_MirrorFlipConfig+0x16>
3400cec8:	2903      	cmp	r1, #3
3400ceca:	d006      	beq.n	3400ceda <IMX335_MirrorFlipConfig+0x1a>
3400cecc:	2901      	cmp	r1, #1
3400cece:	d106      	bne.n	3400cede <IMX335_MirrorFlipConfig+0x1e>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[1], ARRAY_SIZE(mirrorflip_mode_regs[1]));
3400ced0:	4904      	ldr	r1, [pc, #16]	@ (3400cee4 <IMX335_MirrorFlipConfig+0x24>)
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
3400ced2:	f7ff be83 	b.w	3400cbdc <IMX335_WriteTable>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[2], ARRAY_SIZE(mirrorflip_mode_regs[2]));
3400ced6:	4904      	ldr	r1, [pc, #16]	@ (3400cee8 <IMX335_MirrorFlipConfig+0x28>)
3400ced8:	e7fb      	b.n	3400ced2 <IMX335_MirrorFlipConfig+0x12>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
3400ceda:	4904      	ldr	r1, [pc, #16]	@ (3400ceec <IMX335_MirrorFlipConfig+0x2c>)
3400cedc:	e7f9      	b.n	3400ced2 <IMX335_MirrorFlipConfig+0x12>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
3400cede:	4904      	ldr	r1, [pc, #16]	@ (3400cef0 <IMX335_MirrorFlipConfig+0x30>)
3400cee0:	e7f7      	b.n	3400ced2 <IMX335_MirrorFlipConfig+0x12>
3400cee2:	bf00      	nop
3400cee4:	3401148a 	.word	0x3401148a
3400cee8:	340114b2 	.word	0x340114b2
3400ceec:	340114da 	.word	0x340114da
3400cef0:	34011462 	.word	0x34011462

3400cef4 <IMX335_SetTestPattern>:
  *               10: Horizontal color bars
  *               11: Vertical color bars
  * @retval Component status
  */
int32_t IMX335_SetTestPattern(IMX335_Object_t *pObj, int32_t mode)
{
3400cef4:	b513      	push	{r0, r1, r4, lr}
  int32_t ret = IMX335_OK;
  uint8_t val;

  if (mode >= 0)
3400cef6:	2900      	cmp	r1, #0
{
3400cef8:	4604      	mov	r4, r0
  if (mode >= 0)
3400cefa:	db15      	blt.n	3400cf28 <IMX335_SetTestPattern+0x34>
  {
    /* Enable Test Pattern #mode */
    val = mode;
3400cefc:	f88d 1007 	strb.w	r1, [sp, #7]
    if (imx335_write_reg(&pObj->Ctx, IMX335_REG_TPG, &val, 1) != IMX335_OK)
3400cf00:	2301      	movs	r3, #1
3400cf02:	f243 219e 	movw	r1, #12958	@ 0x329e
3400cf06:	f10d 0207 	add.w	r2, sp, #7
3400cf0a:	3018      	adds	r0, #24
3400cf0c:	f000 f81d 	bl	3400cf4a <imx335_write_reg>
3400cf10:	b968      	cbnz	r0, 3400cf2e <IMX335_SetTestPattern+0x3a>
    {
      return IMX335_ERROR;
    }
    if (IMX335_WriteTable(pObj, test_pattern_enable_regs, ARRAY_SIZE(test_pattern_enable_regs)) != IMX335_OK)
3400cf12:	2207      	movs	r2, #7
3400cf14:	4620      	mov	r0, r4
3400cf16:	4907      	ldr	r1, [pc, #28]	@ (3400cf34 <IMX335_SetTestPattern+0x40>)
    }
  }
  else
  {
    /* Disable Test Pattern */
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
3400cf18:	f7ff fe60 	bl	3400cbdc <IMX335_WriteTable>
3400cf1c:	3800      	subs	r0, #0
3400cf1e:	bf18      	it	ne
3400cf20:	2001      	movne	r0, #1
3400cf22:	4240      	negs	r0, r0
      return IMX335_ERROR;
    }
  }

  return ret;
}
3400cf24:	b002      	add	sp, #8
3400cf26:	bd10      	pop	{r4, pc}
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
3400cf28:	2207      	movs	r2, #7
3400cf2a:	4903      	ldr	r1, [pc, #12]	@ (3400cf38 <IMX335_SetTestPattern+0x44>)
3400cf2c:	e7f4      	b.n	3400cf18 <IMX335_SetTestPattern+0x24>
      return IMX335_ERROR;
3400cf2e:	f04f 30ff 	mov.w	r0, #4294967295
3400cf32:	e7f7      	b.n	3400cf24 <IMX335_SetTestPattern+0x30>
3400cf34:	34011446 	.word	0x34011446
3400cf38:	3401142a 	.word	0x3401142a

3400cf3c <imx335_read_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to read
  * @retval Component status
  */
int32_t imx335_read_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *pdata, uint16_t length)
{
3400cf3c:	b410      	push	{r4}
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
3400cf3e:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
3400cf42:	46a4      	mov	ip, r4
}
3400cf44:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
3400cf48:	4760      	bx	ip

3400cf4a <imx335_write_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to write
  * @retval Component status
  */
int32_t imx335_write_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *data, uint16_t length)
{
3400cf4a:	b410      	push	{r4}
  return ctx->WriteReg(ctx->handle, reg, data, length);
3400cf4c:	6804      	ldr	r4, [r0, #0]
3400cf4e:	6880      	ldr	r0, [r0, #8]
3400cf50:	46a4      	mov	ip, r4
}
3400cf52:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->WriteReg(ctx->handle, reg, data, length);
3400cf56:	4760      	bx	ip

3400cf58 <LL_MEM_EnableClock>:
  WRITE_REG(RCC->MEMENSR, Memories);
3400cf58:	4b04      	ldr	r3, [pc, #16]	@ (3400cf6c <LL_MEM_EnableClock+0x14>)
{
3400cf5a:	b082      	sub	sp, #8
  WRITE_REG(RCC->MEMENSR, Memories);
3400cf5c:	f8c3 0a4c 	str.w	r0, [r3, #2636]	@ 0xa4c
  tmpreg = READ_REG(RCC->MEMENR);
3400cf60:	f8d3 324c 	ldr.w	r3, [r3, #588]	@ 0x24c
3400cf64:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400cf66:	9b01      	ldr	r3, [sp, #4]
}
3400cf68:	b002      	add	sp, #8
3400cf6a:	4770      	bx	lr
3400cf6c:	56028000 	.word	0x56028000

3400cf70 <LL_MEM_EnableClockLowPower>:
  WRITE_REG(RCC->MEMLPENSR, Memories);
3400cf70:	4b04      	ldr	r3, [pc, #16]	@ (3400cf84 <LL_MEM_EnableClockLowPower+0x14>)
{
3400cf72:	b082      	sub	sp, #8
  WRITE_REG(RCC->MEMLPENSR, Memories);
3400cf74:	f8c3 0a8c 	str.w	r0, [r3, #2700]	@ 0xa8c
  tmpreg = READ_REG(RCC->MEMLPENR);
3400cf78:	f8d3 328c 	ldr.w	r3, [r3, #652]	@ 0x28c
3400cf7c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400cf7e:	9b01      	ldr	r3, [sp, #4]
}
3400cf80:	b002      	add	sp, #8
3400cf82:	4770      	bx	lr
3400cf84:	56028000 	.word	0x56028000

3400cf88 <LL_AHB5_GRP1_EnableClockLowPower>:
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
3400cf88:	4b04      	ldr	r3, [pc, #16]	@ (3400cf9c <LL_AHB5_GRP1_EnableClockLowPower+0x14>)
{
3400cf8a:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
3400cf8c:	f8c3 0aa0 	str.w	r0, [r3, #2720]	@ 0xaa0
  tmpreg = READ_REG(RCC->AHB5LPENR);
3400cf90:	f8d3 32a0 	ldr.w	r3, [r3, #672]	@ 0x2a0
3400cf94:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400cf96:	9b01      	ldr	r3, [sp, #4]
}
3400cf98:	b002      	add	sp, #8
3400cf9a:	4770      	bx	lr
3400cf9c:	56028000 	.word	0x56028000

3400cfa0 <set_clk_sleep_mode>:
LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(Default)
uint8_t *buffer_in;
uint8_t *buffer_out;

void set_clk_sleep_mode(void)
{
3400cfa0:	b510      	push	{r4, lr}
  * @retval None
  */
__STATIC_INLINE void LL_MISC_EnableClockLowPower(uint32_t Misc)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MISCLPENSR, Misc);
3400cfa2:	2401      	movs	r4, #1
3400cfa4:	2108      	movs	r1, #8
3400cfa6:	4a2b      	ldr	r2, [pc, #172]	@ (3400d054 <set_clk_sleep_mode+0xb4>)
3400cfa8:	b086      	sub	sp, #24
3400cfaa:	f8c2 4a88 	str.w	r4, [r2, #2696]	@ 0xa88
  /* Delay after an RCC miscellaneous clock enabling */
  tmpreg = READ_REG(RCC->MISCLPENR);
3400cfae:	f8d2 3288 	ldr.w	r3, [r2, #648]	@ 0x288
  __HAL_RCC_DBG_CLK_SLEEP_ENABLE();
#endif
  __HAL_RCC_XSPIPHYCOMP_CLK_SLEEP_ENABLE();

  // Low-power clock enable for memories
  __HAL_RCC_AXISRAM1_MEM_CLK_SLEEP_ENABLE();
3400cfb2:	2080      	movs	r0, #128	@ 0x80
3400cfb4:	9305      	str	r3, [sp, #20]
  (void)tmpreg;
3400cfb6:	9b05      	ldr	r3, [sp, #20]
  WRITE_REG(RCC->MISCLPENSR, Misc);
3400cfb8:	f8c2 1a88 	str.w	r1, [r2, #2696]	@ 0xa88
  tmpreg = READ_REG(RCC->MISCLPENR);
3400cfbc:	f8d2 3288 	ldr.w	r3, [r2, #648]	@ 0x288
3400cfc0:	9304      	str	r3, [sp, #16]
  (void)tmpreg;
3400cfc2:	9b04      	ldr	r3, [sp, #16]
3400cfc4:	f7ff ffd4 	bl	3400cf70 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM2_MEM_CLK_SLEEP_ENABLE();
3400cfc8:	f44f 7080 	mov.w	r0, #256	@ 0x100
3400cfcc:	f7ff ffd0 	bl	3400cf70 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM3_MEM_CLK_SLEEP_ENABLE();
3400cfd0:	4620      	mov	r0, r4
3400cfd2:	f7ff ffcd 	bl	3400cf70 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM4_MEM_CLK_SLEEP_ENABLE();
3400cfd6:	2002      	movs	r0, #2
3400cfd8:	f7ff ffca 	bl	3400cf70 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM5_MEM_CLK_SLEEP_ENABLE();
3400cfdc:	2004      	movs	r0, #4
3400cfde:	f7ff ffc7 	bl	3400cf70 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM6_MEM_CLK_SLEEP_ENABLE();
3400cfe2:	4608      	mov	r0, r1
3400cfe4:	f7ff ffc4 	bl	3400cf70 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_FLEXRAM_MEM_CLK_SLEEP_ENABLE();
3400cfe8:	f44f 7000 	mov.w	r0, #512	@ 0x200
3400cfec:	f7ff ffc0 	bl	3400cf70 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_CACHEAXIRAM_MEM_CLK_SLEEP_ENABLE();
3400cff0:	f44f 6080 	mov.w	r0, #1024	@ 0x400
3400cff4:	f7ff ffbc 	bl	3400cf70 <LL_MEM_EnableClockLowPower>
  WRITE_REG(RCC->AHB3LPENSR, Periphs);
3400cff8:	f44f 7300 	mov.w	r3, #512	@ 0x200
3400cffc:	f8c2 3a98 	str.w	r3, [r2, #2712]	@ 0xa98
  tmpreg = READ_REG(RCC->AHB3LPENR);
3400d000:	f8d2 3298 	ldr.w	r3, [r2, #664]	@ 0x298
3400d004:	9303      	str	r3, [sp, #12]
  (void)tmpreg;
3400d006:	9b03      	ldr	r3, [sp, #12]
  WRITE_REG(RCC->AHB3LPENSR, Periphs);
3400d008:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400d00c:	f8c2 3a98 	str.w	r3, [r2, #2712]	@ 0xa98
  tmpreg = READ_REG(RCC->AHB3LPENR);
3400d010:	f8d2 3298 	ldr.w	r3, [r2, #664]	@ 0x298
3400d014:	9302      	str	r3, [sp, #8]
  (void)tmpreg;
3400d016:	9b02      	ldr	r3, [sp, #8]
  WRITE_REG(RCC->AHB3LPENSR, Periphs);
3400d018:	f8c2 0a98 	str.w	r0, [r2, #2712]	@ 0xa98
  tmpreg = READ_REG(RCC->AHB3LPENR);
3400d01c:	f8d2 3298 	ldr.w	r3, [r2, #664]	@ 0x298
  __HAL_RCC_RISAF_CLK_SLEEP_ENABLE();
  __HAL_RCC_IAC_CLK_SLEEP_ENABLE();
#endif
  // LP clock AHB4: None
  // LP clocks AHB5
  __HAL_RCC_XSPI1_CLK_SLEEP_ENABLE();
3400d020:	2020      	movs	r0, #32
3400d022:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400d024:	9b01      	ldr	r3, [sp, #4]
3400d026:	f7ff ffaf 	bl	3400cf88 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_XSPI2_CLK_SLEEP_ENABLE();
3400d02a:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
3400d02e:	f7ff ffab 	bl	3400cf88 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_CACHEAXI_CLK_SLEEP_ENABLE();
3400d032:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
3400d036:	f7ff ffa7 	bl	3400cf88 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_NPU_CLK_SLEEP_ENABLE();
3400d03a:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
3400d03e:	f7ff ffa3 	bl	3400cf88 <LL_AHB5_GRP1_EnableClockLowPower>
  WRITE_REG(RCC->APB2LPENSR, Periphs);
3400d042:	2310      	movs	r3, #16
3400d044:	f8c2 3aac 	str.w	r3, [r2, #2732]	@ 0xaac
  tmpreg = READ_REG(RCC->APB2LPENR);
3400d048:	f8d2 32ac 	ldr.w	r3, [r2, #684]	@ 0x2ac
3400d04c:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
3400d04e:	9b00      	ldr	r3, [sp, #0]
  // LP clocks APB1: None
  // LP clocks APB2
  __HAL_RCC_USART1_CLK_SLEEP_ENABLE();
  // LP clocks APB4: None
  // LP clocks APB5: None
}
3400d050:	b006      	add	sp, #24
3400d052:	bd10      	pop	{r4, pc}
3400d054:	56028000 	.word	0x56028000

3400d058 <MX_X_CUBE_AI_Init>:

void MX_X_CUBE_AI_Init(void)
{
3400d058:	b507      	push	{r0, r1, r2, lr}
    __HAL_RCC_AXISRAM2_MEM_CLK_ENABLE();
3400d05a:	f44f 7080 	mov.w	r0, #256	@ 0x100
3400d05e:	f7ff ff7b 	bl	3400cf58 <LL_MEM_EnableClock>
    __HAL_RCC_AXISRAM3_MEM_CLK_ENABLE();
3400d062:	2001      	movs	r0, #1
3400d064:	f7ff ff78 	bl	3400cf58 <LL_MEM_EnableClock>
    __HAL_RCC_AXISRAM4_MEM_CLK_ENABLE();
3400d068:	2002      	movs	r0, #2
3400d06a:	f7ff ff75 	bl	3400cf58 <LL_MEM_EnableClock>
    __HAL_RCC_AXISRAM5_MEM_CLK_ENABLE();
    __HAL_RCC_AXISRAM6_MEM_CLK_ENABLE();
    RAMCFG_SRAM2_AXI->CR &= ~RAMCFG_CR_SRAMSD;
3400d06e:	4a1d      	ldr	r2, [pc, #116]	@ (3400d0e4 <MX_X_CUBE_AI_Init+0x8c>)
    __HAL_RCC_AXISRAM5_MEM_CLK_ENABLE();
3400d070:	2004      	movs	r0, #4
3400d072:	f7ff ff71 	bl	3400cf58 <LL_MEM_EnableClock>
    __HAL_RCC_AXISRAM6_MEM_CLK_ENABLE();
3400d076:	2008      	movs	r0, #8
3400d078:	f7ff ff6e 	bl	3400cf58 <LL_MEM_EnableClock>
    RAMCFG_SRAM2_AXI->CR &= ~RAMCFG_CR_SRAMSD;
3400d07c:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
3400d080:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3400d084:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
    RAMCFG_SRAM3_AXI->CR &= ~RAMCFG_CR_SRAMSD;
3400d088:	4b17      	ldr	r3, [pc, #92]	@ (3400d0e8 <MX_X_CUBE_AI_Init+0x90>)
3400d08a:	681a      	ldr	r2, [r3, #0]
3400d08c:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
3400d090:	601a      	str	r2, [r3, #0]
    RAMCFG_SRAM4_AXI->CR &= ~RAMCFG_CR_SRAMSD;
3400d092:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3400d096:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
3400d09a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
    RAMCFG_SRAM5_AXI->CR &= ~RAMCFG_CR_SRAMSD;
3400d09e:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400d0a2:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
3400d0a6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
    RAMCFG_SRAM6_AXI->CR &= ~RAMCFG_CR_SRAMSD;
3400d0aa:	f8d3 2180 	ldr.w	r2, [r3, #384]	@ 0x180
3400d0ae:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
3400d0b2:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180
    set_clk_sleep_mode();
3400d0b6:	f7ff ff73 	bl	3400cfa0 <set_clk_sleep_mode>
  WRITE_REG(RCC->AHB5ENSR, Periphs);
3400d0ba:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
3400d0be:	4b0b      	ldr	r3, [pc, #44]	@ (3400d0ec <MX_X_CUBE_AI_Init+0x94>)
3400d0c0:	f8c3 2a60 	str.w	r2, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
3400d0c4:	f8d3 1260 	ldr.w	r1, [r3, #608]	@ 0x260
3400d0c8:	9101      	str	r1, [sp, #4]
  (void)tmpreg;
3400d0ca:	9901      	ldr	r1, [sp, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
3400d0cc:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
3400d0d0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400d0d4:	f8c3 2220 	str.w	r2, [r3, #544]	@ 0x220
    __HAL_RCC_NPU_FORCE_RESET();
    __HAL_RCC_NPU_RELEASE_RESET();
    npu_cache_init();
    /* USER CODE BEGIN 5 */
    /* USER CODE END 5 */
}
3400d0d8:	b003      	add	sp, #12
3400d0da:	f85d eb04 	ldr.w	lr, [sp], #4
    npu_cache_init();
3400d0de:	f7fd b933 	b.w	3400a348 <npu_cache_init>
3400d0e2:	bf00      	nop
3400d0e4:	52023000 	.word	0x52023000
3400d0e8:	52023100 	.word	0x52023100
3400d0ec:	56028000 	.word	0x56028000

3400d0f0 <__assert_func>:
3400d0f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
3400d0f2:	4614      	mov	r4, r2
3400d0f4:	461a      	mov	r2, r3
3400d0f6:	4b09      	ldr	r3, [pc, #36]	@ (3400d11c <__assert_func+0x2c>)
3400d0f8:	4605      	mov	r5, r0
3400d0fa:	681b      	ldr	r3, [r3, #0]
3400d0fc:	68d8      	ldr	r0, [r3, #12]
3400d0fe:	b14c      	cbz	r4, 3400d114 <__assert_func+0x24>
3400d100:	4b07      	ldr	r3, [pc, #28]	@ (3400d120 <__assert_func+0x30>)
3400d102:	9100      	str	r1, [sp, #0]
3400d104:	4907      	ldr	r1, [pc, #28]	@ (3400d124 <__assert_func+0x34>)
3400d106:	e9cd 3401 	strd	r3, r4, [sp, #4]
3400d10a:	462b      	mov	r3, r5
3400d10c:	f000 fa3a 	bl	3400d584 <fiprintf>
3400d110:	f000 fca0 	bl	3400da54 <abort>
3400d114:	4b04      	ldr	r3, [pc, #16]	@ (3400d128 <__assert_func+0x38>)
3400d116:	461c      	mov	r4, r3
3400d118:	e7f3      	b.n	3400d102 <__assert_func+0x12>
3400d11a:	bf00      	nop
3400d11c:	34013bf8 	.word	0x34013bf8
3400d120:	34011064 	.word	0x34011064
3400d124:	34011071 	.word	0x34011071
3400d128:	34010c2e 	.word	0x34010c2e

3400d12c <sbrk_aligned>:
3400d12c:	b570      	push	{r4, r5, r6, lr}
3400d12e:	4e0f      	ldr	r6, [pc, #60]	@ (3400d16c <sbrk_aligned+0x40>)
3400d130:	460c      	mov	r4, r1
3400d132:	4605      	mov	r5, r0
3400d134:	6831      	ldr	r1, [r6, #0]
3400d136:	b911      	cbnz	r1, 3400d13e <sbrk_aligned+0x12>
3400d138:	f000 fc28 	bl	3400d98c <_sbrk_r>
3400d13c:	6030      	str	r0, [r6, #0]
3400d13e:	4621      	mov	r1, r4
3400d140:	4628      	mov	r0, r5
3400d142:	f000 fc23 	bl	3400d98c <_sbrk_r>
3400d146:	1c43      	adds	r3, r0, #1
3400d148:	d103      	bne.n	3400d152 <sbrk_aligned+0x26>
3400d14a:	f04f 34ff 	mov.w	r4, #4294967295
3400d14e:	4620      	mov	r0, r4
3400d150:	bd70      	pop	{r4, r5, r6, pc}
3400d152:	1cc4      	adds	r4, r0, #3
3400d154:	f024 0403 	bic.w	r4, r4, #3
3400d158:	42a0      	cmp	r0, r4
3400d15a:	d0f8      	beq.n	3400d14e <sbrk_aligned+0x22>
3400d15c:	1a21      	subs	r1, r4, r0
3400d15e:	4628      	mov	r0, r5
3400d160:	f000 fc14 	bl	3400d98c <_sbrk_r>
3400d164:	3001      	adds	r0, #1
3400d166:	d1f2      	bne.n	3400d14e <sbrk_aligned+0x22>
3400d168:	e7ef      	b.n	3400d14a <sbrk_aligned+0x1e>
3400d16a:	bf00      	nop
3400d16c:	340d047c 	.word	0x340d047c

3400d170 <_malloc_r>:
3400d170:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3400d174:	1ccd      	adds	r5, r1, #3
3400d176:	4606      	mov	r6, r0
3400d178:	f025 0503 	bic.w	r5, r5, #3
3400d17c:	3508      	adds	r5, #8
3400d17e:	2d0c      	cmp	r5, #12
3400d180:	bf38      	it	cc
3400d182:	250c      	movcc	r5, #12
3400d184:	2d00      	cmp	r5, #0
3400d186:	db01      	blt.n	3400d18c <_malloc_r+0x1c>
3400d188:	42a9      	cmp	r1, r5
3400d18a:	d904      	bls.n	3400d196 <_malloc_r+0x26>
3400d18c:	230c      	movs	r3, #12
3400d18e:	6033      	str	r3, [r6, #0]
3400d190:	2000      	movs	r0, #0
3400d192:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3400d196:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 3400d26c <_malloc_r+0xfc>
3400d19a:	f000 f869 	bl	3400d270 <__malloc_lock>
3400d19e:	f8d8 3000 	ldr.w	r3, [r8]
3400d1a2:	461c      	mov	r4, r3
3400d1a4:	bb44      	cbnz	r4, 3400d1f8 <_malloc_r+0x88>
3400d1a6:	4629      	mov	r1, r5
3400d1a8:	4630      	mov	r0, r6
3400d1aa:	f7ff ffbf 	bl	3400d12c <sbrk_aligned>
3400d1ae:	1c43      	adds	r3, r0, #1
3400d1b0:	4604      	mov	r4, r0
3400d1b2:	d158      	bne.n	3400d266 <_malloc_r+0xf6>
3400d1b4:	f8d8 4000 	ldr.w	r4, [r8]
3400d1b8:	4627      	mov	r7, r4
3400d1ba:	2f00      	cmp	r7, #0
3400d1bc:	d143      	bne.n	3400d246 <_malloc_r+0xd6>
3400d1be:	2c00      	cmp	r4, #0
3400d1c0:	d04b      	beq.n	3400d25a <_malloc_r+0xea>
3400d1c2:	6823      	ldr	r3, [r4, #0]
3400d1c4:	4639      	mov	r1, r7
3400d1c6:	4630      	mov	r0, r6
3400d1c8:	eb04 0903 	add.w	r9, r4, r3
3400d1cc:	f000 fbde 	bl	3400d98c <_sbrk_r>
3400d1d0:	4581      	cmp	r9, r0
3400d1d2:	d142      	bne.n	3400d25a <_malloc_r+0xea>
3400d1d4:	6821      	ldr	r1, [r4, #0]
3400d1d6:	4630      	mov	r0, r6
3400d1d8:	1a6d      	subs	r5, r5, r1
3400d1da:	4629      	mov	r1, r5
3400d1dc:	f7ff ffa6 	bl	3400d12c <sbrk_aligned>
3400d1e0:	3001      	adds	r0, #1
3400d1e2:	d03a      	beq.n	3400d25a <_malloc_r+0xea>
3400d1e4:	6823      	ldr	r3, [r4, #0]
3400d1e6:	442b      	add	r3, r5
3400d1e8:	6023      	str	r3, [r4, #0]
3400d1ea:	f8d8 3000 	ldr.w	r3, [r8]
3400d1ee:	685a      	ldr	r2, [r3, #4]
3400d1f0:	bb62      	cbnz	r2, 3400d24c <_malloc_r+0xdc>
3400d1f2:	f8c8 7000 	str.w	r7, [r8]
3400d1f6:	e00f      	b.n	3400d218 <_malloc_r+0xa8>
3400d1f8:	6822      	ldr	r2, [r4, #0]
3400d1fa:	1b52      	subs	r2, r2, r5
3400d1fc:	d420      	bmi.n	3400d240 <_malloc_r+0xd0>
3400d1fe:	2a0b      	cmp	r2, #11
3400d200:	d917      	bls.n	3400d232 <_malloc_r+0xc2>
3400d202:	1961      	adds	r1, r4, r5
3400d204:	42a3      	cmp	r3, r4
3400d206:	6025      	str	r5, [r4, #0]
3400d208:	bf18      	it	ne
3400d20a:	6059      	strne	r1, [r3, #4]
3400d20c:	6863      	ldr	r3, [r4, #4]
3400d20e:	bf08      	it	eq
3400d210:	f8c8 1000 	streq.w	r1, [r8]
3400d214:	5162      	str	r2, [r4, r5]
3400d216:	604b      	str	r3, [r1, #4]
3400d218:	4630      	mov	r0, r6
3400d21a:	f000 f82f 	bl	3400d27c <__malloc_unlock>
3400d21e:	f104 000b 	add.w	r0, r4, #11
3400d222:	1d23      	adds	r3, r4, #4
3400d224:	f020 0007 	bic.w	r0, r0, #7
3400d228:	1ac2      	subs	r2, r0, r3
3400d22a:	bf1c      	itt	ne
3400d22c:	1a1b      	subne	r3, r3, r0
3400d22e:	50a3      	strne	r3, [r4, r2]
3400d230:	e7af      	b.n	3400d192 <_malloc_r+0x22>
3400d232:	6862      	ldr	r2, [r4, #4]
3400d234:	42a3      	cmp	r3, r4
3400d236:	bf0c      	ite	eq
3400d238:	f8c8 2000 	streq.w	r2, [r8]
3400d23c:	605a      	strne	r2, [r3, #4]
3400d23e:	e7eb      	b.n	3400d218 <_malloc_r+0xa8>
3400d240:	4623      	mov	r3, r4
3400d242:	6864      	ldr	r4, [r4, #4]
3400d244:	e7ae      	b.n	3400d1a4 <_malloc_r+0x34>
3400d246:	463c      	mov	r4, r7
3400d248:	687f      	ldr	r7, [r7, #4]
3400d24a:	e7b6      	b.n	3400d1ba <_malloc_r+0x4a>
3400d24c:	461a      	mov	r2, r3
3400d24e:	685b      	ldr	r3, [r3, #4]
3400d250:	42a3      	cmp	r3, r4
3400d252:	d1fb      	bne.n	3400d24c <_malloc_r+0xdc>
3400d254:	2300      	movs	r3, #0
3400d256:	6053      	str	r3, [r2, #4]
3400d258:	e7de      	b.n	3400d218 <_malloc_r+0xa8>
3400d25a:	230c      	movs	r3, #12
3400d25c:	4630      	mov	r0, r6
3400d25e:	6033      	str	r3, [r6, #0]
3400d260:	f000 f80c 	bl	3400d27c <__malloc_unlock>
3400d264:	e794      	b.n	3400d190 <_malloc_r+0x20>
3400d266:	6005      	str	r5, [r0, #0]
3400d268:	e7d6      	b.n	3400d218 <_malloc_r+0xa8>
3400d26a:	bf00      	nop
3400d26c:	340d0480 	.word	0x340d0480

3400d270 <__malloc_lock>:
3400d270:	4801      	ldr	r0, [pc, #4]	@ (3400d278 <__malloc_lock+0x8>)
3400d272:	f000 bbd8 	b.w	3400da26 <__retarget_lock_acquire_recursive>
3400d276:	bf00      	nop
3400d278:	340d05c4 	.word	0x340d05c4

3400d27c <__malloc_unlock>:
3400d27c:	4801      	ldr	r0, [pc, #4]	@ (3400d284 <__malloc_unlock+0x8>)
3400d27e:	f000 bbd3 	b.w	3400da28 <__retarget_lock_release_recursive>
3400d282:	bf00      	nop
3400d284:	340d05c4 	.word	0x340d05c4

3400d288 <_realloc_r>:
3400d288:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400d28c:	4607      	mov	r7, r0
3400d28e:	4614      	mov	r4, r2
3400d290:	460d      	mov	r5, r1
3400d292:	b921      	cbnz	r1, 3400d29e <_realloc_r+0x16>
3400d294:	4611      	mov	r1, r2
3400d296:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
3400d29a:	f7ff bf69 	b.w	3400d170 <_malloc_r>
3400d29e:	b92a      	cbnz	r2, 3400d2ac <_realloc_r+0x24>
3400d2a0:	4625      	mov	r5, r4
3400d2a2:	f000 fbdf 	bl	3400da64 <_free_r>
3400d2a6:	4628      	mov	r0, r5
3400d2a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3400d2ac:	f000 fc24 	bl	3400daf8 <_malloc_usable_size_r>
3400d2b0:	4284      	cmp	r4, r0
3400d2b2:	4606      	mov	r6, r0
3400d2b4:	d802      	bhi.n	3400d2bc <_realloc_r+0x34>
3400d2b6:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
3400d2ba:	d8f4      	bhi.n	3400d2a6 <_realloc_r+0x1e>
3400d2bc:	4621      	mov	r1, r4
3400d2be:	4638      	mov	r0, r7
3400d2c0:	f7ff ff56 	bl	3400d170 <_malloc_r>
3400d2c4:	4680      	mov	r8, r0
3400d2c6:	b908      	cbnz	r0, 3400d2cc <_realloc_r+0x44>
3400d2c8:	4645      	mov	r5, r8
3400d2ca:	e7ec      	b.n	3400d2a6 <_realloc_r+0x1e>
3400d2cc:	42b4      	cmp	r4, r6
3400d2ce:	4622      	mov	r2, r4
3400d2d0:	4629      	mov	r1, r5
3400d2d2:	bf28      	it	cs
3400d2d4:	4632      	movcs	r2, r6
3400d2d6:	f000 fbb0 	bl	3400da3a <memcpy>
3400d2da:	4629      	mov	r1, r5
3400d2dc:	4638      	mov	r0, r7
3400d2de:	f000 fbc1 	bl	3400da64 <_free_r>
3400d2e2:	e7f1      	b.n	3400d2c8 <_realloc_r+0x40>

3400d2e4 <__sflush_r>:
3400d2e4:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
3400d2e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400d2ec:	0716      	lsls	r6, r2, #28
3400d2ee:	4605      	mov	r5, r0
3400d2f0:	460c      	mov	r4, r1
3400d2f2:	d454      	bmi.n	3400d39e <__sflush_r+0xba>
3400d2f4:	684b      	ldr	r3, [r1, #4]
3400d2f6:	2b00      	cmp	r3, #0
3400d2f8:	dc02      	bgt.n	3400d300 <__sflush_r+0x1c>
3400d2fa:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
3400d2fc:	2b00      	cmp	r3, #0
3400d2fe:	dd48      	ble.n	3400d392 <__sflush_r+0xae>
3400d300:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3400d302:	2e00      	cmp	r6, #0
3400d304:	d045      	beq.n	3400d392 <__sflush_r+0xae>
3400d306:	2300      	movs	r3, #0
3400d308:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
3400d30c:	682f      	ldr	r7, [r5, #0]
3400d30e:	6a21      	ldr	r1, [r4, #32]
3400d310:	602b      	str	r3, [r5, #0]
3400d312:	d030      	beq.n	3400d376 <__sflush_r+0x92>
3400d314:	6d62      	ldr	r2, [r4, #84]	@ 0x54
3400d316:	89a3      	ldrh	r3, [r4, #12]
3400d318:	0759      	lsls	r1, r3, #29
3400d31a:	d505      	bpl.n	3400d328 <__sflush_r+0x44>
3400d31c:	6863      	ldr	r3, [r4, #4]
3400d31e:	1ad2      	subs	r2, r2, r3
3400d320:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400d322:	b10b      	cbz	r3, 3400d328 <__sflush_r+0x44>
3400d324:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400d326:	1ad2      	subs	r2, r2, r3
3400d328:	2300      	movs	r3, #0
3400d32a:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3400d32c:	6a21      	ldr	r1, [r4, #32]
3400d32e:	4628      	mov	r0, r5
3400d330:	47b0      	blx	r6
3400d332:	1c43      	adds	r3, r0, #1
3400d334:	89a3      	ldrh	r3, [r4, #12]
3400d336:	d106      	bne.n	3400d346 <__sflush_r+0x62>
3400d338:	6829      	ldr	r1, [r5, #0]
3400d33a:	291d      	cmp	r1, #29
3400d33c:	d82b      	bhi.n	3400d396 <__sflush_r+0xb2>
3400d33e:	4a2a      	ldr	r2, [pc, #168]	@ (3400d3e8 <__sflush_r+0x104>)
3400d340:	40ca      	lsrs	r2, r1
3400d342:	07d6      	lsls	r6, r2, #31
3400d344:	d527      	bpl.n	3400d396 <__sflush_r+0xb2>
3400d346:	2200      	movs	r2, #0
3400d348:	04d9      	lsls	r1, r3, #19
3400d34a:	6062      	str	r2, [r4, #4]
3400d34c:	6922      	ldr	r2, [r4, #16]
3400d34e:	6022      	str	r2, [r4, #0]
3400d350:	d504      	bpl.n	3400d35c <__sflush_r+0x78>
3400d352:	1c42      	adds	r2, r0, #1
3400d354:	d101      	bne.n	3400d35a <__sflush_r+0x76>
3400d356:	682b      	ldr	r3, [r5, #0]
3400d358:	b903      	cbnz	r3, 3400d35c <__sflush_r+0x78>
3400d35a:	6560      	str	r0, [r4, #84]	@ 0x54
3400d35c:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3400d35e:	602f      	str	r7, [r5, #0]
3400d360:	b1b9      	cbz	r1, 3400d392 <__sflush_r+0xae>
3400d362:	f104 0344 	add.w	r3, r4, #68	@ 0x44
3400d366:	4299      	cmp	r1, r3
3400d368:	d002      	beq.n	3400d370 <__sflush_r+0x8c>
3400d36a:	4628      	mov	r0, r5
3400d36c:	f000 fb7a 	bl	3400da64 <_free_r>
3400d370:	2300      	movs	r3, #0
3400d372:	6363      	str	r3, [r4, #52]	@ 0x34
3400d374:	e00d      	b.n	3400d392 <__sflush_r+0xae>
3400d376:	2301      	movs	r3, #1
3400d378:	4628      	mov	r0, r5
3400d37a:	47b0      	blx	r6
3400d37c:	4602      	mov	r2, r0
3400d37e:	1c50      	adds	r0, r2, #1
3400d380:	d1c9      	bne.n	3400d316 <__sflush_r+0x32>
3400d382:	682b      	ldr	r3, [r5, #0]
3400d384:	2b00      	cmp	r3, #0
3400d386:	d0c6      	beq.n	3400d316 <__sflush_r+0x32>
3400d388:	2b1d      	cmp	r3, #29
3400d38a:	d001      	beq.n	3400d390 <__sflush_r+0xac>
3400d38c:	2b16      	cmp	r3, #22
3400d38e:	d11d      	bne.n	3400d3cc <__sflush_r+0xe8>
3400d390:	602f      	str	r7, [r5, #0]
3400d392:	2000      	movs	r0, #0
3400d394:	e021      	b.n	3400d3da <__sflush_r+0xf6>
3400d396:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3400d39a:	b21b      	sxth	r3, r3
3400d39c:	e01a      	b.n	3400d3d4 <__sflush_r+0xf0>
3400d39e:	690f      	ldr	r7, [r1, #16]
3400d3a0:	2f00      	cmp	r7, #0
3400d3a2:	d0f6      	beq.n	3400d392 <__sflush_r+0xae>
3400d3a4:	0793      	lsls	r3, r2, #30
3400d3a6:	680e      	ldr	r6, [r1, #0]
3400d3a8:	600f      	str	r7, [r1, #0]
3400d3aa:	bf0c      	ite	eq
3400d3ac:	694b      	ldreq	r3, [r1, #20]
3400d3ae:	2300      	movne	r3, #0
3400d3b0:	eba6 0807 	sub.w	r8, r6, r7
3400d3b4:	608b      	str	r3, [r1, #8]
3400d3b6:	f1b8 0f00 	cmp.w	r8, #0
3400d3ba:	ddea      	ble.n	3400d392 <__sflush_r+0xae>
3400d3bc:	4643      	mov	r3, r8
3400d3be:	463a      	mov	r2, r7
3400d3c0:	6a21      	ldr	r1, [r4, #32]
3400d3c2:	4628      	mov	r0, r5
3400d3c4:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
3400d3c6:	47b0      	blx	r6
3400d3c8:	2800      	cmp	r0, #0
3400d3ca:	dc08      	bgt.n	3400d3de <__sflush_r+0xfa>
3400d3cc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3400d3d0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3400d3d4:	f04f 30ff 	mov.w	r0, #4294967295
3400d3d8:	81a3      	strh	r3, [r4, #12]
3400d3da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3400d3de:	4407      	add	r7, r0
3400d3e0:	eba8 0800 	sub.w	r8, r8, r0
3400d3e4:	e7e7      	b.n	3400d3b6 <__sflush_r+0xd2>
3400d3e6:	bf00      	nop
3400d3e8:	20400001 	.word	0x20400001

3400d3ec <_fflush_r>:
3400d3ec:	b538      	push	{r3, r4, r5, lr}
3400d3ee:	690b      	ldr	r3, [r1, #16]
3400d3f0:	4605      	mov	r5, r0
3400d3f2:	460c      	mov	r4, r1
3400d3f4:	b913      	cbnz	r3, 3400d3fc <_fflush_r+0x10>
3400d3f6:	2500      	movs	r5, #0
3400d3f8:	4628      	mov	r0, r5
3400d3fa:	bd38      	pop	{r3, r4, r5, pc}
3400d3fc:	b118      	cbz	r0, 3400d406 <_fflush_r+0x1a>
3400d3fe:	6a03      	ldr	r3, [r0, #32]
3400d400:	b90b      	cbnz	r3, 3400d406 <_fflush_r+0x1a>
3400d402:	f000 f8a7 	bl	3400d554 <__sinit>
3400d406:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3400d40a:	2b00      	cmp	r3, #0
3400d40c:	d0f3      	beq.n	3400d3f6 <_fflush_r+0xa>
3400d40e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
3400d410:	07d0      	lsls	r0, r2, #31
3400d412:	d404      	bmi.n	3400d41e <_fflush_r+0x32>
3400d414:	0599      	lsls	r1, r3, #22
3400d416:	d402      	bmi.n	3400d41e <_fflush_r+0x32>
3400d418:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3400d41a:	f000 fb04 	bl	3400da26 <__retarget_lock_acquire_recursive>
3400d41e:	4628      	mov	r0, r5
3400d420:	4621      	mov	r1, r4
3400d422:	f7ff ff5f 	bl	3400d2e4 <__sflush_r>
3400d426:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3400d428:	4605      	mov	r5, r0
3400d42a:	07da      	lsls	r2, r3, #31
3400d42c:	d4e4      	bmi.n	3400d3f8 <_fflush_r+0xc>
3400d42e:	89a3      	ldrh	r3, [r4, #12]
3400d430:	059b      	lsls	r3, r3, #22
3400d432:	d4e1      	bmi.n	3400d3f8 <_fflush_r+0xc>
3400d434:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3400d436:	f000 faf7 	bl	3400da28 <__retarget_lock_release_recursive>
3400d43a:	e7dd      	b.n	3400d3f8 <_fflush_r+0xc>

3400d43c <std>:
3400d43c:	2300      	movs	r3, #0
3400d43e:	b510      	push	{r4, lr}
3400d440:	4604      	mov	r4, r0
3400d442:	6083      	str	r3, [r0, #8]
3400d444:	8181      	strh	r1, [r0, #12]
3400d446:	4619      	mov	r1, r3
3400d448:	6643      	str	r3, [r0, #100]	@ 0x64
3400d44a:	81c2      	strh	r2, [r0, #14]
3400d44c:	2208      	movs	r2, #8
3400d44e:	6183      	str	r3, [r0, #24]
3400d450:	e9c0 3300 	strd	r3, r3, [r0]
3400d454:	e9c0 3304 	strd	r3, r3, [r0, #16]
3400d458:	305c      	adds	r0, #92	@ 0x5c
3400d45a:	f000 fa5b 	bl	3400d914 <memset>
3400d45e:	4b0d      	ldr	r3, [pc, #52]	@ (3400d494 <std+0x58>)
3400d460:	6224      	str	r4, [r4, #32]
3400d462:	6263      	str	r3, [r4, #36]	@ 0x24
3400d464:	4b0c      	ldr	r3, [pc, #48]	@ (3400d498 <std+0x5c>)
3400d466:	62a3      	str	r3, [r4, #40]	@ 0x28
3400d468:	4b0c      	ldr	r3, [pc, #48]	@ (3400d49c <std+0x60>)
3400d46a:	62e3      	str	r3, [r4, #44]	@ 0x2c
3400d46c:	4b0c      	ldr	r3, [pc, #48]	@ (3400d4a0 <std+0x64>)
3400d46e:	6323      	str	r3, [r4, #48]	@ 0x30
3400d470:	4b0c      	ldr	r3, [pc, #48]	@ (3400d4a4 <std+0x68>)
3400d472:	429c      	cmp	r4, r3
3400d474:	d006      	beq.n	3400d484 <std+0x48>
3400d476:	f103 0268 	add.w	r2, r3, #104	@ 0x68
3400d47a:	4294      	cmp	r4, r2
3400d47c:	d002      	beq.n	3400d484 <std+0x48>
3400d47e:	33d0      	adds	r3, #208	@ 0xd0
3400d480:	429c      	cmp	r4, r3
3400d482:	d105      	bne.n	3400d490 <std+0x54>
3400d484:	f104 0058 	add.w	r0, r4, #88	@ 0x58
3400d488:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3400d48c:	f000 baca 	b.w	3400da24 <__retarget_lock_init_recursive>
3400d490:	bd10      	pop	{r4, pc}
3400d492:	bf00      	nop
3400d494:	3400d731 	.word	0x3400d731
3400d498:	3400d753 	.word	0x3400d753
3400d49c:	3400d78b 	.word	0x3400d78b
3400d4a0:	3400d7af 	.word	0x3400d7af
3400d4a4:	340d0484 	.word	0x340d0484

3400d4a8 <stdio_exit_handler>:
3400d4a8:	4a02      	ldr	r2, [pc, #8]	@ (3400d4b4 <stdio_exit_handler+0xc>)
3400d4aa:	4903      	ldr	r1, [pc, #12]	@ (3400d4b8 <stdio_exit_handler+0x10>)
3400d4ac:	4803      	ldr	r0, [pc, #12]	@ (3400d4bc <stdio_exit_handler+0x14>)
3400d4ae:	f000 b87b 	b.w	3400d5a8 <_fwalk_sglue>
3400d4b2:	bf00      	nop
3400d4b4:	34013bec 	.word	0x34013bec
3400d4b8:	3400d3ed 	.word	0x3400d3ed
3400d4bc:	34013bfc 	.word	0x34013bfc

3400d4c0 <cleanup_stdio>:
3400d4c0:	6841      	ldr	r1, [r0, #4]
3400d4c2:	4b0c      	ldr	r3, [pc, #48]	@ (3400d4f4 <cleanup_stdio+0x34>)
3400d4c4:	4299      	cmp	r1, r3
3400d4c6:	b510      	push	{r4, lr}
3400d4c8:	4604      	mov	r4, r0
3400d4ca:	d001      	beq.n	3400d4d0 <cleanup_stdio+0x10>
3400d4cc:	f7ff ff8e 	bl	3400d3ec <_fflush_r>
3400d4d0:	68a1      	ldr	r1, [r4, #8]
3400d4d2:	4b09      	ldr	r3, [pc, #36]	@ (3400d4f8 <cleanup_stdio+0x38>)
3400d4d4:	4299      	cmp	r1, r3
3400d4d6:	d002      	beq.n	3400d4de <cleanup_stdio+0x1e>
3400d4d8:	4620      	mov	r0, r4
3400d4da:	f7ff ff87 	bl	3400d3ec <_fflush_r>
3400d4de:	68e1      	ldr	r1, [r4, #12]
3400d4e0:	4b06      	ldr	r3, [pc, #24]	@ (3400d4fc <cleanup_stdio+0x3c>)
3400d4e2:	4299      	cmp	r1, r3
3400d4e4:	d004      	beq.n	3400d4f0 <cleanup_stdio+0x30>
3400d4e6:	4620      	mov	r0, r4
3400d4e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3400d4ec:	f7ff bf7e 	b.w	3400d3ec <_fflush_r>
3400d4f0:	bd10      	pop	{r4, pc}
3400d4f2:	bf00      	nop
3400d4f4:	340d0484 	.word	0x340d0484
3400d4f8:	340d04ec 	.word	0x340d04ec
3400d4fc:	340d0554 	.word	0x340d0554

3400d500 <global_stdio_init.part.0>:
3400d500:	b510      	push	{r4, lr}
3400d502:	4b0b      	ldr	r3, [pc, #44]	@ (3400d530 <global_stdio_init.part.0+0x30>)
3400d504:	2104      	movs	r1, #4
3400d506:	4c0b      	ldr	r4, [pc, #44]	@ (3400d534 <global_stdio_init.part.0+0x34>)
3400d508:	4a0b      	ldr	r2, [pc, #44]	@ (3400d538 <global_stdio_init.part.0+0x38>)
3400d50a:	4620      	mov	r0, r4
3400d50c:	601a      	str	r2, [r3, #0]
3400d50e:	2200      	movs	r2, #0
3400d510:	f7ff ff94 	bl	3400d43c <std>
3400d514:	f104 0068 	add.w	r0, r4, #104	@ 0x68
3400d518:	2201      	movs	r2, #1
3400d51a:	2109      	movs	r1, #9
3400d51c:	f7ff ff8e 	bl	3400d43c <std>
3400d520:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
3400d524:	2202      	movs	r2, #2
3400d526:	2112      	movs	r1, #18
3400d528:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3400d52c:	f7ff bf86 	b.w	3400d43c <std>
3400d530:	340d05bc 	.word	0x340d05bc
3400d534:	340d0484 	.word	0x340d0484
3400d538:	3400d4a9 	.word	0x3400d4a9

3400d53c <__sfp_lock_acquire>:
3400d53c:	4801      	ldr	r0, [pc, #4]	@ (3400d544 <__sfp_lock_acquire+0x8>)
3400d53e:	f000 ba72 	b.w	3400da26 <__retarget_lock_acquire_recursive>
3400d542:	bf00      	nop
3400d544:	340d05c5 	.word	0x340d05c5

3400d548 <__sfp_lock_release>:
3400d548:	4801      	ldr	r0, [pc, #4]	@ (3400d550 <__sfp_lock_release+0x8>)
3400d54a:	f000 ba6d 	b.w	3400da28 <__retarget_lock_release_recursive>
3400d54e:	bf00      	nop
3400d550:	340d05c5 	.word	0x340d05c5

3400d554 <__sinit>:
3400d554:	b510      	push	{r4, lr}
3400d556:	4604      	mov	r4, r0
3400d558:	f7ff fff0 	bl	3400d53c <__sfp_lock_acquire>
3400d55c:	6a23      	ldr	r3, [r4, #32]
3400d55e:	b11b      	cbz	r3, 3400d568 <__sinit+0x14>
3400d560:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3400d564:	f7ff bff0 	b.w	3400d548 <__sfp_lock_release>
3400d568:	4b04      	ldr	r3, [pc, #16]	@ (3400d57c <__sinit+0x28>)
3400d56a:	6223      	str	r3, [r4, #32]
3400d56c:	4b04      	ldr	r3, [pc, #16]	@ (3400d580 <__sinit+0x2c>)
3400d56e:	681b      	ldr	r3, [r3, #0]
3400d570:	2b00      	cmp	r3, #0
3400d572:	d1f5      	bne.n	3400d560 <__sinit+0xc>
3400d574:	f7ff ffc4 	bl	3400d500 <global_stdio_init.part.0>
3400d578:	e7f2      	b.n	3400d560 <__sinit+0xc>
3400d57a:	bf00      	nop
3400d57c:	3400d4c1 	.word	0x3400d4c1
3400d580:	340d05bc 	.word	0x340d05bc

3400d584 <fiprintf>:
3400d584:	b40e      	push	{r1, r2, r3}
3400d586:	b503      	push	{r0, r1, lr}
3400d588:	ab03      	add	r3, sp, #12
3400d58a:	4601      	mov	r1, r0
3400d58c:	4805      	ldr	r0, [pc, #20]	@ (3400d5a4 <fiprintf+0x20>)
3400d58e:	f853 2b04 	ldr.w	r2, [r3], #4
3400d592:	6800      	ldr	r0, [r0, #0]
3400d594:	9301      	str	r3, [sp, #4]
3400d596:	f000 fc39 	bl	3400de0c <_vfiprintf_r>
3400d59a:	b002      	add	sp, #8
3400d59c:	f85d eb04 	ldr.w	lr, [sp], #4
3400d5a0:	b003      	add	sp, #12
3400d5a2:	4770      	bx	lr
3400d5a4:	34013bf8 	.word	0x34013bf8

3400d5a8 <_fwalk_sglue>:
3400d5a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3400d5ac:	4607      	mov	r7, r0
3400d5ae:	4688      	mov	r8, r1
3400d5b0:	4614      	mov	r4, r2
3400d5b2:	2600      	movs	r6, #0
3400d5b4:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
3400d5b8:	f1b9 0901 	subs.w	r9, r9, #1
3400d5bc:	d505      	bpl.n	3400d5ca <_fwalk_sglue+0x22>
3400d5be:	6824      	ldr	r4, [r4, #0]
3400d5c0:	2c00      	cmp	r4, #0
3400d5c2:	d1f7      	bne.n	3400d5b4 <_fwalk_sglue+0xc>
3400d5c4:	4630      	mov	r0, r6
3400d5c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3400d5ca:	89ab      	ldrh	r3, [r5, #12]
3400d5cc:	2b01      	cmp	r3, #1
3400d5ce:	d907      	bls.n	3400d5e0 <_fwalk_sglue+0x38>
3400d5d0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
3400d5d4:	3301      	adds	r3, #1
3400d5d6:	d003      	beq.n	3400d5e0 <_fwalk_sglue+0x38>
3400d5d8:	4629      	mov	r1, r5
3400d5da:	4638      	mov	r0, r7
3400d5dc:	47c0      	blx	r8
3400d5de:	4306      	orrs	r6, r0
3400d5e0:	3568      	adds	r5, #104	@ 0x68
3400d5e2:	e7e9      	b.n	3400d5b8 <_fwalk_sglue+0x10>

3400d5e4 <iprintf>:
3400d5e4:	b40f      	push	{r0, r1, r2, r3}
3400d5e6:	b507      	push	{r0, r1, r2, lr}
3400d5e8:	4906      	ldr	r1, [pc, #24]	@ (3400d604 <iprintf+0x20>)
3400d5ea:	ab04      	add	r3, sp, #16
3400d5ec:	6808      	ldr	r0, [r1, #0]
3400d5ee:	f853 2b04 	ldr.w	r2, [r3], #4
3400d5f2:	6881      	ldr	r1, [r0, #8]
3400d5f4:	9301      	str	r3, [sp, #4]
3400d5f6:	f000 fc09 	bl	3400de0c <_vfiprintf_r>
3400d5fa:	b003      	add	sp, #12
3400d5fc:	f85d eb04 	ldr.w	lr, [sp], #4
3400d600:	b004      	add	sp, #16
3400d602:	4770      	bx	lr
3400d604:	34013bf8 	.word	0x34013bf8

3400d608 <_puts_r>:
3400d608:	6a03      	ldr	r3, [r0, #32]
3400d60a:	b570      	push	{r4, r5, r6, lr}
3400d60c:	4605      	mov	r5, r0
3400d60e:	460e      	mov	r6, r1
3400d610:	6884      	ldr	r4, [r0, #8]
3400d612:	b90b      	cbnz	r3, 3400d618 <_puts_r+0x10>
3400d614:	f7ff ff9e 	bl	3400d554 <__sinit>
3400d618:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3400d61a:	07db      	lsls	r3, r3, #31
3400d61c:	d405      	bmi.n	3400d62a <_puts_r+0x22>
3400d61e:	89a3      	ldrh	r3, [r4, #12]
3400d620:	0598      	lsls	r0, r3, #22
3400d622:	d402      	bmi.n	3400d62a <_puts_r+0x22>
3400d624:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3400d626:	f000 f9fe 	bl	3400da26 <__retarget_lock_acquire_recursive>
3400d62a:	89a3      	ldrh	r3, [r4, #12]
3400d62c:	0719      	lsls	r1, r3, #28
3400d62e:	d502      	bpl.n	3400d636 <_puts_r+0x2e>
3400d630:	6923      	ldr	r3, [r4, #16]
3400d632:	2b00      	cmp	r3, #0
3400d634:	d135      	bne.n	3400d6a2 <_puts_r+0x9a>
3400d636:	4621      	mov	r1, r4
3400d638:	4628      	mov	r0, r5
3400d63a:	f000 f8fb 	bl	3400d834 <__swsetup_r>
3400d63e:	b380      	cbz	r0, 3400d6a2 <_puts_r+0x9a>
3400d640:	f04f 35ff 	mov.w	r5, #4294967295
3400d644:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3400d646:	07da      	lsls	r2, r3, #31
3400d648:	d405      	bmi.n	3400d656 <_puts_r+0x4e>
3400d64a:	89a3      	ldrh	r3, [r4, #12]
3400d64c:	059b      	lsls	r3, r3, #22
3400d64e:	d402      	bmi.n	3400d656 <_puts_r+0x4e>
3400d650:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3400d652:	f000 f9e9 	bl	3400da28 <__retarget_lock_release_recursive>
3400d656:	4628      	mov	r0, r5
3400d658:	bd70      	pop	{r4, r5, r6, pc}
3400d65a:	2b00      	cmp	r3, #0
3400d65c:	da04      	bge.n	3400d668 <_puts_r+0x60>
3400d65e:	69a2      	ldr	r2, [r4, #24]
3400d660:	429a      	cmp	r2, r3
3400d662:	dc17      	bgt.n	3400d694 <_puts_r+0x8c>
3400d664:	290a      	cmp	r1, #10
3400d666:	d015      	beq.n	3400d694 <_puts_r+0x8c>
3400d668:	6823      	ldr	r3, [r4, #0]
3400d66a:	1c5a      	adds	r2, r3, #1
3400d66c:	6022      	str	r2, [r4, #0]
3400d66e:	7019      	strb	r1, [r3, #0]
3400d670:	68a3      	ldr	r3, [r4, #8]
3400d672:	f816 1f01 	ldrb.w	r1, [r6, #1]!
3400d676:	3b01      	subs	r3, #1
3400d678:	60a3      	str	r3, [r4, #8]
3400d67a:	2900      	cmp	r1, #0
3400d67c:	d1ed      	bne.n	3400d65a <_puts_r+0x52>
3400d67e:	2b00      	cmp	r3, #0
3400d680:	da11      	bge.n	3400d6a6 <_puts_r+0x9e>
3400d682:	4622      	mov	r2, r4
3400d684:	210a      	movs	r1, #10
3400d686:	4628      	mov	r0, r5
3400d688:	f000 f895 	bl	3400d7b6 <__swbuf_r>
3400d68c:	3001      	adds	r0, #1
3400d68e:	d0d7      	beq.n	3400d640 <_puts_r+0x38>
3400d690:	250a      	movs	r5, #10
3400d692:	e7d7      	b.n	3400d644 <_puts_r+0x3c>
3400d694:	4622      	mov	r2, r4
3400d696:	4628      	mov	r0, r5
3400d698:	f000 f88d 	bl	3400d7b6 <__swbuf_r>
3400d69c:	3001      	adds	r0, #1
3400d69e:	d1e7      	bne.n	3400d670 <_puts_r+0x68>
3400d6a0:	e7ce      	b.n	3400d640 <_puts_r+0x38>
3400d6a2:	3e01      	subs	r6, #1
3400d6a4:	e7e4      	b.n	3400d670 <_puts_r+0x68>
3400d6a6:	6823      	ldr	r3, [r4, #0]
3400d6a8:	1c5a      	adds	r2, r3, #1
3400d6aa:	6022      	str	r2, [r4, #0]
3400d6ac:	220a      	movs	r2, #10
3400d6ae:	701a      	strb	r2, [r3, #0]
3400d6b0:	e7ee      	b.n	3400d690 <_puts_r+0x88>
	...

3400d6b4 <puts>:
3400d6b4:	4b02      	ldr	r3, [pc, #8]	@ (3400d6c0 <puts+0xc>)
3400d6b6:	4601      	mov	r1, r0
3400d6b8:	6818      	ldr	r0, [r3, #0]
3400d6ba:	f7ff bfa5 	b.w	3400d608 <_puts_r>
3400d6be:	bf00      	nop
3400d6c0:	34013bf8 	.word	0x34013bf8

3400d6c4 <sniprintf>:
3400d6c4:	b40c      	push	{r2, r3}
3400d6c6:	4b19      	ldr	r3, [pc, #100]	@ (3400d72c <sniprintf+0x68>)
3400d6c8:	b530      	push	{r4, r5, lr}
3400d6ca:	1e0c      	subs	r4, r1, #0
3400d6cc:	b09d      	sub	sp, #116	@ 0x74
3400d6ce:	681d      	ldr	r5, [r3, #0]
3400d6d0:	da08      	bge.n	3400d6e4 <sniprintf+0x20>
3400d6d2:	238b      	movs	r3, #139	@ 0x8b
3400d6d4:	f04f 30ff 	mov.w	r0, #4294967295
3400d6d8:	602b      	str	r3, [r5, #0]
3400d6da:	b01d      	add	sp, #116	@ 0x74
3400d6dc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3400d6e0:	b002      	add	sp, #8
3400d6e2:	4770      	bx	lr
3400d6e4:	f44f 7302 	mov.w	r3, #520	@ 0x208
3400d6e8:	9002      	str	r0, [sp, #8]
3400d6ea:	9006      	str	r0, [sp, #24]
3400d6ec:	a902      	add	r1, sp, #8
3400d6ee:	f8ad 3014 	strh.w	r3, [sp, #20]
3400d6f2:	f04f 0300 	mov.w	r3, #0
3400d6f6:	9a20      	ldr	r2, [sp, #128]	@ 0x80
3400d6f8:	4628      	mov	r0, r5
3400d6fa:	931b      	str	r3, [sp, #108]	@ 0x6c
3400d6fc:	bf14      	ite	ne
3400d6fe:	f104 33ff 	addne.w	r3, r4, #4294967295
3400d702:	4623      	moveq	r3, r4
3400d704:	9304      	str	r3, [sp, #16]
3400d706:	9307      	str	r3, [sp, #28]
3400d708:	f64f 73ff 	movw	r3, #65535	@ 0xffff
3400d70c:	f8ad 3016 	strh.w	r3, [sp, #22]
3400d710:	ab21      	add	r3, sp, #132	@ 0x84
3400d712:	9301      	str	r3, [sp, #4]
3400d714:	f000 fa54 	bl	3400dbc0 <_svfiprintf_r>
3400d718:	1c43      	adds	r3, r0, #1
3400d71a:	bfbc      	itt	lt
3400d71c:	238b      	movlt	r3, #139	@ 0x8b
3400d71e:	602b      	strlt	r3, [r5, #0]
3400d720:	2c00      	cmp	r4, #0
3400d722:	d0da      	beq.n	3400d6da <sniprintf+0x16>
3400d724:	9b02      	ldr	r3, [sp, #8]
3400d726:	2200      	movs	r2, #0
3400d728:	701a      	strb	r2, [r3, #0]
3400d72a:	e7d6      	b.n	3400d6da <sniprintf+0x16>
3400d72c:	34013bf8 	.word	0x34013bf8

3400d730 <__sread>:
3400d730:	b510      	push	{r4, lr}
3400d732:	460c      	mov	r4, r1
3400d734:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3400d738:	f000 f916 	bl	3400d968 <_read_r>
3400d73c:	2800      	cmp	r0, #0
3400d73e:	bfab      	itete	ge
3400d740:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
3400d742:	89a3      	ldrhlt	r3, [r4, #12]
3400d744:	181b      	addge	r3, r3, r0
3400d746:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
3400d74a:	bfac      	ite	ge
3400d74c:	6563      	strge	r3, [r4, #84]	@ 0x54
3400d74e:	81a3      	strhlt	r3, [r4, #12]
3400d750:	bd10      	pop	{r4, pc}

3400d752 <__swrite>:
3400d752:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400d756:	461f      	mov	r7, r3
3400d758:	898b      	ldrh	r3, [r1, #12]
3400d75a:	4605      	mov	r5, r0
3400d75c:	460c      	mov	r4, r1
3400d75e:	05db      	lsls	r3, r3, #23
3400d760:	4616      	mov	r6, r2
3400d762:	d505      	bpl.n	3400d770 <__swrite+0x1e>
3400d764:	2302      	movs	r3, #2
3400d766:	2200      	movs	r2, #0
3400d768:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3400d76c:	f000 f8ea 	bl	3400d944 <_lseek_r>
3400d770:	89a3      	ldrh	r3, [r4, #12]
3400d772:	4632      	mov	r2, r6
3400d774:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
3400d778:	4628      	mov	r0, r5
3400d77a:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
3400d77e:	81a3      	strh	r3, [r4, #12]
3400d780:	463b      	mov	r3, r7
3400d782:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
3400d786:	f000 b911 	b.w	3400d9ac <_write_r>

3400d78a <__sseek>:
3400d78a:	b510      	push	{r4, lr}
3400d78c:	460c      	mov	r4, r1
3400d78e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3400d792:	f000 f8d7 	bl	3400d944 <_lseek_r>
3400d796:	1c43      	adds	r3, r0, #1
3400d798:	89a3      	ldrh	r3, [r4, #12]
3400d79a:	bf15      	itete	ne
3400d79c:	6560      	strne	r0, [r4, #84]	@ 0x54
3400d79e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
3400d7a2:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
3400d7a6:	81a3      	strheq	r3, [r4, #12]
3400d7a8:	bf18      	it	ne
3400d7aa:	81a3      	strhne	r3, [r4, #12]
3400d7ac:	bd10      	pop	{r4, pc}

3400d7ae <__sclose>:
3400d7ae:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3400d7b2:	f000 b8b7 	b.w	3400d924 <_close_r>

3400d7b6 <__swbuf_r>:
3400d7b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400d7b8:	460e      	mov	r6, r1
3400d7ba:	4614      	mov	r4, r2
3400d7bc:	4605      	mov	r5, r0
3400d7be:	b118      	cbz	r0, 3400d7c8 <__swbuf_r+0x12>
3400d7c0:	6a03      	ldr	r3, [r0, #32]
3400d7c2:	b90b      	cbnz	r3, 3400d7c8 <__swbuf_r+0x12>
3400d7c4:	f7ff fec6 	bl	3400d554 <__sinit>
3400d7c8:	69a3      	ldr	r3, [r4, #24]
3400d7ca:	60a3      	str	r3, [r4, #8]
3400d7cc:	89a3      	ldrh	r3, [r4, #12]
3400d7ce:	071a      	lsls	r2, r3, #28
3400d7d0:	d501      	bpl.n	3400d7d6 <__swbuf_r+0x20>
3400d7d2:	6923      	ldr	r3, [r4, #16]
3400d7d4:	b943      	cbnz	r3, 3400d7e8 <__swbuf_r+0x32>
3400d7d6:	4621      	mov	r1, r4
3400d7d8:	4628      	mov	r0, r5
3400d7da:	f000 f82b 	bl	3400d834 <__swsetup_r>
3400d7de:	b118      	cbz	r0, 3400d7e8 <__swbuf_r+0x32>
3400d7e0:	f04f 37ff 	mov.w	r7, #4294967295
3400d7e4:	4638      	mov	r0, r7
3400d7e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
3400d7e8:	6823      	ldr	r3, [r4, #0]
3400d7ea:	b2f6      	uxtb	r6, r6
3400d7ec:	6922      	ldr	r2, [r4, #16]
3400d7ee:	4637      	mov	r7, r6
3400d7f0:	1a98      	subs	r0, r3, r2
3400d7f2:	6963      	ldr	r3, [r4, #20]
3400d7f4:	4283      	cmp	r3, r0
3400d7f6:	dc05      	bgt.n	3400d804 <__swbuf_r+0x4e>
3400d7f8:	4621      	mov	r1, r4
3400d7fa:	4628      	mov	r0, r5
3400d7fc:	f7ff fdf6 	bl	3400d3ec <_fflush_r>
3400d800:	2800      	cmp	r0, #0
3400d802:	d1ed      	bne.n	3400d7e0 <__swbuf_r+0x2a>
3400d804:	68a3      	ldr	r3, [r4, #8]
3400d806:	3b01      	subs	r3, #1
3400d808:	60a3      	str	r3, [r4, #8]
3400d80a:	6823      	ldr	r3, [r4, #0]
3400d80c:	1c5a      	adds	r2, r3, #1
3400d80e:	6022      	str	r2, [r4, #0]
3400d810:	701e      	strb	r6, [r3, #0]
3400d812:	1c43      	adds	r3, r0, #1
3400d814:	6962      	ldr	r2, [r4, #20]
3400d816:	429a      	cmp	r2, r3
3400d818:	d004      	beq.n	3400d824 <__swbuf_r+0x6e>
3400d81a:	89a3      	ldrh	r3, [r4, #12]
3400d81c:	07db      	lsls	r3, r3, #31
3400d81e:	d5e1      	bpl.n	3400d7e4 <__swbuf_r+0x2e>
3400d820:	2e0a      	cmp	r6, #10
3400d822:	d1df      	bne.n	3400d7e4 <__swbuf_r+0x2e>
3400d824:	4621      	mov	r1, r4
3400d826:	4628      	mov	r0, r5
3400d828:	f7ff fde0 	bl	3400d3ec <_fflush_r>
3400d82c:	2800      	cmp	r0, #0
3400d82e:	d0d9      	beq.n	3400d7e4 <__swbuf_r+0x2e>
3400d830:	e7d6      	b.n	3400d7e0 <__swbuf_r+0x2a>
	...

3400d834 <__swsetup_r>:
3400d834:	b538      	push	{r3, r4, r5, lr}
3400d836:	4b29      	ldr	r3, [pc, #164]	@ (3400d8dc <__swsetup_r+0xa8>)
3400d838:	4605      	mov	r5, r0
3400d83a:	460c      	mov	r4, r1
3400d83c:	6818      	ldr	r0, [r3, #0]
3400d83e:	b118      	cbz	r0, 3400d848 <__swsetup_r+0x14>
3400d840:	6a03      	ldr	r3, [r0, #32]
3400d842:	b90b      	cbnz	r3, 3400d848 <__swsetup_r+0x14>
3400d844:	f7ff fe86 	bl	3400d554 <__sinit>
3400d848:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3400d84c:	0719      	lsls	r1, r3, #28
3400d84e:	d422      	bmi.n	3400d896 <__swsetup_r+0x62>
3400d850:	06da      	lsls	r2, r3, #27
3400d852:	d407      	bmi.n	3400d864 <__swsetup_r+0x30>
3400d854:	2209      	movs	r2, #9
3400d856:	602a      	str	r2, [r5, #0]
3400d858:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3400d85c:	f04f 30ff 	mov.w	r0, #4294967295
3400d860:	81a3      	strh	r3, [r4, #12]
3400d862:	e033      	b.n	3400d8cc <__swsetup_r+0x98>
3400d864:	0758      	lsls	r0, r3, #29
3400d866:	d512      	bpl.n	3400d88e <__swsetup_r+0x5a>
3400d868:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3400d86a:	b141      	cbz	r1, 3400d87e <__swsetup_r+0x4a>
3400d86c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
3400d870:	4299      	cmp	r1, r3
3400d872:	d002      	beq.n	3400d87a <__swsetup_r+0x46>
3400d874:	4628      	mov	r0, r5
3400d876:	f000 f8f5 	bl	3400da64 <_free_r>
3400d87a:	2300      	movs	r3, #0
3400d87c:	6363      	str	r3, [r4, #52]	@ 0x34
3400d87e:	89a3      	ldrh	r3, [r4, #12]
3400d880:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
3400d884:	81a3      	strh	r3, [r4, #12]
3400d886:	2300      	movs	r3, #0
3400d888:	6063      	str	r3, [r4, #4]
3400d88a:	6923      	ldr	r3, [r4, #16]
3400d88c:	6023      	str	r3, [r4, #0]
3400d88e:	89a3      	ldrh	r3, [r4, #12]
3400d890:	f043 0308 	orr.w	r3, r3, #8
3400d894:	81a3      	strh	r3, [r4, #12]
3400d896:	6923      	ldr	r3, [r4, #16]
3400d898:	b94b      	cbnz	r3, 3400d8ae <__swsetup_r+0x7a>
3400d89a:	89a3      	ldrh	r3, [r4, #12]
3400d89c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
3400d8a0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400d8a4:	d003      	beq.n	3400d8ae <__swsetup_r+0x7a>
3400d8a6:	4621      	mov	r1, r4
3400d8a8:	4628      	mov	r0, r5
3400d8aa:	f000 fd7c 	bl	3400e3a6 <__smakebuf_r>
3400d8ae:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3400d8b2:	f013 0201 	ands.w	r2, r3, #1
3400d8b6:	d00a      	beq.n	3400d8ce <__swsetup_r+0x9a>
3400d8b8:	2200      	movs	r2, #0
3400d8ba:	60a2      	str	r2, [r4, #8]
3400d8bc:	6962      	ldr	r2, [r4, #20]
3400d8be:	4252      	negs	r2, r2
3400d8c0:	61a2      	str	r2, [r4, #24]
3400d8c2:	6922      	ldr	r2, [r4, #16]
3400d8c4:	b942      	cbnz	r2, 3400d8d8 <__swsetup_r+0xa4>
3400d8c6:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
3400d8ca:	d1c5      	bne.n	3400d858 <__swsetup_r+0x24>
3400d8cc:	bd38      	pop	{r3, r4, r5, pc}
3400d8ce:	0799      	lsls	r1, r3, #30
3400d8d0:	bf58      	it	pl
3400d8d2:	6962      	ldrpl	r2, [r4, #20]
3400d8d4:	60a2      	str	r2, [r4, #8]
3400d8d6:	e7f4      	b.n	3400d8c2 <__swsetup_r+0x8e>
3400d8d8:	2000      	movs	r0, #0
3400d8da:	e7f7      	b.n	3400d8cc <__swsetup_r+0x98>
3400d8dc:	34013bf8 	.word	0x34013bf8

3400d8e0 <memmove>:
3400d8e0:	4288      	cmp	r0, r1
3400d8e2:	b510      	push	{r4, lr}
3400d8e4:	eb01 0402 	add.w	r4, r1, r2
3400d8e8:	d902      	bls.n	3400d8f0 <memmove+0x10>
3400d8ea:	4284      	cmp	r4, r0
3400d8ec:	4623      	mov	r3, r4
3400d8ee:	d807      	bhi.n	3400d900 <memmove+0x20>
3400d8f0:	1e43      	subs	r3, r0, #1
3400d8f2:	42a1      	cmp	r1, r4
3400d8f4:	d008      	beq.n	3400d908 <memmove+0x28>
3400d8f6:	f811 2b01 	ldrb.w	r2, [r1], #1
3400d8fa:	f803 2f01 	strb.w	r2, [r3, #1]!
3400d8fe:	e7f8      	b.n	3400d8f2 <memmove+0x12>
3400d900:	4402      	add	r2, r0
3400d902:	4601      	mov	r1, r0
3400d904:	428a      	cmp	r2, r1
3400d906:	d100      	bne.n	3400d90a <memmove+0x2a>
3400d908:	bd10      	pop	{r4, pc}
3400d90a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
3400d90e:	f802 4d01 	strb.w	r4, [r2, #-1]!
3400d912:	e7f7      	b.n	3400d904 <memmove+0x24>

3400d914 <memset>:
3400d914:	4402      	add	r2, r0
3400d916:	4603      	mov	r3, r0
3400d918:	4293      	cmp	r3, r2
3400d91a:	d100      	bne.n	3400d91e <memset+0xa>
3400d91c:	4770      	bx	lr
3400d91e:	f803 1b01 	strb.w	r1, [r3], #1
3400d922:	e7f9      	b.n	3400d918 <memset+0x4>

3400d924 <_close_r>:
3400d924:	b538      	push	{r3, r4, r5, lr}
3400d926:	2300      	movs	r3, #0
3400d928:	4d05      	ldr	r5, [pc, #20]	@ (3400d940 <_close_r+0x1c>)
3400d92a:	4604      	mov	r4, r0
3400d92c:	4608      	mov	r0, r1
3400d92e:	602b      	str	r3, [r5, #0]
3400d930:	f001 fc72 	bl	3400f218 <_close>
3400d934:	1c43      	adds	r3, r0, #1
3400d936:	d102      	bne.n	3400d93e <_close_r+0x1a>
3400d938:	682b      	ldr	r3, [r5, #0]
3400d93a:	b103      	cbz	r3, 3400d93e <_close_r+0x1a>
3400d93c:	6023      	str	r3, [r4, #0]
3400d93e:	bd38      	pop	{r3, r4, r5, pc}
3400d940:	340d05c0 	.word	0x340d05c0

3400d944 <_lseek_r>:
3400d944:	b538      	push	{r3, r4, r5, lr}
3400d946:	4604      	mov	r4, r0
3400d948:	4d06      	ldr	r5, [pc, #24]	@ (3400d964 <_lseek_r+0x20>)
3400d94a:	4608      	mov	r0, r1
3400d94c:	4611      	mov	r1, r2
3400d94e:	2200      	movs	r2, #0
3400d950:	602a      	str	r2, [r5, #0]
3400d952:	461a      	mov	r2, r3
3400d954:	f001 fc88 	bl	3400f268 <_lseek>
3400d958:	1c43      	adds	r3, r0, #1
3400d95a:	d102      	bne.n	3400d962 <_lseek_r+0x1e>
3400d95c:	682b      	ldr	r3, [r5, #0]
3400d95e:	b103      	cbz	r3, 3400d962 <_lseek_r+0x1e>
3400d960:	6023      	str	r3, [r4, #0]
3400d962:	bd38      	pop	{r3, r4, r5, pc}
3400d964:	340d05c0 	.word	0x340d05c0

3400d968 <_read_r>:
3400d968:	b538      	push	{r3, r4, r5, lr}
3400d96a:	4604      	mov	r4, r0
3400d96c:	4d06      	ldr	r5, [pc, #24]	@ (3400d988 <_read_r+0x20>)
3400d96e:	4608      	mov	r0, r1
3400d970:	4611      	mov	r1, r2
3400d972:	2200      	movs	r2, #0
3400d974:	602a      	str	r2, [r5, #0]
3400d976:	461a      	mov	r2, r3
3400d978:	f001 fc7e 	bl	3400f278 <_read>
3400d97c:	1c43      	adds	r3, r0, #1
3400d97e:	d102      	bne.n	3400d986 <_read_r+0x1e>
3400d980:	682b      	ldr	r3, [r5, #0]
3400d982:	b103      	cbz	r3, 3400d986 <_read_r+0x1e>
3400d984:	6023      	str	r3, [r4, #0]
3400d986:	bd38      	pop	{r3, r4, r5, pc}
3400d988:	340d05c0 	.word	0x340d05c0

3400d98c <_sbrk_r>:
3400d98c:	b538      	push	{r3, r4, r5, lr}
3400d98e:	2300      	movs	r3, #0
3400d990:	4d05      	ldr	r5, [pc, #20]	@ (3400d9a8 <_sbrk_r+0x1c>)
3400d992:	4604      	mov	r4, r0
3400d994:	4608      	mov	r0, r1
3400d996:	602b      	str	r3, [r5, #0]
3400d998:	f7f4 fff4 	bl	34002984 <_sbrk>
3400d99c:	1c43      	adds	r3, r0, #1
3400d99e:	d102      	bne.n	3400d9a6 <_sbrk_r+0x1a>
3400d9a0:	682b      	ldr	r3, [r5, #0]
3400d9a2:	b103      	cbz	r3, 3400d9a6 <_sbrk_r+0x1a>
3400d9a4:	6023      	str	r3, [r4, #0]
3400d9a6:	bd38      	pop	{r3, r4, r5, pc}
3400d9a8:	340d05c0 	.word	0x340d05c0

3400d9ac <_write_r>:
3400d9ac:	b538      	push	{r3, r4, r5, lr}
3400d9ae:	4604      	mov	r4, r0
3400d9b0:	4d06      	ldr	r5, [pc, #24]	@ (3400d9cc <_write_r+0x20>)
3400d9b2:	4608      	mov	r0, r1
3400d9b4:	4611      	mov	r1, r2
3400d9b6:	2200      	movs	r2, #0
3400d9b8:	602a      	str	r2, [r5, #0]
3400d9ba:	461a      	mov	r2, r3
3400d9bc:	f001 fc64 	bl	3400f288 <_write>
3400d9c0:	1c43      	adds	r3, r0, #1
3400d9c2:	d102      	bne.n	3400d9ca <_write_r+0x1e>
3400d9c4:	682b      	ldr	r3, [r5, #0]
3400d9c6:	b103      	cbz	r3, 3400d9ca <_write_r+0x1e>
3400d9c8:	6023      	str	r3, [r4, #0]
3400d9ca:	bd38      	pop	{r3, r4, r5, pc}
3400d9cc:	340d05c0 	.word	0x340d05c0

3400d9d0 <__errno>:
3400d9d0:	4b01      	ldr	r3, [pc, #4]	@ (3400d9d8 <__errno+0x8>)
3400d9d2:	6818      	ldr	r0, [r3, #0]
3400d9d4:	4770      	bx	lr
3400d9d6:	bf00      	nop
3400d9d8:	34013bf8 	.word	0x34013bf8

3400d9dc <__libc_init_array>:
3400d9dc:	b570      	push	{r4, r5, r6, lr}
3400d9de:	4d0d      	ldr	r5, [pc, #52]	@ (3400da14 <__libc_init_array+0x38>)
3400d9e0:	2600      	movs	r6, #0
3400d9e2:	4c0d      	ldr	r4, [pc, #52]	@ (3400da18 <__libc_init_array+0x3c>)
3400d9e4:	1b64      	subs	r4, r4, r5
3400d9e6:	10a4      	asrs	r4, r4, #2
3400d9e8:	42a6      	cmp	r6, r4
3400d9ea:	d109      	bne.n	3400da00 <__libc_init_array+0x24>
3400d9ec:	4d0b      	ldr	r5, [pc, #44]	@ (3400da1c <__libc_init_array+0x40>)
3400d9ee:	2600      	movs	r6, #0
3400d9f0:	4c0b      	ldr	r4, [pc, #44]	@ (3400da20 <__libc_init_array+0x44>)
3400d9f2:	f001 fc53 	bl	3400f29c <_init>
3400d9f6:	1b64      	subs	r4, r4, r5
3400d9f8:	10a4      	asrs	r4, r4, #2
3400d9fa:	42a6      	cmp	r6, r4
3400d9fc:	d105      	bne.n	3400da0a <__libc_init_array+0x2e>
3400d9fe:	bd70      	pop	{r4, r5, r6, pc}
3400da00:	f855 3b04 	ldr.w	r3, [r5], #4
3400da04:	3601      	adds	r6, #1
3400da06:	4798      	blx	r3
3400da08:	e7ee      	b.n	3400d9e8 <__libc_init_array+0xc>
3400da0a:	f855 3b04 	ldr.w	r3, [r5], #4
3400da0e:	3601      	adds	r6, #1
3400da10:	4798      	blx	r3
3400da12:	e7f2      	b.n	3400d9fa <__libc_init_array+0x1e>
3400da14:	34013b04 	.word	0x34013b04
3400da18:	34013b04 	.word	0x34013b04
3400da1c:	34013b04 	.word	0x34013b04
3400da20:	34013b08 	.word	0x34013b08

3400da24 <__retarget_lock_init_recursive>:
3400da24:	4770      	bx	lr

3400da26 <__retarget_lock_acquire_recursive>:
3400da26:	4770      	bx	lr

3400da28 <__retarget_lock_release_recursive>:
3400da28:	4770      	bx	lr

3400da2a <strcpy>:
3400da2a:	4603      	mov	r3, r0
3400da2c:	f811 2b01 	ldrb.w	r2, [r1], #1
3400da30:	f803 2b01 	strb.w	r2, [r3], #1
3400da34:	2a00      	cmp	r2, #0
3400da36:	d1f9      	bne.n	3400da2c <strcpy+0x2>
3400da38:	4770      	bx	lr

3400da3a <memcpy>:
3400da3a:	440a      	add	r2, r1
3400da3c:	1e43      	subs	r3, r0, #1
3400da3e:	4291      	cmp	r1, r2
3400da40:	d100      	bne.n	3400da44 <memcpy+0xa>
3400da42:	4770      	bx	lr
3400da44:	b510      	push	{r4, lr}
3400da46:	f811 4b01 	ldrb.w	r4, [r1], #1
3400da4a:	4291      	cmp	r1, r2
3400da4c:	f803 4f01 	strb.w	r4, [r3, #1]!
3400da50:	d1f9      	bne.n	3400da46 <memcpy+0xc>
3400da52:	bd10      	pop	{r4, pc}

3400da54 <abort>:
3400da54:	2006      	movs	r0, #6
3400da56:	b508      	push	{r3, lr}
3400da58:	f000 fd0a 	bl	3400e470 <raise>
3400da5c:	2001      	movs	r0, #1
3400da5e:	f001 fc1b 	bl	3400f298 <_exit>
	...

3400da64 <_free_r>:
3400da64:	b538      	push	{r3, r4, r5, lr}
3400da66:	4605      	mov	r5, r0
3400da68:	2900      	cmp	r1, #0
3400da6a:	d041      	beq.n	3400daf0 <_free_r+0x8c>
3400da6c:	f851 3c04 	ldr.w	r3, [r1, #-4]
3400da70:	1f0c      	subs	r4, r1, #4
3400da72:	2b00      	cmp	r3, #0
3400da74:	bfb8      	it	lt
3400da76:	18e4      	addlt	r4, r4, r3
3400da78:	f7ff fbfa 	bl	3400d270 <__malloc_lock>
3400da7c:	4a1d      	ldr	r2, [pc, #116]	@ (3400daf4 <_free_r+0x90>)
3400da7e:	6813      	ldr	r3, [r2, #0]
3400da80:	b933      	cbnz	r3, 3400da90 <_free_r+0x2c>
3400da82:	6063      	str	r3, [r4, #4]
3400da84:	6014      	str	r4, [r2, #0]
3400da86:	4628      	mov	r0, r5
3400da88:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
3400da8c:	f7ff bbf6 	b.w	3400d27c <__malloc_unlock>
3400da90:	42a3      	cmp	r3, r4
3400da92:	d908      	bls.n	3400daa6 <_free_r+0x42>
3400da94:	6820      	ldr	r0, [r4, #0]
3400da96:	1821      	adds	r1, r4, r0
3400da98:	428b      	cmp	r3, r1
3400da9a:	bf01      	itttt	eq
3400da9c:	6819      	ldreq	r1, [r3, #0]
3400da9e:	685b      	ldreq	r3, [r3, #4]
3400daa0:	1809      	addeq	r1, r1, r0
3400daa2:	6021      	streq	r1, [r4, #0]
3400daa4:	e7ed      	b.n	3400da82 <_free_r+0x1e>
3400daa6:	461a      	mov	r2, r3
3400daa8:	685b      	ldr	r3, [r3, #4]
3400daaa:	b10b      	cbz	r3, 3400dab0 <_free_r+0x4c>
3400daac:	42a3      	cmp	r3, r4
3400daae:	d9fa      	bls.n	3400daa6 <_free_r+0x42>
3400dab0:	6811      	ldr	r1, [r2, #0]
3400dab2:	1850      	adds	r0, r2, r1
3400dab4:	42a0      	cmp	r0, r4
3400dab6:	d10b      	bne.n	3400dad0 <_free_r+0x6c>
3400dab8:	6820      	ldr	r0, [r4, #0]
3400daba:	4401      	add	r1, r0
3400dabc:	1850      	adds	r0, r2, r1
3400dabe:	6011      	str	r1, [r2, #0]
3400dac0:	4283      	cmp	r3, r0
3400dac2:	d1e0      	bne.n	3400da86 <_free_r+0x22>
3400dac4:	6818      	ldr	r0, [r3, #0]
3400dac6:	685b      	ldr	r3, [r3, #4]
3400dac8:	4408      	add	r0, r1
3400daca:	6053      	str	r3, [r2, #4]
3400dacc:	6010      	str	r0, [r2, #0]
3400dace:	e7da      	b.n	3400da86 <_free_r+0x22>
3400dad0:	d902      	bls.n	3400dad8 <_free_r+0x74>
3400dad2:	230c      	movs	r3, #12
3400dad4:	602b      	str	r3, [r5, #0]
3400dad6:	e7d6      	b.n	3400da86 <_free_r+0x22>
3400dad8:	6820      	ldr	r0, [r4, #0]
3400dada:	1821      	adds	r1, r4, r0
3400dadc:	428b      	cmp	r3, r1
3400dade:	bf02      	ittt	eq
3400dae0:	6819      	ldreq	r1, [r3, #0]
3400dae2:	685b      	ldreq	r3, [r3, #4]
3400dae4:	1809      	addeq	r1, r1, r0
3400dae6:	6063      	str	r3, [r4, #4]
3400dae8:	bf08      	it	eq
3400daea:	6021      	streq	r1, [r4, #0]
3400daec:	6054      	str	r4, [r2, #4]
3400daee:	e7ca      	b.n	3400da86 <_free_r+0x22>
3400daf0:	bd38      	pop	{r3, r4, r5, pc}
3400daf2:	bf00      	nop
3400daf4:	340d0480 	.word	0x340d0480

3400daf8 <_malloc_usable_size_r>:
3400daf8:	f851 3c04 	ldr.w	r3, [r1, #-4]
3400dafc:	1f18      	subs	r0, r3, #4
3400dafe:	2b00      	cmp	r3, #0
3400db00:	bfbc      	itt	lt
3400db02:	580b      	ldrlt	r3, [r1, r0]
3400db04:	18c0      	addlt	r0, r0, r3
3400db06:	4770      	bx	lr

3400db08 <__ssputs_r>:
3400db08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3400db0c:	461f      	mov	r7, r3
3400db0e:	688e      	ldr	r6, [r1, #8]
3400db10:	4682      	mov	sl, r0
3400db12:	460c      	mov	r4, r1
3400db14:	42be      	cmp	r6, r7
3400db16:	4690      	mov	r8, r2
3400db18:	680b      	ldr	r3, [r1, #0]
3400db1a:	d82d      	bhi.n	3400db78 <__ssputs_r+0x70>
3400db1c:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
3400db20:	f412 6f90 	tst.w	r2, #1152	@ 0x480
3400db24:	d026      	beq.n	3400db74 <__ssputs_r+0x6c>
3400db26:	6965      	ldr	r5, [r4, #20]
3400db28:	6909      	ldr	r1, [r1, #16]
3400db2a:	eb05 0545 	add.w	r5, r5, r5, lsl #1
3400db2e:	eba3 0901 	sub.w	r9, r3, r1
3400db32:	1c7b      	adds	r3, r7, #1
3400db34:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
3400db38:	444b      	add	r3, r9
3400db3a:	106d      	asrs	r5, r5, #1
3400db3c:	429d      	cmp	r5, r3
3400db3e:	bf38      	it	cc
3400db40:	461d      	movcc	r5, r3
3400db42:	0553      	lsls	r3, r2, #21
3400db44:	d527      	bpl.n	3400db96 <__ssputs_r+0x8e>
3400db46:	4629      	mov	r1, r5
3400db48:	f7ff fb12 	bl	3400d170 <_malloc_r>
3400db4c:	4606      	mov	r6, r0
3400db4e:	b360      	cbz	r0, 3400dbaa <__ssputs_r+0xa2>
3400db50:	464a      	mov	r2, r9
3400db52:	6921      	ldr	r1, [r4, #16]
3400db54:	f7ff ff71 	bl	3400da3a <memcpy>
3400db58:	89a3      	ldrh	r3, [r4, #12]
3400db5a:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
3400db5e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
3400db62:	81a3      	strh	r3, [r4, #12]
3400db64:	6126      	str	r6, [r4, #16]
3400db66:	444e      	add	r6, r9
3400db68:	6165      	str	r5, [r4, #20]
3400db6a:	eba5 0509 	sub.w	r5, r5, r9
3400db6e:	6026      	str	r6, [r4, #0]
3400db70:	463e      	mov	r6, r7
3400db72:	60a5      	str	r5, [r4, #8]
3400db74:	42be      	cmp	r6, r7
3400db76:	d900      	bls.n	3400db7a <__ssputs_r+0x72>
3400db78:	463e      	mov	r6, r7
3400db7a:	4632      	mov	r2, r6
3400db7c:	4641      	mov	r1, r8
3400db7e:	6820      	ldr	r0, [r4, #0]
3400db80:	f7ff feae 	bl	3400d8e0 <memmove>
3400db84:	68a3      	ldr	r3, [r4, #8]
3400db86:	2000      	movs	r0, #0
3400db88:	1b9b      	subs	r3, r3, r6
3400db8a:	60a3      	str	r3, [r4, #8]
3400db8c:	6823      	ldr	r3, [r4, #0]
3400db8e:	4433      	add	r3, r6
3400db90:	6023      	str	r3, [r4, #0]
3400db92:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3400db96:	462a      	mov	r2, r5
3400db98:	f7ff fb76 	bl	3400d288 <_realloc_r>
3400db9c:	4606      	mov	r6, r0
3400db9e:	2800      	cmp	r0, #0
3400dba0:	d1e0      	bne.n	3400db64 <__ssputs_r+0x5c>
3400dba2:	6921      	ldr	r1, [r4, #16]
3400dba4:	4650      	mov	r0, sl
3400dba6:	f7ff ff5d 	bl	3400da64 <_free_r>
3400dbaa:	230c      	movs	r3, #12
3400dbac:	f04f 30ff 	mov.w	r0, #4294967295
3400dbb0:	f8ca 3000 	str.w	r3, [sl]
3400dbb4:	89a3      	ldrh	r3, [r4, #12]
3400dbb6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3400dbba:	81a3      	strh	r3, [r4, #12]
3400dbbc:	e7e9      	b.n	3400db92 <__ssputs_r+0x8a>
	...

3400dbc0 <_svfiprintf_r>:
3400dbc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400dbc4:	4698      	mov	r8, r3
3400dbc6:	898b      	ldrh	r3, [r1, #12]
3400dbc8:	b09d      	sub	sp, #116	@ 0x74
3400dbca:	4607      	mov	r7, r0
3400dbcc:	061b      	lsls	r3, r3, #24
3400dbce:	460d      	mov	r5, r1
3400dbd0:	4614      	mov	r4, r2
3400dbd2:	d510      	bpl.n	3400dbf6 <_svfiprintf_r+0x36>
3400dbd4:	690b      	ldr	r3, [r1, #16]
3400dbd6:	b973      	cbnz	r3, 3400dbf6 <_svfiprintf_r+0x36>
3400dbd8:	2140      	movs	r1, #64	@ 0x40
3400dbda:	f7ff fac9 	bl	3400d170 <_malloc_r>
3400dbde:	6028      	str	r0, [r5, #0]
3400dbe0:	6128      	str	r0, [r5, #16]
3400dbe2:	b930      	cbnz	r0, 3400dbf2 <_svfiprintf_r+0x32>
3400dbe4:	230c      	movs	r3, #12
3400dbe6:	603b      	str	r3, [r7, #0]
3400dbe8:	f04f 30ff 	mov.w	r0, #4294967295
3400dbec:	b01d      	add	sp, #116	@ 0x74
3400dbee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400dbf2:	2340      	movs	r3, #64	@ 0x40
3400dbf4:	616b      	str	r3, [r5, #20]
3400dbf6:	2300      	movs	r3, #0
3400dbf8:	f8cd 800c 	str.w	r8, [sp, #12]
3400dbfc:	f04f 0901 	mov.w	r9, #1
3400dc00:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 3400dda4 <_svfiprintf_r+0x1e4>
3400dc04:	9309      	str	r3, [sp, #36]	@ 0x24
3400dc06:	2320      	movs	r3, #32
3400dc08:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
3400dc0c:	2330      	movs	r3, #48	@ 0x30
3400dc0e:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
3400dc12:	4623      	mov	r3, r4
3400dc14:	469a      	mov	sl, r3
3400dc16:	f813 2b01 	ldrb.w	r2, [r3], #1
3400dc1a:	b10a      	cbz	r2, 3400dc20 <_svfiprintf_r+0x60>
3400dc1c:	2a25      	cmp	r2, #37	@ 0x25
3400dc1e:	d1f9      	bne.n	3400dc14 <_svfiprintf_r+0x54>
3400dc20:	ebba 0b04 	subs.w	fp, sl, r4
3400dc24:	d00b      	beq.n	3400dc3e <_svfiprintf_r+0x7e>
3400dc26:	465b      	mov	r3, fp
3400dc28:	4622      	mov	r2, r4
3400dc2a:	4629      	mov	r1, r5
3400dc2c:	4638      	mov	r0, r7
3400dc2e:	f7ff ff6b 	bl	3400db08 <__ssputs_r>
3400dc32:	3001      	adds	r0, #1
3400dc34:	f000 80a7 	beq.w	3400dd86 <_svfiprintf_r+0x1c6>
3400dc38:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3400dc3a:	445a      	add	r2, fp
3400dc3c:	9209      	str	r2, [sp, #36]	@ 0x24
3400dc3e:	f89a 3000 	ldrb.w	r3, [sl]
3400dc42:	2b00      	cmp	r3, #0
3400dc44:	f000 809f 	beq.w	3400dd86 <_svfiprintf_r+0x1c6>
3400dc48:	2300      	movs	r3, #0
3400dc4a:	f04f 32ff 	mov.w	r2, #4294967295
3400dc4e:	f10a 0a01 	add.w	sl, sl, #1
3400dc52:	9304      	str	r3, [sp, #16]
3400dc54:	9307      	str	r3, [sp, #28]
3400dc56:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
3400dc5a:	931a      	str	r3, [sp, #104]	@ 0x68
3400dc5c:	e9cd 2305 	strd	r2, r3, [sp, #20]
3400dc60:	4654      	mov	r4, sl
3400dc62:	2205      	movs	r2, #5
3400dc64:	484f      	ldr	r0, [pc, #316]	@ (3400dda4 <_svfiprintf_r+0x1e4>)
3400dc66:	f814 1b01 	ldrb.w	r1, [r4], #1
3400dc6a:	f000 fc3f 	bl	3400e4ec <memchr>
3400dc6e:	9a04      	ldr	r2, [sp, #16]
3400dc70:	b9d8      	cbnz	r0, 3400dcaa <_svfiprintf_r+0xea>
3400dc72:	06d0      	lsls	r0, r2, #27
3400dc74:	bf44      	itt	mi
3400dc76:	2320      	movmi	r3, #32
3400dc78:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3400dc7c:	0711      	lsls	r1, r2, #28
3400dc7e:	bf44      	itt	mi
3400dc80:	232b      	movmi	r3, #43	@ 0x2b
3400dc82:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3400dc86:	f89a 3000 	ldrb.w	r3, [sl]
3400dc8a:	2b2a      	cmp	r3, #42	@ 0x2a
3400dc8c:	d015      	beq.n	3400dcba <_svfiprintf_r+0xfa>
3400dc8e:	9a07      	ldr	r2, [sp, #28]
3400dc90:	4654      	mov	r4, sl
3400dc92:	2000      	movs	r0, #0
3400dc94:	f04f 0c0a 	mov.w	ip, #10
3400dc98:	4621      	mov	r1, r4
3400dc9a:	f811 3b01 	ldrb.w	r3, [r1], #1
3400dc9e:	3b30      	subs	r3, #48	@ 0x30
3400dca0:	2b09      	cmp	r3, #9
3400dca2:	d94b      	bls.n	3400dd3c <_svfiprintf_r+0x17c>
3400dca4:	b1b0      	cbz	r0, 3400dcd4 <_svfiprintf_r+0x114>
3400dca6:	9207      	str	r2, [sp, #28]
3400dca8:	e014      	b.n	3400dcd4 <_svfiprintf_r+0x114>
3400dcaa:	eba0 0308 	sub.w	r3, r0, r8
3400dcae:	46a2      	mov	sl, r4
3400dcb0:	fa09 f303 	lsl.w	r3, r9, r3
3400dcb4:	4313      	orrs	r3, r2
3400dcb6:	9304      	str	r3, [sp, #16]
3400dcb8:	e7d2      	b.n	3400dc60 <_svfiprintf_r+0xa0>
3400dcba:	9b03      	ldr	r3, [sp, #12]
3400dcbc:	1d19      	adds	r1, r3, #4
3400dcbe:	681b      	ldr	r3, [r3, #0]
3400dcc0:	2b00      	cmp	r3, #0
3400dcc2:	9103      	str	r1, [sp, #12]
3400dcc4:	bfbb      	ittet	lt
3400dcc6:	425b      	neglt	r3, r3
3400dcc8:	f042 0202 	orrlt.w	r2, r2, #2
3400dccc:	9307      	strge	r3, [sp, #28]
3400dcce:	9307      	strlt	r3, [sp, #28]
3400dcd0:	bfb8      	it	lt
3400dcd2:	9204      	strlt	r2, [sp, #16]
3400dcd4:	7823      	ldrb	r3, [r4, #0]
3400dcd6:	2b2e      	cmp	r3, #46	@ 0x2e
3400dcd8:	d10a      	bne.n	3400dcf0 <_svfiprintf_r+0x130>
3400dcda:	7863      	ldrb	r3, [r4, #1]
3400dcdc:	2b2a      	cmp	r3, #42	@ 0x2a
3400dcde:	d132      	bne.n	3400dd46 <_svfiprintf_r+0x186>
3400dce0:	9b03      	ldr	r3, [sp, #12]
3400dce2:	3402      	adds	r4, #2
3400dce4:	1d1a      	adds	r2, r3, #4
3400dce6:	681b      	ldr	r3, [r3, #0]
3400dce8:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
3400dcec:	9203      	str	r2, [sp, #12]
3400dcee:	9305      	str	r3, [sp, #20]
3400dcf0:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 3400ddb4 <_svfiprintf_r+0x1f4>
3400dcf4:	2203      	movs	r2, #3
3400dcf6:	7821      	ldrb	r1, [r4, #0]
3400dcf8:	4650      	mov	r0, sl
3400dcfa:	f000 fbf7 	bl	3400e4ec <memchr>
3400dcfe:	b138      	cbz	r0, 3400dd10 <_svfiprintf_r+0x150>
3400dd00:	eba0 000a 	sub.w	r0, r0, sl
3400dd04:	2240      	movs	r2, #64	@ 0x40
3400dd06:	9b04      	ldr	r3, [sp, #16]
3400dd08:	3401      	adds	r4, #1
3400dd0a:	4082      	lsls	r2, r0
3400dd0c:	4313      	orrs	r3, r2
3400dd0e:	9304      	str	r3, [sp, #16]
3400dd10:	f814 1b01 	ldrb.w	r1, [r4], #1
3400dd14:	2206      	movs	r2, #6
3400dd16:	4824      	ldr	r0, [pc, #144]	@ (3400dda8 <_svfiprintf_r+0x1e8>)
3400dd18:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
3400dd1c:	f000 fbe6 	bl	3400e4ec <memchr>
3400dd20:	2800      	cmp	r0, #0
3400dd22:	d036      	beq.n	3400dd92 <_svfiprintf_r+0x1d2>
3400dd24:	4b21      	ldr	r3, [pc, #132]	@ (3400ddac <_svfiprintf_r+0x1ec>)
3400dd26:	bb1b      	cbnz	r3, 3400dd70 <_svfiprintf_r+0x1b0>
3400dd28:	9b03      	ldr	r3, [sp, #12]
3400dd2a:	3307      	adds	r3, #7
3400dd2c:	f023 0307 	bic.w	r3, r3, #7
3400dd30:	3308      	adds	r3, #8
3400dd32:	9303      	str	r3, [sp, #12]
3400dd34:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3400dd36:	4433      	add	r3, r6
3400dd38:	9309      	str	r3, [sp, #36]	@ 0x24
3400dd3a:	e76a      	b.n	3400dc12 <_svfiprintf_r+0x52>
3400dd3c:	fb0c 3202 	mla	r2, ip, r2, r3
3400dd40:	460c      	mov	r4, r1
3400dd42:	2001      	movs	r0, #1
3400dd44:	e7a8      	b.n	3400dc98 <_svfiprintf_r+0xd8>
3400dd46:	2300      	movs	r3, #0
3400dd48:	3401      	adds	r4, #1
3400dd4a:	f04f 0c0a 	mov.w	ip, #10
3400dd4e:	4619      	mov	r1, r3
3400dd50:	9305      	str	r3, [sp, #20]
3400dd52:	4620      	mov	r0, r4
3400dd54:	f810 2b01 	ldrb.w	r2, [r0], #1
3400dd58:	3a30      	subs	r2, #48	@ 0x30
3400dd5a:	2a09      	cmp	r2, #9
3400dd5c:	d903      	bls.n	3400dd66 <_svfiprintf_r+0x1a6>
3400dd5e:	2b00      	cmp	r3, #0
3400dd60:	d0c6      	beq.n	3400dcf0 <_svfiprintf_r+0x130>
3400dd62:	9105      	str	r1, [sp, #20]
3400dd64:	e7c4      	b.n	3400dcf0 <_svfiprintf_r+0x130>
3400dd66:	fb0c 2101 	mla	r1, ip, r1, r2
3400dd6a:	4604      	mov	r4, r0
3400dd6c:	2301      	movs	r3, #1
3400dd6e:	e7f0      	b.n	3400dd52 <_svfiprintf_r+0x192>
3400dd70:	ab03      	add	r3, sp, #12
3400dd72:	462a      	mov	r2, r5
3400dd74:	a904      	add	r1, sp, #16
3400dd76:	4638      	mov	r0, r7
3400dd78:	9300      	str	r3, [sp, #0]
3400dd7a:	4b0d      	ldr	r3, [pc, #52]	@ (3400ddb0 <_svfiprintf_r+0x1f0>)
3400dd7c:	f3af 8000 	nop.w
3400dd80:	1c42      	adds	r2, r0, #1
3400dd82:	4606      	mov	r6, r0
3400dd84:	d1d6      	bne.n	3400dd34 <_svfiprintf_r+0x174>
3400dd86:	89ab      	ldrh	r3, [r5, #12]
3400dd88:	065b      	lsls	r3, r3, #25
3400dd8a:	f53f af2d 	bmi.w	3400dbe8 <_svfiprintf_r+0x28>
3400dd8e:	9809      	ldr	r0, [sp, #36]	@ 0x24
3400dd90:	e72c      	b.n	3400dbec <_svfiprintf_r+0x2c>
3400dd92:	ab03      	add	r3, sp, #12
3400dd94:	462a      	mov	r2, r5
3400dd96:	a904      	add	r1, sp, #16
3400dd98:	4638      	mov	r0, r7
3400dd9a:	9300      	str	r3, [sp, #0]
3400dd9c:	4b04      	ldr	r3, [pc, #16]	@ (3400ddb0 <_svfiprintf_r+0x1f0>)
3400dd9e:	f000 f9bf 	bl	3400e120 <_printf_i>
3400dda2:	e7ed      	b.n	3400dd80 <_svfiprintf_r+0x1c0>
3400dda4:	340110a0 	.word	0x340110a0
3400dda8:	340110aa 	.word	0x340110aa
3400ddac:	00000000 	.word	0x00000000
3400ddb0:	3400db09 	.word	0x3400db09
3400ddb4:	340110a6 	.word	0x340110a6

3400ddb8 <__sfputc_r>:
3400ddb8:	6893      	ldr	r3, [r2, #8]
3400ddba:	3b01      	subs	r3, #1
3400ddbc:	2b00      	cmp	r3, #0
3400ddbe:	b410      	push	{r4}
3400ddc0:	6093      	str	r3, [r2, #8]
3400ddc2:	da08      	bge.n	3400ddd6 <__sfputc_r+0x1e>
3400ddc4:	6994      	ldr	r4, [r2, #24]
3400ddc6:	42a3      	cmp	r3, r4
3400ddc8:	db01      	blt.n	3400ddce <__sfputc_r+0x16>
3400ddca:	290a      	cmp	r1, #10
3400ddcc:	d103      	bne.n	3400ddd6 <__sfputc_r+0x1e>
3400ddce:	f85d 4b04 	ldr.w	r4, [sp], #4
3400ddd2:	f7ff bcf0 	b.w	3400d7b6 <__swbuf_r>
3400ddd6:	6813      	ldr	r3, [r2, #0]
3400ddd8:	1c58      	adds	r0, r3, #1
3400ddda:	6010      	str	r0, [r2, #0]
3400dddc:	4608      	mov	r0, r1
3400ddde:	7019      	strb	r1, [r3, #0]
3400dde0:	f85d 4b04 	ldr.w	r4, [sp], #4
3400dde4:	4770      	bx	lr

3400dde6 <__sfputs_r>:
3400dde6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400dde8:	4606      	mov	r6, r0
3400ddea:	460f      	mov	r7, r1
3400ddec:	4614      	mov	r4, r2
3400ddee:	18d5      	adds	r5, r2, r3
3400ddf0:	42ac      	cmp	r4, r5
3400ddf2:	d101      	bne.n	3400ddf8 <__sfputs_r+0x12>
3400ddf4:	2000      	movs	r0, #0
3400ddf6:	e007      	b.n	3400de08 <__sfputs_r+0x22>
3400ddf8:	463a      	mov	r2, r7
3400ddfa:	f814 1b01 	ldrb.w	r1, [r4], #1
3400ddfe:	4630      	mov	r0, r6
3400de00:	f7ff ffda 	bl	3400ddb8 <__sfputc_r>
3400de04:	1c43      	adds	r3, r0, #1
3400de06:	d1f3      	bne.n	3400ddf0 <__sfputs_r+0xa>
3400de08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

3400de0c <_vfiprintf_r>:
3400de0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400de10:	460d      	mov	r5, r1
3400de12:	b09d      	sub	sp, #116	@ 0x74
3400de14:	4614      	mov	r4, r2
3400de16:	4698      	mov	r8, r3
3400de18:	4606      	mov	r6, r0
3400de1a:	b118      	cbz	r0, 3400de24 <_vfiprintf_r+0x18>
3400de1c:	6a03      	ldr	r3, [r0, #32]
3400de1e:	b90b      	cbnz	r3, 3400de24 <_vfiprintf_r+0x18>
3400de20:	f7ff fb98 	bl	3400d554 <__sinit>
3400de24:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3400de26:	07d9      	lsls	r1, r3, #31
3400de28:	d405      	bmi.n	3400de36 <_vfiprintf_r+0x2a>
3400de2a:	89ab      	ldrh	r3, [r5, #12]
3400de2c:	059a      	lsls	r2, r3, #22
3400de2e:	d402      	bmi.n	3400de36 <_vfiprintf_r+0x2a>
3400de30:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3400de32:	f7ff fdf8 	bl	3400da26 <__retarget_lock_acquire_recursive>
3400de36:	89ab      	ldrh	r3, [r5, #12]
3400de38:	071b      	lsls	r3, r3, #28
3400de3a:	d501      	bpl.n	3400de40 <_vfiprintf_r+0x34>
3400de3c:	692b      	ldr	r3, [r5, #16]
3400de3e:	b99b      	cbnz	r3, 3400de68 <_vfiprintf_r+0x5c>
3400de40:	4629      	mov	r1, r5
3400de42:	4630      	mov	r0, r6
3400de44:	f7ff fcf6 	bl	3400d834 <__swsetup_r>
3400de48:	b170      	cbz	r0, 3400de68 <_vfiprintf_r+0x5c>
3400de4a:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3400de4c:	07dc      	lsls	r4, r3, #31
3400de4e:	d504      	bpl.n	3400de5a <_vfiprintf_r+0x4e>
3400de50:	f04f 30ff 	mov.w	r0, #4294967295
3400de54:	b01d      	add	sp, #116	@ 0x74
3400de56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400de5a:	89ab      	ldrh	r3, [r5, #12]
3400de5c:	0598      	lsls	r0, r3, #22
3400de5e:	d4f7      	bmi.n	3400de50 <_vfiprintf_r+0x44>
3400de60:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3400de62:	f7ff fde1 	bl	3400da28 <__retarget_lock_release_recursive>
3400de66:	e7f3      	b.n	3400de50 <_vfiprintf_r+0x44>
3400de68:	2300      	movs	r3, #0
3400de6a:	f8cd 800c 	str.w	r8, [sp, #12]
3400de6e:	f04f 0901 	mov.w	r9, #1
3400de72:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 3400e028 <_vfiprintf_r+0x21c>
3400de76:	9309      	str	r3, [sp, #36]	@ 0x24
3400de78:	2320      	movs	r3, #32
3400de7a:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
3400de7e:	2330      	movs	r3, #48	@ 0x30
3400de80:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
3400de84:	4623      	mov	r3, r4
3400de86:	469a      	mov	sl, r3
3400de88:	f813 2b01 	ldrb.w	r2, [r3], #1
3400de8c:	b10a      	cbz	r2, 3400de92 <_vfiprintf_r+0x86>
3400de8e:	2a25      	cmp	r2, #37	@ 0x25
3400de90:	d1f9      	bne.n	3400de86 <_vfiprintf_r+0x7a>
3400de92:	ebba 0b04 	subs.w	fp, sl, r4
3400de96:	d00b      	beq.n	3400deb0 <_vfiprintf_r+0xa4>
3400de98:	465b      	mov	r3, fp
3400de9a:	4622      	mov	r2, r4
3400de9c:	4629      	mov	r1, r5
3400de9e:	4630      	mov	r0, r6
3400dea0:	f7ff ffa1 	bl	3400dde6 <__sfputs_r>
3400dea4:	3001      	adds	r0, #1
3400dea6:	f000 80a7 	beq.w	3400dff8 <_vfiprintf_r+0x1ec>
3400deaa:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3400deac:	445a      	add	r2, fp
3400deae:	9209      	str	r2, [sp, #36]	@ 0x24
3400deb0:	f89a 3000 	ldrb.w	r3, [sl]
3400deb4:	2b00      	cmp	r3, #0
3400deb6:	f000 809f 	beq.w	3400dff8 <_vfiprintf_r+0x1ec>
3400deba:	2300      	movs	r3, #0
3400debc:	f04f 32ff 	mov.w	r2, #4294967295
3400dec0:	f10a 0a01 	add.w	sl, sl, #1
3400dec4:	9304      	str	r3, [sp, #16]
3400dec6:	9307      	str	r3, [sp, #28]
3400dec8:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
3400decc:	931a      	str	r3, [sp, #104]	@ 0x68
3400dece:	e9cd 2305 	strd	r2, r3, [sp, #20]
3400ded2:	4654      	mov	r4, sl
3400ded4:	2205      	movs	r2, #5
3400ded6:	4854      	ldr	r0, [pc, #336]	@ (3400e028 <_vfiprintf_r+0x21c>)
3400ded8:	f814 1b01 	ldrb.w	r1, [r4], #1
3400dedc:	f000 fb06 	bl	3400e4ec <memchr>
3400dee0:	9a04      	ldr	r2, [sp, #16]
3400dee2:	b9d8      	cbnz	r0, 3400df1c <_vfiprintf_r+0x110>
3400dee4:	06d1      	lsls	r1, r2, #27
3400dee6:	bf44      	itt	mi
3400dee8:	2320      	movmi	r3, #32
3400deea:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3400deee:	0713      	lsls	r3, r2, #28
3400def0:	bf44      	itt	mi
3400def2:	232b      	movmi	r3, #43	@ 0x2b
3400def4:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3400def8:	f89a 3000 	ldrb.w	r3, [sl]
3400defc:	2b2a      	cmp	r3, #42	@ 0x2a
3400defe:	d015      	beq.n	3400df2c <_vfiprintf_r+0x120>
3400df00:	9a07      	ldr	r2, [sp, #28]
3400df02:	4654      	mov	r4, sl
3400df04:	2000      	movs	r0, #0
3400df06:	f04f 0c0a 	mov.w	ip, #10
3400df0a:	4621      	mov	r1, r4
3400df0c:	f811 3b01 	ldrb.w	r3, [r1], #1
3400df10:	3b30      	subs	r3, #48	@ 0x30
3400df12:	2b09      	cmp	r3, #9
3400df14:	d94b      	bls.n	3400dfae <_vfiprintf_r+0x1a2>
3400df16:	b1b0      	cbz	r0, 3400df46 <_vfiprintf_r+0x13a>
3400df18:	9207      	str	r2, [sp, #28]
3400df1a:	e014      	b.n	3400df46 <_vfiprintf_r+0x13a>
3400df1c:	eba0 0308 	sub.w	r3, r0, r8
3400df20:	46a2      	mov	sl, r4
3400df22:	fa09 f303 	lsl.w	r3, r9, r3
3400df26:	4313      	orrs	r3, r2
3400df28:	9304      	str	r3, [sp, #16]
3400df2a:	e7d2      	b.n	3400ded2 <_vfiprintf_r+0xc6>
3400df2c:	9b03      	ldr	r3, [sp, #12]
3400df2e:	1d19      	adds	r1, r3, #4
3400df30:	681b      	ldr	r3, [r3, #0]
3400df32:	2b00      	cmp	r3, #0
3400df34:	9103      	str	r1, [sp, #12]
3400df36:	bfbb      	ittet	lt
3400df38:	425b      	neglt	r3, r3
3400df3a:	f042 0202 	orrlt.w	r2, r2, #2
3400df3e:	9307      	strge	r3, [sp, #28]
3400df40:	9307      	strlt	r3, [sp, #28]
3400df42:	bfb8      	it	lt
3400df44:	9204      	strlt	r2, [sp, #16]
3400df46:	7823      	ldrb	r3, [r4, #0]
3400df48:	2b2e      	cmp	r3, #46	@ 0x2e
3400df4a:	d10a      	bne.n	3400df62 <_vfiprintf_r+0x156>
3400df4c:	7863      	ldrb	r3, [r4, #1]
3400df4e:	2b2a      	cmp	r3, #42	@ 0x2a
3400df50:	d132      	bne.n	3400dfb8 <_vfiprintf_r+0x1ac>
3400df52:	9b03      	ldr	r3, [sp, #12]
3400df54:	3402      	adds	r4, #2
3400df56:	1d1a      	adds	r2, r3, #4
3400df58:	681b      	ldr	r3, [r3, #0]
3400df5a:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
3400df5e:	9203      	str	r2, [sp, #12]
3400df60:	9305      	str	r3, [sp, #20]
3400df62:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 3400e038 <_vfiprintf_r+0x22c>
3400df66:	2203      	movs	r2, #3
3400df68:	7821      	ldrb	r1, [r4, #0]
3400df6a:	4650      	mov	r0, sl
3400df6c:	f000 fabe 	bl	3400e4ec <memchr>
3400df70:	b138      	cbz	r0, 3400df82 <_vfiprintf_r+0x176>
3400df72:	eba0 000a 	sub.w	r0, r0, sl
3400df76:	2240      	movs	r2, #64	@ 0x40
3400df78:	9b04      	ldr	r3, [sp, #16]
3400df7a:	3401      	adds	r4, #1
3400df7c:	4082      	lsls	r2, r0
3400df7e:	4313      	orrs	r3, r2
3400df80:	9304      	str	r3, [sp, #16]
3400df82:	f814 1b01 	ldrb.w	r1, [r4], #1
3400df86:	2206      	movs	r2, #6
3400df88:	4828      	ldr	r0, [pc, #160]	@ (3400e02c <_vfiprintf_r+0x220>)
3400df8a:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
3400df8e:	f000 faad 	bl	3400e4ec <memchr>
3400df92:	2800      	cmp	r0, #0
3400df94:	d03f      	beq.n	3400e016 <_vfiprintf_r+0x20a>
3400df96:	4b26      	ldr	r3, [pc, #152]	@ (3400e030 <_vfiprintf_r+0x224>)
3400df98:	bb1b      	cbnz	r3, 3400dfe2 <_vfiprintf_r+0x1d6>
3400df9a:	9b03      	ldr	r3, [sp, #12]
3400df9c:	3307      	adds	r3, #7
3400df9e:	f023 0307 	bic.w	r3, r3, #7
3400dfa2:	3308      	adds	r3, #8
3400dfa4:	9303      	str	r3, [sp, #12]
3400dfa6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3400dfa8:	443b      	add	r3, r7
3400dfaa:	9309      	str	r3, [sp, #36]	@ 0x24
3400dfac:	e76a      	b.n	3400de84 <_vfiprintf_r+0x78>
3400dfae:	fb0c 3202 	mla	r2, ip, r2, r3
3400dfb2:	460c      	mov	r4, r1
3400dfb4:	2001      	movs	r0, #1
3400dfb6:	e7a8      	b.n	3400df0a <_vfiprintf_r+0xfe>
3400dfb8:	2300      	movs	r3, #0
3400dfba:	3401      	adds	r4, #1
3400dfbc:	f04f 0c0a 	mov.w	ip, #10
3400dfc0:	4619      	mov	r1, r3
3400dfc2:	9305      	str	r3, [sp, #20]
3400dfc4:	4620      	mov	r0, r4
3400dfc6:	f810 2b01 	ldrb.w	r2, [r0], #1
3400dfca:	3a30      	subs	r2, #48	@ 0x30
3400dfcc:	2a09      	cmp	r2, #9
3400dfce:	d903      	bls.n	3400dfd8 <_vfiprintf_r+0x1cc>
3400dfd0:	2b00      	cmp	r3, #0
3400dfd2:	d0c6      	beq.n	3400df62 <_vfiprintf_r+0x156>
3400dfd4:	9105      	str	r1, [sp, #20]
3400dfd6:	e7c4      	b.n	3400df62 <_vfiprintf_r+0x156>
3400dfd8:	fb0c 2101 	mla	r1, ip, r1, r2
3400dfdc:	4604      	mov	r4, r0
3400dfde:	2301      	movs	r3, #1
3400dfe0:	e7f0      	b.n	3400dfc4 <_vfiprintf_r+0x1b8>
3400dfe2:	ab03      	add	r3, sp, #12
3400dfe4:	462a      	mov	r2, r5
3400dfe6:	a904      	add	r1, sp, #16
3400dfe8:	4630      	mov	r0, r6
3400dfea:	9300      	str	r3, [sp, #0]
3400dfec:	4b11      	ldr	r3, [pc, #68]	@ (3400e034 <_vfiprintf_r+0x228>)
3400dfee:	f3af 8000 	nop.w
3400dff2:	4607      	mov	r7, r0
3400dff4:	1c78      	adds	r0, r7, #1
3400dff6:	d1d6      	bne.n	3400dfa6 <_vfiprintf_r+0x19a>
3400dff8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3400dffa:	07d9      	lsls	r1, r3, #31
3400dffc:	d405      	bmi.n	3400e00a <_vfiprintf_r+0x1fe>
3400dffe:	89ab      	ldrh	r3, [r5, #12]
3400e000:	059a      	lsls	r2, r3, #22
3400e002:	d402      	bmi.n	3400e00a <_vfiprintf_r+0x1fe>
3400e004:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3400e006:	f7ff fd0f 	bl	3400da28 <__retarget_lock_release_recursive>
3400e00a:	89ab      	ldrh	r3, [r5, #12]
3400e00c:	065b      	lsls	r3, r3, #25
3400e00e:	f53f af1f 	bmi.w	3400de50 <_vfiprintf_r+0x44>
3400e012:	9809      	ldr	r0, [sp, #36]	@ 0x24
3400e014:	e71e      	b.n	3400de54 <_vfiprintf_r+0x48>
3400e016:	ab03      	add	r3, sp, #12
3400e018:	462a      	mov	r2, r5
3400e01a:	a904      	add	r1, sp, #16
3400e01c:	4630      	mov	r0, r6
3400e01e:	9300      	str	r3, [sp, #0]
3400e020:	4b04      	ldr	r3, [pc, #16]	@ (3400e034 <_vfiprintf_r+0x228>)
3400e022:	f000 f87d 	bl	3400e120 <_printf_i>
3400e026:	e7e4      	b.n	3400dff2 <_vfiprintf_r+0x1e6>
3400e028:	340110a0 	.word	0x340110a0
3400e02c:	340110aa 	.word	0x340110aa
3400e030:	00000000 	.word	0x00000000
3400e034:	3400dde7 	.word	0x3400dde7
3400e038:	340110a6 	.word	0x340110a6

3400e03c <_printf_common>:
3400e03c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3400e040:	4616      	mov	r6, r2
3400e042:	4698      	mov	r8, r3
3400e044:	688a      	ldr	r2, [r1, #8]
3400e046:	4607      	mov	r7, r0
3400e048:	690b      	ldr	r3, [r1, #16]
3400e04a:	460c      	mov	r4, r1
3400e04c:	f8dd 9020 	ldr.w	r9, [sp, #32]
3400e050:	4293      	cmp	r3, r2
3400e052:	bfb8      	it	lt
3400e054:	4613      	movlt	r3, r2
3400e056:	6033      	str	r3, [r6, #0]
3400e058:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
3400e05c:	b10a      	cbz	r2, 3400e062 <_printf_common+0x26>
3400e05e:	3301      	adds	r3, #1
3400e060:	6033      	str	r3, [r6, #0]
3400e062:	6823      	ldr	r3, [r4, #0]
3400e064:	0699      	lsls	r1, r3, #26
3400e066:	bf42      	ittt	mi
3400e068:	6833      	ldrmi	r3, [r6, #0]
3400e06a:	3302      	addmi	r3, #2
3400e06c:	6033      	strmi	r3, [r6, #0]
3400e06e:	6825      	ldr	r5, [r4, #0]
3400e070:	f015 0506 	ands.w	r5, r5, #6
3400e074:	d106      	bne.n	3400e084 <_printf_common+0x48>
3400e076:	f104 0a19 	add.w	sl, r4, #25
3400e07a:	68e3      	ldr	r3, [r4, #12]
3400e07c:	6832      	ldr	r2, [r6, #0]
3400e07e:	1a9b      	subs	r3, r3, r2
3400e080:	42ab      	cmp	r3, r5
3400e082:	dc2b      	bgt.n	3400e0dc <_printf_common+0xa0>
3400e084:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
3400e088:	6822      	ldr	r2, [r4, #0]
3400e08a:	3b00      	subs	r3, #0
3400e08c:	bf18      	it	ne
3400e08e:	2301      	movne	r3, #1
3400e090:	0692      	lsls	r2, r2, #26
3400e092:	d430      	bmi.n	3400e0f6 <_printf_common+0xba>
3400e094:	f104 0243 	add.w	r2, r4, #67	@ 0x43
3400e098:	4641      	mov	r1, r8
3400e09a:	4638      	mov	r0, r7
3400e09c:	47c8      	blx	r9
3400e09e:	3001      	adds	r0, #1
3400e0a0:	d023      	beq.n	3400e0ea <_printf_common+0xae>
3400e0a2:	6823      	ldr	r3, [r4, #0]
3400e0a4:	341a      	adds	r4, #26
3400e0a6:	f854 2c0a 	ldr.w	r2, [r4, #-10]
3400e0aa:	f003 0306 	and.w	r3, r3, #6
3400e0ae:	2b04      	cmp	r3, #4
3400e0b0:	bf0a      	itet	eq
3400e0b2:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
3400e0b6:	2500      	movne	r5, #0
3400e0b8:	6833      	ldreq	r3, [r6, #0]
3400e0ba:	f04f 0600 	mov.w	r6, #0
3400e0be:	bf08      	it	eq
3400e0c0:	1aed      	subeq	r5, r5, r3
3400e0c2:	f854 3c12 	ldr.w	r3, [r4, #-18]
3400e0c6:	bf08      	it	eq
3400e0c8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
3400e0cc:	4293      	cmp	r3, r2
3400e0ce:	bfc4      	itt	gt
3400e0d0:	1a9b      	subgt	r3, r3, r2
3400e0d2:	18ed      	addgt	r5, r5, r3
3400e0d4:	42b5      	cmp	r5, r6
3400e0d6:	d11a      	bne.n	3400e10e <_printf_common+0xd2>
3400e0d8:	2000      	movs	r0, #0
3400e0da:	e008      	b.n	3400e0ee <_printf_common+0xb2>
3400e0dc:	2301      	movs	r3, #1
3400e0de:	4652      	mov	r2, sl
3400e0e0:	4641      	mov	r1, r8
3400e0e2:	4638      	mov	r0, r7
3400e0e4:	47c8      	blx	r9
3400e0e6:	3001      	adds	r0, #1
3400e0e8:	d103      	bne.n	3400e0f2 <_printf_common+0xb6>
3400e0ea:	f04f 30ff 	mov.w	r0, #4294967295
3400e0ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3400e0f2:	3501      	adds	r5, #1
3400e0f4:	e7c1      	b.n	3400e07a <_printf_common+0x3e>
3400e0f6:	18e1      	adds	r1, r4, r3
3400e0f8:	1c5a      	adds	r2, r3, #1
3400e0fa:	2030      	movs	r0, #48	@ 0x30
3400e0fc:	3302      	adds	r3, #2
3400e0fe:	4422      	add	r2, r4
3400e100:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
3400e104:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
3400e108:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
3400e10c:	e7c2      	b.n	3400e094 <_printf_common+0x58>
3400e10e:	2301      	movs	r3, #1
3400e110:	4622      	mov	r2, r4
3400e112:	4641      	mov	r1, r8
3400e114:	4638      	mov	r0, r7
3400e116:	47c8      	blx	r9
3400e118:	3001      	adds	r0, #1
3400e11a:	d0e6      	beq.n	3400e0ea <_printf_common+0xae>
3400e11c:	3601      	adds	r6, #1
3400e11e:	e7d9      	b.n	3400e0d4 <_printf_common+0x98>

3400e120 <_printf_i>:
3400e120:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
3400e124:	7e0f      	ldrb	r7, [r1, #24]
3400e126:	4691      	mov	r9, r2
3400e128:	4680      	mov	r8, r0
3400e12a:	460c      	mov	r4, r1
3400e12c:	2f78      	cmp	r7, #120	@ 0x78
3400e12e:	469a      	mov	sl, r3
3400e130:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
3400e132:	f101 0243 	add.w	r2, r1, #67	@ 0x43
3400e136:	d807      	bhi.n	3400e148 <_printf_i+0x28>
3400e138:	2f62      	cmp	r7, #98	@ 0x62
3400e13a:	d80a      	bhi.n	3400e152 <_printf_i+0x32>
3400e13c:	2f00      	cmp	r7, #0
3400e13e:	f000 80d1 	beq.w	3400e2e4 <_printf_i+0x1c4>
3400e142:	2f58      	cmp	r7, #88	@ 0x58
3400e144:	f000 80b8 	beq.w	3400e2b8 <_printf_i+0x198>
3400e148:	f104 0642 	add.w	r6, r4, #66	@ 0x42
3400e14c:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
3400e150:	e03a      	b.n	3400e1c8 <_printf_i+0xa8>
3400e152:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
3400e156:	2b15      	cmp	r3, #21
3400e158:	d8f6      	bhi.n	3400e148 <_printf_i+0x28>
3400e15a:	a101      	add	r1, pc, #4	@ (adr r1, 3400e160 <_printf_i+0x40>)
3400e15c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
3400e160:	3400e1b9 	.word	0x3400e1b9
3400e164:	3400e1cd 	.word	0x3400e1cd
3400e168:	3400e149 	.word	0x3400e149
3400e16c:	3400e149 	.word	0x3400e149
3400e170:	3400e149 	.word	0x3400e149
3400e174:	3400e149 	.word	0x3400e149
3400e178:	3400e1cd 	.word	0x3400e1cd
3400e17c:	3400e149 	.word	0x3400e149
3400e180:	3400e149 	.word	0x3400e149
3400e184:	3400e149 	.word	0x3400e149
3400e188:	3400e149 	.word	0x3400e149
3400e18c:	3400e2cb 	.word	0x3400e2cb
3400e190:	3400e1f7 	.word	0x3400e1f7
3400e194:	3400e285 	.word	0x3400e285
3400e198:	3400e149 	.word	0x3400e149
3400e19c:	3400e149 	.word	0x3400e149
3400e1a0:	3400e2ed 	.word	0x3400e2ed
3400e1a4:	3400e149 	.word	0x3400e149
3400e1a8:	3400e1f7 	.word	0x3400e1f7
3400e1ac:	3400e149 	.word	0x3400e149
3400e1b0:	3400e149 	.word	0x3400e149
3400e1b4:	3400e28d 	.word	0x3400e28d
3400e1b8:	6833      	ldr	r3, [r6, #0]
3400e1ba:	1d1a      	adds	r2, r3, #4
3400e1bc:	681b      	ldr	r3, [r3, #0]
3400e1be:	6032      	str	r2, [r6, #0]
3400e1c0:	f104 0642 	add.w	r6, r4, #66	@ 0x42
3400e1c4:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
3400e1c8:	2301      	movs	r3, #1
3400e1ca:	e09c      	b.n	3400e306 <_printf_i+0x1e6>
3400e1cc:	6833      	ldr	r3, [r6, #0]
3400e1ce:	6820      	ldr	r0, [r4, #0]
3400e1d0:	1d19      	adds	r1, r3, #4
3400e1d2:	6031      	str	r1, [r6, #0]
3400e1d4:	0606      	lsls	r6, r0, #24
3400e1d6:	d501      	bpl.n	3400e1dc <_printf_i+0xbc>
3400e1d8:	681d      	ldr	r5, [r3, #0]
3400e1da:	e003      	b.n	3400e1e4 <_printf_i+0xc4>
3400e1dc:	0645      	lsls	r5, r0, #25
3400e1de:	d5fb      	bpl.n	3400e1d8 <_printf_i+0xb8>
3400e1e0:	f9b3 5000 	ldrsh.w	r5, [r3]
3400e1e4:	2d00      	cmp	r5, #0
3400e1e6:	da03      	bge.n	3400e1f0 <_printf_i+0xd0>
3400e1e8:	232d      	movs	r3, #45	@ 0x2d
3400e1ea:	426d      	negs	r5, r5
3400e1ec:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
3400e1f0:	4858      	ldr	r0, [pc, #352]	@ (3400e354 <_printf_i+0x234>)
3400e1f2:	230a      	movs	r3, #10
3400e1f4:	e011      	b.n	3400e21a <_printf_i+0xfa>
3400e1f6:	6821      	ldr	r1, [r4, #0]
3400e1f8:	6833      	ldr	r3, [r6, #0]
3400e1fa:	0608      	lsls	r0, r1, #24
3400e1fc:	f853 5b04 	ldr.w	r5, [r3], #4
3400e200:	d402      	bmi.n	3400e208 <_printf_i+0xe8>
3400e202:	0649      	lsls	r1, r1, #25
3400e204:	bf48      	it	mi
3400e206:	b2ad      	uxthmi	r5, r5
3400e208:	2f6f      	cmp	r7, #111	@ 0x6f
3400e20a:	6033      	str	r3, [r6, #0]
3400e20c:	4851      	ldr	r0, [pc, #324]	@ (3400e354 <_printf_i+0x234>)
3400e20e:	bf14      	ite	ne
3400e210:	230a      	movne	r3, #10
3400e212:	2308      	moveq	r3, #8
3400e214:	2100      	movs	r1, #0
3400e216:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
3400e21a:	6866      	ldr	r6, [r4, #4]
3400e21c:	2e00      	cmp	r6, #0
3400e21e:	60a6      	str	r6, [r4, #8]
3400e220:	db05      	blt.n	3400e22e <_printf_i+0x10e>
3400e222:	6821      	ldr	r1, [r4, #0]
3400e224:	432e      	orrs	r6, r5
3400e226:	f021 0104 	bic.w	r1, r1, #4
3400e22a:	6021      	str	r1, [r4, #0]
3400e22c:	d04b      	beq.n	3400e2c6 <_printf_i+0x1a6>
3400e22e:	4616      	mov	r6, r2
3400e230:	fbb5 f1f3 	udiv	r1, r5, r3
3400e234:	fb03 5711 	mls	r7, r3, r1, r5
3400e238:	5dc7      	ldrb	r7, [r0, r7]
3400e23a:	f806 7d01 	strb.w	r7, [r6, #-1]!
3400e23e:	462f      	mov	r7, r5
3400e240:	460d      	mov	r5, r1
3400e242:	42bb      	cmp	r3, r7
3400e244:	d9f4      	bls.n	3400e230 <_printf_i+0x110>
3400e246:	2b08      	cmp	r3, #8
3400e248:	d10b      	bne.n	3400e262 <_printf_i+0x142>
3400e24a:	6823      	ldr	r3, [r4, #0]
3400e24c:	07df      	lsls	r7, r3, #31
3400e24e:	d508      	bpl.n	3400e262 <_printf_i+0x142>
3400e250:	6923      	ldr	r3, [r4, #16]
3400e252:	6861      	ldr	r1, [r4, #4]
3400e254:	4299      	cmp	r1, r3
3400e256:	bfde      	ittt	le
3400e258:	2330      	movle	r3, #48	@ 0x30
3400e25a:	f806 3c01 	strble.w	r3, [r6, #-1]
3400e25e:	f106 36ff 	addle.w	r6, r6, #4294967295
3400e262:	1b92      	subs	r2, r2, r6
3400e264:	6122      	str	r2, [r4, #16]
3400e266:	464b      	mov	r3, r9
3400e268:	aa03      	add	r2, sp, #12
3400e26a:	4621      	mov	r1, r4
3400e26c:	4640      	mov	r0, r8
3400e26e:	f8cd a000 	str.w	sl, [sp]
3400e272:	f7ff fee3 	bl	3400e03c <_printf_common>
3400e276:	3001      	adds	r0, #1
3400e278:	d14a      	bne.n	3400e310 <_printf_i+0x1f0>
3400e27a:	f04f 30ff 	mov.w	r0, #4294967295
3400e27e:	b004      	add	sp, #16
3400e280:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3400e284:	6823      	ldr	r3, [r4, #0]
3400e286:	f043 0320 	orr.w	r3, r3, #32
3400e28a:	6023      	str	r3, [r4, #0]
3400e28c:	2778      	movs	r7, #120	@ 0x78
3400e28e:	4832      	ldr	r0, [pc, #200]	@ (3400e358 <_printf_i+0x238>)
3400e290:	6823      	ldr	r3, [r4, #0]
3400e292:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
3400e296:	061f      	lsls	r7, r3, #24
3400e298:	6831      	ldr	r1, [r6, #0]
3400e29a:	f851 5b04 	ldr.w	r5, [r1], #4
3400e29e:	d402      	bmi.n	3400e2a6 <_printf_i+0x186>
3400e2a0:	065f      	lsls	r7, r3, #25
3400e2a2:	bf48      	it	mi
3400e2a4:	b2ad      	uxthmi	r5, r5
3400e2a6:	6031      	str	r1, [r6, #0]
3400e2a8:	07d9      	lsls	r1, r3, #31
3400e2aa:	bf44      	itt	mi
3400e2ac:	f043 0320 	orrmi.w	r3, r3, #32
3400e2b0:	6023      	strmi	r3, [r4, #0]
3400e2b2:	b11d      	cbz	r5, 3400e2bc <_printf_i+0x19c>
3400e2b4:	2310      	movs	r3, #16
3400e2b6:	e7ad      	b.n	3400e214 <_printf_i+0xf4>
3400e2b8:	4826      	ldr	r0, [pc, #152]	@ (3400e354 <_printf_i+0x234>)
3400e2ba:	e7e9      	b.n	3400e290 <_printf_i+0x170>
3400e2bc:	6823      	ldr	r3, [r4, #0]
3400e2be:	f023 0320 	bic.w	r3, r3, #32
3400e2c2:	6023      	str	r3, [r4, #0]
3400e2c4:	e7f6      	b.n	3400e2b4 <_printf_i+0x194>
3400e2c6:	4616      	mov	r6, r2
3400e2c8:	e7bd      	b.n	3400e246 <_printf_i+0x126>
3400e2ca:	6833      	ldr	r3, [r6, #0]
3400e2cc:	6825      	ldr	r5, [r4, #0]
3400e2ce:	1d18      	adds	r0, r3, #4
3400e2d0:	6961      	ldr	r1, [r4, #20]
3400e2d2:	6030      	str	r0, [r6, #0]
3400e2d4:	062e      	lsls	r6, r5, #24
3400e2d6:	681b      	ldr	r3, [r3, #0]
3400e2d8:	d501      	bpl.n	3400e2de <_printf_i+0x1be>
3400e2da:	6019      	str	r1, [r3, #0]
3400e2dc:	e002      	b.n	3400e2e4 <_printf_i+0x1c4>
3400e2de:	0668      	lsls	r0, r5, #25
3400e2e0:	d5fb      	bpl.n	3400e2da <_printf_i+0x1ba>
3400e2e2:	8019      	strh	r1, [r3, #0]
3400e2e4:	2300      	movs	r3, #0
3400e2e6:	4616      	mov	r6, r2
3400e2e8:	6123      	str	r3, [r4, #16]
3400e2ea:	e7bc      	b.n	3400e266 <_printf_i+0x146>
3400e2ec:	6833      	ldr	r3, [r6, #0]
3400e2ee:	2100      	movs	r1, #0
3400e2f0:	1d1a      	adds	r2, r3, #4
3400e2f2:	6032      	str	r2, [r6, #0]
3400e2f4:	681e      	ldr	r6, [r3, #0]
3400e2f6:	6862      	ldr	r2, [r4, #4]
3400e2f8:	4630      	mov	r0, r6
3400e2fa:	f000 f8f7 	bl	3400e4ec <memchr>
3400e2fe:	b108      	cbz	r0, 3400e304 <_printf_i+0x1e4>
3400e300:	1b80      	subs	r0, r0, r6
3400e302:	6060      	str	r0, [r4, #4]
3400e304:	6863      	ldr	r3, [r4, #4]
3400e306:	6123      	str	r3, [r4, #16]
3400e308:	2300      	movs	r3, #0
3400e30a:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
3400e30e:	e7aa      	b.n	3400e266 <_printf_i+0x146>
3400e310:	6923      	ldr	r3, [r4, #16]
3400e312:	4632      	mov	r2, r6
3400e314:	4649      	mov	r1, r9
3400e316:	4640      	mov	r0, r8
3400e318:	47d0      	blx	sl
3400e31a:	3001      	adds	r0, #1
3400e31c:	d0ad      	beq.n	3400e27a <_printf_i+0x15a>
3400e31e:	6823      	ldr	r3, [r4, #0]
3400e320:	079b      	lsls	r3, r3, #30
3400e322:	d413      	bmi.n	3400e34c <_printf_i+0x22c>
3400e324:	68e0      	ldr	r0, [r4, #12]
3400e326:	9b03      	ldr	r3, [sp, #12]
3400e328:	4298      	cmp	r0, r3
3400e32a:	bfb8      	it	lt
3400e32c:	4618      	movlt	r0, r3
3400e32e:	e7a6      	b.n	3400e27e <_printf_i+0x15e>
3400e330:	2301      	movs	r3, #1
3400e332:	4632      	mov	r2, r6
3400e334:	4649      	mov	r1, r9
3400e336:	4640      	mov	r0, r8
3400e338:	47d0      	blx	sl
3400e33a:	3001      	adds	r0, #1
3400e33c:	d09d      	beq.n	3400e27a <_printf_i+0x15a>
3400e33e:	3501      	adds	r5, #1
3400e340:	68e3      	ldr	r3, [r4, #12]
3400e342:	9903      	ldr	r1, [sp, #12]
3400e344:	1a5b      	subs	r3, r3, r1
3400e346:	42ab      	cmp	r3, r5
3400e348:	dcf2      	bgt.n	3400e330 <_printf_i+0x210>
3400e34a:	e7eb      	b.n	3400e324 <_printf_i+0x204>
3400e34c:	2500      	movs	r5, #0
3400e34e:	f104 0619 	add.w	r6, r4, #25
3400e352:	e7f5      	b.n	3400e340 <_printf_i+0x220>
3400e354:	340110b1 	.word	0x340110b1
3400e358:	340110c2 	.word	0x340110c2

3400e35c <__swhatbuf_r>:
3400e35c:	b570      	push	{r4, r5, r6, lr}
3400e35e:	460c      	mov	r4, r1
3400e360:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3400e364:	b096      	sub	sp, #88	@ 0x58
3400e366:	4615      	mov	r5, r2
3400e368:	2900      	cmp	r1, #0
3400e36a:	461e      	mov	r6, r3
3400e36c:	da0c      	bge.n	3400e388 <__swhatbuf_r+0x2c>
3400e36e:	89a3      	ldrh	r3, [r4, #12]
3400e370:	2100      	movs	r1, #0
3400e372:	f013 0f80 	tst.w	r3, #128	@ 0x80
3400e376:	bf14      	ite	ne
3400e378:	2340      	movne	r3, #64	@ 0x40
3400e37a:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
3400e37e:	2000      	movs	r0, #0
3400e380:	6031      	str	r1, [r6, #0]
3400e382:	602b      	str	r3, [r5, #0]
3400e384:	b016      	add	sp, #88	@ 0x58
3400e386:	bd70      	pop	{r4, r5, r6, pc}
3400e388:	466a      	mov	r2, sp
3400e38a:	f000 f879 	bl	3400e480 <_fstat_r>
3400e38e:	2800      	cmp	r0, #0
3400e390:	dbed      	blt.n	3400e36e <__swhatbuf_r+0x12>
3400e392:	9901      	ldr	r1, [sp, #4]
3400e394:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
3400e398:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
3400e39c:	4259      	negs	r1, r3
3400e39e:	4159      	adcs	r1, r3
3400e3a0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3400e3a4:	e7eb      	b.n	3400e37e <__swhatbuf_r+0x22>

3400e3a6 <__smakebuf_r>:
3400e3a6:	898b      	ldrh	r3, [r1, #12]
3400e3a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400e3aa:	079d      	lsls	r5, r3, #30
3400e3ac:	4606      	mov	r6, r0
3400e3ae:	460c      	mov	r4, r1
3400e3b0:	d507      	bpl.n	3400e3c2 <__smakebuf_r+0x1c>
3400e3b2:	f104 0347 	add.w	r3, r4, #71	@ 0x47
3400e3b6:	6023      	str	r3, [r4, #0]
3400e3b8:	6123      	str	r3, [r4, #16]
3400e3ba:	2301      	movs	r3, #1
3400e3bc:	6163      	str	r3, [r4, #20]
3400e3be:	b003      	add	sp, #12
3400e3c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
3400e3c2:	ab01      	add	r3, sp, #4
3400e3c4:	466a      	mov	r2, sp
3400e3c6:	f7ff ffc9 	bl	3400e35c <__swhatbuf_r>
3400e3ca:	9f00      	ldr	r7, [sp, #0]
3400e3cc:	4605      	mov	r5, r0
3400e3ce:	4630      	mov	r0, r6
3400e3d0:	4639      	mov	r1, r7
3400e3d2:	f7fe fecd 	bl	3400d170 <_malloc_r>
3400e3d6:	b948      	cbnz	r0, 3400e3ec <__smakebuf_r+0x46>
3400e3d8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3400e3dc:	059a      	lsls	r2, r3, #22
3400e3de:	d4ee      	bmi.n	3400e3be <__smakebuf_r+0x18>
3400e3e0:	f023 0303 	bic.w	r3, r3, #3
3400e3e4:	f043 0302 	orr.w	r3, r3, #2
3400e3e8:	81a3      	strh	r3, [r4, #12]
3400e3ea:	e7e2      	b.n	3400e3b2 <__smakebuf_r+0xc>
3400e3ec:	89a3      	ldrh	r3, [r4, #12]
3400e3ee:	6020      	str	r0, [r4, #0]
3400e3f0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
3400e3f4:	81a3      	strh	r3, [r4, #12]
3400e3f6:	9b01      	ldr	r3, [sp, #4]
3400e3f8:	e9c4 0704 	strd	r0, r7, [r4, #16]
3400e3fc:	b15b      	cbz	r3, 3400e416 <__smakebuf_r+0x70>
3400e3fe:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
3400e402:	4630      	mov	r0, r6
3400e404:	f000 f84e 	bl	3400e4a4 <_isatty_r>
3400e408:	b128      	cbz	r0, 3400e416 <__smakebuf_r+0x70>
3400e40a:	89a3      	ldrh	r3, [r4, #12]
3400e40c:	f023 0303 	bic.w	r3, r3, #3
3400e410:	f043 0301 	orr.w	r3, r3, #1
3400e414:	81a3      	strh	r3, [r4, #12]
3400e416:	89a3      	ldrh	r3, [r4, #12]
3400e418:	431d      	orrs	r5, r3
3400e41a:	81a5      	strh	r5, [r4, #12]
3400e41c:	e7cf      	b.n	3400e3be <__smakebuf_r+0x18>

3400e41e <_raise_r>:
3400e41e:	291f      	cmp	r1, #31
3400e420:	b538      	push	{r3, r4, r5, lr}
3400e422:	4605      	mov	r5, r0
3400e424:	460c      	mov	r4, r1
3400e426:	d904      	bls.n	3400e432 <_raise_r+0x14>
3400e428:	2316      	movs	r3, #22
3400e42a:	6003      	str	r3, [r0, #0]
3400e42c:	f04f 30ff 	mov.w	r0, #4294967295
3400e430:	bd38      	pop	{r3, r4, r5, pc}
3400e432:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
3400e434:	b112      	cbz	r2, 3400e43c <_raise_r+0x1e>
3400e436:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
3400e43a:	b94b      	cbnz	r3, 3400e450 <_raise_r+0x32>
3400e43c:	4628      	mov	r0, r5
3400e43e:	f000 f853 	bl	3400e4e8 <_getpid_r>
3400e442:	4622      	mov	r2, r4
3400e444:	4601      	mov	r1, r0
3400e446:	4628      	mov	r0, r5
3400e448:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
3400e44c:	f000 b83a 	b.w	3400e4c4 <_kill_r>
3400e450:	2b01      	cmp	r3, #1
3400e452:	d00a      	beq.n	3400e46a <_raise_r+0x4c>
3400e454:	1c59      	adds	r1, r3, #1
3400e456:	d103      	bne.n	3400e460 <_raise_r+0x42>
3400e458:	2316      	movs	r3, #22
3400e45a:	6003      	str	r3, [r0, #0]
3400e45c:	2001      	movs	r0, #1
3400e45e:	e7e7      	b.n	3400e430 <_raise_r+0x12>
3400e460:	2100      	movs	r1, #0
3400e462:	4620      	mov	r0, r4
3400e464:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
3400e468:	4798      	blx	r3
3400e46a:	2000      	movs	r0, #0
3400e46c:	e7e0      	b.n	3400e430 <_raise_r+0x12>
	...

3400e470 <raise>:
3400e470:	4b02      	ldr	r3, [pc, #8]	@ (3400e47c <raise+0xc>)
3400e472:	4601      	mov	r1, r0
3400e474:	6818      	ldr	r0, [r3, #0]
3400e476:	f7ff bfd2 	b.w	3400e41e <_raise_r>
3400e47a:	bf00      	nop
3400e47c:	34013bf8 	.word	0x34013bf8

3400e480 <_fstat_r>:
3400e480:	b538      	push	{r3, r4, r5, lr}
3400e482:	2300      	movs	r3, #0
3400e484:	4d06      	ldr	r5, [pc, #24]	@ (3400e4a0 <_fstat_r+0x20>)
3400e486:	4604      	mov	r4, r0
3400e488:	4608      	mov	r0, r1
3400e48a:	4611      	mov	r1, r2
3400e48c:	602b      	str	r3, [r5, #0]
3400e48e:	f000 fecb 	bl	3400f228 <_fstat>
3400e492:	1c43      	adds	r3, r0, #1
3400e494:	d102      	bne.n	3400e49c <_fstat_r+0x1c>
3400e496:	682b      	ldr	r3, [r5, #0]
3400e498:	b103      	cbz	r3, 3400e49c <_fstat_r+0x1c>
3400e49a:	6023      	str	r3, [r4, #0]
3400e49c:	bd38      	pop	{r3, r4, r5, pc}
3400e49e:	bf00      	nop
3400e4a0:	340d05c0 	.word	0x340d05c0

3400e4a4 <_isatty_r>:
3400e4a4:	b538      	push	{r3, r4, r5, lr}
3400e4a6:	2300      	movs	r3, #0
3400e4a8:	4d05      	ldr	r5, [pc, #20]	@ (3400e4c0 <_isatty_r+0x1c>)
3400e4aa:	4604      	mov	r4, r0
3400e4ac:	4608      	mov	r0, r1
3400e4ae:	602b      	str	r3, [r5, #0]
3400e4b0:	f000 feca 	bl	3400f248 <_isatty>
3400e4b4:	1c43      	adds	r3, r0, #1
3400e4b6:	d102      	bne.n	3400e4be <_isatty_r+0x1a>
3400e4b8:	682b      	ldr	r3, [r5, #0]
3400e4ba:	b103      	cbz	r3, 3400e4be <_isatty_r+0x1a>
3400e4bc:	6023      	str	r3, [r4, #0]
3400e4be:	bd38      	pop	{r3, r4, r5, pc}
3400e4c0:	340d05c0 	.word	0x340d05c0

3400e4c4 <_kill_r>:
3400e4c4:	b538      	push	{r3, r4, r5, lr}
3400e4c6:	2300      	movs	r3, #0
3400e4c8:	4d06      	ldr	r5, [pc, #24]	@ (3400e4e4 <_kill_r+0x20>)
3400e4ca:	4604      	mov	r4, r0
3400e4cc:	4608      	mov	r0, r1
3400e4ce:	4611      	mov	r1, r2
3400e4d0:	602b      	str	r3, [r5, #0]
3400e4d2:	f000 fec1 	bl	3400f258 <_kill>
3400e4d6:	1c43      	adds	r3, r0, #1
3400e4d8:	d102      	bne.n	3400e4e0 <_kill_r+0x1c>
3400e4da:	682b      	ldr	r3, [r5, #0]
3400e4dc:	b103      	cbz	r3, 3400e4e0 <_kill_r+0x1c>
3400e4de:	6023      	str	r3, [r4, #0]
3400e4e0:	bd38      	pop	{r3, r4, r5, pc}
3400e4e2:	bf00      	nop
3400e4e4:	340d05c0 	.word	0x340d05c0

3400e4e8 <_getpid_r>:
3400e4e8:	f000 bea6 	b.w	3400f238 <_getpid>

3400e4ec <memchr>:
3400e4ec:	b2c9      	uxtb	r1, r1
3400e4ee:	4603      	mov	r3, r0
3400e4f0:	4402      	add	r2, r0
3400e4f2:	b510      	push	{r4, lr}
3400e4f4:	4293      	cmp	r3, r2
3400e4f6:	4618      	mov	r0, r3
3400e4f8:	d101      	bne.n	3400e4fe <memchr+0x12>
3400e4fa:	2000      	movs	r0, #0
3400e4fc:	e003      	b.n	3400e506 <memchr+0x1a>
3400e4fe:	7804      	ldrb	r4, [r0, #0]
3400e500:	3301      	adds	r3, #1
3400e502:	428c      	cmp	r4, r1
3400e504:	d1f6      	bne.n	3400e4f4 <memchr+0x8>
3400e506:	bd10      	pop	{r4, pc}

3400e508 <log10>:
3400e508:	b508      	push	{r3, lr}
3400e50a:	ed2d 8b02 	vpush	{d8}
3400e50e:	eeb0 8b40 	vmov.f64	d8, d0
3400e512:	f000 fd19 	bl	3400ef48 <__ieee754_log10>
3400e516:	eeb4 8b48 	vcmp.f64	d8, d8
3400e51a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400e51e:	d60f      	bvs.n	3400e540 <log10+0x38>
3400e520:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
3400e524:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400e528:	d80a      	bhi.n	3400e540 <log10+0x38>
3400e52a:	eeb5 8b40 	vcmp.f64	d8, #0.0
3400e52e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400e532:	d108      	bne.n	3400e546 <log10+0x3e>
3400e534:	f7ff fa4c 	bl	3400d9d0 <__errno>
3400e538:	2322      	movs	r3, #34	@ 0x22
3400e53a:	ed9f 0b09 	vldr	d0, [pc, #36]	@ 3400e560 <log10+0x58>
3400e53e:	6003      	str	r3, [r0, #0]
3400e540:	ecbd 8b02 	vpop	{d8}
3400e544:	bd08      	pop	{r3, pc}
3400e546:	f7ff fa43 	bl	3400d9d0 <__errno>
3400e54a:	2321      	movs	r3, #33	@ 0x21
3400e54c:	ecbd 8b02 	vpop	{d8}
3400e550:	6003      	str	r3, [r0, #0]
3400e552:	4805      	ldr	r0, [pc, #20]	@ (3400e568 <log10+0x60>)
3400e554:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
3400e558:	f000 b82a 	b.w	3400e5b0 <nan>
3400e55c:	f3af 8000 	nop.w
3400e560:	00000000 	.word	0x00000000
3400e564:	fff00000 	.word	0xfff00000
3400e568:	34010c2e 	.word	0x34010c2e
3400e56c:	00000000 	.word	0x00000000

3400e570 <sqrt>:
3400e570:	b508      	push	{r3, lr}
3400e572:	ed2d 8b04 	vpush	{d8-d9}
3400e576:	eeb0 8b40 	vmov.f64	d8, d0
3400e57a:	f000 fce2 	bl	3400ef42 <__ieee754_sqrt>
3400e57e:	eeb4 8b48 	vcmp.f64	d8, d8
3400e582:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400e586:	d60c      	bvs.n	3400e5a2 <sqrt+0x32>
3400e588:	ed9f 9b07 	vldr	d9, [pc, #28]	@ 3400e5a8 <sqrt+0x38>
3400e58c:	eeb4 8bc9 	vcmpe.f64	d8, d9
3400e590:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400e594:	d505      	bpl.n	3400e5a2 <sqrt+0x32>
3400e596:	f7ff fa1b 	bl	3400d9d0 <__errno>
3400e59a:	ee89 0b09 	vdiv.f64	d0, d9, d9
3400e59e:	2321      	movs	r3, #33	@ 0x21
3400e5a0:	6003      	str	r3, [r0, #0]
3400e5a2:	ecbd 8b04 	vpop	{d8-d9}
3400e5a6:	bd08      	pop	{r3, pc}
	...

3400e5b0 <nan>:
3400e5b0:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3400e5b8 <nan+0x8>
3400e5b4:	4770      	bx	lr
3400e5b6:	bf00      	nop
3400e5b8:	00000000 	.word	0x00000000
3400e5bc:	7ff80000 	.word	0x7ff80000

3400e5c0 <with_errno>:
3400e5c0:	b510      	push	{r4, lr}
3400e5c2:	ed2d 8b02 	vpush	{d8}
3400e5c6:	eeb0 8b40 	vmov.f64	d8, d0
3400e5ca:	4604      	mov	r4, r0
3400e5cc:	f7ff fa00 	bl	3400d9d0 <__errno>
3400e5d0:	6004      	str	r4, [r0, #0]
3400e5d2:	eeb0 0b48 	vmov.f64	d0, d8
3400e5d6:	ecbd 8b02 	vpop	{d8}
3400e5da:	bd10      	pop	{r4, pc}

3400e5dc <xflow>:
3400e5dc:	b082      	sub	sp, #8
3400e5de:	b158      	cbz	r0, 3400e5f8 <xflow+0x1c>
3400e5e0:	eeb1 7b40 	vneg.f64	d7, d0
3400e5e4:	2022      	movs	r0, #34	@ 0x22
3400e5e6:	ed8d 7b00 	vstr	d7, [sp]
3400e5ea:	ed9d 7b00 	vldr	d7, [sp]
3400e5ee:	ee20 0b07 	vmul.f64	d0, d0, d7
3400e5f2:	b002      	add	sp, #8
3400e5f4:	f7ff bfe4 	b.w	3400e5c0 <with_errno>
3400e5f8:	eeb0 7b40 	vmov.f64	d7, d0
3400e5fc:	e7f2      	b.n	3400e5e4 <xflow+0x8>
	...

3400e600 <__math_uflow>:
3400e600:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3400e608 <__math_uflow+0x8>
3400e604:	f7ff bfea 	b.w	3400e5dc <xflow>
3400e608:	00000000 	.word	0x00000000
3400e60c:	10000000 	.word	0x10000000

3400e610 <__math_oflow>:
3400e610:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3400e618 <__math_oflow+0x8>
3400e614:	f7ff bfe2 	b.w	3400e5dc <xflow>
3400e618:	00000000 	.word	0x00000000
3400e61c:	70000000 	.word	0x70000000

3400e620 <__math_divzero>:
3400e620:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
3400e624:	b082      	sub	sp, #8
3400e626:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
3400e62a:	2800      	cmp	r0, #0
3400e62c:	f04f 0022 	mov.w	r0, #34	@ 0x22
3400e630:	fe07 7b06 	vseleq.f64	d7, d7, d6
3400e634:	ed8d 7b00 	vstr	d7, [sp]
3400e638:	ed9d 0b00 	vldr	d0, [sp]
3400e63c:	ed9f 7b04 	vldr	d7, [pc, #16]	@ 3400e650 <__math_divzero+0x30>
3400e640:	ee80 0b07 	vdiv.f64	d0, d0, d7
3400e644:	b002      	add	sp, #8
3400e646:	f7ff bfbb 	b.w	3400e5c0 <with_errno>
3400e64a:	bf00      	nop
3400e64c:	f3af 8000 	nop.w
	...

3400e658 <__math_invalid>:
3400e658:	eeb0 7b40 	vmov.f64	d7, d0
3400e65c:	ee30 6b40 	vsub.f64	d6, d0, d0
3400e660:	eeb4 7b47 	vcmp.f64	d7, d7
3400e664:	ee86 0b06 	vdiv.f64	d0, d6, d6
3400e668:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400e66c:	d602      	bvs.n	3400e674 <__math_invalid+0x1c>
3400e66e:	2021      	movs	r0, #33	@ 0x21
3400e670:	f7ff bfa6 	b.w	3400e5c0 <with_errno>
3400e674:	4770      	bx	lr

3400e676 <__math_check_uflow>:
3400e676:	eeb5 0b40 	vcmp.f64	d0, #0.0
3400e67a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400e67e:	d102      	bne.n	3400e686 <__math_check_uflow+0x10>
3400e680:	2022      	movs	r0, #34	@ 0x22
3400e682:	f7ff bf9d 	b.w	3400e5c0 <with_errno>
3400e686:	4770      	bx	lr

3400e688 <__math_check_oflow>:
3400e688:	eeb0 7bc0 	vabs.f64	d7, d0
3400e68c:	ed9f 6b06 	vldr	d6, [pc, #24]	@ 3400e6a8 <__math_check_oflow+0x20>
3400e690:	eeb4 7b46 	vcmp.f64	d7, d6
3400e694:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400e698:	dd02      	ble.n	3400e6a0 <__math_check_oflow+0x18>
3400e69a:	2022      	movs	r0, #34	@ 0x22
3400e69c:	f7ff bf90 	b.w	3400e5c0 <with_errno>
3400e6a0:	4770      	bx	lr
3400e6a2:	bf00      	nop
3400e6a4:	f3af 8000 	nop.w
3400e6a8:	ffffffff 	.word	0xffffffff
3400e6ac:	7fefffff 	.word	0x7fefffff

3400e6b0 <checkint>:
3400e6b0:	f3c1 520a 	ubfx	r2, r1, #20, #11
3400e6b4:	f240 33fe 	movw	r3, #1022	@ 0x3fe
3400e6b8:	429a      	cmp	r2, r3
3400e6ba:	b570      	push	{r4, r5, r6, lr}
3400e6bc:	dd2a      	ble.n	3400e714 <checkint+0x64>
3400e6be:	f240 4333 	movw	r3, #1075	@ 0x433
3400e6c2:	429a      	cmp	r2, r3
3400e6c4:	dc24      	bgt.n	3400e710 <checkint+0x60>
3400e6c6:	1a9b      	subs	r3, r3, r2
3400e6c8:	f04f 32ff 	mov.w	r2, #4294967295
3400e6cc:	f1a3 0620 	sub.w	r6, r3, #32
3400e6d0:	fa02 f403 	lsl.w	r4, r2, r3
3400e6d4:	f1c3 0520 	rsb	r5, r3, #32
3400e6d8:	fa02 f606 	lsl.w	r6, r2, r6
3400e6dc:	fa22 f505 	lsr.w	r5, r2, r5
3400e6e0:	409a      	lsls	r2, r3
3400e6e2:	4334      	orrs	r4, r6
3400e6e4:	ea20 0202 	bic.w	r2, r0, r2
3400e6e8:	432c      	orrs	r4, r5
3400e6ea:	ea21 0404 	bic.w	r4, r1, r4
3400e6ee:	4322      	orrs	r2, r4
3400e6f0:	f1a3 0420 	sub.w	r4, r3, #32
3400e6f4:	f1c3 0220 	rsb	r2, r3, #32
3400e6f8:	d10c      	bne.n	3400e714 <checkint+0x64>
3400e6fa:	40d8      	lsrs	r0, r3
3400e6fc:	fa01 f302 	lsl.w	r3, r1, r2
3400e700:	40e1      	lsrs	r1, r4
3400e702:	4318      	orrs	r0, r3
3400e704:	4308      	orrs	r0, r1
3400e706:	f000 0001 	and.w	r0, r0, #1
3400e70a:	f1d0 0002 	rsbs	r0, r0, #2
3400e70e:	bd70      	pop	{r4, r5, r6, pc}
3400e710:	2002      	movs	r0, #2
3400e712:	e7fc      	b.n	3400e70e <checkint+0x5e>
3400e714:	2000      	movs	r0, #0
3400e716:	e7fa      	b.n	3400e70e <checkint+0x5e>

3400e718 <pow>:
3400e718:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400e71c:	ee10 4a90 	vmov	r4, s1
3400e720:	f240 73fd 	movw	r3, #2045	@ 0x7fd
3400e724:	ee11 aa90 	vmov	sl, s3
3400e728:	ee10 5a10 	vmov	r5, s0
3400e72c:	ea4f 5814 	mov.w	r8, r4, lsr #20
3400e730:	ee11 0a10 	vmov	r0, s2
3400e734:	ea4f 561a 	mov.w	r6, sl, lsr #20
3400e738:	f108 32ff 	add.w	r2, r8, #4294967295
3400e73c:	46c4      	mov	ip, r8
3400e73e:	429a      	cmp	r2, r3
3400e740:	ed2d 8b0a 	vpush	{d8-d12}
3400e744:	b087      	sub	sp, #28
3400e746:	d806      	bhi.n	3400e756 <pow+0x3e>
3400e748:	f3c6 030a 	ubfx	r3, r6, #0, #11
3400e74c:	f2a3 33be 	subw	r3, r3, #958	@ 0x3be
3400e750:	2b7f      	cmp	r3, #127	@ 0x7f
3400e752:	f240 8157 	bls.w	3400ea04 <pow+0x2ec>
3400e756:	1802      	adds	r2, r0, r0
3400e758:	f06f 0b01 	mvn.w	fp, #1
3400e75c:	f46f 1e00 	mvn.w	lr, #2097152	@ 0x200000
3400e760:	eb4a 010a 	adc.w	r1, sl, sl
3400e764:	1e57      	subs	r7, r2, #1
3400e766:	f141 33ff 	adc.w	r3, r1, #4294967295
3400e76a:	45bb      	cmp	fp, r7
3400e76c:	eb7e 0303 	sbcs.w	r3, lr, r3
3400e770:	d242      	bcs.n	3400e7f8 <pow+0xe0>
3400e772:	ea52 0301 	orrs.w	r3, r2, r1
3400e776:	f04f 0300 	mov.w	r3, #0
3400e77a:	d10c      	bne.n	3400e796 <pow+0x7e>
3400e77c:	196d      	adds	r5, r5, r5
3400e77e:	f484 2400 	eor.w	r4, r4, #524288	@ 0x80000
3400e782:	4164      	adcs	r4, r4
3400e784:	42ab      	cmp	r3, r5
3400e786:	f5a3 1380 	sub.w	r3, r3, #1048576	@ 0x100000
3400e78a:	41a3      	sbcs	r3, r4
3400e78c:	f0c0 808f 	bcc.w	3400e8ae <pow+0x196>
3400e790:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3400e794:	e02b      	b.n	3400e7ee <pow+0xd6>
3400e796:	4ed4      	ldr	r6, [pc, #848]	@ (3400eae8 <pow+0x3d0>)
3400e798:	42b4      	cmp	r4, r6
3400e79a:	bf08      	it	eq
3400e79c:	429d      	cmpeq	r5, r3
3400e79e:	d109      	bne.n	3400e7b4 <pow+0x9c>
3400e7a0:	1800      	adds	r0, r0, r0
3400e7a2:	f48a 2a00 	eor.w	sl, sl, #524288	@ 0x80000
3400e7a6:	eb4a 0a0a 	adc.w	sl, sl, sl
3400e7aa:	4283      	cmp	r3, r0
3400e7ac:	4bcf      	ldr	r3, [pc, #828]	@ (3400eaec <pow+0x3d4>)
3400e7ae:	eb73 030a 	sbcs.w	r3, r3, sl
3400e7b2:	e7eb      	b.n	3400e78c <pow+0x74>
3400e7b4:	196d      	adds	r5, r5, r5
3400e7b6:	48ce      	ldr	r0, [pc, #824]	@ (3400eaf0 <pow+0x3d8>)
3400e7b8:	4164      	adcs	r4, r4
3400e7ba:	42ab      	cmp	r3, r5
3400e7bc:	eb70 0604 	sbcs.w	r6, r0, r4
3400e7c0:	d375      	bcc.n	3400e8ae <pow+0x196>
3400e7c2:	4281      	cmp	r1, r0
3400e7c4:	bf08      	it	eq
3400e7c6:	429a      	cmpeq	r2, r3
3400e7c8:	d171      	bne.n	3400e8ae <pow+0x196>
3400e7ca:	4aca      	ldr	r2, [pc, #808]	@ (3400eaf4 <pow+0x3dc>)
3400e7cc:	4294      	cmp	r4, r2
3400e7ce:	bf08      	it	eq
3400e7d0:	429d      	cmpeq	r5, r3
3400e7d2:	d0dd      	beq.n	3400e790 <pow+0x78>
3400e7d4:	4294      	cmp	r4, r2
3400e7d6:	ea6f 0a0a 	mvn.w	sl, sl
3400e7da:	bf34      	ite	cc
3400e7dc:	2400      	movcc	r4, #0
3400e7de:	2401      	movcs	r4, #1
3400e7e0:	ea4f 7ada 	mov.w	sl, sl, lsr #31
3400e7e4:	4554      	cmp	r4, sl
3400e7e6:	f040 81dc 	bne.w	3400eba2 <pow+0x48a>
3400e7ea:	ee21 0b01 	vmul.f64	d0, d1, d1
3400e7ee:	b007      	add	sp, #28
3400e7f0:	ecbd 8b0a 	vpop	{d8-d12}
3400e7f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400e7f8:	196f      	adds	r7, r5, r5
3400e7fa:	eb44 0904 	adc.w	r9, r4, r4
3400e7fe:	1e7a      	subs	r2, r7, #1
3400e800:	f169 0300 	sbc.w	r3, r9, #0
3400e804:	4593      	cmp	fp, r2
3400e806:	eb7e 0303 	sbcs.w	r3, lr, r3
3400e80a:	d225      	bcs.n	3400e858 <pow+0x140>
3400e80c:	2c00      	cmp	r4, #0
3400e80e:	ee20 0b00 	vmul.f64	d0, d0, d0
3400e812:	da13      	bge.n	3400e83c <pow+0x124>
3400e814:	4651      	mov	r1, sl
3400e816:	f7ff ff4b 	bl	3400e6b0 <checkint>
3400e81a:	2801      	cmp	r0, #1
3400e81c:	d10e      	bne.n	3400e83c <pow+0x124>
3400e81e:	eeb1 0b40 	vneg.f64	d0, d0
3400e822:	ea57 0909 	orrs.w	r9, r7, r9
3400e826:	d10b      	bne.n	3400e840 <pow+0x128>
3400e828:	f1ba 0f00 	cmp.w	sl, #0
3400e82c:	dadf      	bge.n	3400e7ee <pow+0xd6>
3400e82e:	b007      	add	sp, #28
3400e830:	ecbd 8b0a 	vpop	{d8-d12}
3400e834:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400e838:	f7ff bef2 	b.w	3400e620 <__math_divzero>
3400e83c:	2000      	movs	r0, #0
3400e83e:	e7f0      	b.n	3400e822 <pow+0x10a>
3400e840:	f1ba 0f00 	cmp.w	sl, #0
3400e844:	dad3      	bge.n	3400e7ee <pow+0xd6>
3400e846:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
3400e84a:	ee86 7b00 	vdiv.f64	d7, d6, d0
3400e84e:	ed8d 7b00 	vstr	d7, [sp]
3400e852:	ed9d 0b00 	vldr	d0, [sp]
3400e856:	e7ca      	b.n	3400e7ee <pow+0xd6>
3400e858:	2c00      	cmp	r4, #0
3400e85a:	da2b      	bge.n	3400e8b4 <pow+0x19c>
3400e85c:	4651      	mov	r1, sl
3400e85e:	f7ff ff27 	bl	3400e6b0 <checkint>
3400e862:	b930      	cbnz	r0, 3400e872 <pow+0x15a>
3400e864:	b007      	add	sp, #28
3400e866:	ecbd 8b0a 	vpop	{d8-d12}
3400e86a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400e86e:	f7ff bef3 	b.w	3400e658 <__math_invalid>
3400e872:	1e41      	subs	r1, r0, #1
3400e874:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
3400e878:	f3c8 0c0a 	ubfx	ip, r8, #0, #11
3400e87c:	4248      	negs	r0, r1
3400e87e:	4148      	adcs	r0, r1
3400e880:	0480      	lsls	r0, r0, #18
3400e882:	f3c6 020a 	ubfx	r2, r6, #0, #11
3400e886:	f2a2 33be 	subw	r3, r2, #958	@ 0x3be
3400e88a:	2b7f      	cmp	r3, #127	@ 0x7f
3400e88c:	d92d      	bls.n	3400e8ea <pow+0x1d2>
3400e88e:	2000      	movs	r0, #0
3400e890:	4b95      	ldr	r3, [pc, #596]	@ (3400eae8 <pow+0x3d0>)
3400e892:	429c      	cmp	r4, r3
3400e894:	bf08      	it	eq
3400e896:	4285      	cmpeq	r5, r0
3400e898:	f43f af7a 	beq.w	3400e790 <pow+0x78>
3400e89c:	f240 31bd 	movw	r1, #957	@ 0x3bd
3400e8a0:	428a      	cmp	r2, r1
3400e8a2:	d80c      	bhi.n	3400e8be <pow+0x1a6>
3400e8a4:	42a8      	cmp	r0, r5
3400e8a6:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3400e8aa:	41a3      	sbcs	r3, r4
3400e8ac:	d204      	bcs.n	3400e8b8 <pow+0x1a0>
3400e8ae:	ee31 0b00 	vadd.f64	d0, d1, d0
3400e8b2:	e79c      	b.n	3400e7ee <pow+0xd6>
3400e8b4:	2000      	movs	r0, #0
3400e8b6:	e7e4      	b.n	3400e882 <pow+0x16a>
3400e8b8:	ee30 0b41 	vsub.f64	d0, d0, d1
3400e8bc:	e797      	b.n	3400e7ee <pow+0xd6>
3400e8be:	2d01      	cmp	r5, #1
3400e8c0:	f240 72ff 	movw	r2, #2047	@ 0x7ff
3400e8c4:	eb74 0303 	sbcs.w	r3, r4, r3
3400e8c8:	bf34      	ite	cc
3400e8ca:	2301      	movcc	r3, #1
3400e8cc:	2300      	movcs	r3, #0
3400e8ce:	4296      	cmp	r6, r2
3400e8d0:	bf8c      	ite	hi
3400e8d2:	2600      	movhi	r6, #0
3400e8d4:	2601      	movls	r6, #1
3400e8d6:	42b3      	cmp	r3, r6
3400e8d8:	f000 809c 	beq.w	3400ea14 <pow+0x2fc>
3400e8dc:	b007      	add	sp, #28
3400e8de:	ecbd 8b0a 	vpop	{d8-d12}
3400e8e2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400e8e6:	f7ff be93 	b.w	3400e610 <__math_oflow>
3400e8ea:	f1bc 0f00 	cmp.w	ip, #0
3400e8ee:	d10a      	bne.n	3400e906 <pow+0x1ee>
3400e8f0:	ed9f 7b79 	vldr	d7, [pc, #484]	@ 3400ead8 <pow+0x3c0>
3400e8f4:	ee20 7b07 	vmul.f64	d7, d0, d7
3400e8f8:	ec53 2b17 	vmov	r2, r3, d7
3400e8fc:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
3400e900:	4615      	mov	r5, r2
3400e902:	f1a4 7450 	sub.w	r4, r4, #54525952	@ 0x3400000
3400e906:	4a7c      	ldr	r2, [pc, #496]	@ (3400eaf8 <pow+0x3e0>)
3400e908:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
3400e90c:	4422      	add	r2, r4
3400e90e:	1513      	asrs	r3, r2, #20
3400e910:	f3c2 3146 	ubfx	r1, r2, #13, #7
3400e914:	f36f 0213 	bfc	r2, #0, #20
3400e918:	ee03 3a10 	vmov	s6, r3
3400e91c:	4b77      	ldr	r3, [pc, #476]	@ (3400eafc <pow+0x3e4>)
3400e91e:	1aa7      	subs	r7, r4, r2
3400e920:	eb03 1641 	add.w	r6, r3, r1, lsl #5
3400e924:	eeb8 3bc3 	vcvt.f64.s32	d3, s6
3400e928:	eb03 1241 	add.w	r2, r3, r1, lsl #5
3400e92c:	ed96 7b18 	vldr	d7, [r6, #96]	@ 0x60
3400e930:	ed92 5b12 	vldr	d5, [r2, #72]	@ 0x48
3400e934:	1e2e      	subs	r6, r5, #0
3400e936:	ec47 6b14 	vmov	d4, r6, r7
3400e93a:	eea4 6b05 	vfma.f64	d6, d4, d5
3400e93e:	ed92 2b16 	vldr	d2, [r2, #88]	@ 0x58
3400e942:	ed93 5b00 	vldr	d5, [r3]
3400e946:	ed93 cb10 	vldr	d12, [r3, #64]	@ 0x40
3400e94a:	f46f 7272 	mvn.w	r2, #968	@ 0x3c8
3400e94e:	eea3 2b05 	vfma.f64	d2, d3, d5
3400e952:	ed93 5b02 	vldr	d5, [r3, #8]
3400e956:	eea3 7b05 	vfma.f64	d7, d3, d5
3400e95a:	ee36 4b02 	vadd.f64	d4, d6, d2
3400e95e:	ed93 5b04 	vldr	d5, [r3, #16]
3400e962:	ee32 2b44 	vsub.f64	d2, d2, d4
3400e966:	ee26 5b05 	vmul.f64	d5, d6, d5
3400e96a:	ee32 2b06 	vadd.f64	d2, d2, d6
3400e96e:	ed93 3b0c 	vldr	d3, [r3, #48]	@ 0x30
3400e972:	ee26 0b05 	vmul.f64	d0, d6, d5
3400e976:	ee37 7b02 	vadd.f64	d7, d7, d2
3400e97a:	ee34 8b00 	vadd.f64	d8, d4, d0
3400e97e:	eeb0 9b40 	vmov.f64	d9, d0
3400e982:	ee26 bb00 	vmul.f64	d11, d6, d0
3400e986:	ee34 4b48 	vsub.f64	d4, d4, d8
3400e98a:	ee96 9b05 	vfnms.f64	d9, d6, d5
3400e98e:	ee34 ab00 	vadd.f64	d10, d4, d0
3400e992:	ed93 5b06 	vldr	d5, [r3, #24]
3400e996:	ed93 4b08 	vldr	d4, [r3, #32]
3400e99a:	eea6 5b04 	vfma.f64	d5, d6, d4
3400e99e:	ee37 7b09 	vadd.f64	d7, d7, d9
3400e9a2:	ed93 4b0a 	vldr	d4, [r3, #40]	@ 0x28
3400e9a6:	ee37 7b0a 	vadd.f64	d7, d7, d10
3400e9aa:	eea6 4b03 	vfma.f64	d4, d6, d3
3400e9ae:	ed93 3b0e 	vldr	d3, [r3, #56]	@ 0x38
3400e9b2:	eea6 3b0c 	vfma.f64	d3, d6, d12
3400e9b6:	eea0 4b03 	vfma.f64	d4, d0, d3
3400e9ba:	eea0 5b04 	vfma.f64	d5, d0, d4
3400e9be:	eeab 7b05 	vfma.f64	d7, d11, d5
3400e9c2:	ee38 4b07 	vadd.f64	d4, d8, d7
3400e9c6:	ee21 6b04 	vmul.f64	d6, d1, d4
3400e9ca:	ee38 8b44 	vsub.f64	d8, d8, d4
3400e9ce:	eeb0 5b46 	vmov.f64	d5, d6
3400e9d2:	ee16 3a90 	vmov	r3, s13
3400e9d6:	ee38 8b07 	vadd.f64	d8, d8, d7
3400e9da:	f3c3 560a 	ubfx	r6, r3, #20, #11
3400e9de:	ee91 5b04 	vfnms.f64	d5, d1, d4
3400e9e2:	18b2      	adds	r2, r6, r2
3400e9e4:	2a3e      	cmp	r2, #62	@ 0x3e
3400e9e6:	eea1 5b08 	vfma.f64	d5, d1, d8
3400e9ea:	d91b      	bls.n	3400ea24 <pow+0x30c>
3400e9ec:	2a00      	cmp	r2, #0
3400e9ee:	da0b      	bge.n	3400ea08 <pow+0x2f0>
3400e9f0:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3400e9f4:	ee36 0b00 	vadd.f64	d0, d6, d0
3400e9f8:	2800      	cmp	r0, #0
3400e9fa:	f43f aef8 	beq.w	3400e7ee <pow+0xd6>
3400e9fe:	eeb1 0b40 	vneg.f64	d0, d0
3400ea02:	e6f4      	b.n	3400e7ee <pow+0xd6>
3400ea04:	2000      	movs	r0, #0
3400ea06:	e77e      	b.n	3400e906 <pow+0x1ee>
3400ea08:	f5b6 6f81 	cmp.w	r6, #1032	@ 0x408
3400ea0c:	d909      	bls.n	3400ea22 <pow+0x30a>
3400ea0e:	2b00      	cmp	r3, #0
3400ea10:	f6bf af64 	bge.w	3400e8dc <pow+0x1c4>
3400ea14:	b007      	add	sp, #28
3400ea16:	ecbd 8b0a 	vpop	{d8-d12}
3400ea1a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400ea1e:	f7ff bdef 	b.w	3400e600 <__math_uflow>
3400ea22:	2600      	movs	r6, #0
3400ea24:	4936      	ldr	r1, [pc, #216]	@ (3400eb00 <pow+0x3e8>)
3400ea26:	2700      	movs	r7, #0
3400ea28:	ed91 4b02 	vldr	d4, [r1, #8]
3400ea2c:	ed91 3b00 	vldr	d3, [r1]
3400ea30:	eeb0 7b44 	vmov.f64	d7, d4
3400ea34:	eea6 7b03 	vfma.f64	d7, d6, d3
3400ea38:	ed91 3b0a 	vldr	d3, [r1, #40]	@ 0x28
3400ea3c:	ee17 5a10 	vmov	r5, s14
3400ea40:	ee37 7b44 	vsub.f64	d7, d7, d4
3400ea44:	ed91 4b04 	vldr	d4, [r1, #16]
3400ea48:	f005 037f 	and.w	r3, r5, #127	@ 0x7f
3400ea4c:	eea7 6b04 	vfma.f64	d6, d7, d4
3400ea50:	18dc      	adds	r4, r3, r3
3400ea52:	1940      	adds	r0, r0, r5
3400ea54:	f104 030f 	add.w	r3, r4, #15
3400ea58:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
3400ea5c:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
3400ea60:	f851 c033 	ldr.w	ip, [r1, r3, lsl #3]
3400ea64:	ed91 4b06 	vldr	d4, [r1, #24]
3400ea68:	f8d2 e004 	ldr.w	lr, [r2, #4]
3400ea6c:	eb17 020c 	adds.w	r2, r7, ip
3400ea70:	eb0e 3340 	add.w	r3, lr, r0, lsl #13
3400ea74:	eea7 6b04 	vfma.f64	d6, d7, d4
3400ea78:	ed91 4b08 	vldr	d4, [r1, #32]
3400ea7c:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
3400ea80:	ee35 5b06 	vadd.f64	d5, d5, d6
3400ea84:	eea5 4b03 	vfma.f64	d4, d5, d3
3400ea88:	ee25 6b05 	vmul.f64	d6, d5, d5
3400ea8c:	ee35 7b07 	vadd.f64	d7, d5, d7
3400ea90:	ed91 3b0e 	vldr	d3, [r1, #56]	@ 0x38
3400ea94:	eea6 7b04 	vfma.f64	d7, d6, d4
3400ea98:	ee26 6b06 	vmul.f64	d6, d6, d6
3400ea9c:	ed91 4b0c 	vldr	d4, [r1, #48]	@ 0x30
3400eaa0:	eea5 4b03 	vfma.f64	d4, d5, d3
3400eaa4:	eea6 7b04 	vfma.f64	d7, d6, d4
3400eaa8:	2e00      	cmp	r6, #0
3400eaaa:	d175      	bne.n	3400eb98 <pow+0x480>
3400eaac:	42bd      	cmp	r5, r7
3400eaae:	db29      	blt.n	3400eb04 <pow+0x3ec>
3400eab0:	f103 4140 	add.w	r1, r3, #3221225472	@ 0xc0000000
3400eab4:	4610      	mov	r0, r2
3400eab6:	f501 0170 	add.w	r1, r1, #15728640	@ 0xf00000
3400eaba:	ec41 0b10 	vmov	d0, r0, r1
3400eabe:	eea7 0b00 	vfma.f64	d0, d7, d0
3400eac2:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 3400eae0 <pow+0x3c8>
3400eac6:	ee20 0b07 	vmul.f64	d0, d0, d7
3400eaca:	b007      	add	sp, #28
3400eacc:	ecbd 8b0a 	vpop	{d8-d12}
3400ead0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400ead4:	f7ff bdd8 	b.w	3400e688 <__math_check_oflow>
3400ead8:	00000000 	.word	0x00000000
3400eadc:	43300000 	.word	0x43300000
3400eae0:	00000000 	.word	0x00000000
3400eae4:	7f000000 	.word	0x7f000000
3400eae8:	3ff00000 	.word	0x3ff00000
3400eaec:	fff00000 	.word	0xfff00000
3400eaf0:	ffe00000 	.word	0xffe00000
3400eaf4:	7fe00000 	.word	0x7fe00000
3400eaf8:	c0196aab 	.word	0xc0196aab
3400eafc:	34011fa8 	.word	0x34011fa8
3400eb00:	34011738 	.word	0x34011738
3400eb04:	f103 517f 	add.w	r1, r3, #1069547520	@ 0x3fc00000
3400eb08:	4610      	mov	r0, r2
3400eb0a:	eeb7 3b00 	vmov.f64	d3, #112	@ 0x3f800000  1.0
3400eb0e:	f501 1100 	add.w	r1, r1, #2097152	@ 0x200000
3400eb12:	ec41 0b15 	vmov	d5, r0, r1
3400eb16:	ee27 6b05 	vmul.f64	d6, d7, d5
3400eb1a:	ed9f 0b23 	vldr	d0, [pc, #140]	@ 3400eba8 <pow+0x490>
3400eb1e:	ee35 7b06 	vadd.f64	d7, d5, d6
3400eb22:	eeb0 4bc7 	vabs.f64	d4, d7
3400eb26:	eeb4 4bc3 	vcmpe.f64	d4, d3
3400eb2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400eb2e:	d52a      	bpl.n	3400eb86 <pow+0x46e>
3400eb30:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
3400eb34:	eebf 4b00 	vmov.f64	d4, #240	@ 0xbf800000 -1.0
3400eb38:	ee35 5b47 	vsub.f64	d5, d5, d7
3400eb3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400eb40:	ee35 5b06 	vadd.f64	d5, d5, d6
3400eb44:	bf58      	it	pl
3400eb46:	eeb0 4b43 	vmovpl.f64	d4, d3
3400eb4a:	ee37 3b04 	vadd.f64	d3, d7, d4
3400eb4e:	ee34 6b43 	vsub.f64	d6, d4, d3
3400eb52:	ee36 6b07 	vadd.f64	d6, d6, d7
3400eb56:	ee36 6b05 	vadd.f64	d6, d6, d5
3400eb5a:	ee36 6b03 	vadd.f64	d6, d6, d3
3400eb5e:	ee36 7b44 	vsub.f64	d7, d6, d4
3400eb62:	eeb5 7b40 	vcmp.f64	d7, #0.0
3400eb66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400eb6a:	d104      	bne.n	3400eb76 <pow+0x45e>
3400eb6c:	4632      	mov	r2, r6
3400eb6e:	f001 4300 	and.w	r3, r1, #2147483648	@ 0x80000000
3400eb72:	ec43 2b17 	vmov	d7, r2, r3
3400eb76:	ed8d 0b02 	vstr	d0, [sp, #8]
3400eb7a:	ed9d 6b02 	vldr	d6, [sp, #8]
3400eb7e:	ee26 6b00 	vmul.f64	d6, d6, d0
3400eb82:	ed8d 6b04 	vstr	d6, [sp, #16]
3400eb86:	ee27 0b00 	vmul.f64	d0, d7, d0
3400eb8a:	b007      	add	sp, #28
3400eb8c:	ecbd 8b0a 	vpop	{d8-d12}
3400eb90:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400eb94:	f7ff bd6f 	b.w	3400e676 <__math_check_uflow>
3400eb98:	ec43 2b10 	vmov	d0, r2, r3
3400eb9c:	eea7 0b00 	vfma.f64	d0, d7, d0
3400eba0:	e625      	b.n	3400e7ee <pow+0xd6>
3400eba2:	ed9f 0b03 	vldr	d0, [pc, #12]	@ 3400ebb0 <pow+0x498>
3400eba6:	e622      	b.n	3400e7ee <pow+0xd6>
3400eba8:	00000000 	.word	0x00000000
3400ebac:	00100000 	.word	0x00100000
	...

3400ebb8 <checkint>:
3400ebb8:	f3c0 53c7 	ubfx	r3, r0, #23, #8
3400ebbc:	2b7e      	cmp	r3, #126	@ 0x7e
3400ebbe:	d910      	bls.n	3400ebe2 <checkint+0x2a>
3400ebc0:	2b96      	cmp	r3, #150	@ 0x96
3400ebc2:	d80c      	bhi.n	3400ebde <checkint+0x26>
3400ebc4:	2201      	movs	r2, #1
3400ebc6:	f1c3 0396 	rsb	r3, r3, #150	@ 0x96
3400ebca:	fa02 f303 	lsl.w	r3, r2, r3
3400ebce:	1e5a      	subs	r2, r3, #1
3400ebd0:	4202      	tst	r2, r0
3400ebd2:	d106      	bne.n	3400ebe2 <checkint+0x2a>
3400ebd4:	4203      	tst	r3, r0
3400ebd6:	bf14      	ite	ne
3400ebd8:	2001      	movne	r0, #1
3400ebda:	2002      	moveq	r0, #2
3400ebdc:	4770      	bx	lr
3400ebde:	2002      	movs	r0, #2
3400ebe0:	4770      	bx	lr
3400ebe2:	2000      	movs	r0, #0
3400ebe4:	4770      	bx	lr
	...

3400ebe8 <powf>:
3400ebe8:	b537      	push	{r0, r1, r2, r4, r5, lr}
3400ebea:	ee10 1a10 	vmov	r1, s0
3400ebee:	ee10 4a90 	vmov	r4, s1
3400ebf2:	eef0 7a40 	vmov.f32	s15, s0
3400ebf6:	f5a1 0200 	sub.w	r2, r1, #8388608	@ 0x800000
3400ebfa:	0063      	lsls	r3, r4, #1
3400ebfc:	eeb0 7a60 	vmov.f32	s14, s1
3400ec00:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
3400ec04:	f103 30ff 	add.w	r0, r3, #4294967295
3400ec08:	f06f 7280 	mvn.w	r2, #16777216	@ 0x1000000
3400ec0c:	d252      	bcs.n	3400ecb4 <powf+0xcc>
3400ec0e:	4290      	cmp	r0, r2
3400ec10:	d258      	bcs.n	3400ecc4 <powf+0xdc>
3400ec12:	2000      	movs	r0, #0
3400ec14:	f101 4340 	add.w	r3, r1, #3221225472	@ 0xc0000000
3400ec18:	4a9f      	ldr	r2, [pc, #636]	@ (3400ee98 <powf+0x2b0>)
3400ec1a:	eebf 2b00 	vmov.f64	d2, #240	@ 0xbf800000 -1.0
3400ec1e:	f503 034d 	add.w	r3, r3, #13434880	@ 0xcd0000
3400ec22:	f3c3 44c3 	ubfx	r4, r3, #19, #4
3400ec26:	f36f 0316 	bfc	r3, #0, #23
3400ec2a:	1ac9      	subs	r1, r1, r3
3400ec2c:	eb02 1404 	add.w	r4, r2, r4, lsl #4
3400ec30:	15db      	asrs	r3, r3, #23
3400ec32:	ee07 1a90 	vmov	s15, r1
3400ec36:	ed94 4b00 	vldr	d4, [r4]
3400ec3a:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
3400ec3e:	ee07 3a90 	vmov	s15, r3
3400ec42:	ed94 5b02 	vldr	d5, [r4, #8]
3400ec46:	eea4 2b06 	vfma.f64	d2, d4, d6
3400ec4a:	eeb8 6be7 	vcvt.f64.s32	d6, s15
3400ec4e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400ec52:	ee36 6b05 	vadd.f64	d6, d6, d5
3400ec56:	ed92 1b42 	vldr	d1, [r2, #264]	@ 0x108
3400ec5a:	ed92 5b40 	vldr	d5, [r2, #256]	@ 0x100
3400ec5e:	ed92 3b44 	vldr	d3, [r2, #272]	@ 0x110
3400ec62:	ee22 4b02 	vmul.f64	d4, d2, d2
3400ec66:	eea2 1b05 	vfma.f64	d1, d2, d5
3400ec6a:	ee24 0b04 	vmul.f64	d0, d4, d4
3400ec6e:	ed92 5b46 	vldr	d5, [r2, #280]	@ 0x118
3400ec72:	eea2 5b03 	vfma.f64	d5, d2, d3
3400ec76:	ed92 3b48 	vldr	d3, [r2, #288]	@ 0x120
3400ec7a:	eea2 6b03 	vfma.f64	d6, d2, d3
3400ec7e:	eea4 6b05 	vfma.f64	d6, d4, d5
3400ec82:	eea1 6b00 	vfma.f64	d6, d1, d0
3400ec86:	ee27 7b06 	vmul.f64	d7, d7, d6
3400ec8a:	ee17 3a90 	vmov	r3, s15
3400ec8e:	f3c3 32cf 	ubfx	r2, r3, #15, #16
3400ec92:	f248 03bf 	movw	r3, #32959	@ 0x80bf
3400ec96:	429a      	cmp	r2, r3
3400ec98:	f0c0 8098 	bcc.w	3400edcc <powf+0x1e4>
3400ec9c:	ed9f 6b76 	vldr	d6, [pc, #472]	@ 3400ee78 <powf+0x290>
3400eca0:	eeb4 7bc6 	vcmpe.f64	d7, d6
3400eca4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400eca8:	dd79      	ble.n	3400ed9e <powf+0x1b6>
3400ecaa:	b003      	add	sp, #12
3400ecac:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3400ecb0:	f000 b920 	b.w	3400eef4 <__math_oflowf>
3400ecb4:	4290      	cmp	r0, r2
3400ecb6:	d330      	bcc.n	3400ed1a <powf+0x132>
3400ecb8:	b12b      	cbz	r3, 3400ecc6 <powf+0xde>
3400ecba:	0049      	lsls	r1, r1, #1
3400ecbc:	f1b1 4f7f 	cmp.w	r1, #4278190080	@ 0xff000000
3400ecc0:	d808      	bhi.n	3400ecd4 <powf+0xec>
3400ecc2:	e015      	b.n	3400ecf0 <powf+0x108>
3400ecc4:	b953      	cbnz	r3, 3400ecdc <powf+0xf4>
3400ecc6:	f481 0180 	eor.w	r1, r1, #4194304	@ 0x400000
3400ecca:	0049      	lsls	r1, r1, #1
3400eccc:	f511 0f00 	cmn.w	r1, #8388608	@ 0x800000
3400ecd0:	f240 80ca 	bls.w	3400ee68 <powf+0x280>
3400ecd4:	ee37 0a87 	vadd.f32	s0, s15, s14
3400ecd8:	b003      	add	sp, #12
3400ecda:	bd30      	pop	{r4, r5, pc}
3400ecdc:	f1b1 5f7e 	cmp.w	r1, #1065353216	@ 0x3f800000
3400ece0:	d105      	bne.n	3400ecee <powf+0x106>
3400ece2:	f484 0480 	eor.w	r4, r4, #4194304	@ 0x400000
3400ece6:	0064      	lsls	r4, r4, #1
3400ece8:	f514 0f00 	cmn.w	r4, #8388608	@ 0x800000
3400ecec:	e7f0      	b.n	3400ecd0 <powf+0xe8>
3400ecee:	0049      	lsls	r1, r1, #1
3400ecf0:	f1b3 4f7f 	cmp.w	r3, #4278190080	@ 0xff000000
3400ecf4:	d1ee      	bne.n	3400ecd4 <powf+0xec>
3400ecf6:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
3400ecfa:	f000 80b5 	beq.w	3400ee68 <powf+0x280>
3400ecfe:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
3400ed02:	ea6f 0404 	mvn.w	r4, r4
3400ed06:	bf34      	ite	cc
3400ed08:	2100      	movcc	r1, #0
3400ed0a:	2101      	movcs	r1, #1
3400ed0c:	0fe4      	lsrs	r4, r4, #31
3400ed0e:	42a1      	cmp	r1, r4
3400ed10:	f040 80ad 	bne.w	3400ee6e <powf+0x286>
3400ed14:	ee27 0a07 	vmul.f32	s0, s14, s14
3400ed18:	e7de      	b.n	3400ecd8 <powf+0xf0>
3400ed1a:	004d      	lsls	r5, r1, #1
3400ed1c:	1e6b      	subs	r3, r5, #1
3400ed1e:	4293      	cmp	r3, r2
3400ed20:	d31b      	bcc.n	3400ed5a <powf+0x172>
3400ed22:	2900      	cmp	r1, #0
3400ed24:	ee20 0a00 	vmul.f32	s0, s0, s0
3400ed28:	da0e      	bge.n	3400ed48 <powf+0x160>
3400ed2a:	4620      	mov	r0, r4
3400ed2c:	f7ff ff44 	bl	3400ebb8 <checkint>
3400ed30:	2801      	cmp	r0, #1
3400ed32:	d109      	bne.n	3400ed48 <powf+0x160>
3400ed34:	eeb1 0a40 	vneg.f32	s0, s0
3400ed38:	b945      	cbnz	r5, 3400ed4c <powf+0x164>
3400ed3a:	2c00      	cmp	r4, #0
3400ed3c:	dacc      	bge.n	3400ecd8 <powf+0xf0>
3400ed3e:	b003      	add	sp, #12
3400ed40:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3400ed44:	f000 b8dc 	b.w	3400ef00 <__math_divzerof>
3400ed48:	2000      	movs	r0, #0
3400ed4a:	e7f5      	b.n	3400ed38 <powf+0x150>
3400ed4c:	2c00      	cmp	r4, #0
3400ed4e:	dac3      	bge.n	3400ecd8 <powf+0xf0>
3400ed50:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3400ed54:	ee87 0a80 	vdiv.f32	s0, s15, s0
3400ed58:	e7be      	b.n	3400ecd8 <powf+0xf0>
3400ed5a:	2900      	cmp	r1, #0
3400ed5c:	da1d      	bge.n	3400ed9a <powf+0x1b2>
3400ed5e:	4620      	mov	r0, r4
3400ed60:	f7ff ff2a 	bl	3400ebb8 <checkint>
3400ed64:	b920      	cbnz	r0, 3400ed70 <powf+0x188>
3400ed66:	b003      	add	sp, #12
3400ed68:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3400ed6c:	f000 b8da 	b.w	3400ef24 <__math_invalidf>
3400ed70:	1e43      	subs	r3, r0, #1
3400ed72:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
3400ed76:	4258      	negs	r0, r3
3400ed78:	4158      	adcs	r0, r3
3400ed7a:	0400      	lsls	r0, r0, #16
3400ed7c:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
3400ed80:	f4bf af48 	bcs.w	3400ec14 <powf+0x2c>
3400ed84:	eddf 6a45 	vldr	s13, [pc, #276]	@ 3400ee9c <powf+0x2b4>
3400ed88:	ee27 0aa6 	vmul.f32	s0, s15, s13
3400ed8c:	ee10 3a10 	vmov	r3, s0
3400ed90:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400ed94:	f1a3 6138 	sub.w	r1, r3, #192937984	@ 0xb800000
3400ed98:	e73c      	b.n	3400ec14 <powf+0x2c>
3400ed9a:	2000      	movs	r0, #0
3400ed9c:	e7ee      	b.n	3400ed7c <powf+0x194>
3400ed9e:	ed9f 6b38 	vldr	d6, [pc, #224]	@ 3400ee80 <powf+0x298>
3400eda2:	eeb4 7bc6 	vcmpe.f64	d7, d6
3400eda6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400edaa:	dd45      	ble.n	3400ee38 <powf+0x250>
3400edac:	f04f 534c 	mov.w	r3, #855638016	@ 0x33000000
3400edb0:	b3d0      	cbz	r0, 3400ee28 <powf+0x240>
3400edb2:	eebf 6a00 	vmov.f32	s12, #240	@ 0xbf800000 -1.0
3400edb6:	9301      	str	r3, [sp, #4]
3400edb8:	eddd 6a01 	vldr	s13, [sp, #4]
3400edbc:	ee76 6a66 	vsub.f32	s13, s12, s13
3400edc0:	eef4 6a46 	vcmp.f32	s13, s12
3400edc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400edc8:	f47f af6f 	bne.w	3400ecaa <powf+0xc2>
3400edcc:	4b34      	ldr	r3, [pc, #208]	@ (3400eea0 <powf+0x2b8>)
3400edce:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3400edd2:	ed93 5b40 	vldr	d5, [r3, #256]	@ 0x100
3400edd6:	ee37 6b05 	vadd.f64	d6, d7, d5
3400edda:	ee16 2a10 	vmov	r2, s12
3400edde:	ee36 6b45 	vsub.f64	d6, d6, d5
3400ede2:	ed93 5b42 	vldr	d5, [r3, #264]	@ 0x108
3400ede6:	ee37 7b46 	vsub.f64	d7, d7, d6
3400edea:	f002 011f 	and.w	r1, r2, #31
3400edee:	1880      	adds	r0, r0, r2
3400edf0:	eb03 05c1 	add.w	r5, r3, r1, lsl #3
3400edf4:	f853 4031 	ldr.w	r4, [r3, r1, lsl #3]
3400edf8:	ee27 4b07 	vmul.f64	d4, d7, d7
3400edfc:	2100      	movs	r1, #0
3400edfe:	686d      	ldr	r5, [r5, #4]
3400ee00:	190a      	adds	r2, r1, r4
3400ee02:	ed93 6b44 	vldr	d6, [r3, #272]	@ 0x110
3400ee06:	eea7 6b05 	vfma.f64	d6, d7, d5
3400ee0a:	ed93 5b46 	vldr	d5, [r3, #280]	@ 0x118
3400ee0e:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
3400ee12:	eea7 0b05 	vfma.f64	d0, d7, d5
3400ee16:	ec43 2b17 	vmov	d7, r2, r3
3400ee1a:	eea6 0b04 	vfma.f64	d0, d6, d4
3400ee1e:	ee20 0b07 	vmul.f64	d0, d0, d7
3400ee22:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
3400ee26:	e757      	b.n	3400ecd8 <powf+0xf0>
3400ee28:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
3400ee2c:	9300      	str	r3, [sp, #0]
3400ee2e:	eddd 6a00 	vldr	s13, [sp]
3400ee32:	ee76 6a86 	vadd.f32	s13, s13, s12
3400ee36:	e7c3      	b.n	3400edc0 <powf+0x1d8>
3400ee38:	ed9f 6b13 	vldr	d6, [pc, #76]	@ 3400ee88 <powf+0x2a0>
3400ee3c:	eeb4 7bc6 	vcmpe.f64	d7, d6
3400ee40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400ee44:	d804      	bhi.n	3400ee50 <powf+0x268>
3400ee46:	b003      	add	sp, #12
3400ee48:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3400ee4c:	f000 b846 	b.w	3400eedc <__math_uflowf>
3400ee50:	ed9f 6b0f 	vldr	d6, [pc, #60]	@ 3400ee90 <powf+0x2a8>
3400ee54:	eeb4 7bc6 	vcmpe.f64	d7, d6
3400ee58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400ee5c:	d5b6      	bpl.n	3400edcc <powf+0x1e4>
3400ee5e:	b003      	add	sp, #12
3400ee60:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3400ee64:	f000 b840 	b.w	3400eee8 <__math_may_uflowf>
3400ee68:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3400ee6c:	e734      	b.n	3400ecd8 <powf+0xf0>
3400ee6e:	ed9f 0a0d 	vldr	s0, [pc, #52]	@ 3400eea4 <powf+0x2bc>
3400ee72:	e731      	b.n	3400ecd8 <powf+0xf0>
3400ee74:	f3af 8000 	nop.w
3400ee78:	ffd1d571 	.word	0xffd1d571
3400ee7c:	405fffff 	.word	0x405fffff
3400ee80:	ffa3aae2 	.word	0xffa3aae2
3400ee84:	405fffff 	.word	0x405fffff
3400ee88:	00000000 	.word	0x00000000
3400ee8c:	c062c000 	.word	0xc062c000
3400ee90:	00000000 	.word	0x00000000
3400ee94:	c062a000 	.word	0xc062a000
3400ee98:	340139c8 	.word	0x340139c8
3400ee9c:	4b000000 	.word	0x4b000000
3400eea0:	34012ff0 	.word	0x34012ff0
3400eea4:	00000000 	.word	0x00000000

3400eea8 <with_errnof>:
3400eea8:	b510      	push	{r4, lr}
3400eeaa:	ed2d 8b02 	vpush	{d8}
3400eeae:	eeb0 8a40 	vmov.f32	s16, s0
3400eeb2:	4604      	mov	r4, r0
3400eeb4:	f7fe fd8c 	bl	3400d9d0 <__errno>
3400eeb8:	6004      	str	r4, [r0, #0]
3400eeba:	eeb0 0a48 	vmov.f32	s0, s16
3400eebe:	ecbd 8b02 	vpop	{d8}
3400eec2:	bd10      	pop	{r4, pc}

3400eec4 <xflowf>:
3400eec4:	b130      	cbz	r0, 3400eed4 <xflowf+0x10>
3400eec6:	eef1 7a40 	vneg.f32	s15, s0
3400eeca:	ee27 0a80 	vmul.f32	s0, s15, s0
3400eece:	2022      	movs	r0, #34	@ 0x22
3400eed0:	f7ff bfea 	b.w	3400eea8 <with_errnof>
3400eed4:	eef0 7a40 	vmov.f32	s15, s0
3400eed8:	e7f7      	b.n	3400eeca <xflowf+0x6>
	...

3400eedc <__math_uflowf>:
3400eedc:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3400eee4 <__math_uflowf+0x8>
3400eee0:	f7ff bff0 	b.w	3400eec4 <xflowf>
3400eee4:	10000000 	.word	0x10000000

3400eee8 <__math_may_uflowf>:
3400eee8:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3400eef0 <__math_may_uflowf+0x8>
3400eeec:	f7ff bfea 	b.w	3400eec4 <xflowf>
3400eef0:	1a200000 	.word	0x1a200000

3400eef4 <__math_oflowf>:
3400eef4:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3400eefc <__math_oflowf+0x8>
3400eef8:	f7ff bfe4 	b.w	3400eec4 <xflowf>
3400eefc:	70000000 	.word	0x70000000

3400ef00 <__math_divzerof>:
3400ef00:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3400ef04:	2800      	cmp	r0, #0
3400ef06:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
3400ef0a:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 3400ef20 <__math_divzerof+0x20>
3400ef0e:	f04f 0022 	mov.w	r0, #34	@ 0x22
3400ef12:	fe47 7a87 	vseleq.f32	s15, s15, s14
3400ef16:	ee87 0a80 	vdiv.f32	s0, s15, s0
3400ef1a:	f7ff bfc5 	b.w	3400eea8 <with_errnof>
3400ef1e:	bf00      	nop
3400ef20:	00000000 	.word	0x00000000

3400ef24 <__math_invalidf>:
3400ef24:	eef0 7a40 	vmov.f32	s15, s0
3400ef28:	ee30 7a40 	vsub.f32	s14, s0, s0
3400ef2c:	eef4 7a67 	vcmp.f32	s15, s15
3400ef30:	ee87 0a07 	vdiv.f32	s0, s14, s14
3400ef34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400ef38:	d602      	bvs.n	3400ef40 <__math_invalidf+0x1c>
3400ef3a:	2021      	movs	r0, #33	@ 0x21
3400ef3c:	f7ff bfb4 	b.w	3400eea8 <with_errnof>
3400ef40:	4770      	bx	lr

3400ef42 <__ieee754_sqrt>:
3400ef42:	eeb1 0bc0 	vsqrt.f64	d0, d0
3400ef46:	4770      	bx	lr

3400ef48 <__ieee754_log10>:
3400ef48:	ee10 3a90 	vmov	r3, s1
3400ef4c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400ef50:	b510      	push	{r4, lr}
3400ef52:	ed2d 8b02 	vpush	{d8}
3400ef56:	da21      	bge.n	3400ef9c <__ieee754_log10+0x54>
3400ef58:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
3400ef5c:	ee10 1a10 	vmov	r1, s0
3400ef60:	430a      	orrs	r2, r1
3400ef62:	d108      	bne.n	3400ef76 <__ieee754_log10+0x2e>
3400ef64:	ed9f 6b22 	vldr	d6, [pc, #136]	@ 3400eff0 <__ieee754_log10+0xa8>
3400ef68:	ed9f 7b23 	vldr	d7, [pc, #140]	@ 3400eff8 <__ieee754_log10+0xb0>
3400ef6c:	ee86 0b07 	vdiv.f64	d0, d6, d7
3400ef70:	ecbd 8b02 	vpop	{d8}
3400ef74:	bd10      	pop	{r4, pc}
3400ef76:	2b00      	cmp	r3, #0
3400ef78:	da02      	bge.n	3400ef80 <__ieee754_log10+0x38>
3400ef7a:	ee30 6b40 	vsub.f64	d6, d0, d0
3400ef7e:	e7f3      	b.n	3400ef68 <__ieee754_log10+0x20>
3400ef80:	ed9f 7b1f 	vldr	d7, [pc, #124]	@ 3400f000 <__ieee754_log10+0xb8>
3400ef84:	f06f 0235 	mvn.w	r2, #53	@ 0x35
3400ef88:	ee20 0b07 	vmul.f64	d0, d0, d7
3400ef8c:	ee10 3a90 	vmov	r3, s1
3400ef90:	4923      	ldr	r1, [pc, #140]	@ (3400f020 <__ieee754_log10+0xd8>)
3400ef92:	428b      	cmp	r3, r1
3400ef94:	dd04      	ble.n	3400efa0 <__ieee754_log10+0x58>
3400ef96:	ee30 0b00 	vadd.f64	d0, d0, d0
3400ef9a:	e7e9      	b.n	3400ef70 <__ieee754_log10+0x28>
3400ef9c:	2200      	movs	r2, #0
3400ef9e:	e7f7      	b.n	3400ef90 <__ieee754_log10+0x48>
3400efa0:	1518      	asrs	r0, r3, #20
3400efa2:	f240 34ff 	movw	r4, #1023	@ 0x3ff
3400efa6:	f3c3 0113 	ubfx	r1, r3, #0, #20
3400efaa:	f2a0 30ff 	subw	r0, r0, #1023	@ 0x3ff
3400efae:	4410      	add	r0, r2
3400efb0:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
3400efb4:	eba4 70d0 	sub.w	r0, r4, r0, lsr #31
3400efb8:	ee08 3a10 	vmov	s16, r3
3400efbc:	ec53 2b10 	vmov	r2, r3, d0
3400efc0:	ea41 5300 	orr.w	r3, r1, r0, lsl #20
3400efc4:	eeb8 8bc8 	vcvt.f64.s32	d8, s16
3400efc8:	ec43 2b10 	vmov	d0, r2, r3
3400efcc:	f000 f82c 	bl	3400f028 <log>
3400efd0:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3400f008 <__ieee754_log10+0xc0>
3400efd4:	ee20 0b07 	vmul.f64	d0, d0, d7
3400efd8:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3400f010 <__ieee754_log10+0xc8>
3400efdc:	eea8 0b07 	vfma.f64	d0, d8, d7
3400efe0:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3400f018 <__ieee754_log10+0xd0>
3400efe4:	eea8 0b07 	vfma.f64	d0, d8, d7
3400efe8:	e7c2      	b.n	3400ef70 <__ieee754_log10+0x28>
3400efea:	bf00      	nop
3400efec:	f3af 8000 	nop.w
3400eff0:	00000000 	.word	0x00000000
3400eff4:	c3500000 	.word	0xc3500000
	...
3400f004:	43500000 	.word	0x43500000
3400f008:	1526e50e 	.word	0x1526e50e
3400f00c:	3fdbcb7b 	.word	0x3fdbcb7b
3400f010:	11f12b36 	.word	0x11f12b36
3400f014:	3d59fef3 	.word	0x3d59fef3
3400f018:	509f6000 	.word	0x509f6000
3400f01c:	3fd34413 	.word	0x3fd34413
3400f020:	7fefffff 	.word	0x7fefffff
3400f024:	00000000 	.word	0x00000000

3400f028 <log>:
3400f028:	ee10 0a90 	vmov	r0, s1
3400f02c:	ee10 3a10 	vmov	r3, s0
3400f030:	b4f0      	push	{r4, r5, r6, r7}
3400f032:	f100 4140 	add.w	r1, r0, #3221225472	@ 0xc0000000
3400f036:	f04f 34ff 	mov.w	r4, #4294967295
3400f03a:	0c02      	lsrs	r2, r0, #16
3400f03c:	429c      	cmp	r4, r3
3400f03e:	f501 1190 	add.w	r1, r1, #1179648	@ 0x120000
3400f042:	4c71      	ldr	r4, [pc, #452]	@ (3400f208 <log+0x1e0>)
3400f044:	418c      	sbcs	r4, r1
3400f046:	ed2d 8b02 	vpush	{d8}
3400f04a:	d35a      	bcc.n	3400f102 <log+0xda>
3400f04c:	4a6f      	ldr	r2, [pc, #444]	@ (3400f20c <log+0x1e4>)
3400f04e:	4290      	cmp	r0, r2
3400f050:	bf08      	it	eq
3400f052:	2b00      	cmpeq	r3, #0
3400f054:	f000 80c7 	beq.w	3400f1e6 <log+0x1be>
3400f058:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
3400f05c:	4b6c      	ldr	r3, [pc, #432]	@ (3400f210 <log+0x1e8>)
3400f05e:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
3400f062:	ee30 0b47 	vsub.f64	d0, d0, d7
3400f066:	ed93 7b10 	vldr	d7, [r3, #64]	@ 0x40
3400f06a:	ee20 2b00 	vmul.f64	d2, d0, d0
3400f06e:	eea6 7b00 	vfma.f64	d7, d6, d0
3400f072:	ee20 4b02 	vmul.f64	d4, d0, d2
3400f076:	ed93 6b14 	vldr	d6, [r3, #80]	@ 0x50
3400f07a:	ed93 5b18 	vldr	d5, [r3, #96]	@ 0x60
3400f07e:	ed93 3b1e 	vldr	d3, [r3, #120]	@ 0x78
3400f082:	eea6 7b02 	vfma.f64	d7, d6, d2
3400f086:	ed93 6b16 	vldr	d6, [r3, #88]	@ 0x58
3400f08a:	eea5 6b00 	vfma.f64	d6, d5, d0
3400f08e:	ed93 5b1a 	vldr	d5, [r3, #104]	@ 0x68
3400f092:	eea5 6b02 	vfma.f64	d6, d5, d2
3400f096:	ed93 5b1c 	vldr	d5, [r3, #112]	@ 0x70
3400f09a:	eea3 5b00 	vfma.f64	d5, d3, d0
3400f09e:	ed93 3b20 	vldr	d3, [r3, #128]	@ 0x80
3400f0a2:	eea3 5b02 	vfma.f64	d5, d3, d2
3400f0a6:	ed93 3b22 	vldr	d3, [r3, #136]	@ 0x88
3400f0aa:	eea3 5b04 	vfma.f64	d5, d3, d4
3400f0ae:	eeb0 3b40 	vmov.f64	d3, d0
3400f0b2:	eea5 6b04 	vfma.f64	d6, d5, d4
3400f0b6:	ed93 5b0e 	vldr	d5, [r3, #56]	@ 0x38
3400f0ba:	eea6 7b04 	vfma.f64	d7, d6, d4
3400f0be:	eeb0 6b40 	vmov.f64	d6, d0
3400f0c2:	eeb0 2b47 	vmov.f64	d2, d7
3400f0c6:	ed9f 7b4a 	vldr	d7, [pc, #296]	@ 3400f1f0 <log+0x1c8>
3400f0ca:	eea0 6b07 	vfma.f64	d6, d0, d7
3400f0ce:	eea0 6b47 	vfms.f64	d6, d0, d7
3400f0d2:	ee26 1b06 	vmul.f64	d1, d6, d6
3400f0d6:	ee30 8b46 	vsub.f64	d8, d0, d6
3400f0da:	eea1 3b05 	vfma.f64	d3, d1, d5
3400f0de:	ee30 7b43 	vsub.f64	d7, d0, d3
3400f0e2:	ee30 0b06 	vadd.f64	d0, d0, d6
3400f0e6:	eea1 7b05 	vfma.f64	d7, d1, d5
3400f0ea:	ee25 5b08 	vmul.f64	d5, d5, d8
3400f0ee:	eea5 7b00 	vfma.f64	d7, d5, d0
3400f0f2:	eea2 7b04 	vfma.f64	d7, d2, d4
3400f0f6:	ee33 0b07 	vadd.f64	d0, d3, d7
3400f0fa:	ecbd 8b02 	vpop	{d8}
3400f0fe:	bcf0      	pop	{r4, r5, r6, r7}
3400f100:	4770      	bx	lr
3400f102:	f1a2 0410 	sub.w	r4, r2, #16
3400f106:	f647 71df 	movw	r1, #32735	@ 0x7fdf
3400f10a:	428c      	cmp	r4, r1
3400f10c:	d923      	bls.n	3400f156 <log+0x12e>
3400f10e:	18d9      	adds	r1, r3, r3
3400f110:	eb40 0400 	adc.w	r4, r0, r0
3400f114:	4321      	orrs	r1, r4
3400f116:	d105      	bne.n	3400f124 <log+0xfc>
3400f118:	2001      	movs	r0, #1
3400f11a:	ecbd 8b02 	vpop	{d8}
3400f11e:	bcf0      	pop	{r4, r5, r6, r7}
3400f120:	f7ff ba7e 	b.w	3400e620 <__math_divzero>
3400f124:	493b      	ldr	r1, [pc, #236]	@ (3400f214 <log+0x1ec>)
3400f126:	4288      	cmp	r0, r1
3400f128:	bf08      	it	eq
3400f12a:	2b00      	cmpeq	r3, #0
3400f12c:	d0e5      	beq.n	3400f0fa <log+0xd2>
3400f12e:	0413      	lsls	r3, r2, #16
3400f130:	d403      	bmi.n	3400f13a <log+0x112>
3400f132:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
3400f136:	4393      	bics	r3, r2
3400f138:	d104      	bne.n	3400f144 <log+0x11c>
3400f13a:	ecbd 8b02 	vpop	{d8}
3400f13e:	bcf0      	pop	{r4, r5, r6, r7}
3400f140:	f7ff ba8a 	b.w	3400e658 <__math_invalid>
3400f144:	ed9f 7b2c 	vldr	d7, [pc, #176]	@ 3400f1f8 <log+0x1d0>
3400f148:	ee20 7b07 	vmul.f64	d7, d0, d7
3400f14c:	ec53 2b17 	vmov	r2, r3, d7
3400f150:	f1a3 7050 	sub.w	r0, r3, #54525952	@ 0x3400000
3400f154:	4613      	mov	r3, r2
3400f156:	f100 4240 	add.w	r2, r0, #3221225472	@ 0xc0000000
3400f15a:	492d      	ldr	r1, [pc, #180]	@ (3400f210 <log+0x1e8>)
3400f15c:	eebf 5b00 	vmov.f64	d5, #240	@ 0xbf800000 -1.0
3400f160:	1e1e      	subs	r6, r3, #0
3400f162:	f502 12d0 	add.w	r2, r2, #1703936	@ 0x1a0000
3400f166:	f3c2 3446 	ubfx	r4, r2, #13, #7
3400f16a:	ea4f 5c12 	mov.w	ip, r2, lsr #20
3400f16e:	1512      	asrs	r2, r2, #20
3400f170:	eb01 1504 	add.w	r5, r1, r4, lsl #4
3400f174:	ea4f 5c0c 	mov.w	ip, ip, lsl #20
3400f178:	ed95 7b24 	vldr	d7, [r5, #144]	@ 0x90
3400f17c:	eba0 070c 	sub.w	r7, r0, ip
3400f180:	ec47 6b16 	vmov	d6, r6, r7
3400f184:	eea7 5b06 	vfma.f64	d5, d7, d6
3400f188:	ee07 2a90 	vmov	s15, r2
3400f18c:	eeb8 6be7 	vcvt.f64.s32	d6, s15
3400f190:	ed91 4b00 	vldr	d4, [r1]
3400f194:	ed95 7b26 	vldr	d7, [r5, #152]	@ 0x98
3400f198:	ed91 3b0c 	vldr	d3, [r1, #48]	@ 0x30
3400f19c:	eea4 7b06 	vfma.f64	d7, d4, d6
3400f1a0:	ee25 2b05 	vmul.f64	d2, d5, d5
3400f1a4:	ee35 4b07 	vadd.f64	d4, d5, d7
3400f1a8:	ee25 1b02 	vmul.f64	d1, d5, d2
3400f1ac:	ee37 0b44 	vsub.f64	d0, d7, d4
3400f1b0:	ed91 7b02 	vldr	d7, [r1, #8]
3400f1b4:	ee30 0b05 	vadd.f64	d0, d0, d5
3400f1b8:	eea7 0b06 	vfma.f64	d0, d7, d6
3400f1bc:	ed91 7b04 	vldr	d7, [r1, #16]
3400f1c0:	ed91 6b08 	vldr	d6, [r1, #32]
3400f1c4:	eea7 0b02 	vfma.f64	d0, d7, d2
3400f1c8:	ed91 7b06 	vldr	d7, [r1, #24]
3400f1cc:	eea6 7b05 	vfma.f64	d7, d6, d5
3400f1d0:	ed91 6b0a 	vldr	d6, [r1, #40]	@ 0x28
3400f1d4:	eea3 6b05 	vfma.f64	d6, d3, d5
3400f1d8:	eea6 7b02 	vfma.f64	d7, d6, d2
3400f1dc:	eea1 0b07 	vfma.f64	d0, d1, d7
3400f1e0:	ee30 0b04 	vadd.f64	d0, d0, d4
3400f1e4:	e789      	b.n	3400f0fa <log+0xd2>
3400f1e6:	ed9f 0b06 	vldr	d0, [pc, #24]	@ 3400f200 <log+0x1d8>
3400f1ea:	e786      	b.n	3400f0fa <log+0xd2>
3400f1ec:	f3af 8000 	nop.w
3400f1f0:	00000000 	.word	0x00000000
3400f1f4:	41a00000 	.word	0x41a00000
3400f1f8:	00000000 	.word	0x00000000
3400f1fc:	43300000 	.word	0x43300000
	...
3400f208:	000308ff 	.word	0x000308ff
3400f20c:	3ff00000 	.word	0x3ff00000
3400f210:	34013138 	.word	0x34013138
3400f214:	7ff00000 	.word	0x7ff00000

3400f218 <_close>:
3400f218:	4b02      	ldr	r3, [pc, #8]	@ (3400f224 <_close+0xc>)
3400f21a:	2258      	movs	r2, #88	@ 0x58
3400f21c:	f04f 30ff 	mov.w	r0, #4294967295
3400f220:	601a      	str	r2, [r3, #0]
3400f222:	4770      	bx	lr
3400f224:	340d05c0 	.word	0x340d05c0

3400f228 <_fstat>:
3400f228:	4b02      	ldr	r3, [pc, #8]	@ (3400f234 <_fstat+0xc>)
3400f22a:	2258      	movs	r2, #88	@ 0x58
3400f22c:	f04f 30ff 	mov.w	r0, #4294967295
3400f230:	601a      	str	r2, [r3, #0]
3400f232:	4770      	bx	lr
3400f234:	340d05c0 	.word	0x340d05c0

3400f238 <_getpid>:
3400f238:	4b02      	ldr	r3, [pc, #8]	@ (3400f244 <_getpid+0xc>)
3400f23a:	2258      	movs	r2, #88	@ 0x58
3400f23c:	f04f 30ff 	mov.w	r0, #4294967295
3400f240:	601a      	str	r2, [r3, #0]
3400f242:	4770      	bx	lr
3400f244:	340d05c0 	.word	0x340d05c0

3400f248 <_isatty>:
3400f248:	4b02      	ldr	r3, [pc, #8]	@ (3400f254 <_isatty+0xc>)
3400f24a:	2258      	movs	r2, #88	@ 0x58
3400f24c:	2000      	movs	r0, #0
3400f24e:	601a      	str	r2, [r3, #0]
3400f250:	4770      	bx	lr
3400f252:	bf00      	nop
3400f254:	340d05c0 	.word	0x340d05c0

3400f258 <_kill>:
3400f258:	4b02      	ldr	r3, [pc, #8]	@ (3400f264 <_kill+0xc>)
3400f25a:	2258      	movs	r2, #88	@ 0x58
3400f25c:	f04f 30ff 	mov.w	r0, #4294967295
3400f260:	601a      	str	r2, [r3, #0]
3400f262:	4770      	bx	lr
3400f264:	340d05c0 	.word	0x340d05c0

3400f268 <_lseek>:
3400f268:	4b02      	ldr	r3, [pc, #8]	@ (3400f274 <_lseek+0xc>)
3400f26a:	2258      	movs	r2, #88	@ 0x58
3400f26c:	f04f 30ff 	mov.w	r0, #4294967295
3400f270:	601a      	str	r2, [r3, #0]
3400f272:	4770      	bx	lr
3400f274:	340d05c0 	.word	0x340d05c0

3400f278 <_read>:
3400f278:	4b02      	ldr	r3, [pc, #8]	@ (3400f284 <_read+0xc>)
3400f27a:	2258      	movs	r2, #88	@ 0x58
3400f27c:	f04f 30ff 	mov.w	r0, #4294967295
3400f280:	601a      	str	r2, [r3, #0]
3400f282:	4770      	bx	lr
3400f284:	340d05c0 	.word	0x340d05c0

3400f288 <_write>:
3400f288:	4b02      	ldr	r3, [pc, #8]	@ (3400f294 <_write+0xc>)
3400f28a:	2258      	movs	r2, #88	@ 0x58
3400f28c:	f04f 30ff 	mov.w	r0, #4294967295
3400f290:	601a      	str	r2, [r3, #0]
3400f292:	4770      	bx	lr
3400f294:	340d05c0 	.word	0x340d05c0

3400f298 <_exit>:
3400f298:	e7fe      	b.n	3400f298 <_exit>
	...

3400f29c <_init>:
3400f29c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400f29e:	bf00      	nop
3400f2a0:	bcf8      	pop	{r3, r4, r5, r6, r7}
3400f2a2:	bc08      	pop	{r3}
3400f2a4:	469e      	mov	lr, r3
3400f2a6:	4770      	bx	lr

3400f2a8 <_fini>:
3400f2a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400f2aa:	bf00      	nop
3400f2ac:	bcf8      	pop	{r3, r4, r5, r6, r7}
3400f2ae:	bc08      	pop	{r3}
3400f2b0:	469e      	mov	lr, r3
3400f2b2:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

34013c60 <SECURE_SystemCoreClockUpdate>:
34013c60:	e97f e97f 	sg
34013c64:	f7ee bfe8 	b.w	34002c38 <__acle_se_SECURE_SystemCoreClockUpdate>

34013c68 <SECURE_RegisterCallback>:
34013c68:	e97f e97f 	sg
34013c6c:	f7ee bd94 	b.w	34002798 <__acle_se_SECURE_RegisterCallback>
	...
